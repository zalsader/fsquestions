"body"
"<p><code>per_io_data_size</code> is the key here. By setting the member of <code>struct dm_target</code>, device-mapper allocates the extra space for user-defined data ahead of dm_target_io so they are placed like this:</p>

<p>(extra)(dm_target_io  ...   (clone))</p>

<p>so dm_per_bio_data returns the pointer to the beginning of the extra space.</p>

<pre><code>struct dm_md_mempools *dm_alloc_md_mempools(struct mapped_device *md, enum dm_queue_mode type,
                                            unsigned integrity, unsigned per_io_data_size)
{
        struct dm_md_mempools *pools = kzalloc_node(sizeof(*pools), GFP_KERNEL, md-&gt;numa_node_id);
        unsigned int pool_size = 0;
        unsigned int front_pad;

        if (!pools)
                return NULL;

        switch (type) {
        case DM_TYPE_BIO_BASED:
        case DM_TYPE_DAX_BIO_BASED:
                pool_size = dm_get_reserved_bio_based_ios();
                front_pad = roundup(per_io_data_size, __alignof__(struct dm_target_io)) + offsetof(struct dm_target_io, clone);

                pools-&gt;io_pool = mempool_create_slab_pool(pool_size, _io_cache);
                if (!pools-&gt;io_pool)
                        goto out;
                break;
        case DM_TYPE_REQUEST_BASED:
        case DM_TYPE_MQ_REQUEST_BASED:
                pool_size = dm_get_reserved_rq_based_ios();
                front_pad = offsetof(struct dm_rq_clone_bio_info, clone);
                /* per_io_data_size is used for blk-mq pdu at queue allocation */
                break;
        default:
                BUG();
        }

        pools-&gt;bs = bioset_create(pool_size, front_pad, BIOSET_NEED_RESCUER);
        if (!pools-&gt;bs)
                goto out;
</code></pre>
"
"<p>It is old question, but anyway here is the code for reading, I hope it will help someone:</p>

<pre><code>int readPage(struct block_device *device, sector_t sector, int size,
     struct page *page)
{
    int ret;
    struct completion event;
    struct bio *bio = bio_alloc(GFP_NOIO, 1);
    bio-&gt;bi_bdev = device;
    bio-&gt;bi_sector = sector;
    bio_add_page(bio, page, size, 0);
    init_completion(&amp;event);
    bio-&gt;bi_private = &amp;event;
    bio-&gt;bi_end_io = readComplete;
    submit_bio(READ | REQ_SYNC, bio);
    wait_for_completion(&amp;event);
    ret = test_bit(BIO_UPTODATE, &amp;bio-&gt;bi_flags);
    bio_put(bio);
    return ret;
}
</code></pre>

<p>And for writing:</p>

<pre><code>void writePage(struct block_device *device,
           sector_t sector, int size, struct page *page)
{
    struct bio *bio = bio_alloc(GFP_NOIO, 1);
    bio-&gt;bi_bdev = vnode-&gt;blkDevice;
    bio-&gt;bi_sector = sector;
    bio_add_page(bio, page, size, 0);
    bio-&gt;bi_end_io = writeComplete;
    submit_bio(WRITE_FLUSH_FUA, bio);
}
</code></pre>

<p><code>page</code> can be allocated with alloc_page(GFP_KERNEL). Also for changing data in <code>page</code> use <code>page_address(page)</code>. It returns <code>void*</code> so you can interpret that pointer as whatever you want.</p>
"
"<p>I found a better way for I/O to block device from kernel module. I have used <code>bio</code> structure for that. Hope this information save somebody from headache.</p>

<p>1) So, if you want to redirect I/O from your block device to existing block device, you have to use own <code>make_request</code> function. For that you should use <code>blk_alloc_queue</code> function to create queue for your block device like this:</p>

<pre><code>device-&gt;queue = blk_alloc_queue(GFP_KERNEL);
blk_queue_make_request(device-&gt;queue, own_make_request);
</code></pre>

<p>Than into <code>own_make_request</code> function change <code>bi_bdev</code> member into <code>bio</code> structure to device in which you redirecting I/O and call <code>generic_make_request</code> function:</p>

<pre><code>bio-&gt;bi_bdev = device_in_which_redirect;
generic_make_request(bio);
</code></pre>

<p>More information <a href=""http://lwn.net/Kernel/LDD3"" rel=""nofollow"" title=""here"">here</a> at 16 chapter. If link is broken by some cause, here is name of the book - ""Linux Device Drivers, Third Edition""</p>

<p>2) If you want read or write your own data to existing block device from kernel module you should use <code>submit_bio</code> function. </p>

<p>Code for writing into specific sector(you need to implement <code>writeComplete</code> function also):</p>

<pre><code>void writePage(struct block_device *device,
           sector_t sector, int size, struct page *page)
{
    struct bio *bio = bio_alloc(GFP_NOIO, 1);
    bio-&gt;bi_bdev = vnode-&gt;blkDevice;
    bio-&gt;bi_sector = sector;
    bio_add_page(bio, page, size, 0);
    bio-&gt;bi_end_io = writeComplete;
    submit_bio(WRITE_FLUSH_FUA, bio);
}
</code></pre>

<p>Code for reading from specific sector(you need to implement <code>readComplete</code> function also):</p>

<pre><code>int readPage(struct block_device *device, sector_t sector, int size,
     struct page *page)
{
    int ret;
    struct completion event;
    struct bio *bio = bio_alloc(GFP_NOIO, 1);
    bio-&gt;bi_bdev = device;
    bio-&gt;bi_sector = sector;
    bio_add_page(bio, page, size, 0);
    init_completion(&amp;event);
    bio-&gt;bi_private = &amp;event;
    bio-&gt;bi_end_io = readComplete;
    submit_bio(READ | REQ_SYNC, bio);
    wait_for_completion(&amp;event);
    ret = test_bit(BIO_UPTODATE, &amp;bio-&gt;bi_flags);
    bio_put(bio);
    return ret;
}
</code></pre>

<p><code>page</code> can be allocated with alloc_page(GFP_KERNEL). Also for changing data in <code>page</code> use <code>page_address(page)</code>. It returns <code>void*</code> so you can interpret that pointer as whatever you want.</p>
"
"<p>NOTE: My answer is related to kernel version &lt; 3.14, because since 3.14 API is slightly changed.</p>

<p>In kernel you read/write certain sectors with <a href=""http://lxr.free-electrons.com/source/include/linux/blk_types.h?v=3.13#L35"" rel=""noreferrer""><code>struct bio</code></a>. This struct is used for all block level I/O. Comprehensive documentation can be found <a href=""http://lxr.free-electrons.com/source/Documentation/block/biodoc.txt?v=3.13"" rel=""noreferrer"">in kernel</a> and on <a href=""http://lwn.net/Articles/26404/"" rel=""noreferrer"">lwn</a>. These are the several most significant members of this structure:</p>

<ul>
<li><code>bio-&gt;bi_sector</code> - first sector of block I/O request</li>
<li><code>bio-&gt;bi_size</code> - size of I/O request</li>
<li><code>bio-&gt;bi_bdev</code> - device to read/write</li>
<li><code>bio-&gt;bi_end_io</code> - callback that kernel will call on the end of request</li>
</ul>

<p>What you do in device mapper target is <strong>map incoming <code>bio</code></strong>. When you creating your device mapper target you supply at least 2 callbacks: <code>ctr</code>, and <code>map</code>. For example, the simplest device-mapper target <em>dm-zero</em> declares it's callbacks <a href=""http://lxr.free-electrons.com/source/drivers/md/dm-zero.c?v=3.13#L56"" rel=""noreferrer"">as following</a>:</p>

<pre><code>static struct target_type zero_target = {
         .name   = ""zero"",
         .version = {1, 1, 0},
         .module = THIS_MODULE,
         .ctr    = zero_ctr,
         .map    = zero_map,
};
</code></pre>

<p><code>map</code> is a key callback - it's a heart of every device-mapper target. <code>map</code> receive incoming <code>bio</code> and it can do anything with it. For example, dm-linear just shift sector of every incoming <code>bio</code> by predefined offset. See the code:</p>

<pre><code>static sector_t linear_map_sector(struct dm_target *ti, sector_t bi_sector)
{
        struct linear_c *lc = ti-&gt;private;

        return lc-&gt;start + dm_target_offset(ti, bi_sector);
}

static void linear_map_bio(struct dm_target *ti, struct bio *bio)
{
        struct linear_c *lc = ti-&gt;private;

        bio-&gt;bi_bdev = lc-&gt;dev-&gt;bdev;
        if (bio_sectors(bio))
                bio-&gt;bi_sector = linear_map_sector(ti, bio-&gt;bi_sector);
}

static int linear_map(struct dm_target *ti, struct bio *bio)
{
        linear_map_bio(ti, bio);

        return DM_MAPIO_REMAPPED;
}
</code></pre>

<p>Because map receives pointer to <code>bio</code> it can change value under that pointer and that's it.</p>

<p>That's how you map I/O requests. If you want to create your own requests then you must allocate <code>bio</code>, fill it's sector, device, size, end callback and add buffers to read into/write from. Basically, it's just a few steps:</p>

<ul>
<li>Call to bio_alloc to allocate bio.</li>
<li>Set <code>bio-&gt;bi_bdev</code>, <code>bio-&gt;bi_sector</code>, <code>bio-&gt;bi_size</code>, <code>bio-&gt;bi_end_io</code></li>
<li>Add pages via <code>bio_add_page</code>.</li>
<li>Call <code>submit_bio</code>.</li>
<li>Handle results and errors in <code>bio-&gt;bi_end_io</code> callback</li>
</ul>

<p>Example can be found in <em>dm-crypt</em> target in <a href=""http://lxr.free-electrons.com/source/drivers/md/dm-crypt.c?v=3.13#L983"" rel=""noreferrer""><code>crypt_alloc_buffer</code></a> function.</p>
"
"<p>The way you're calculating the sector seems fine, although I don't think you're gonna end up with the precise sector you want.  That being said, you're fetching the block device all wrong.  Don't invoke <code>ext2_get_block</code>, because not only is it file system specific but you don't seem to really understand what it does and it's so much more confusing than the standard way of getting the block device.  Instead, just use</p>

<pre><code>bio.bi_bdev = I_BDEV(mapping-&gt;host);
</code></pre>

<p>Also, if you want to test this out and see it in action, then just compile it into a module and set up a hook so that when you open a certain block device (that you've created) it will trigger the function.  Your current method of adding it into existing functions can interfere with whatever the kernel is currently doing and it will mess up your testing.</p>
"
"<p>page_address will return a pointer (void*) that you can use to read or write the content of the page. However, if it is a page in high memory it will only work if the page is mapped. </p>

<p>Using kmap may be preferable, as it will do that check for you :</p>

<pre><code>void *kmap(struct page *page)
{
        might_sleep();
        if (!PageHighMem(page))
               return page_address(page);
        return kmap_high(page);
}
</code></pre>
"
"<p>If you finish your I/O on a particular CPU, then that processor is immediately free to start working on a new thread - if you finish your i/o on the same processor as the thread the requested it, then the next thread is likely to be the one you finished i/o for.</p>

<p>On the other hand, if you finish on a different processor, the thread that requested the i/o won't get to run immediately - it has to wait until whatever's currently executing finishes its quantum or otherwise relinquishes the CPU.</p>

<p>As far as I understand.</p>
"
"<p>It could just be the latency inherent in issuing an IPI from the CPU that completed the bio to the CPU where the task gets scheduled - to test this, try booting with <code>idle=poll</code>.</p>
"
"<p>Looks like I misunderstood the problem a bit: it seems to be related to cache misses; when the cpu handling interrupts wasn't the cpu that started the i/o, the cpu can hit 100% utilization, and then everything slows down, giving the impression that there is a long delay communicating between cpus.</p>

<p>Thanks to everyone for their ideas.</p>
"
"<p><a href=""http://lkml.indiana.edu/hypermail/linux/kernel/0912.2/02308.html"" rel=""nofollow noreferrer"">This patch</a> was just posted to LKML, implementing <code>QUEUE_FLAG_SAME_CPU</code> in the block device layer, which is described as:</p>

<blockquote>
  <p>Add a flag to make request complete on
  cpu where request is submitted. The
  flag implies <code>QUEUE_FLAG_SAME_COMP</code>. By
  default, it is off.</p>
</blockquote>

<p>It sounds like it might be just what you need...</p>
"
"<p>You know, if you're a GPL'd kernel module you can just <em>call</em> open(), read(), write(), etc. from kernel mode right?</p>

<p>Of course this way has certain caveats including requiring forking from kernel mode to create a space for your handle to live.</p>
"
"<p>Consider examining the code for the <code>dm</code> / <code>md</code> block devices in <code>drivers/md</code> - these existing drivers create a block device that stores data on other block devices.</p>

<p>In fact, you could probably implement your idea as another ""RAID personality"" in <code>md</code>, and thereby make use of the existing userspace tools for setting up the devices.</p>
"
"<p>The source code in the device mapper driver will suit your needs. Look at the code in the Linux source in Linux/drivers/md/dm-*.</p>

<p>You don't need to access the other device's gendisk structure, but rather its request queue. You can prepare I/O requests and push it down the other device's queue, and it will do the rest itself.</p>

<p>I have implemented a simple block device that opens another block device. Take a look in my post describing it:
<a href=""http://orenkishon.wordpress.com/2014/10/29/stackbd-stacking-a-block-device-over-another-block-device/"" rel=""nofollow"">stackbd: Stacking a block device over another block device</a></p>

<p>Here are some examples of functions that you need for accessing another device's gendisk.
The way to open another block device using its path (""/dev/""):</p>

<pre class=""lang-c prettyprint-override""><code>struct block_device *bdev_raw = lookup_bdev(dev_path);
printk(""Opened %s\n"", dev_path);
if (IS_ERR(bdev_raw))
{
    printk(""stackbd: error opening raw device &lt;%lu&gt;\n"", PTR_ERR(bdev_raw));
    return NULL;
}
if (!bdget(bdev_raw-&gt;bd_dev))
{
    printk(""stackbd: error bdget()\n"");
    return NULL;
}
if (blkdev_get(bdev_raw, STACKBD_BDEV_MODE, &amp;stackbd))
{
    printk(""stackbd: error blkdev_get()\n"");
    bdput(bdev_raw);
    return NULL;
}
</code></pre>

<p>The simplest example of passing an I/O request from one device to another is by remapping it without modifying it. Notice in the following code that the <em>bi_bdev</em> entry is modified with a different device. One can also modify the block address (*bi_sector) and the data itself.</p>

<pre class=""lang-c prettyprint-override""><code>static void stackbd_io_fn(struct bio *bio)
{
    bio-&gt;bi_bdev = stackbd.bdev_raw;

    trace_block_bio_remap(bdev_get_queue(stackbd.bdev_raw), bio,
            bio-&gt;bi_bdev-&gt;bd_dev, bio-&gt;bi_sector);

    /* No need to call bio_endio() */
    generic_make_request(bio);
}
</code></pre>
"
"<p>I'm not sure how to string multiple <code>struct bio</code> together, but you might want to take a look at the ""task collector"" implementation in <a href=""http://lxr.linux.no/#linux+v2.6.39/drivers/scsi/libsas/"" rel=""nofollow"">libsas</a> and the <a href=""http://lxr.linux.no/#linux+v2.6.39/drivers/scsi/aic94xx/"" rel=""nofollow"">aic94xx</a> driver for an alternate approach. There isn't much documentation, but the libsas <a href=""http://lxr.linux.no/#linux+v2.6.39/Documentation/scsi/libsas.txt"" rel=""nofollow"">documentation</a> describes it as</p>

<blockquote>
  <p>Some hardware (e.g. aic94xx) has the capability to DMA more
   than one task at a time (interrupt) from host memory.  Task
   Collector Mode is an optional feature for HAs which support
   this in their hardware.  (Again, it is completely optional
   even if your hardware supports it.)</p>

  <p>In Task Collector Mode, the SAS Layer would do <em>natural</em>
   coalescing of tasks and at the appropriate moment it would
   call your driver to DMA more than one task in a single HA
   interrupt. DMBS may want to use this by insmod/modprobe
   setting the lldd_max_execute_num to something greater than 1.</p>
</blockquote>

<p>Effectively, this lets the block layer (a.k.a. BIO) remain unchanged, but multiple requests are accumulated at the driver layer and submitted together.</p>
"
"<p>Thanks for the reply, @ctuffli. I've decided to use a structure similar to the one described <a href=""http://lxr.missinglinkelectronics.com/linux+v2.6.39/include/linux/pktcdvd.h#L200"" rel=""nofollow"">here</a>. Basically, I allocate a <code>struct packet_data</code> which would contain pointers to all <code>struct bio</code>s that should be merged to form one single <code>struct bio</code> (and later on, one single <code>struct request</code>). In addition, I store some driver related information as well in this <code>struct packet_data</code>. Next, I allocate a new <code>struct bio</code> (lets call it ""merged_bio""), copy all the pages from the list of original BIOs and then make the <code>merged_bio-&gt;bi_private</code> point to the <code>struct packet_data</code>. This last hack would allow me to keep track of the list of original BIOs, and also call <code>bio_endio()</code> to end I/O on all individual BIOs once the <code>merged_bio</code> has been successfully transferred.</p>

<p>Not sure if this is the smartest way to do this, but it does what I intended! :^)</p>
"
"<p>The offset per segment does not refer to an offset from the block device location, but rather an offset into the page.  To cause this to be nonzero, you'll probably need to write your own C program that runs <code>read()</code> and <code>write()</code>.  Allocate a page-aligned buffer, then read/write to/from different locations in that buffer, and those should show up as offsets in the bvec.</p>

<p>That said, LWN warns of managing this page offset manually, and recommends instead the macro <code>bio_kmap_irq()</code>, which is called on the <code>bio_for_each_segment()</code> variable <code>bio</code>, and takes care of the atomic kmap AND manages the offset entry as well.  Source: <a href=""http://lwn.net/Articles/26404/"" rel=""nofollow"">http://lwn.net/Articles/26404/</a></p>

<p>Your code will look something like:</p>

<pre><code>    bio_for_each_segment(bvec, bio, i) {
            unsigned int len = bvec-&gt;bv_len;
            unsigned long flags;

            char *buf = bio_kmap_irq(bio, &amp;flags);
            err = esd_do_bvec(esd, buf, len, rw, sector);
            bio_kunmap_irq(buf, &amp;flags);

            if (err) {
                    printk(""err!\n"");
                    break;
            }
            sector += len &gt;&gt; SECTOR_SHIFT;
    }
</code></pre>

<p>Of course this changes the signature of <code>esd_do_bvec</code> to accept the memory buffer directly rather than page/offset.</p>
"
"<p>Try read ""The Art of Linux Kernel Design 2014"" Page: 58; - item ""Initialize the Request Structure of the I Block Device. </p>

<p>att</p>
"
"<p>The solution I used seemed like a common workaround once I found something similar in the source of drbd block driver. The bi_private field can be used only by the function that allocates it. So I used bio_clone in the following way</p>

<pre><code>bio_copy = bio_clone(bio_source, GFP_NOIO);
struct something *instance = kmalloc(sizeof(struct something), GFP_KERNEL);
instance-&gt;bio_original = bio_source;
//update timestamps for latency inside this struct instance
bio_copy-&gt;bi_private = instance;
bio_copy-&gt;bi_end_io = my_end_io_function;
bio_copy-&gt;bi_dev = bio_source-&gt;bi_dev;

...
...
make_request_fn(queue, bio_copy);
</code></pre>

<p>You'll have to write a bi_end_io function. Do remember to call bio_endio for original bio inside this function. You might need to copy bi_error field into bio_source's bi_error before calling bio_endio(bio_source).</p>

<p>Hope this helps someone.</p>
"
"<p>Instead of bb->bi_bdev = bdget_disk(self->gd,PARTITIONNO);
Try this bb->bi_bdev = blkdev_get_by_dev(self->di, FMODE_READ|FMODE_WRITE|FMODE_EXCL, NULL);</p>
"
"<p>I found that I would first lookup the bdev by its path:</p>

<pre><code>struct block_device *bdev;
bdev = lookup_bdev(""/dev/loop0"");
</code></pre>

<p>And then open it:</p>

<pre><code>bb-&gt;bi_bdev = blkdev_get_by_dev(bdev-&gt;bd_dev, FMODE_READ|FMODE_WRITE, NULL);
</code></pre>

<p>OR</p>

<pre><code>bb-&gt;bi_bdev = blkdev_get_by_path(""/dev/loop0"", FMODE_READ|FMODE_WRITE, NULL);
</code></pre>

<p>Without FMODE_EXCL. But when you are done, you need to close the device:</p>

<pre><code>blkdev_put(bb-&gt;bi_bdev, FMODE_READ|FMODE_WRITE);
</code></pre>
"
"<p>I'm not sure to get you right but here is how I usually proceed with OpenSSL:</p>

<p>I consider OpenSSL's BIO structures to be some kind of <em>opaque</em> streams.</p>

<p>Whatever data I have to pass to (or get from) OpenSSL, it is usually stored in a custom data structure of my own, then copied to/from an OpenSSL BIO for processing.</p>

<p>As you stated, the documentation of OpenSSL is not really clear on some points. Since we cannot reasonably make an assumption of its internal behavior, I believe this way of doing things to be safer.</p>

<p>However, in case you need high performance and want to avoid the <em>useless</em> copy (this would be legitimate), you better ask the <a href=""http://http://www.openssl.org/support/community.html"" rel=""nofollow noreferrer"">OpenSSL Users mailing-list</a>. Their answers will be acurate and I believe that only them can answer things which aren't precisely described into the documentation.</p>
"
"<pre><code>//just a code for demo,not for actually use
int len;
RSA *rsa;
BIO *bio;
unsigned char *data;
bio = BIO_new(BIO_s_meme());
BIO *b64;
b64 = BIO_new(BIO_f_base64());
BIO_write(bio, ""&lt;RSAKeyPair&gt;\n"",strlen(""&lt;RSAKeyPair&gt;\n""));
//write Modulus
len=BN_num_bytes(rsa-&gt;n);
data=(unsigned char *)OPENSSL_malloc(len);
if(data) {
  BIO_write(bio,""  &lt;Modulus&gt;"",strlen(""  &lt;Modulus&gt;""));
  BN_bn2bin(rsa-&gt;n,data);
  bio = BIO_push(b64, bio);
  BIO_write(bio, data, len);
  (void)BIO_flush(bio);
  BIO_pop(bio);
  BIO_reset(b64);
  BIO_write(bio,""&lt;/Modulus&gt;"",strlen(""&lt;/Modulus&gt;""));
}
//write Exp
...
//write the bignum in rsa structure you want
BIO_write(bio, ""&lt;/RSAKeyPair&gt;\n"",strlen(""&lt;/RSAKeyPair&gt;""));
</code></pre>
"
"<pre><code>RSA_print_fp(stdout, x, 0);
</code></pre>

<p><a href=""http://linux.die.net/man/3/rsa_print_fp"" rel=""nofollow"">http://linux.die.net/man/3/rsa_print_fp</a></p>
"
"<pre><code>#include &lt;iostream&gt;
using std::cout;
using std::endl;

#include &lt;string&gt;
using std::string;

#include &lt;memory&gt;
using std::unique_ptr;

#include &lt;openssl/bn.h&gt;
#include &lt;openssl/rsa.h&gt;
#include &lt;openssl/bio.h&gt;
#include &lt;openssl/buffer.h&gt;

#include &lt;cassert&gt;
#define ASSERT assert

using BN_ptr = std::unique_ptr&lt;BIGNUM, decltype(&amp;::BN_free)&gt;;
using RSA_ptr = std::unique_ptr&lt;RSA, decltype(&amp;::RSA_free)&gt;;
using BIO_MEM_ptr = std::unique_ptr&lt;BIO, decltype(&amp;::BIO_free)&gt;;

int main(int argc, char* argv[])
{
    int rc;

    RSA_ptr rsa(RSA_new(), ::RSA_free);
    BN_ptr bn(BN_new(), ::BN_free);
    BIO_MEM_ptr bio(BIO_new(BIO_s_mem()), ::BIO_free);

    rc = BN_set_word(bn.get(), RSA_F4);
    ASSERT(rc == 1);

    rc = RSA_generate_key_ex(rsa.get(), 2048, bn.get(), NULL);
    ASSERT(rc == 1);

    rc = RSA_print(bio.get(), rsa.get(), 0);
    ASSERT(rc == 1);

    BUF_MEM* mem = NULL;
    BIO_get_mem_ptr(bio.get(), &amp;mem);
    ASSERT(mem != NULL);

    string s;
    if(mem-&gt;data &amp;&amp; mem-&gt;length)
        s.assign(mem-&gt;data, mem-&gt;length);

    if(s.length())
        cout &lt;&lt; s &lt;&lt; endl;
    else
        cout &lt;&lt; ""Failed to retrieve key"" &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>A typical run:</p>

<pre><code>$ ./test-openssl.exe
Private-Key: (1024 bit)
modulus:
    00:9e:44:ab:26:da:2d:42:3f:ea:06:1f:3b:80:22:
    39:0f:89:ee:38:ba:f9:49:a6:7d:69:be:f7:b8:43:
    30:db:7b:32:82:09:89:c4:84:43:af:75:33:22:40:
    07:ad:43:c8:56:54:f3:c5:6e:a5:bc:a6:b2:83:49:
    a4:07:8e:d3:b8:a1:5b:c9:55:04:0a:01:73:12:85:
    93:ef:20:0b:29:2e:a8:2d:4f:4a:1d:ad:31:b8:81:
    dd:57:49:3c:d1:57:71:29:c3:34:1c:cf:ba:31:86:
    cb:d6:d7:92:b9:3c:84:ca:2e:f6:fa:85:0a:86:e4:
    b1:e0:1e:00:86:d9:c6:14:37
publicExponent: 65537 (0x10001)
privateExponent:
    5e:1d:7f:99:af:0c:52:e5:27:09:54:f1:51:15:08:
    d1:90:b8:34:cc:1b:0a:0d:13:6f:1a:bc:bc:ba:58:
    07:6c:8f:70:7c:b3:8c:45:0a:ea:ff:ca:d4:87:37:
    09:75:d1:60:65:4c:41:0f:b7:47:23:e9:eb:e0:92:
    c6:5b:cc:d2:82:d5:f3:42:75:d4:88:95:35:20:62:
    f9:9a:18:df:6b:5b:ff:6c:97:11:63:d6:24:2c:86:
    bb:be:c1:ed:a3:87:8e:78:70:7a:c8:fc:73:9c:53:
    70:eb:ff:06:b9:91:be:81:56:a5:25:71:d3:54:09:
    04:ea:8d:1e:8e:48:eb:c1
prime1:
    00:cc:25:66:b7:dc:66:64:eb:5c:f2:15:9f:7b:66:
    c0:9e:8d:51:63:e0:8b:15:73:64:54:d2:62:35:a6:
    14:29:20:ba:92:3e:dc:d4:32:6a:c6:ba:45:56:94:
    3e:77:e1:ab:e0:60:cf:12:2b:09:1f:45:0e:2c:b2:
    49:1e:85:66:ef
prime2:
    00:c6:78:0f:44:19:cc:74:22:32:58:d1:ee:a7:6f:
    fa:b4:57:a4:4a:7c:7a:52:53:c8:52:48:34:05:b4:
    59:3f:18:a3:88:17:fd:ae:2e:54:d7:83:2c:a9:bf:
    52:7b:f4:e9:af:02:61:99:fa:35:4a:b0:e4:a0:8c:
    5f:f8:d8:67:39
exponent1:
    00:a3:41:7d:c5:a7:72:13:5e:cd:b3:a3:6b:28:ca:
    61:5b:ea:73:9e:45:e1:b4:43:d5:86:a7:c0:76:5a:
    dc:60:8f:95:e4:82:75:23:15:36:a2:ba:2f:dd:2f:
    2c:4d:be:a1:2f:0c:fc:4b:f1:32:98:59:27:1e:c3:
    6d:0a:05:70:ed
exponent2:
    00:97:d5:de:08:01:9c:b2:f4:3e:84:49:07:45:bd:
    9b:95:40:bf:85:e4:b9:48:26:a4:c8:9e:48:7e:5c:
    bd:32:52:4d:39:9e:f1:0a:c2:93:51:d5:1e:e4:36:
    64:8a:44:92:4a:bb:8d:a3:d9:11:d0:34:88:94:73:
    10:31:36:8d:b1
coefficient:
    1d:97:1c:37:72:66:87:6f:a8:10:5d:bf:02:31:3d:
    69:bb:a8:13:78:cb:20:d7:70:ee:f9:ba:1e:a9:e1:
    ca:5b:db:a8:12:64:39:32:4f:0b:b8:0e:0f:fc:2c:
    ec:89:25:06:bf:84:d7:94:e5:18:bd:80:f4:74:ba:
    5e:0a:4c:24
</code></pre>

<hr>

<p>If you don't like that output, you can access the <code>RSA</code> members directly. For example:</p>

<pre><code>// RSA object 'owns' the BIGNUM. Don't destroy it.
BIGNUM* n = rsa.get()-&gt;n;
BIGNUM* e = rsa.get()-&gt;e;
BIGNUM* d = rsa.get()-&gt;d;

string s;

BIO_reset(bio.get());
mem = NULL;

rc = BN_print(bio.get(), n);
ASSERT(rc == 1);

BIO_get_mem_ptr(bio.get(), &amp;mem);
if(mem &amp;&amp; mem-&gt;data &amp;&amp; mem-&gt;length)
    s.assign(mem-&gt;data, mem-&gt;length);

if(s.length())
    cout &lt;&lt; ""Modulus: "" &lt;&lt; endl &lt;&lt; s &lt;&lt; endl;
else
    cout &lt;&lt; ""Failed to retrieve modulus"" &lt;&lt; endl;

BIO_reset(bio.get());
mem = NULL;

rc = BN_print(bio.get(), e);
ASSERT(rc == 1);

BIO_get_mem_ptr(bio.get(), &amp;mem);
if(mem &amp;&amp; mem-&gt;data &amp;&amp; mem-&gt;length)
    s.assign(mem-&gt;data, mem-&gt;length);

if(s.length())
    cout &lt;&lt; ""Public exponent: "" &lt;&lt; endl &lt;&lt; s &lt;&lt; endl;
else
    cout &lt;&lt; ""Failed to retrieve public exponent"" &lt;&lt; endl;

BIO_reset(bio.get());
mem = NULL;

rc = BN_print(bio.get(), d);
ASSERT(rc == 1);

BIO_get_mem_ptr(bio.get(), &amp;mem);
if(mem &amp;&amp; mem-&gt;data &amp;&amp; mem-&gt;length)
    s.assign(mem-&gt;data, mem-&gt;length);

if(s.length())
    cout &lt;&lt; ""Private exponent: "" &lt;&lt; endl &lt;&lt; s &lt;&lt; endl;
else
    cout &lt;&lt; ""Failed to retrieve private exponent"" &lt;&lt; endl;
</code></pre>

<p>Output will be similar to:</p>

<pre><code>Modulus:
E00226E63C7BE6A23990592F3F861393B1F563D7CF57699619E6ED558EFA6D64C326203825E163EF
28B7B3608C68B8A9F1A5952FA8E4C42A4F6066BE6D1502D20894577C91DB94F6F596891DCF9532E2
19FBAEA1201215E014DEE8A270BEABDFC7D00860BF3C08A26707CADAECCF9A2229984C23F198691E
B59D26D4AC8460BD
Public exponent:
10001
Private exponent:
3D3E99600D5D5ABB33BDD184677BC2D278AF3CB2FE4F49E0EE08030F875DD496DDFC08871164442C
591790856F1E1A8EEC30774F667FD55A34058951BB052995BC24A80AAA547E1764FB33500007A743
C9B41F376F655EB8BDD729172F8592886C299994565F9F72A0235CBB22AA33BD1A2D20AF07DCBAC5
6DB22E4DCBC4DCC1
</code></pre>

<hr>

<p>If you like the formatting of the first example (the octets separated with a colon), then take a look at <code>ASN1_bn_print</code>. You can use it to print <code>RSA</code> members in turn. <code>RSA_print</code> and <code>RSA_print_fp</code> internally calls <code>ASN1_bn_print</code>. There's an example of it at <a href=""https://stackoverflow.com/questions/23176439/openssl-command-in-c-to-get-modulus-of-a-public-key-in-the-rsa"">OpenSSL command in c to get Modulus of a public Key in the RSA</a>.</p>

<pre><code>BIGNUM* n = rsa.get()-&gt;n;

int req = BN_num_bytes(n) + 4;
unsigned char* ptr = (unsigned char*)OPENSSL_malloc(req);

rc = ASN1_bn_print(bio.get(), ""Modulus:"", n, ptr, 0);
ASSERT(rc == 1);

BIO_get_mem_ptr(bio.get(), &amp;mem);
if(mem &amp;&amp; mem-&gt;data &amp;&amp; mem-&gt;length)
    s.assign(mem-&gt;data, mem-&gt;length);

if(s.length())
    cout &lt;&lt; s &lt;&lt; endl;
else
    cout &lt;&lt; ""Failed to retrieve modulus"" &lt;&lt; endl;
</code></pre>

<p>It will produce output similar to:</p>

<pre><code>Modulus:
    00:bf:49:fa:f2:30:21:42:de:91:60:f3:02:37:87:
    86:f4:eb:85:2c:95:86:42:69:6f:bc:cf:3f:27:9e:
    17:b6:44:06:5f:e7:ea:9f:e8:38:a7:5a:d5:da:9f:
    4b:26:df:78:15:d7:df:22:c0:16:12:77:f9:18:aa:
    85:01:21:3a:b0:ae:39:b8:07:cd:d4:2c:a3:0b:1c:
    df:be:09:03:09:76:5f:a1:1e:c0:00:8e:bf:b2:40:
    e2:3c:eb:d1:85:6f:7a:ab:35:c3:3a:c4:23:db:39:
    0c:d0:2b:39:b3:a5:a5:08:a2:e4:00:d5:0b:b0:87:
    62:ae:7c:a4:6c:e6:1c:d6:c9
</code></pre>

<hr>

<p>You can also use <code>BN_bn2dec</code> and friends. For example:</p>

<pre><code>BIGNUM* n = rsa.get()-&gt;n;
cout &lt;&lt; ""BN_bn2dec:"" &lt;&lt; endl;
cout &lt;&lt; BN_bn2dec(n) &lt;&lt; endl;
</code></pre>

<p>It will produce:</p>

<pre><code>BN_bn2dec:
12243739000135209335165415265342326792394455644180015057748915050940947919482400
64106225312022889083399949792870649447719809295883754268473265926413766309145047
08000254475023744104439182803717332048247971986885955229841406443364223719542912
385690146029374797423322891147172613041161904860242946608474463378207
</code></pre>
"
"<p>Are you on your recipient list? Because you need to be the recipient to decrypt the message. Make sure you use the correct key and certificates.</p>
"
"<p><code>PKCS7_decrypt(p7, rkey, rcert, out, 0)</code> is failing because the BIO ""out"" that you are passing to the routine is a null pointer.</p>

<p>If you do not want to write the output into a file, try passing a memory BIO: </p>

<pre><code>BIO *out = BIO_new(BIO_s_mem());
</code></pre>

<p>Then you can access the decrypted data directly from out, and once you are done with it you can destroy it.</p>
"
"<p>Try to add the following line:</p>

<p>OpenSSL_add_all_ciphers();</p>
"
"<p>I just copied the sample of OpenSSL cms_dec which works with PEM and adapted it for DER Encoded CMS File</p>

<pre><code>BIO *in = NULL, *out = NULL, *tbio = NULL;
X509 *cert= NULL;
EVP_PKEY *rkey = NULL;
CMS_ContentInfo *cms = NULL;
int ret = 1;

OpenSSL_add_all_algorithms();
ERR_load_crypto_strings();

/* Read in recipient certificate and private key */
tbio = BIO_new_file(""yourCMS.der"", ""r"");
rcert = i2d_x509_bio(tbio, NULL);
BIO_reset(tbio);
i2d_PrivateKey_bio(tbio, rkey);

/* Open S/MIME message to decrypt */
in = BIO_new_file(""smencr.txt"", ""r"");

/* Parse message */
cms = SMIME_read_CMS(in, NULL);

out = BIO_new_file(""decout.txt"", ""w"");

/* Decrypt S/MIME message */
CMS_decrypt(cms, rkey, rcert, out, NULL, CMS_BINARY) //Edit : Added Flags for DER.
...
</code></pre>
"
"<p>It could be because your code doesn't call <code>SSL_library_init();</code>. Adding that, the includes, a <code>main</code> and removing references to <code>connection</code> made it all work for me.</p>

<p>Without  <code>SSL_library_init();</code> it crashed in <code>BIO_should_retry</code> because <code>bio</code> was <code>NULL</code>.</p>
"
"<p>I was freeing the memory properly. It turned out that the issue was a result of me using OpenSSL with threads but not initializing OpenSSLs threading system.</p>
"
"<p>Finally did it. </p>

<p>It was just a missing flag. </p>

<pre><code>int flgs = PKCS7_STREAM | PKCS7_DETACHED | PKCS7_BINARY ;
</code></pre>

<p>Added this flag and it started working perfectly. </p>
"
"<p>I have found my solution. Here is the piece of code I have used :</p>

<pre><code>BIO* output = BIO_new(BIO_s_mem());
if (CMS_verify(cms, stack, store, dcont, nullptr, CMS_NOINTERN)) {
    CMS_ContentInfo* cms2 = SMIME_read_CMS(dcont, nullptr);
}
</code></pre>

<p>Apparently, it is the dcont <code>BIO</code> that holds the <code>SignedData</code> and I can properly decrypt it afterwards using the <code>cms2</code> variable.</p>
"
"<p>No, <a href=""https://linux.die.net/man/3/bio_reset"" rel=""nofollow noreferrer"">BIO_Reset</a>() does not close the underlying file descriptor. You don't need to call BIO_Reset in the code you have shown if all you do afterwards is to free/close the BIO.</p>

<p>BIO_free()/BIO_free_all() will close the underlying file descriptor if you have set the BIO_CLOSE flag on the BIO. Otherwise you have to close() the file descriptor yourself.</p>

<p>(Note that your ERR_clear_error and other ERR_ calls operate globally, you shouldn't perform these calls unless you never intend to use the SSL library again)</p>
"
"<p>The split_bio() function only works for bios with a single page (when bi_vcnt field is exactly 1).</p>

<p>To deal with bios with multiple pages - and I suspect you deal with these most of the time - you have to create new bios and set them up so that they contain only a single sector.</p>

<p>Tip: If the sector size is the same as the page size (currently 4K), and your block driver tells the kernel to supply no less than this size, than you only have to put each page from the incoming bio to the new bio. If the sector size is less then the page size, than the logic will be a bit more complicated.</p>

<p>Use bio_kmalloc to allocate the new bios and copy the data onto the memory pages in them manually.</p>
"
"<p>Replace the below line from your code </p>

<p><em>blkdev = lookup_bdev(path);</em></p>

<p>and use, </p>

<p><em>blkdev = blkdev_get_by_path(path, FMODE_READ | FMODE_WRITE, NULL);</em></p>

<p>This should fix the kernel reboot problem.</p>
"
"<p>There is no standard library in the C-standard to read the file-formats.</p>

<p>However, most programs, especially on the linux platform use the same library to decode the image-formats: </p>

<p>For jpeg it's libjpeg, for png it's libpng. </p>

<p>The chances that the libs are already installed is <em>very</em> high.</p>

<p><a href=""http://www.libpng.org"" rel=""noreferrer"">http://www.libpng.org</a></p>

<p><a href=""http://www.ijg.org"" rel=""noreferrer"">http://www.ijg.org</a> </p>
"
"<p>For jpeg, there is already a library called <a href=""http://en.wikipedia.org/wiki/Libjpeg"" rel=""nofollow noreferrer"">libjpeg</a>, and there is <a href=""http://www.libpng.org/pub/png/libpng.html"" rel=""nofollow noreferrer"">libpng</a> for png. The good news is that they compile right in and so target machines will not need dll files or anything. The bad news is they are in C :(</p>

<p>Also, don't even think of <a href=""http://en.wikipedia.org/wiki/Jpeg#Discrete_cosine_transform"" rel=""nofollow noreferrer"">trying to read</a> <a href=""http://en.wikipedia.org/wiki/DEFLATE#Encoder_.2F_Compressor"" rel=""nofollow noreferrer"">the files</a> yourself. If you want an easy-to-read format, use <a href=""http://en.wikipedia.org/wiki/Portable_pixmap"" rel=""nofollow noreferrer"">PPM</a> instead.</p>
"
"<p>Unfortunately, jpeg format is compressed, so you would have to decompress it before reading individual pixels. This is a non-trivial task. If you can't use a library, you may want to refer to one to see how it's decompressing the image. There is an open-source library on sourceforge: <a href=""http://cimg.sourceforge.net/reference/group__cimg__tutorial.html"" rel=""nofollow noreferrer"">CImg on sourceforge.</a></p>
"
"<p>This is a small routine I digged from 10 year old source code (using libjpeg):</p>

<pre><code>#include &lt;jpeglib.h&gt;

int loadJpg(const char* Name) {
  unsigned char a, r, g, b;
  int width, height;
  struct jpeg_decompress_struct cinfo;
  struct jpeg_error_mgr jerr;

  FILE * infile;        /* source file */
  JSAMPARRAY pJpegBuffer;       /* Output row buffer */
  int row_stride;       /* physical row width in output buffer */
  if ((infile = fopen(Name, ""rb"")) == NULL) {
    fprintf(stderr, ""can't open %s\n"", Name);
    return 0;
  }
  cinfo.err = jpeg_std_error(&amp;jerr);
  jpeg_create_decompress(&amp;cinfo);
  jpeg_stdio_src(&amp;cinfo, infile);
  (void) jpeg_read_header(&amp;cinfo, TRUE);
  (void) jpeg_start_decompress(&amp;cinfo);
  width = cinfo.output_width;
  height = cinfo.output_height;

  unsigned char * pDummy = new unsigned char [width*height*4];
  unsigned char * pTest = pDummy;
  if (!pDummy) {
    printf(""NO MEM FOR JPEG CONVERT!\n"");
    return 0;
  }
  row_stride = width * cinfo.output_components;
  pJpegBuffer = (*cinfo.mem-&gt;alloc_sarray)
    ((j_common_ptr) &amp;cinfo, JPOOL_IMAGE, row_stride, 1);

  while (cinfo.output_scanline &lt; cinfo.output_height) {
    (void) jpeg_read_scanlines(&amp;cinfo, pJpegBuffer, 1);
    for (int x = 0; x &lt; width; x++) {
      a = 0; // alpha value is not supported on jpg
      r = pJpegBuffer[0][cinfo.output_components * x];
      if (cinfo.output_components &gt; 2) {
        g = pJpegBuffer[0][cinfo.output_components * x + 1];
        b = pJpegBuffer[0][cinfo.output_components * x + 2];
      } else {
        g = r;
        b = r;
      }
      *(pDummy++) = b;
      *(pDummy++) = g;
      *(pDummy++) = r;
      *(pDummy++) = a;
    }
  }
  fclose(infile);
  (void) jpeg_finish_decompress(&amp;cinfo);
  jpeg_destroy_decompress(&amp;cinfo);

  BMap = (int*)pTest;
  Height = height;
  Width = width;
  Depth = 32;
}
</code></pre>
"
"<p>I've had good experiences with the <a href=""http://openil.sourceforge.net/"" rel=""nofollow noreferrer"">DevIL</a> library. It supports a wide range of image formats and follows a  function-style very similar to OpenGL. </p>

<p>Granted, it is a library, but it's definitely worth a try.</p>
"
"<p>Since the other answers already mention that you will most likely need to use a library, take a look at <a href=""http://www.imagemagick.org/script/index.php"" rel=""nofollow noreferrer"">ImageMagick</a> and see if it is possible to do what you need it to do. It comes with a variety of different ways to interface with the core functionality of ImageMagick, including libraries for almost every single programming language available.</p>

<p>Homepage: <a href=""http://www.imagemagick.org/script/index.php"" rel=""nofollow noreferrer"">ImageMagick</a></p>
"
"<p>Since it could use the exposure, I'll mention one other library to investigate: <a href=""http://www.tecgraf.puc-rio.br/im"" rel=""nofollow noreferrer"">The IM Toolkit</a>, which is hosted at <a href=""http://sourceforge.net/projects/imtoolkit/"" rel=""nofollow noreferrer"">Sourceforge</a>. It is cross platform, and abstracts the file format completely away from the user, allowing an image to be loaded and processed without worrying about most of the details. It does support both PNG and JPEG out of the box, and can be extended with other import filters if needed.</p>

<p>It comes with a large collection of image processing operators as well...</p>

<p>It also has a good quality binding to <a href=""http://www.lua.org/"" rel=""nofollow noreferrer"">Lua</a>.</p>
"
"<p>As Nils pointed, there is no such thing as a C or C++ standard library for JPEG compression and image manipulation.</p>

<p>In case you'd be able to use a third party library, you may want to try <a href=""http://www.gdal.org"" rel=""nofollow noreferrer"">GDAL</a> which supports JPEG, PNG and tens of other formats, compressions and mediums.</p>

<p>Here is simple example that presents how to read pixel data from JPEG file using GDAL C++ API:</p>

<pre><code>#include &lt;gdal_priv.h&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main()
{
    GDALAllRegister(); // once per application

    // Assume 3-band image with 8-bit per pixel per channel (24-bit depth)
    std::string const file(""/home/mloskot/test.jpg"");

    // Open file with image data
    GDALDataset* ds = static_cast&lt;GDALDataset*&gt;(GDALOpen(file.c_str(), GA_ReadOnly));
    assert(0 != ds);

    // Example 1 - Read multiple bands at once, assume 8-bit depth per band
    {
        int const ncols = ds-&gt;GetRasterXSize();
        int const nrows = ds-&gt;GetRasterYSize();
        int const nbands = ds-&gt;GetRasterCount();
        int const nbpp = GDALGetDataTypeSize(GDT_Byte) / 8;
        std::vector&lt;unsigned char&gt; data(ncols * nrows * nbands * nbpp);

        CPLErr err = ds-&gt;RasterIO(GF_Read, 0, 0, ncols, nrows, &amp;data[0], ncols, nrows, GDT_Byte, nbands, 0, 0, 0, 0);
        assert(CE_None == err);

        // ... use data
    }

    // Example 2 - Read first scanline by scanline of 1 band only, assume 8-bit depth per band
    {
        GDALRasterBand* band1 = ds-&gt;GetRasterBand(1);
        assert(0 != band1);

        int const ncols = band1-&gt;GetXSize();
        int const nrows = band1-&gt;GetYSize();
        int const nbpp = GDALGetDataTypeSize(GDT_Byte) / 8;
        std::vector&lt;unsigned char&gt; scanline(ncols * nbpp);

        for (int i = 0; i &lt; nrows; ++i)
        {
            CPLErr err = band1-&gt;RasterIO(GF_Read, 0, 0, ncols, 1, &amp;scanline[0], ncols, 1, GDT_Byte, 0, 0);
            assert(CE_None == err);

            // ... use scanline
        }
    }

    return 0;
}
</code></pre>

<p>There is more complete <a href=""http://www.gdal.org/gdal_tutorial.html"" rel=""nofollow noreferrer"">GDAL API tutorial</a> available.</p>
"
"<p><strong>If speed is not a problem</strong> you can try <a href=""http://members.gamedev.net/lode/projects/LodePNG/"" rel=""nofollow"">LodePNG</a> that take a very minimalist approach to PNG loading and saving.</p>

<p>Or even go with picoPNG from the same author that is a self-contained png loader in a function.</p>
"
"<p>1) You don't need stream operators for class B, but it does need a serialize() method. I had to wrap the serialization with the <code>BOOST_SERIALIZATION_NVP</code> (name value pair) macro:</p>

<pre><code>ar &amp; BOOST_SERIALIZATION_NVP(someNamedValue); // use this macro for everything you want to name
</code></pre>

<p>There might be a way to avoid naming your map, but I don't know how that's done.</p>

<p>2) No, class A doesn't need map-specific serialization code. Just make sure you include <code>&lt;boost/serialization/map.hpp&gt;</code>.</p>

<p>3) The implicit default constructor should be fine. You only ever need an explicit default constructor if a) you've already provided a non-default constructor or b) you want to change the behavior of the default constructor.</p>

<p>4) No operator &lt; is needed :)</p>

<p>Here's some sample code which compiled, but I haven't run:</p>

<pre><code>#include &lt;boost/serialization/map.hpp&gt;

struct A
{
    struct B
    {
        template&lt;class Archive&gt;
        void serialize(Archive &amp;ar, const unsigned int version)
        {
        }
    };
    typedef std::map&lt;int, SomeClass&gt; MyMap;
    MyMap myMap;

    template&lt;class Archive&gt;
    void serialize(Archive &amp;ar, const unsigned int version)
    {
        ar &amp; BOOST_SERIALIZATION_NVP(myMap);
    }
};
</code></pre>
"
"<p>It's actually very straightforward to do. Use</p>

<p><code>Bitmap yourBitmap = Bitmap.createBitmap(sourceBitmap, x to start from, y to start from, width, height)</code></p>

<p>Update: use <a href=""http://developer.android.com/reference/android/graphics/BitmapRegionDecoder.html"" rel=""nofollow noreferrer"">BitmapRegionDecoder</a></p>
"
"<p>try this</p>

<pre><code>InputStream istream =   null;
try {
     istream = this.getContentResolver().openInputStream(yourBitmapUri);
} catch (FileNotFoundException e1) {
     e1.printStackTrace();
}

BitmapRegionDecoder decoder     =   null;
try {
    decoder = BitmapRegionDecoder.newInstance(istream, false);
} catch (IOException e) {
    e.printStackTrace();
}
Bitmap bMap = decoder.decodeRegion(new Rect(istream, x to start from, y to start from, x to end with, y to end with), null);
imageView.setImageBitmap(bMap);
</code></pre>
"
"<p>@RKN</p>

<p>Your method can also throw OutOfMemoryError exception - if cropped bitmap exceeds VM.</p>

<p>My method combines Yours and protection against this exeption:
(l, t, r, b - % of image)</p>

<pre><code>    Bitmap cropBitmap(ContentResolver cr, String file, float l, float t, float r, float b)
{
    try
    {
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;

        // First decode with inJustDecodeBounds=true to check dimensions
        BitmapFactory.decodeFile(file, options);
        int oWidth = options.outWidth;
        int oHeight = options.outHeight;

        InputStream istream = cr.openInputStream(Uri.fromFile(new File(file)));

        BitmapRegionDecoder decoder = BitmapRegionDecoder.newInstance(istream, false);
        if (decoder != null)
        {
            options = new BitmapFactory.Options();

            int startingSize = 1;
            if ((r - l) * oWidth * (b - t) * oHeight &gt; 2073600)
                startingSize = (int) ((r - l) * oWidth * (b - t) * oHeight / 2073600) + 1;

            for (options.inSampleSize = startingSize; options.inSampleSize &lt;= 32; options.inSampleSize++)
            {
                try
                {
                    return decoder.decodeRegion(new Rect((int) (l * oWidth), (int) (t * oHeight), (int) (r * oWidth), (int) (b * oHeight)), options);
                }
                catch (OutOfMemoryError e)
                {
                    Continue with for loop if OutOfMemoryError occurs
                }
            }
        }
        else
            return null;
    }
    catch (FileNotFoundException e)
    {
        e.printStackTrace();
    }
    catch (IOException e)
    {
        e.printStackTrace();
    }

    return null;
}
</code></pre>

<p>and returns max available bitmap or null</p>
"
"<p>Use <a href=""https://github.com/suckgamony/RapidDecoder"" rel=""nofollow"">RapidDecoder</a>.</p>

<p>And simply do this</p>

<pre><code>import rapid.decoder.BitmapDecoder;

Rect bounds = new Rect(left, top, right, bottom);
Bitmap bitmap = BitmapDecoder.from(getResources(), R.drawable.image)
        .region(bounds).decode();
</code></pre>

<p>It requires Android 2.2 or above.</p>
"
"<p>You can load the scaled version of bitmap with out fully loading the bitmap using following algorithm</p>

<ul>
<li>Calculate the maximum possible inSampleSize that still yields an
image larger than your target.   </li>
<li>Load the image using
BitmapFactory.decodeFile(file, options), passing inSampleSize as an
option.   </li>
<li>Resize to the desired dimensions using
Bitmap.createScaledBitmap().</li>
</ul>

<p>Check the following post
<a href=""https://stackoverflow.com/questions/3331527/android-resize-a-large-bitmap-file-to-scaled-output-file"">Android: Resize a large bitmap file to scaled output file</a> for further details.</p>
"
"<p>Well, <a href=""http://lxr.linux.no/#linux+v2.6.33/arch/um/drivers/cow_user.c"" rel=""nofollow noreferrer"">http://lxr.linux.no/#linux+v2.6.33/arch/um/drivers/cow_user.c</a> indicates that User Mode Linux uses an explicit bitmap for this, FWIW.</p>
"
"<p><a href=""http://www.kernel.org/doc/Documentation/filesystems/fiemap.txt"" rel=""nofollow noreferrer"">/usr/src/linux/Documentation/filesystems/fiemap.txt</a></p>

<blockquote>
  <p>The fiemap ioctl is an efficient method for userspace to get file
  extent mappings. Instead of block-by-block mapping (such as bmap), fiemap
  returns a list of extents.</p>
</blockquote>

<p>There's a quick example of usage in <a href=""http://kernel.ubuntu.com/git?p=cking/debug-code/.git;a=tree;f=fiemap;hb=HEAD"" rel=""nofollow noreferrer"">git://kernel.ubuntu.com/cking/debug-code/</a>fiemap/.  A sparse file will lack extents for the ""missing"" portions.</p>
"
"<p>Since Linux 3.1, <a href=""http://man7.org/linux/man-pages/man2/lseek.2.html"" rel=""nofollow noreferrer""><code>lseek</code></a> provides flags <code>SEEK_HOLE</code> and <code>SEEK_DATA</code> to navigate to the beginning or end of a hole, so this might be an alternative to the <code>ioctl</code> based <a href=""https://stackoverflow.com/a/2564060/1468366"">solution</a>. Haven't tried either in practice, so I don't have any real experience to compare the two.</p>
"
"<p>It isn't possible in a filesystem-independent way.  Filesystems aren't necessarily even built on top of block devices (simple example: NFS).</p>

<p>For <code>ext2</code>, <code>ext3</code> and <code>ext4</code> you can use the <code>ext2fslib</code> library, which is included in the <code>e2fsprogs</code> distribution.</p>
"
"<p>For at least your first question, it is possible in a filesystem-independent way. Copying from <a href=""https://serverfault.com/questions/29886/how-do-i-list-a-files-data-blocks-on-linux/29918#29918"">my answer to a serverfault question</a>:</p>

<blockquote>
  <p>A simple way to get the list of blocks (without having to read from the partition like in the <code>debugfs</code> answers) is to use the <code>FIBMAP</code> ioctl. I do not know of any command to do so, but it is very simple to write one; a quick Google search gave me <a href=""http://lists.debian.org/debian-mips/2002/04/msg00059.html"" rel=""nofollow noreferrer"">an example of FIBMAP use</a>, which does exactly what you want. One advantage is that it will work on any filesystem which supports the <code>bmap</code> operation, not just ext3.</p>

  <p>A newer (and more efficient) alternative is the <code>FIEMAP</code> ioctl, which can also return detailed information about extents (useful for ext4).</p>
</blockquote>

<p>Unfortunately, I do not know of anything similar for the free space. I only know about <a href=""http://xfs.org/index.php/FITRIM/discard"" rel=""nofollow noreferrer""><code>FITRIM</code></a>, which tells the underlying block device to discard the blocks corresponding to the free space of the filesystem.</p>
"
"<p>A <strong>filefrag</strong> command line tool let's you look at allocation of files. It uses the FIEMAP/FIBMAP ioctls mentioned in earlier answers. As mentioned before this is filesystem dependent. Not sure whether anything else than ext2/3/4 supports those ioctls.</p>

<p>I'm not sure whether the pysical values reported refer to the start of the disk or to the start of the block device (partition or logical volume). I have the feeling it might be the latter one. Calling it on a bunch of files located on the same disk but in different partitions will tell.</p>

<p>The <strong>dumpe2fs</strong> command will report free blocks. Again it is specific to ext2/3/4 filesystems. Block numbers seem to be relative to the partition.</p>
"
"<p>You have to call the function BZ2_bzBuffToBuffDecompress from the libbzip2 library
<a href=""http://www.bzip.org/1.0.6/bzip2-1.0.6.tar.gz"" rel=""nofollow"">http://www.bzip.org/1.0.6/bzip2-1.0.6.tar.gz</a></p>

<p>Here is the documentation:
<a href=""http://www.bzip.org/1.0.3/html/util-fns.html"" rel=""nofollow"">http://www.bzip.org/1.0.3/html/util-fns.html</a></p>

<p>You would call that code somehow like this:</p>

<pre><code>#include &lt;malloc.h&gt;


int size;
void *buf=build_save(&amp;size, ... add all the parameters ... );

enum{DEST=100000};
char*dest=malloc(DEST);
BZ2_bzBuffToBuffDecompress( dest,
                            DEST, //unsigned int* destLen,
                            buf+12, //char*         source,
                            size-12, //unsigned int  sourceLen,
                            int           small,
                            int           verbosity );
</code></pre>

<p>Where I realize that you didn't give enough information.
Try to search for your source for a call to</p>

<pre><code>BZ2_bzDecompressInit ( bz_stream *strm, int verbosity, int small );
</code></pre>

<p>You will need to know the parameters verbosity and small for the decompression.</p>
"
"<p>You should use <code>iterator</code> instead of <code>const_iterator</code>, if your intent is to call <code>clear</code>. <code>const_iterator</code> is for cases where you are calling only <code>const</code> member functions.</p>

<p>Using <code>mutable</code> is not appropriate for this situation. Only mark member variables <code>mutable</code> if they are not part of the object's visible state, e.g., cached data.</p>
"
"<p>Have you tried, putting simple <code>iterator</code> ?</p>

<pre><code>AList::iterator a;
</code></pre>

<p><code>const_iterator</code> doesn't allow the members to be modifiable (some what like <code>const</code> in normal context).</p>
"
"<p>The code given by you is not correct. <code>destroy</code> should have been a const-member of class, but you have shown it as global function. Since/If <code>destroy</code> is const method, <code>clear</code> wouldn't work on it.</p>
"
"<p>In your custom Gallery </p>

<pre><code>@Override
public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX,float velocityY) {
    --&gt;&gt; super.onFling(e1, e2, 20, velocityY); &lt;&lt;--

    return false;
}
</code></pre>

<p>Try modifying the 3rd parameter.</p>
"
"<p>Instead of declaring Gallery in you xml.</p>

<pre><code>Gallery gallery = new  CustomGaller(getActivity());

RelativeLayout.LayoutParams params = new RelativeLayout.LayoutParams  (LayoutParams.FILL_PARENT,LayoutParams.FILL_PARENT);
            params.addRule(RelativeLayout.RIGHT_OF, R.id.left);
            params.addRule(RelativeLayout.LEFT_OF,R.id.right);
            gallery.setLayoutParams(params);
            gallery.setAdapter(new GalleryAdapter(&lt;Pass values&gt;));
</code></pre>

<p>You dant have to pass View id to CustomGallery.</p>
"
"<p>I don't think your project is really solvable at the <code>stat(2)</code> API layer. Consider the case of a file 4096 bytes long. Presume it was created by iteratively appending 512 byte blocks over and over again. Presume that the filesystem was completely full, except for one 512 byte block, for each and every write. Presume that the 512 byte block available for each write was located in a randomly available spot on the disk.</p>

<p>This file is 100% fragmented -- no two blocks are near each other.</p>

<p>And yet, a measure based solely on the <code>stat(2)</code> variables might well show that there are no wasted blocks anywhere in the file.</p>

<p>When trying to track down an answer to your actual question, I got as far as <code>ext3_write_begin()</code> before being called away -- hope this is a useful starting point for your search.</p>

<p><strong>Update</strong></p>

<p>If you're interested in finding fragmentation, I think the place to start is the <code>bmap</code> command from the <code>debugfs(8)</code> program:</p>

<pre class=""lang-none prettyprint-override""><code>debugfs:  bmap sars_first_radio_show.zip 0
94441752
debugfs:  bmap sars_first_radio_show.zip 1
94441781
debugfs:  bmap sars_first_radio_show.zip 2
94441782
debugfs:  bmap sars_first_radio_show.zip 3
94441783
debugfs:  bmap sars_first_radio_show.zip 4
94441784
debugfs:  bmap sars_first_radio_show.zip 5
94459905
debugfs:  bmap sars_first_radio_show.zip 6
95126019
debugfs:  bmap sars_first_radio_show.zip 7
95126020
debugfs:  bmap sars_first_radio_show.zip 8
95126021
debugfs:  bmap sars_first_radio_show.zip 9
95126022
debugfs:
</code></pre>

<p>This shows the first ten blocks for the file <code>sars_first_radio_show.zip</code>; you can see that the blocks aren't all contiguous: 944417{52,81,82,83,84}, 94459905, 951260{19,20,21,22}.</p>

<p>You could either script an answer around <code>debugfs(8)</code> or you could use the <code>libext2fs</code> library routines yourself. It would be a significant step up in complexity compared to the <code>stat(2)</code> exercises you were going through -- but the answers would <em>mean something</em>, rather than just be a vague guess. </p>
"
"<p>IIRC The st_blocks, has to report the st_size / 512 so various Linux programs work properly.  It doesn't necessarily have anything to do with the how many blocks are allocated on the file system.  Furthermore the st_blksize only tells higher level applications what size reads and writes to send down to the syscalls for optimal performance.  Once more this does not necessarily mean the file system is actually storing things in these block sizes.</p>

<p>The real answer to your questions regarding file fragmentation will be highly dependant on the FS you're working with.  I recommend starting your reading at a lower level </p>
"
"<p>Get the images in lower detail, or get a faster Phone.<br />
Either that, or program the gridview in such a way that the images are loaded only when you start to see them.</p>
"
"<p>you can modify your code like this:</p>

<pre><code>public View getView(final int position, View convertView, ViewGroup parent) {

    View MyView;

    if(convertView==null)
    {
        // Inflate the layout
        LayoutInflater li = ((Activity) MyContext).getLayoutInflater();

        MyView = li.inflate(R.layout.gallery_adapter, null);
        ImageButton imageFolders = (ImageButton) MyView.findViewById(R.id.folder);


        try {

            imageFolders.setImageBitmap(bMap);
            imageFolders.setOnClickListener(this);
            imageFolders.setId(products.get(position).getId());
        } catch (Exception e) {

        }

        MyView.setLayoutParams(70, 70);
    }
    else
        MyView = convertView;
    return MyView;
}
</code></pre>

<p>images already loaded will not be reloaded. have you tried this possibility ?</p>
"
"<pre><code>public View getView(final int position, View convertView, ViewGroup parent){

    View MyView;
    ImageButton imageFolders;

    if(convertView==null){
        LayoutInflater li = ((Activity) MyContext).getLayoutInflater();
        MyView = li.inflate(R.layout.gallery_adapter, null);
     }else{
        MyView = convertView;
     }

     imageFolders = (ImageButton) MyView.findViewById(R.id.folder);

     try {
        imageFolders.setImageBitmap(bMap);
        imageFolders.setOnClickListener(this);
        imageFolders.setId(products.get(position).getId());
     } catch (Exception e) {}

     MyView.setLayoutParams(70, 70);
     return MyView;
}
</code></pre>

<p>i didnt test it, but give it a try</p>
"
"<p>doing all the layout modifications like  <code>textView.setText(""text"");</code> inside the <code>if(convertView == null)</code> improved the performance extremely for me.</p>

<p>Also if you need to call <code>super.getView();</code> call it right after the <code>if(convertView == null)</code> Block.</p>

<p>For the <code>else</code> part <code>return convertView</code>.</p>
"
"<ol>
<li>Recycle your Views. Inflate the layout and set the layout params only once.</li>
<li>Make sure you don't load the Bitmap from disk/network on the main thread.</li>
<li>Simplify the view hierarchy in your grid item layout (R.layout.gallery_adapter).</li>
<li>Make sure hardware acceleration is not disabled in your app's manifest.</li>
<li>Make sure you don't have overdraw (drawing multiple backgrounds on top of each other).</li>
</ol>
"
"<p>I unfortunately can't help you with the original implementation of UNIX; but the job of mapping the high-level directory hierarchy to an on-disk representation, and for assigning ranges on the bare block device to files normally falls to one or more <em>file systems</em>. The POSIX spec makes some high-level demands on the file system, but what actually ends up on disk is completely specific to each file system.</p>

<p>The ext2 file system is comparatively simple, but a detailed explanation of it still fills an entire chapter of a book - one such book is <em>Understanding the Linux Kernel</em> by Daniel P. Bovet and Marco Cesati.</p>

<p>A more brief, higher-level introductory text comes with the Linux kernel itself, and <a href=""http://kernel.org/doc/Documentation/filesystems/ext2.txt"" rel=""nofollow"">can also be found here</a>. That directory also contains <a href=""http://kernel.org/doc/Documentation/filesystems/"" rel=""nofollow"">documentation on other Linux file systems</a> and also the ""VFS"" layer, which handles a lot of the higher-level aspects which are common to all or most file systems. <a href=""http://en.wikipedia.org/wiki/Ext2"" rel=""nofollow"">Wikipedia's ext2 article</a> also covers it at a high level. It also provides some links to more detailed online descriptions.</p>

<p>This is unfortunately not a topic that will fit in a SO answer, but I hope the above pointers help to get you started.</p>
"
"<p>The <code>unsigned long</code> values in this structure should be only 32 bits. Given the value you're displaying for <code>height</code> you're reading much more than that.</p>
"
"<p>If you are going to parse the data that way, which is discouraged, at least:</p>

<ul>
<li>Use correct, platform-independed types. <code>uint16_t</code> instead of <code>unsigned short</code>, <code>uint32_t</code> instead <code>unsigned long</code></li>
<li>Make your structures <a href=""http://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Type-Attributes.html"" rel=""nofollow"">packed</a>.</li>
</ul>

<p>It won't work everywhere, but should work at least on <code>x86</code> and <code>x86_64</code>.</p>

<p>It's discouraged mainly because it's platform and compiler dependent:</p>

<ul>
<li><code>__attribute__ ((packed))</code> is gcc extension. Other compilers may handle it differently.</li>
<li>On some platforms it's impossible to tightly pack a structure. On others, they will work a little slower.</li>
<li>It will work only on little-endian machines.</li>
</ul>
"
"<p>The type long on gcc 64 bit is 64 bits long, but the original structure uses LONG, defined as 32 bit integers on Windows:</p>

<pre><code>#pragma pack(push,1)
typedef struct tagBITMAPINFOHEADER {
  DWORD biSize; // use uint32_t instead
  LONG  biWidth;  // use int32_t instead
  LONG  biHeight; // use int32_t instead
  WORD  biPlanes;  // use uint16_t instead
  WORD  biBitCount;  // use uint16_t instead
  DWORD biCompression;  // use uint32_t instead
  DWORD biSizeImage;  // use uint32_t instead
  LONG  biXPelsPerMeter;  // use int32_t instead
  LONG  biYPelsPerMeter;  // use int32_t instead
  DWORD biClrUsed;  // use uint32_t instead
  DWORD biClrImportant;  // use uint32_t instead
} BITMAPINFOHEADER, *PBITMAPINFOHEADER;
#pragma pack(pop)
</code></pre>

<p>Also, be aware of negative height values: this identify an image where the first scan row is at the top of the image (you have to get a labs() of the height)
Positive height values identify an image where the first scan row is at the bottom of the image.</p>
"
"<p>I think this is an issue that you can't add elements to a map or set by copying to the end.  A more simple example that illustrate this is</p>

<pre><code>std::set&lt;int&gt; aSet;
std::set&lt;int&gt; bSet;
aSet.insert(0);

std::move(aSet.begin(), aSet.end(), bSet.end());
</code></pre>

<p>to get around this, you need an insert_iterator, so</p>

<pre><code>std::move(aSet.begin(), aSet.end(), inserter(bSet, bSet.begin()));
</code></pre>

<p>or</p>

<pre><code>std::move(aMap.begin(), aMap.end(), inserter(bMap, bMap.begin()));
</code></pre>

<p>Internally, the insert iterator will attempt to call 'insert' in the passed in container, so rather than trying to do '*(bMap.end()) = *(aMap.begin())', it will call 'bMap.insert(pos, *(aMap.begin()))', though pos is not extremely important for this situation.</p>
"
"<p>Try specifying external C linkage explicitly by putting the following near the top of the header file:</p>

<pre><code>#ifdef __cplusplus
extern ""C"" {
#endif
</code></pre>

<p>and this near the bottom:</p>

<pre><code>#ifdef __cplusplus
}
#endif
</code></pre>
"
"<p>Note that <code>""Height""""Map""</code> actually is the same as <code>""HeightMap""</code> when parsed. So you can simply use this:</p>

<pre><code>#define DO_MAPPING(x,y,z)\
    myMaps[map##x] = GetTex( #x ""Map"" );\
    myRemaps[map##x] = GetHandle( #x ""Remap"" );
</code></pre>
"
"<p>Try this instead:</p>

<pre><code>#define DO_MAPPING(x,y,z)\
    myMaps[map##x] = GetTex( #x ""Map"" );\
    myRemaps[map##x] = GetHandle( #x ""Remap"" );
</code></pre>

<p>Two string litterals are automatically concatenated by the compiler.</p>
"
"<p>In C, <code>""X""""Y""</code> is equivalent to <code>""XY""</code>. However, when you write such a thing in a macro:</p>

<pre><code>str1##str2
</code></pre>

<p>you are telling the lexer to <em>concat the two as <strong>one</strong> token</em>. <code>""X""""Y""</code> is actually two tokens that are concatenated by the lexer<sup>1</sup>, while <code>""X""##""Y""</code> is supposed to be one token (which is not a valid token).</p>

<p>What you need is to simply drop the <code>##</code>:</p>

<pre><code>#define DO_MAPPING(x,y,z)\
    myMaps[map##x] = GetTex( #x ""Map"" );\
    myRemaps[map##x] = GetHandle( #x ""Remap"" );
</code></pre>

<p><sup>1</sup> Or the semantics analyzer, depending on the implementation</p>

<hr>

<p>Typically, the regex matching a string looks like this (simplified):</p>

<pre><code>""(a|\b)*""
</code></pre>

<p>(assume <code>a</code> is a list of all characters that don't need to be escaped and  <code>b</code> is the others). Probably, for MSVC, it is defined like this:</p>

<pre><code>""(a|\b)*""s*+
</code></pre>

<p>(<code>s</code> is whitespace)</p>

<p>This means that MSVC probably sees <code>""X"" ""Y""</code> as one token instead of two.</p>
"
"<p>Just use <code>(#x ""Map"")</code> in place of <code>#x##""Map""</code>. It should work in C++. E.g. this is perfectly valid: <code>(""B"" ""Map"")</code> and evaluates to <code>""BMap""</code>.</p>
"
"<p>There doesn't seem to be any reason from your code to declare <code>m_mv_ab</code> as</p>

<pre><code>const std::shared_ptr&lt;MoveAbility&gt; m_mv_ab;
</code></pre>

<p>which is the smart-pointer version of:</p>

<pre><code>MoveAbility * const m_mv_ab;
</code></pre>

<p>(constant pointer to non-constant <code>MoveAbility</code>)</p>

<p>If you don't want to modify the pointed-to <code>MoveAbility</code> object and want it to be <code>const</code>, you should do:</p>

<pre><code>std::shared_ptr&lt;const MoveAbility&gt; m_mv_ab;
</code></pre>

<p>which is the smart-pointer version of:</p>

<pre><code>const MoveAbility * m_mv_ab;
</code></pre>

<p>(non-constant pointer to constant <code>MoveAbility</code>)</p>

<p>To make this a bit more intuitive you can use <code>const</code> as a suffix always and always read right-to-left, except that <code>std::shared_ptr&lt;X&gt;</code> is read ""(smart) pointer to X"":</p>

<pre><code>std::shared_ptr&lt;MoveAbility&gt; const m_mv_ab; // const ptr to non-const MoveAbility
MoveAbility * const m_mv_ab; // const ptr to non-const MoveAbility

std::shared_ptr&lt;MoveAbility const&gt; m_mv_ab; // non-const ptr to const MoveAbility
MoveAbility const * m_mv_ab; // non-const ptr to const MoveAbility
</code></pre>

<p>but most people use <code>const</code> as a prefix whenever possible, which makes it confusing.</p>
"
"<p>Yes, you are right, many places you can read that comment saying there is little documentation on FUSE.   Perhaps that's because there is so little to document.   Or perhaps the implementation is only meant for those who understand the tradeoff of userspace filesystem well enough.   So perhaps you can refer to the following documentation, tutorials, slides or even sample codes for more information:</p>

<p>FUSE Design Document (original documentation from Sun?):</p>

<p><a href=""http://www.youblisher.com/p/31627-fuse/"" rel=""noreferrer"">http://www.youblisher.com/p/31627-fuse/</a></p>

<p><a href=""http://wr.informatik.uni-hamburg.de/_media/research/labs/2008/2008-03-michael_kuhn-container_library_and_fuse_container_file_system-report.pdf"" rel=""noreferrer"">http://wr.informatik.uni-hamburg.de/_media/research/labs/2008/2008-03-michael_kuhn-container_library_and_fuse_container_file_system-report.pdf</a></p>

<p><a href=""http://www.oug.org/files/presentations/losug-fuse.pdf"" rel=""noreferrer"">http://www.oug.org/files/presentations/losug-fuse.pdf</a></p>

<p><a href=""http://sar.informatik.hu-berlin.de/teaching/2013-w/2013w_osp2/lab/Lab-4-FUSE/lab-FUSE_.pdf"" rel=""noreferrer"">http://sar.informatik.hu-berlin.de/teaching/2013-w/2013w_osp2/lab/Lab-4-FUSE/lab-FUSE_.pdf</a></p>

<p><a href=""http://www.cs.hmc.edu/~geoff/classes/hmc.cs135.201001/homework/fuse/fuse_doc.html"" rel=""noreferrer"">http://www.cs.hmc.edu/~geoff/classes/hmc.cs135.201001/homework/fuse/fuse_doc.html</a>  (tutorials)</p>

<p><a href=""http://www.cs.cmu.edu/~./fp/courses/15213-s07/lectures/15-filesys/index.html"" rel=""noreferrer"">http://www.cs.cmu.edu/~./fp/courses/15213-s07/lectures/15-filesys/index.html</a></p>

<p><a href=""http://www.cs.nmsu.edu/~pfeiffer/fuse-tutorial/"" rel=""noreferrer"">http://www.cs.nmsu.edu/~pfeiffer/fuse-tutorial/</a></p>

<p>Sample code:</p>

<p><a href=""http://fuse.sourceforge.net/helloworld.html"" rel=""noreferrer"">http://fuse.sourceforge.net/helloworld.html</a></p>

<p>And perhaps this is more research-oriented:</p>

<p><a href=""http://www.msrsas.org/docs/sastech_journals/archives/May2011/2.pdf"" rel=""noreferrer"">http://www.msrsas.org/docs/sastech_journals/archives/May2011/2.pdf</a></p>

<p><a href=""https://code.google.com/p/s3fs/wiki/FuseOverAmazon"" rel=""noreferrer"">https://code.google.com/p/s3fs/wiki/FuseOverAmazon</a></p>

<p>But generally there is a lot of problems/issues (which may be solved through some complex algorithm) with implementing filesystem in userspace, which is why Linus has commented it as ""toy"":</p>

<p><a href=""https://ceph.com/dev-notes/linus-vs-fuse/"" rel=""noreferrer"">https://ceph.com/dev-notes/linus-vs-fuse/</a></p>

<p>15Apr2015 update:</p>

<p>I just found this (and many other slides - just look at the right hand side of this webpage):</p>

<p><a href=""http://www.slideshare.net/adorepump/fuse-developing-fillesystems-in-userspace"" rel=""noreferrer"">http://www.slideshare.net/adorepump/fuse-developing-fillesystems-in-userspace</a></p>
"
"<p>I don't think this is possible. When userspace invokes a file I/O the file system implementation or the generic implementation will be called from VFS.
what you would need is to change this function pointers to point to your module, which encrypts your data and then invokes the file system function.</p>

<p>I did something like this in university, but it was an old kernel and you had to set a specific configuration flag. If I remember this flag has disappeared as you don't want kernel modules to mess around with functions pointers outside their scope.</p>

<p>In any case, you can find the module here: <a href=""https://motzblog.wordpress.com/2007/10/27/linux-monitoring-module/"" rel=""nofollow"">https://motzblog.wordpress.com/2007/10/27/linux-monitoring-module/</a></p>

<p>But be warned, it was a university project, so the code quality isn't what you except from Linux kernel code.</p>
"
"<p>Use <a href=""http://en.wikipedia.org/wiki/Linux_Security_Modules"" rel=""nofollow"">Linux Security Modules</a>. These are loadable kernel modules, that provide hooks to mediate accesses to various internal objects in the kernel. You can use the hook to filesystem, or inodes as per your requirement. A god place to start is to read Greg Kroah Hartman's <a href=""http://www.kroah.com/linux/talks/ols_2002_lsm_paper/lsm.pdf"" rel=""nofollow"">paper</a> on LSM. Then you can visit this <a href=""http://blog.ptsecurity.com/2012/09/writing-linux-security-module.html"" rel=""nofollow"">link</a>, where it is shown along with an example how to make use of LSM hooks. The example is to mediate access to the system only when a particular USB is inserted, and is a good reference point on how to start with LSM hooks.  </p>
"
"<p>Well, it's interesting question.</p>

<p>Unfortunately, even LSM doesn't help here. As a possible solution I'll recommend use <code>address_space_operations</code> tables and hook <code>writepage</code> function. For example, look at <a href=""http://lxr.free-electrons.com/source/fs/ext3/inode.c#L1984"" rel=""nofollow"">ext3_writeback_aops</a>:</p>

<pre><code>1984 static const struct address_space_operations ext3_writeback_aops = {
1985         .readpage               = ext3_readpage,
1986         .readpages              = ext3_readpages,
1987         .writepage              = ext3_writeback_writepage,
1988         .write_begin            = ext3_write_begin,
1989         .write_end              = ext3_writeback_write_end,
1990         .bmap                   = ext3_bmap,
1991         .invalidatepage         = ext3_invalidatepage,
1992         .releasepage            = ext3_releasepage,
1993         .direct_IO              = ext3_direct_IO,
1994         .migratepage            = buffer_migrate_page,
1995         .is_partially_uptodate  = block_is_partially_uptodate,
1996         .error_remove_page      = generic_error_remove_page,
1997 };
</code></pre>

<p>So, in case of <code>ext3</code> filesystem we need to find this struct in memory and replace the <code>writepage</code> pointer to point to <code>our_writepage</code> wrapper. Note also that this table is in read-only memory and you need to handle it correctly.</p>

<p>EDIT:</p>

<p>With LSM it is possible to hook on <code>inode</code> open operation and replace <code>inode-&gt;i_mapping-&gt;a_ops</code> inplace.</p>
"
"<p>Try the <strong>FUSE</strong>(<a href=""https://github.com/libfuse/libfuse"" rel=""nofollow"">https://github.com/libfuse/libfuse</a>).</p>

<p>This is a file system in userspace. You can write file I/O handler in user space and simply mount it as execution of application.</p>
"
"<p>To flip the picture, you don't negate the height of the source -- you negate the height of the destination. To go with this, you have to specify the <em>bottom</em> of your destination rectangle as the origin, so your call would looks something like this:</p>

<pre><code>StretchBlt(pdc, 0, h, w, -h, dc, 0, 0, w, h, SRCCOPY);
</code></pre>
"
"<p>I'd say with macros you're out of luck. Indeed there are variadic macros that allow to pass ahead args, but that is all you can do with them.</p>

<p>I tried</p>

<pre><code>#define B(x, y) int x = y;
#define A(x, y, ...) B(x, y)  A(__VA_ARGS__)

void f()
{
  A( g, 1, h, 2);
}
</code></pre>

<p>doesn't work obviously. Proposals to add things to preprocessor are common but are routinely rejected.  </p>
"
"<p>Aside from mixing floating point and integer arithmetic, I suspect you're getting numeric overflow / underflow with some of your intermediate values.</p>

<p>One easy fix is to just be consistent and use floating point throughout.  Right now you have:</p>

<pre><code>unsigned char C[5] = { 0 };

for (unsigned i = 0; i &lt; dest_height; ++i)
{
    for (unsigned j = 0; j &lt; dest_width; ++j)
    {
        const int x = int(tx * j);
        const int y = int(ty * i);
        const double dx = tx * j - x;
        const double dy = ty * i - y;

        for (int k = 0; k &lt; 3; ++k)
        {
            for (int jj = 0; jj &lt; 4; ++jj)
            {
                const int idx = y - 1 + jj;
                unsigned char a0 = get_subpixel(bmap, idx, x, k);
                unsigned char d0 = get_subpixel(bmap, idx, x - 1, k) - a0;
                unsigned char d2 = get_subpixel(bmap, idx, x + 1, k) - a0;
                unsigned char d3 = get_subpixel(bmap, idx, x + 2, k) - a0;
                unsigned char a1 = -1.0 / 3 * d0 + d2 - 1.0 / 6 * d3;
                unsigned char a2 = 1.0 / 2 * d0 + 1.0 / 2 * d2;
                unsigned char a3 = -1.0 / 6 * d0 - 1.0 / 2 * d2 + 1.0 / 6 * d3;
                C[jj] = a0 + a1 * dx + a2 * dx * dx + a3 * dx * dx * dx;

                d0 = C[0] - C[1];
                d2 = C[2] - C[1];
                d3 = C[3] - C[1];
                a0 = C[1];
                a1 = -1.0 / 3 * d0 + d2 -1.0 / 6 * d3;
                a2 = 1.0 / 2 * d0 + 1.0 / 2 * d2;
                a3 = -1.0 / 6 * d0 - 1.0 / 2 * d2 + 1.0 / 6 * d3;
                out[i * row_stride + j * channels + k] = a0 + a1 * dy + a2 * dy * dy + a3 * dy * dy * dy;
            }
        }
    }
}
</code></pre>

<p>You have a mixture of <code>unsigned char</code>, <code>int</code> and <code>double</code>.  Each one of those <code>1.0 / 3</code> converts your 8-bit data to double-precision float, and then the assignment truncates it back.</p>

<p>Instead, why not just use <code>float</code> throughout?</p>

<pre><code>float C[5] = { 0 };

for (unsigned i = 0; i &lt; dest_height; ++i)
{
    for (unsigned j = 0; j &lt; dest_width; ++j)
    {
        const float x = float(tx * j);
        const float y = float(ty * i);
        const float dx = tx * j - x;
        const float dy = ty * i - y;

        for (int k = 0; k &lt; 3; ++k)
        {
            for (int jj = 0; jj &lt; 4; ++jj)
            {
                const int idx = y - 1 + jj;
                float a0 = get_subpixel(bmap, idx, x, k);
                float d0 = get_subpixel(bmap, idx, x - 1, k) - a0;
                float d2 = get_subpixel(bmap, idx, x + 1, k) - a0;
                float d3 = get_subpixel(bmap, idx, x + 2, k) - a0;
                float a1 = -(1.0f / 3.0f) * d0 + d2 - (1.0f / 6.0f) * d3;
                float a2 =          0.5f  * d0 +              0.5f *  d2;
                float a3 = -(1.0f / 6.0f) * d0 - 0.5f * d2 + (1.0f / 6.0f) * d3;
                C[jj] = a0 + a1 * dx + a2 * dx * dx + a3 * dx * dx * dx;

                d0 = C[0] - C[1];
                d2 = C[2] - C[1];
                d3 = C[3] - C[1];
                a0 = C[1];
                a1 = -(1.0f / 3.0f) * d0 + d2 -(1.0f / 6.0f) * d3;
                a2 =          0.5f  * d0 +             0.5f  * d2;
                a3 = -(1.0f / 6.0f) * d0 - 0.5f * d2 + (1.0f / 6.0f) * d3;
                out[i * row_stride + j * channels + k] = saturate( a0 + a1 * dy + a2 * dy * dy + a3 * dy * dy * dy );
            }
        }
    }
}
</code></pre>

<p>Then define a function <code>saturate</code> that does this:</p>

<pre><code>inline unsigned char saturate( float x )
{
    return x &gt; 255.0f ? 255
         : x &lt; 0.0f   ? 0
         :              unsigned char(x);
}
</code></pre>

<p>That will fix your overflow issues, and give you better precision and likely better performance too.</p>

<p>If you need to further improve the performance, then you should look into fixed point arithmetic.  But for now, I think the above implementation is better.</p>

<p>Also, one other thought:  You should be able to get some further efficiencies by precomputing <code>dx * dx</code>, <code>dx * dx * dx</code>, and so on:</p>

<pre><code>float C[5] = { 0 };

for (unsigned i = 0; i &lt; dest_height; ++i)
{
    for (unsigned j = 0; j &lt; dest_width; ++j)
    {
        const float x = float(tx * j);
        const float y = float(ty * i);
        const float dx = tx * j - x, dx2 = dx * dx, dx3 = dx2 * dx;
        const float dy = ty * i - y, dy2 = dy * dy, dy3 = dy2 * dy;

        for (int k = 0; k &lt; 3; ++k)
        {
            for (int jj = 0; jj &lt; 4; ++jj)
            {
                const int idx = y - 1 + jj;
                float a0 = get_subpixel(bmap, idx, x, k);
                float d0 = get_subpixel(bmap, idx, x - 1, k) - a0;
                float d2 = get_subpixel(bmap, idx, x + 1, k) - a0;
                float d3 = get_subpixel(bmap, idx, x + 2, k) - a0;
                float a1 = -(1.0f / 3.0f) * d0 + d2 - (1.0f / 6.0f) * d3;
                float a2 =          0.5f  * d0 +              0.5f *  d2;
                float a3 = -(1.0f / 6.0f) * d0 - 0.5f * d2 + (1.0f / 6.0f) * d3;
                C[jj] = a0 + a1 * dx + a2 * dx2 + a3 * dx3;

                d0 = C[0] - C[1];
                d2 = C[2] - C[1];
                d3 = C[3] - C[1];
                a0 = C[1];
                a1 = -(1.0f / 3.0f) * d0 + d2 -(1.0f / 6.0f) * d3;
                a2 =          0.5f  * d0 +             0.5f  * d2;
                a3 = -(1.0f / 6.0f) * d0 - 0.5f * d2 + (1.0f / 6.0f) * d3;
                out[i * row_stride + j * channels + k] = saturate( a0 + a1 * dy + a2 * dy2 + a3 * dy3 );
            }
        }
    }
}
</code></pre>
"
"<p>The values from a <code>bimap</code> cannot be directly assigned to thos of a <code>map</code> because there is a problem of type (ignoring the more obvious problem of const-ness of the value): </p>

<blockquote>
  <p>When a bimap left view iterator is dereferenced the return type is signature-compatible with a std::pair&lt; const A, const B ></p>
</blockquote>

<p>(<a href=""http://www.boost.org/doc/libs/1_55_0/libs/bimap/doc/html/boost_bimap/the_tutorial/differences_with_standard_maps.html#boost_bimap.the_tutorial.differences_with_standard_maps.iterator__value_type"" rel=""nofollow"">source</a>)</p>

<p>And :</p>

<blockquote>
  <p>A type is signature-compatible with other type if it has the same signature for functions and metadata. Preconditions, postconditions and the order of operations need not be the same. </p>
</blockquote>

<p>That means that there is no guarantee that your bimap value_type is assignable or copyable to a map value_type. In fact it is not:</p>

<pre><code>typedef boost::bimap&lt;int, std::string&gt; BiMapType;
typedef std::map&lt;int, std::string&gt; MapType;

BiMapType bimap;
BiMapType::left_value_type t1 = *(bimap.left.begin()); // Mandatory for compilation on my version at least
MapType::value_type t2(t1);
</code></pre>

<p>That will fail horribly (same kind of thing if you try <code>t2 = t1;</code>)</p>

<p>So either you find a way to convert your value_types either you keep with a for_each/transform/copy ... idiom.</p>

<p>There is a neat solution signaled here in comment by @CharlesPehlivanian (that he will maybe provide as an answer also), that is to use <code>boost::trasnform_iterator</code>.</p>

<p>For that you have to provide a <code>transformer</code> functor (it does not work with a raw lambda, you have to use a struct with <code>operator()</code> and <code>result_type</code> or a <code>std::function</code>) that will convert the input iterator value to the output one:</p>

<pre><code>    typedef std::function&lt;MapType::value_type (const BiMapType::left_value_type&amp;)&gt;
        Transformer;
    Transformer transformer_func = [](const BiMapType::left_value_type&amp; elem)
        {
            return std::make_pair(elem.first, elem.second);
        };
</code></pre>

<p>Then you just have to wrap begin and end iterator with <code>boost::make_transform_iterator</code>:</p>

<pre><code>    auto begin = boost::make_transform_iterator(bimap.left.begin(), transformer_func);
    auto end = boost::make_transform_iterator(bimap.left.end(), transformer_func);
</code></pre>

<p>Here is the whole code:</p>

<pre><code>#include &lt;boost/bimap.hpp&gt;
#include &lt;boost/iterator/transform_iterator.hpp&gt;
#include &lt;map&gt;

int main(int argc, char const *argv[])
{
    typedef boost::bimap&lt;int, std::string&gt; BiMapType;
    typedef std::map&lt;int, std::string&gt; MapType;
    typedef std::function&lt;MapType::value_type (const BiMapType::left_value_type&amp;)&gt;
        Transformer;

    BiMapType bimap;


    Transformer transformer_func = [](const BiMapType::left_value_type&amp; elem)
        {
            return std::make_pair(elem.first, elem.second);
        };

    auto begin = boost::make_transform_iterator(bimap.left.begin(), transformer_func);
    auto end = boost::make_transform_iterator(bimap.left.end(), transformer_func);

    MapType map(begin, end);

    return 0;
}
</code></pre>

<p><a href=""http://coliru.stacked-crooked.com/a/8fae0d47ca4b72a1"" rel=""nofollow"">http://coliru.stacked-crooked.com/a/8fae0d47ca4b72a1</a></p>
"
"<p>The only way to accomplish this that I can think of is to iterate through it. This is most likely not what you want, but it's the best shot I can think of. Good luck!</p>
"
"<p>You can achieve this by <em>iterating</em> which will take <code>O(n) time</code>. Or you can <em>store the reverse map</em> which will take <code>O(n) space</code>.</p>

<p>By iterating:</p>

<pre><code>std::map&lt;int, string&gt; fmap;

for (std::map&lt;int,string&gt;::iterator it=fmap.begin(); it!=fmap.end(); ++it)
    if (strcmp(it-&gt;second,""foo""))
        break;
</code></pre>

<p>By storing reverse map:</p>

<pre><code>std::map&lt;int, string&gt; fmap;
std::map&lt;string, int&gt; bmap;

fmap.insert(std::make_pair(0, ""foo""));
bmap.insert(std::make_pair(""foo"", 0));

fmap[0]; // original map lookup

bmap[""foo""]; //reverse map lookup
</code></pre>
"
"<p>No, You can not do this. You simply have to iterate over map and match each value with the item to be matched and return the corresponding key and it will cost you high time complexity equal to O(n).</p>
"
"<p>No, not directly.</p>

<p>One option is to examine each value in the map until you find what you are looking for.  This, obviously, will be O(n).</p>

<p>In order to do this you could just write a <code>for()</code> loop, or you could use <code>std::find_if()</code>.  In order to use <code>find_if()</code>, you'll need to create a predicate.  In C++11, this might be a lambda:</p>

<pre><code>typedef std::map &lt;unsigned, Student&gt; MyMap;
MyMap myMap;

// ...

const string targetName = ""Jones"";
find_if (myMap.begin(), myMap.end(), [&amp;targetName] (const MyMap::value_type&amp; test)
{
  if (test.second.mName == targetName)
    return true;
});
</code></pre>

<p>If you're using C++03, then this could be a functor:</p>

<pre><code>struct MatchName
: public std::unary_function &lt;bool, MyMap::value_type&gt;
{
  MatchName (const std::string&amp; target) : mTarget (target) {}
  bool operator() (const MyMap::value_type&amp; test) const
  {
    if (test.second.mName == mTarget)
      return true;
    return false;
  }
private:
  const std::string mTarget;
};


// ...

find_if (myMap.begin(), myMap.end(), MatchName (target));
</code></pre>

<p>Another option is to build an index.  The index would likely be another map, where the key is whatever values you want to find and the value is some kind of index back to the main map.  </p>

<p>Suppose your main map contains <code>Student</code> objects which consist of a name and some other stuff, and the key in this map is the Student ID, an integer.  If you want to find the student with a particular last name, you could build an indexing map where the key is a last name (probably want to use <code>multimap</code> here), and the value is the student ID.  You can then index back in to the main map to get the remainder of the <code>Student</code>'s attributes.</p>

<p>There are challenges with the second approach.  You must keep the main map and the index (or indicies) synchronized when you add or remove elements.  You must make sure the index you choose as the value in the index is not something that may change, like a pointer.  If you are multithreading, then you have to give a think to how both the map and index will be protected without introducing deadlocks or race conditions.</p>
"
"<p><code>std::map</code> doesn't provide a (fast) way to find the key of a given value.</p>

<p>What you want is often called a ""bijective map"", or short ""bimap"". <a href=""http://www.boost.org/doc/libs/1_55_0/libs/bimap/doc/html/index.html"" rel=""nofollow"">Boost has such a data structure.</a> This is typically implemented by using two index trees ""glued"" together (where <code>std::map</code> has only one for the keys). <a href=""http://www.boost.org/doc/libs/1_55_0b1/libs/multi_index/doc/index.html"" rel=""nofollow"">Boost also provides the more general <em>multi</em> index with similar use cases.</a></p>

<p>If you don't want to use Boost, if storage is not a big problem, and if you can affort the extra code effort, you can simply use two maps and glue them together manually:</p>

<pre><code>std::map&lt;int, string&gt; myMapForward;
std::map&lt;string, int&gt; myMapBackward;    // maybe even std::set

// insertion becomes:
myMapForward.insert(std::make_pair(0, ""foo""));
myMapBackward.insert(std::make_pair(""foo"", 0));

// forward lookup becomes:
myMapForwar[0];

// backward lookup becomes:
myMapBackward[""foo""];
</code></pre>

<p>Of course you can wrap those two maps in a class and provide some useful interface, but this might be a bit overkill, and using two maps with the same content is not an optional solution anyways. As commented below, exception safety is also a problem of this solution. But in many applications it's already enough to simply add another reverse map.</p>

<p>Please note that since <code>std::map</code> stores <em>unique keys</em>, this approach will support backward lookup only for <em>unique values</em>, as collisions in the value space of the forward map correspond to collisions in the key space of the backward map.</p>
"
"<p>Following is an list of Programming Language based on the levels, </p>

<ul>
<li>Assembly Language ( Machine Language, Lover Level ) </li>
<li>C Language ( Middle Level ) </li>
<li>C++, Java, .net, ( Higher Level ) </li>
</ul>

<p>Here Lower level language has direct access to the Hardware. As long as the level gets increased the access to the hardware gets decrease. So Assembly Language's code  runs at the highest speed while other language's code runs based on their levels. </p>

<p>This is the reason that C Language's code run much faster than the Java's code. </p>
"
"<p>For algorithms that operate over arrays of data, there are two things that significantly change performance between a language like Java, and C:</p>

<ul>
<li><p>array bound checking - Java will check every access, bmap[i], and confirm i is within the array bounds.  If the code tries to access out of bounds, you will get a useful exception.  C &amp; C++ do not check anything and just trust your code.  The best case response to an out of bounds access is a page fault.  A more likely result is ""unexpected behavior"".</p></li>
<li><p>pointers - You can significantly reduce the operations by using pointers.  </p></li>
</ul>

<p>Take this innocent example of a common filter (similar to blur, but 1D):</p>

<pre><code>for{i=0; i&lt;ndata-ncoef; ++i) {
  z[i] = 0;
  for{k=0; k&lt;ncoef; ++k) {
    z[i] += c[k] * d[i+k];
  }
}
</code></pre>

<p>When you access an array element, coef[k] is:</p>

<ul>
<li>load address of array coef into register</li>
<li>load value k into a register</li>
<li>sum them</li>
<li>go get memory at that address</li>
</ul>

<p>Every one of those array accesses can be improved because you know that the indexes are sequential.  The compiler, nor the JIT, can know that the indexes are sequential so cannot optimize fully (although they keep trying).</p>

<p>In C++, you would write code more like this:</p>

<pre><code>int d[10000];
int z[10000];
int coef[10];
int* zptr;
int* dptr;
int* cptr;
dptr = &amp;(d[0]); // Just being overly explicit here, more likely you would dptr = d;
zptr = &amp;(z[0]); // or zptr = z;
for{i=0; i&lt;(ndata-ncoef); ++i) {
  *zptr = 0;
  *cptr = coef;
  *dptr = d + i;
  for{k=0; k&lt;ncoef; ++k) {
    *zptr += *cptr * *dptr;
    cptr++;
    dptr++;
  }
  zptr++;
}
</code></pre>

<p>When you first do something like this (and succeed in getting it correct) you will be surprised how much faster it can be.  All the array address calculations of fetching the index and summing the index and base address are replaced with an increment instruction.</p>

<p>For 2D array operations such as blur on an image, an innocent code  data[r,c] involves two value fetches, a multiply and a sum. So with 2D arrays the benefits of pointers allows you to remove multiply operations.</p>

<p>So the language allows real reduction in the operations the CPU must perform.  The cost is that the C++ code is horrendous to read and debug.  Errors in pointers and buffer overflows are food for hackers.  But when it comes to raw number grinding algorithms, the speed improvement is too tempting to ignore.</p>
"
"<p>Looks like one of the headers included indirectly via <code>air.h</code> is defining a macro which conflicts with a symbol name elsewhere in the sources. The macro basically defines a search-replace operation which is carried out by the preprocessor, before the compiler kicks in. </p>

<p>Take this example:</p>

<pre><code>/** header_1.h **/
void foo(){ std::cout &lt;&lt; ""Hello"" &lt;&lt; std::endl; }

/** header_2.h **/
#define foo bar

/** main.cpp **/
#include ""header_1.h""
#include ""header_2.h""

int main() {
  foo();
}
</code></pre>

<p>Compiling <code>main.cpp</code> will give you an error that the method <code>bar</code> is not defined, since the preprocessor replaced all occurrences of <code>foo</code> appearing after the point <code>header_2.h</code>was included with <code>bar</code>.</p>
"
"<p>Using separate command queue for every mem object IMHO looks like not best practice. In such case you are issuing commands seldom in scope of every queue. Commands can't be reordered, put in conveyor, etc. Briefly - you can't benefit massive data transfers &amp; you're wasting your CPU resources on multiple queues handling. My advice is to use several command queues with OpenMP thread-safe access:</p>

<pre><code>cl_command_queue
    q_DtoH = clCreateCommandQueue(...),
    q_DtoD = clCreateCommandQueue(...)
    ...;

#pragma omp parallel for
for(;;)
{
    #pragma omp critical
    clEnqueueNDWriteBuffer(q_DtoH, ...); //Or whatever else

    ....
}
</code></pre>

<p>Ideally, try to use out-of-order queues with events synchronization for data transfers. Also, objects reference counts are handy for debugging purposes (Presumably, your command queues are using same context, you may check it's ref counts).</p>

<p>And, in your code snippet:</p>

<pre><code>/* update heat*/
....
gpu-&gt;Compute(""UpdateAirHeatLoop0"");
gpu-&gt;sync();

/*update air*/
gpu-&gt;ReadFromClTo2DCPP(""pv"",&amp;pv[0][0]);
...
</code></pre>

<p>Why not use same command queue to issue kernel execution &amp; data transfer? This will allow you to get rid of sync points.</p>
"
"<p><code>std::map</code>s keep their data sorted by key. But to do this, they need some way to compare two key objects and determine which one should come first. By default, this comparison is done using the <code>&lt;</code> operator, but that operation is not defined for <code>A</code>, which (probably) explains the compile error you are (probably) seeing.</p>

<p>So; to use <code>A</code> as the key in a <code>std::map</code>, you will either need to define <code>operator &lt;</code> for it or provide the map with a custom <code>key_compare</code> functor. The code below demonstrates both approaches:</p>

<pre><code>#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

struct A
{
    int a;
    std::string b;
};

bool operator &lt;(const A&amp; l, const A&amp; r)
{
    if(l.a != r.a)
        return l.a &lt; r.a;
    return l.b &lt; r.b;
}

struct B
{
    int a;
    std::string b;
};

struct CompareBs
{
    bool operator()(const B&amp; l, const B&amp; r) const
    {
        if(l.a != r.a)
            return l.a &lt; r.a;
        return l.b &lt; r.b;
    }
};

int main()
{
    std::map&lt;A, std::vector&lt;A&gt;&gt; aMap;
    std::map&lt;B, std::vector&lt;B&gt;, CompareBs&gt; bMap;
    return 0;
}
</code></pre>
"
"<p>Use <code>dd</code>, <code>mkfs.ext{2,3,4}</code>, <code>losetup</code> to create disk image, file system and mount the device.</p>

<p>Next, you may want to explore and learn using <a href=""http://linux.die.net/man/8/debugfs"" rel=""nofollow"">debugfs - ext2/ext3/ext4 file system debugger</a>. This is a lot of commands <code>bmap</code>, <code>dump</code>, <code>dump_extents</code> and many more commands. </p>

<p>Additionally, if you want to read file system meta data and debug, it would be good idea to explore <code>tune2fs</code>, and <code>e2image</code> commands which would require good understanding of FS internals. </p>
"
"<p>You do not need to specify any constraints in your generic type, like comparable in Java. By just using operator &lt; in your templated class, makes this a requirement.</p>

<p>So in C++ you would just write:</p>

<pre><code>template&lt;typename K, typename V&gt;

class MyMap {
..

if(a &lt; b) {

..

}
</code></pre>

<p>What happens as soon as you instantiate a template, for example by writing <code>MyMap&lt;string, string&gt;</code> the compiler creates a new class by  substituting K and V with string. If you put a type in without operator&lt;, this will create a compile error.</p>
"
"<p>Look at <a href=""http://en.cppreference.com/w/cpp/container/map"" rel=""nofollow noreferrer"">http://en.cppreference.com/w/cpp/container/map</a>:</p>

<pre><code>template&lt;
    class Key,
    class T,
    class Compare = std::less&lt;Key&gt;,
    class Allocator = std::allocator&lt;std::pair&lt;const Key, T&gt; &gt;
&gt; class map;
</code></pre>

<p>The reason your compiler complaints about a missing '&lt;'-operator is that the Compare-object <code>std::less&lt;Key&gt;</code> want's it. The keys are 'sorted by using the comparison function Compare', see <a href=""https://stackoverflow.com/questions/10680076/c-stdmap-key-sort-comparison-function"">C++ std::map key sort comparison function?</a> for more information about how to implement your 'own' Compare-object. Usually you won't need to do this because the <code>&lt;</code>-operator is implmented for fundamental types already (ints, floats etc) and for other types it is implemted as part of the STL:</p>

<pre><code>https://sourceforge.net/p/stlport/code/ci/master/tree/stlport/stl/_string_operators.h#l347

template &lt;class _CharT, class _Traits, class _Alloc&gt;
inline bool _STLP_CALL
operator&lt;(const basic_string&lt;_CharT,_Traits,_Alloc&gt;&amp; __x,
      const basic_string&lt;_CharT,_Traits,_Alloc&gt;&amp; __y) {
return basic_string&lt;_CharT,_Traits,_Alloc&gt; ::_M_compare(__x.begin(), __x.end(),
                                                      __y.begin(), __y.end()) &lt; 0;
}
</code></pre>

<p>Note: the Compare-object is not only used to sort the maps, but also determines if a key is considered 'existant in the map':</p>

<pre><code>Internally, the elements in a map are always sorted by its
key following a specific strict weak ordering criterion indicated
by its internal comparison object (of type Compare).
</code></pre>

<p>And:</p>

<pre><code>Compare:

A binary predicate that takes two element keys as arguments and returns
a bool. The expression comp(a,b), where comp is an object of this type
and a and b are key values, shall return true if a is considered to go
before b in the strict weak ordering the function defines.
The map object uses this expression to determine both the order the
elements follow in the container and whether two element keys are equivalent
(by comparing them reflexively: they are equivalent if !comp(a,b) &amp;&amp; !comp(b,a)).

No two elements in a map container can have equivalent keys.

This can be a function pointer or a function object (see constructor for an
example). This defaults to `std::less&lt;Key&gt;`, which returns the same as applying the
less-than operator (a&lt;b).

Aliased as member type map::key_compare.
</code></pre>

<p>(see <a href=""http://www.cplusplus.com/reference/map/map/"" rel=""nofollow noreferrer"">http://www.cplusplus.com/reference/map/map/</a> ) Another good source of information is SGI's  documentation of their STL-implementation: <a href=""https://www.sgi.com/tech/stl/Map.html"" rel=""nofollow noreferrer"">https://www.sgi.com/tech/stl/Map.html</a> </p>

<p>Again, since in these docs are a lot of words and you would need to read them very very carefully:</p>

<pre><code>they are equivalent if !comp(a,b) &amp;&amp; !comp(b,a)
</code></pre>

<p>So, (since it felt onto my toes onces) you can construct a <code>map&lt;struct my*, int, my_cmp&gt;</code> where the <code>my_cmp</code> compare-function decides that 2 pointers of type <code>my</code> are NOT equal, allthough they are the same value:</p>

<pre><code>struct my* a = &amp;my_a;
struct my* b = a;
</code></pre>

<p>The output of my_cmp() decides, if a given key (and the associated value) are stored in the map or not. Very subtle.</p>

<p>Maybe interesting to read: <a href=""https://latedev.wordpress.com/2013/08/12/less-than-obvious/"" rel=""nofollow noreferrer"">https://latedev.wordpress.com/2013/08/12/less-than-obvious/</a> and <a href=""http://fusharblog.com/3-ways-to-define-comparison-functions-in-cpp/"" rel=""nofollow noreferrer"">http://fusharblog.com/3-ways-to-define-comparison-functions-in-cpp/</a></p>
"
"<p>Long story short, you don't have to do anything: write your code as if the operator is there.</p>

<p>Unlike Java generics, C++ template mechanism can work without constraints, because the compiler is not required to produce any code until all class parameters are fully specified. In contrast, Java compilers must fully compile the class, and produce the final byte code without knowing the types that you plug in for <code>K</code> and <code>V</code>.</p>

<p>In other words, C++ compiler lets you call any functions and apply any operators you want in your template code. The template will compile without a problem if the classes that you supply have the corresponding functions and/or operators. If the functions and/or operators referenced from the template are missing, the compiler gives you an error message.</p>
"
"<p>Think of a template as an expression that can be used to generate code, not as code itself (that's actually how the templates got their names, prior to C++ templates some people would abuse the preprocessor to achieve the same goal). That is, when you write</p>

<pre><code>template&lt;class T&gt; void foo(const T&amp; bar) {
    baz(bar);
}
</code></pre>

<p>it's pretty much the same as if you had written</p>

<pre><code>#define foo(bar) baz(bar)
</code></pre>

<p>The contents of the definition (template or preprocessor) is pretty much irrelevant <em>as long as it's not used</em>. Only when the template is instanciated / the preprocessor directive is expanded, the compiler will check whether the <em>result</em> of the instanciation/expansion is valid.</p>

<p>As such, when a template uses a certain member function or operator on one of its arguments, it is the job of the user to supply a type that can be used in such a way, otherwise the compiler will do the substitution, look at the resulting code, shake its head, and throw an error message.</p>
"
"<p>You have all the odds against you with this code.</p>

<ol>
<li><p>Memory usage.<br>
With 66425 ranges you are way over L1 cache and with the included set of strings you blow L2D also, and might even exceed L3. This means you will often have latency of 50-200 cpu cycles for each data access and your out-of-order execution will only cover ~32 cycles, meaning that the CPU will essentially stall all the time. This is mitigated a lot if all memory is accessed sequentially through hardware prefetchers.</p></li>
<li><p>Pointer chasing through map.<br>
Maps and set are typically implemented as a rb_tree with pointers. (interval_map might be different?). To further increase the problem, the access of the pointers will insure that the data is not sequentially accessed, meaning you will get hit by the high latency.</p></li>
<li><p>Call of function pointer/virtual function.
Surprisingly this doesn't show up in the top 12 unless you use more interval functions inside <code>f</code>. Later when you have solved the other problems you might see that every call to this function will introduce delay of X cycles for every call, where X is the length of the CPU pipeline.</p></li>
</ol>

<p>If your using perf to get the performance data, please add the result of a run with <code>perf stat -d</code>. This should show the problems mentioned above with lots of cache misses and idle CPU.</p>

<p>The usage of <code>set&lt;string&gt;</code> is bad because its pointer chasing, you should use a <code>vector&lt;string&gt;</code> instead, you will need to keep it sorted yourself. This should speed up the access in <code>f</code>, but doesn't mitigate the other problems.</p>

<p>Adding an allocator, implementing an arena, to the <code>interval_map</code> might speed the access up as the data should have better localization.</p>
"
"<p>In this answer I present three optimizations:</p>

<ol>
<li><p>replacing the objects <code>std::set</code> by <code>boost::container::flat_set</code> for improved locality (and likely reallocation costs, since most object sets are &lt;4 elements)</p>

<blockquote>
  <p><em><strong>UPDATE</strong> In my final version below, simply replacing <code>boost::container::flat_map</code> back with <code>std::set</code> degraded performance of just <code>find_range</code> by a factor ~2x and <code>find_range_ex</code> by a factor of ~4x on my test system</em></p>
</blockquote></li>
<li><p>replacing the object id <code>std::string</code> by <code>string_atom</code> (which is technically a <code>char const*</code> but logically unique). This technique is similar to interned strings in various VM implementations (like Java/.NET).</p>

<blockquote>
  <p><em><strong>NOTE</strong>: The current implementation of <code>make_atom</code> is exceedingly simplistic and never frees atoms. You would potentially want to back the strings in a deque, use Boost Flyweights, a pool allocator or some combination of those to make it smarter. However, whether  this is required depends on your use cases</em></p>
</blockquote></li>
<li><p>replacing the map intersection with a <code>equal_range</code> call, which saves the bulk of time by avoiding copying (large amounts of) data </p>

<blockquote>
  <p>_<strong>UPDATE</strong> When applying <em>just</em> this optimization in isolation the speed up is already <strong>26~30x</strong>. Note that the memory usage is roughly double at ~20MiB compared to when including all three optimizations_</p>
</blockquote></li>
</ol>

<h2>Volume and data efficiency</h2>

<p>Before I start, I like to know what the data looks like. So, writing some code to parse that <code>bmap.txt</code> input, we get:</p>

<p><strong><kbd><a href=""http://coliru.stacked-crooked.com/a/68b536b465429665"">Source On Coliru</a></kbd></strong></p>

<pre><code>Parsed ok
Histogram of 66425 input lines
d: 3367
f: 20613
p: 21222
v: 21223
ranges size:            6442450944
ranges iterative size:  21223
Min object set:         1.000000
Max object set:         234.000000
Average object set:     3.129859
Min interval width:     1024.000000
Max interval width:     2526265344.000000
Average interval width: 296.445177k
First:                  [0,1048576)
Last:                   [3916185600,6442450944)
String atoms:           23904 unique in 66425 total
Atom efficiency:        35.986451%
</code></pre>

<p>As you can see the sets are usually ~3 items, and <strong>many</strong> are duplicated. </p>

<p>Using the <code>make_atom</code> object naming method with <code>boost::flat_set</code> reduced memory allocation from <strong><a href=""http://paste.ubuntu.com/9256518/"">~15GiB</a></strong> to <strong><a href=""http://paste.ubuntu.com/9256482/"">~10Gib</a></strong>.</p>

<p>This optimization also reduces string comparison to pointer comparison for set insertion and the Combiner strategy of the <code>interval_map</code>, so for larger data sets this has the potential to have a lot of speedup.</p>

<h2>Query efficiency</h2>

<p>Query performance is indeed severely crippled by the partial copy of the input.</p>

<p>Don't copy, instead view the overlapping range, simply by replacing:</p>

<pre><code>  const ranges r = *map &amp; window;
  ranges::const_iterator iter = r.begin ();
  while (iter != r.end ()) {
</code></pre>

<p>with </p>

<pre><code>  auto r = map-&gt;equal_range(window);
  ranges::const_iterator iter = r.first;
  while (iter != r.second) {
</code></pre>

<p>On my system running 10000 identical randomized queries with both versions results in a <strong>speedup of 32x</strong>:</p>

<pre><code>10000 'random' OLD lookups resulted in 156729884 callbacks in 29148ms
10000 'random' NEW lookups resulted in 156729884 callbacks in 897ms

real    0m31.715s
user    0m31.664s
sys 0m0.012s
</code></pre>

<p>The runtime is now dominated by the parsing/statistics. Full benchmark code is here: <strong><a href=""http://coliru.stacked-crooked.com/a/68b536b465429665"">On Coliru</a></strong></p>

<pre><code>#define BOOST_RESULT_OF_USE_DECTYPE
#define BOOST_SPIRIT_USE_PHOENIX_V3

/* virt-bmap examiner plugin
 * Copyright (C) 2014 Red Hat Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;assert.h&gt;

#include &lt;boost/icl/interval.hpp&gt;
#include &lt;boost/icl/interval_set.hpp&gt;
#include &lt;boost/icl/interval_map.hpp&gt;
#include &lt;boost/container/flat_set.hpp&gt;

using namespace std;

/* Maps intervals (uint64_t, uint64_t) to a set of strings, where each
 * string represents an object that covers that range.
 */

static size_t atoms_requested = 0;
static size_t atoms_unique_created = 0;

using string_atom = const char*;
string_atom make_atom(std::string&amp;&amp; s)
{
    static std::set&lt;std::string&gt; s_atoms;
    atoms_requested += 1;

    auto it = s_atoms.find(s);
    if (it != s_atoms.end())
        return it-&gt;c_str();

    atoms_unique_created += 1;
    return s_atoms.insert(std::move(s)).first-&gt;c_str();
}

typedef boost::container::flat_set&lt;string_atom&gt; objects;
typedef boost::icl::interval_map&lt;uint64_t, objects&gt; ranges;

ranges*
new_ranges (void)
{
  return new ranges ();
}

void
free_ranges (ranges *mapv)
{
  ranges *map = (ranges *) mapv;
  delete map;
}

extern ""C"" void
insert_range (void *mapv, uint64_t start, uint64_t end, const char *object)
{
  ranges *map = (ranges *) mapv;
  objects obj_set;
  obj_set.insert (obj_set.end(), object);
  map-&gt;add (std::make_pair (boost::icl::interval&lt;uint64_t&gt;::right_open (start, end), // SEHE added std::
                       obj_set));
}

extern ""C"" void
iter_range (void *mapv, void (*f) (uint64_t start, uint64_t end, const char *object, void *opaque), void *opaque)
{
  ranges *map = (ranges *) mapv;
  ranges::iterator iter = map-&gt;begin ();
  while (iter != map-&gt;end ()) {
    boost::icl::interval&lt;uint64_t&gt;::type range = iter-&gt;first;
    uint64_t start = range.lower ();
    uint64_t end = range.upper ();

    objects obj_set = iter-&gt;second;
    objects::iterator iter2 = obj_set.begin ();
    while (iter2 != obj_set.end ()) {
      f (start, end, *iter2/*-&gt;c_str ()*/, opaque); // SEHE
      iter2++;
    }
    iter++;
  }
}

extern ""C"" void
find_range (void const *mapv, uint64_t start, uint64_t end, void (*f) (uint64_t start, uint64_t end, const char *object, void *opaque), void *opaque)
{
  const ranges *map = (const ranges *) mapv;

  boost::icl::interval&lt;uint64_t&gt;::type window;
  window = boost::icl::interval&lt;uint64_t&gt;::right_open (start, end);

  const ranges r = *map &amp; window;

  ranges::const_iterator iter = r.begin ();
  while (iter != r.end ()) {
    boost::icl::interval&lt;uint64_t&gt;::type range = iter-&gt;first;
    uint64_t start = range.lower ();
    uint64_t end = range.upper ();

    objects obj_set = iter-&gt;second;
    objects::iterator iter2 = obj_set.begin ();
    while (iter2 != obj_set.end ()) {
      f (start, end, *iter2/*-&gt;c_str ()*/, opaque); // SEHE
      iter2++;
    }
    iter++;
  }
}

extern ""C"" void
find_range_ex (void const *mapv, uint64_t start, uint64_t end, void (*f) (uint64_t start, uint64_t end, const char *object, void *opaque), void *opaque)
{
  const ranges *map = (const ranges *) mapv;

  boost::icl::interval&lt;uint64_t&gt;::type window;
  window = boost::icl::interval&lt;uint64_t&gt;::right_open (start, end);

#if 0
  const ranges r = *map &amp; window;
  ranges::const_iterator iter = r.begin ();
  while (iter != r.end ()) {
#else
  auto r = map-&gt;equal_range(window);
  ranges::const_iterator iter = r.first;
  while (iter != r.second) {
#endif

    boost::icl::interval&lt;uint64_t&gt;::type range = iter-&gt;first;
    uint64_t start = range.lower ();
    uint64_t end = range.upper ();

    objects obj_set = iter-&gt;second;
    objects::iterator iter2 = obj_set.begin ();
    while (iter2 != obj_set.end ()) {
      f (start, end, *iter2/*-&gt;c_str ()*/, opaque); // SEHE
      iter2++;
    }
    iter++;
  }
}

#include &lt;memory&gt;
#include &lt;boost/spirit/include/qi.hpp&gt;
#include &lt;boost/spirit/include/phoenix.hpp&gt;
#include &lt;boost/accumulators/accumulators.hpp&gt;
#include &lt;boost/accumulators/statistics.hpp&gt;
#include &lt;fstream&gt;
#include &lt;chrono&gt;

std::map&lt;char, size_t&gt; histo;

bool insert_line_of_input(ranges&amp; bmap_data, uint64_t b, uint64_t e, char type, std::string&amp; object) {
    if (!object.empty())
        histo[type]++;
    //std::cout &lt;&lt; std::hex &lt;&lt; b &lt;&lt; "" "" &lt;&lt; e &lt;&lt; "" "" &lt;&lt; type &lt;&lt; "" "" &lt;&lt; object &lt;&lt; ""\n"";

#if 0
    object.insert(object.begin(), ':');
    object.insert(object.begin(), type);
#endif
    insert_range(&amp;bmap_data, b, e, make_atom(std::move(object)));
    return true;
}

std::vector&lt;std::pair&lt;uint64_t, uint64_t&gt; &gt; generate_test_queries(ranges const&amp; bmap_data, size_t n) {
    std::vector&lt;std::pair&lt;uint64_t, uint64_t&gt; &gt; queries;
    queries.reserve(n);

    for (size_t i = 0; i &lt; n; ++i)
    {
        auto start = (static_cast&lt;uint64_t&gt;(rand()) * rand()) % bmap_data.size();
        auto end   = start + rand();

        queries.emplace_back(start,end);
    }

    return queries;
}

ranges read_mapfile(const char* fname) {
    std::ifstream ifs(fname);
    boost::spirit::istream_iterator f(ifs &gt;&gt; std::noskipws), l;

    ranges bmap_data;

    namespace phx = boost::phoenix;
    using namespace boost::spirit::qi;
    uint_parser&lt;uint64_t, 16&gt; offset;
    if (!phrase_parse(f,l,
                (""1 "" &gt;&gt; offset &gt;&gt; offset &gt;&gt; char_(""pvdf"") &gt;&gt; as_string[lexeme[+graph] &gt;&gt; attr('/') &gt;&gt; lexeme[*~char_(""\r\n"")]])
                [ _pass = phx::bind(insert_line_of_input, phx::ref(bmap_data), _1, _2, _3, _4) ] % eol &gt;&gt; *eol,
                blank))
    {
        exit(255);
    } else
    {
        std::cout &lt;&lt; ""Parsed ok\n"";
    }

    if (f!=l)
        std::cout &lt;&lt; ""Warning: remaining input '"" &lt;&lt; std::string(f,l) &lt;&lt; ""\n"";

    return bmap_data;
}

void report_statistics(ranges const&amp; bmap_data) {
    size_t total = 0;
    for (auto e : histo) total += e.second;

    std::cout &lt;&lt; ""Histogram of "" &lt;&lt; total &lt;&lt; "" input lines\n"";

    for (auto e : histo)
        std::cout &lt;&lt; e.first &lt;&lt; "": "" &lt;&lt; e.second &lt;&lt; ""\n"";

    namespace ba = boost::accumulators;
    ba::accumulator_set&lt;double, ba::stats&lt;ba::tag::mean, ba::tag::max, ba::tag::min&gt; &gt;
        object_sets, interval_widths;

    for (auto const&amp; r : bmap_data)
    {
        auto width = r.first.upper() - r.first.lower();
        assert(width % 1024 == 0);

        interval_widths(width);
        object_sets(r.second.size());
    }

    std::cout &lt;&lt; std::fixed;
    std::cout &lt;&lt; ""ranges size:            "" &lt;&lt; bmap_data.size()                 &lt;&lt; ""\n"";
    std::cout &lt;&lt; ""ranges iterative size:  "" &lt;&lt; bmap_data.iterative_size()       &lt;&lt; ""\n"";

    std::cout &lt;&lt; ""Min object set:         "" &lt;&lt; ba::min(object_sets)             &lt;&lt; ""\n"" ;
    std::cout &lt;&lt; ""Max object set:         "" &lt;&lt; ba::max(object_sets)             &lt;&lt; ""\n"" ;
    std::cout &lt;&lt; ""Average object set:     "" &lt;&lt; ba::mean(object_sets)            &lt;&lt; ""\n"" ;
    std::cout &lt;&lt; ""Min interval width:     "" &lt;&lt; ba::min(interval_widths)         &lt;&lt; ""\n"" ;
    std::cout &lt;&lt; ""Max interval width:     "" &lt;&lt; ba::max(interval_widths)         &lt;&lt; ""\n"" ;
    std::cout &lt;&lt; ""Average interval width: "" &lt;&lt; ba::mean(interval_widths)/1024.0 &lt;&lt; ""k\n"" ;
    std::cout &lt;&lt; ""First:                  "" &lt;&lt; bmap_data.begin()-&gt;first         &lt;&lt; ""\n"" ;
    std::cout &lt;&lt; ""Last:                   "" &lt;&lt; bmap_data.rbegin()-&gt;first        &lt;&lt; ""\n"" ;

    std::cout &lt;&lt; ""String atoms:           "" &lt;&lt; atoms_unique_created &lt;&lt; "" unique in "" &lt;&lt; atoms_requested &lt;&lt; "" total\n"";
    std::cout &lt;&lt; ""Atom efficiency:        "" &lt;&lt; (atoms_unique_created*100.0/atoms_requested) &lt;&lt; ""%\n"";
}

void perform_comparative_benchmarks(ranges const&amp; bmap_data, size_t number_of_queries) {
    srand(42);
    auto const queries = generate_test_queries(bmap_data, number_of_queries);

    using hrc = std::chrono::high_resolution_clock;
    {
        auto start = hrc::now();
        size_t callbacks = 0;

        for (auto const&amp; q: queries)
        {
            find_range(&amp;bmap_data, q.first, q.second,
                    [](uint64_t start, uint64_t end, const char *object, void *opaque) {
                    ++(*static_cast&lt;size_t*&gt;(opaque));
                    }, &amp;callbacks);
        }
        std::cout &lt;&lt; number_of_queries &lt;&lt; "" 'random' OLD lookups resulted in "" &lt;&lt; callbacks
                  &lt;&lt; "" callbacks in "" &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;((hrc::now()-start)).count() &lt;&lt; ""ms\n"";
    }

    {
        auto start = hrc::now();
        size_t callbacks = 0;

        for (auto const&amp; q: queries)
        {
            find_range_ex(&amp;bmap_data, q.first, q.second,
                    [](uint64_t start, uint64_t end, const char *object, void *opaque) {
                    ++(*static_cast&lt;size_t*&gt;(opaque));
                    }, &amp;callbacks);
        }
        std::cout &lt;&lt; number_of_queries &lt;&lt; "" 'random' NEW lookups resulted in "" &lt;&lt; callbacks
                  &lt;&lt; "" callbacks in "" &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;((hrc::now()-start)).count() &lt;&lt; ""ms\n"";
    }
}

int main() {
    auto bmap = read_mapfile(""bmap.txt"");

    report_statistics(bmap);

    perform_comparative_benchmarks(bmap, 1000);

#if 0 // to dump ranges to console
    for (auto const&amp; r : bmap)
    {
        std::cout &lt;&lt; r.first &lt;&lt; ""\t"" &lt;&lt; r.second.size() &lt;&lt; ""\t"";
        std::copy(r.second.begin(), r.second.end(), std::ostream_iterator&lt;std::string&gt;(std::cout, ""\t""));
        std::cout &lt;&lt; ""\n"";
    }
#endif
}
</code></pre>
"
"<blockquote>
  <p>hiddenCorner is a void function which update bmap (bmap is a std::map).</p>
</blockquote>

<p>The <code>bind</code> version makes copies of <code>other</code> and <code>bmap</code> which are stored in the binder, <em>then</em> passes them to the function, so the function updates the copy in the binder, not <code>bmap</code> itself.</p>

<p>So apparently not only have you not tried to measure performance yourself, you haven't even tested to see if it works. No cookie for you.</p>

<p>If you write it properly, using <code>boost::ref</code>, it should be roughly equivalent performance, assuming you turn on optimisation.</p>
"
"<p>If you only have 8 values and that's not going to change, use the array.  But note that the mapping would be <code>0=&gt;0x01, 1=&gt;0x03, ...</code> etc., because C indexing is zero-based.</p>

<p>Also, look for a pattern in your numbers: you could find a logic or arithmetic operation that will set the least significant N bits in a byte.  I.e.  N => (2 * N) -1</p>
"
"<p>The two most obvious solutions would be:</p>

<ol>
<li>Use an array. <code>const uint8_t masks[] = { 1, 3, ... }</code>.</li>
<li>Your mask seems to be ""the <code>i + 1</code> rightmost bits should be set"", so you can trivally compute that at runtime using <code>(1 &lt;&lt; (i + 1)) - 1</code> which is easier to implement and less error-prone.</li>
</ol>
"
"<p>There's nothing <em>wrong</em> with using the lookup table to get your numbers but you <em>could</em> consider another approach.</p>

<p>If you're simply looping through those values in order, each one can be obtained by left-shifting the previous and setting the low order bit to 1:</p>

<pre><code>      0000 0001 (x01)

&lt;&lt; 1: 0000 0010
 | 1: 0000 0011 (x03)

&lt;&lt; 1: 0000 0110
 | 1: 0000 0111 (x07)

&lt;&lt; 1: 0000 1110
 | 1: 0000 1111 (x0f)

&lt;&lt; 1: 0001 1110
 | 1: 0001 1111 (x1f)
</code></pre>

<p>So, something like:</p>

<pre><code>for (unsigned int i = 1; i &lt; 0x100; i = (i &lt;&lt; 1) | 1) ...
</code></pre>

<p>should do the trick.</p>

<p>The only <em>possible</em> advantage I can see that <em>may</em> have would be not having to go out to memory for a lookup table. Depending on your hardware architecture, that may or may not be a problem.</p>

<p>The following complete program:</p>

<pre><code>#include &lt;stdio.h&gt;

int main (void) {
    unsigned int i;
    for (i = 1; i &lt; 0x100; i = (i &lt;&lt; 1) | 1)
        printf (""%02x "", i);
    putchar('\n');
    return 0;
}
</code></pre>

<p>shows it in action:</p>

<pre><code>01 03 07 0f 1f 3f 7f ff
</code></pre>
"
"<p>1.The number of nblocks which is defined in <code>mkfs.c</code> is insufficient.</p>

<pre><code>int nblocks = 20985;
int nlog = LOGSIZE;
int ninodes = 200;
int size = 21029;
</code></pre>

<p>You have defined:</p>

<pre><code>#define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT*NINDIRECT + 4*NINDIRECT*NINDIRECT
</code></pre>

<p>which equals: 10+128+128^2+4*128^2 = 82058.</p>

<p>Just pick a number of <code>nblocks</code> which is greater than 82058, and update <code>size</code> accordingly.</p>

<p>2.In your bmap() function, in the triple indirection code, your first level of indirection is to a four-entry array (as you mentioned in your diagram).
Once you know to which of these four entries you should access, you're back with the double indirection problem, which you already solved.</p>

<p>So, in order to know which of the four entries you should access, you can use this:</p>

<pre><code>if((addr = a[bn/(NINDIRECT*NINDIRECT)]) == 0){
  a[bn/(NINDIRECT*NINDIRECT)] = addr = balloc(ip-&gt;dev);
  log_write(bp);
}
</code></pre>

<p>You then could decrease <code>bn</code> like so:</p>

<pre><code>bn -= ((NINDIRECT*NINDIRECT)*(bn/(NINDIRECT*NINDIRECT)));
</code></pre>

<p>and solve the double indirection problem again.</p>
"
"<p>Apparently this way is impossible. But with root it is possible to write file slack via mounting a loop back device. Still, ignoring EOF is not possible without changing the driver or implementing your own kernel module. </p>
"
"<p>Try facebook's fresco library. It can handle large images and one of my projects, reduces memory consumption about 50%.</p>
"
"<p>Actually this should not be an issue and these images are not so big to make you phone laggy. Take a look on other stuff you have in the application, it is possible there is some heavy operations (like DB writing/readin, API requests) right in UI thread.</p>

<p>If there is no such operations and you see such problems with the perfomance, try to set these images via some libraries, like Picasso. </p>

<p>Gradle dependency:</p>

<pre><code>compile 'com.squareup.picasso:picasso:2.4.0'
</code></pre>

<p>And code will look like this:</p>

<p><code>Picasso.with(this).load(R.drawable.my_image).into(toolbar);</code></p>
"
"<p>TRY </p>

<ol>
<li>Definitely reduce the size of the images.</li>
<li>Cache images if you can.</li>
<li>Download the images on a different thread. Store a HashMap would
make it easy for you</li>
</ol>

<p>When you get the list of image urls, iterate through them:</p>

<pre><code>pictures.put(id,view);
        try{
            FileInputStream in = openFileInput(id);
            Bitmap bitmap = null;
            bitmap = BitmapFactory.decodeStream(in, null, null);
        view.setImageBitmap(bitmap);
        }catch(Exception e){
            new Thread(new PictureGetter(this,mHandler,id)).start();
        }
</code></pre>

<p>Code to update the image view:</p>

<pre><code>if(id!=null){
        ImageView iv = pictures.get(id);
        if(iv!=null){
            try{
                FileInputStream in = openFileInput(id);
                Bitmap bitmap = null;
                bitmap = BitmapFactory.decodeStream(in, null, null);
                iv.setImageBitmap(bitmap);
            }catch(Exception e){
        }
    }
</code></pre>
"
"<p>Problem is <code>resolution</code> of image, if you can <code>reduce resolution</code> of image then work fine here is the some example for reducing <code>image resolution</code> ans size.</p>

<p>If you pass bitmap width and height then use below function.</p>

<pre><code>    public Bitmap getResizedBitmap(Bitmap image, int bitmapWidth,
            int bitmapHeight) {
        return Bitmap.createScaledBitmap(image, bitmapWidth, bitmapHeight,
                true);
    }
</code></pre>

<p>if you want bitmap ratio same and reduce bitmap size. then pass your maximum size bitmap. you can use this function</p>

<pre><code>public Bitmap getResizedBitmap(Bitmap image, int maxSize) {
    int width = image.getWidth();
    int height = image.getHeight();

    float bitmapRatio = (float)width / (float) height;
    if (bitmapRatio &gt; 0) {
        width = maxSize;
        height = (int) (width / bitmapRatio);
    } else {
        height = maxSize;
        width = (int) (height * bitmapRatio);
    }
    return Bitmap.createScaledBitmap(image, width, height, true);
}
</code></pre>

<p>or if you are using drawable resources then use this method</p>

<pre><code>public Drawable resizeImage(int imageResource) {// R.drawable.icon
    // Get device dimensions
    Display display = getWindowManager().getDefaultDisplay();
    double deviceWidth = display.getWidth();

    BitmapDrawable bd = (BitmapDrawable) this.getResources().getDrawable(
            imageResource);
    double imageHeight = bd.getBitmap().getHeight();
    double imageWidth = bd.getBitmap().getWidth();

    double ratio = deviceWidth / imageWidth;
    int newImageHeight = (int) (imageHeight * ratio);

    Bitmap bMap = BitmapFactory.decodeResource(getResources(), imageID);
    Drawable drawable = new BitmapDrawable(this.getResources(),
            getResizedBitmap(bMap, newImageHeight, (int) deviceWidth));

    return drawable;
}

/************************ Resize Bitmap *********************************/
public Bitmap getResizedBitmap(Bitmap bm, int newHeight, int newWidth) {

    int width = bm.getWidth();
    int height = bm.getHeight();

    float scaleWidth = ((float) newWidth) / width;
    float scaleHeight = ((float) newHeight) / height;

    // create a matrix for the manipulation
    Matrix matrix = new Matrix();

    // resize the bit map
    matrix.postScale(scaleWidth, scaleHeight);

    // recreate the new Bitmap
    Bitmap resizedBitmap = Bitmap.createBitmap(bm, 0, 0, width, height,
            matrix, false);

    return resizedBitmap;
}
</code></pre>
"
"<h2>Approach</h2>

<ul>
<li>All the declarations must go in the headers and </li>
<li>all the definitions go into the .cpp files.</li>
<li>None of the headers include each other.</li>
</ul>

<p>In this specific instance the error regarding the missing definition (for the <code>std::pair</code>, as part of the <code>std::map</code>) goes away if all the .cpp files include all the declarations. (A needs C, but C needs B)</p>

<p>So even though the error was for a missing definition, it could be solved by including a declaration. I'm not sure why and will post a <a href=""https://stackoverflow.com/q/36667957/1460794"">separate question</a>.</p>

<h2>Solution</h2>

<p>A.h</p>

<pre><code>#ifndef A_h
#define A_h

#include &lt;map&gt;

class C;

class A {
public:
    C&amp; add();
    std::map&lt;int,C&gt; Cmap;
    void dosomethingwithC();
};

#endif
</code></pre>

<p>B.h</p>

<pre><code>#ifndef B_h
#define B_h

#include &lt;map&gt;

class A;

class B {
public:
    A&amp; add();
    std::map&lt;int,A&gt; Amap;
};

#endif
</code></pre>

<p>C.h</p>

<pre><code>#ifndef C_h
#define C_h

#include &lt;map&gt;

class B;

class C {
public:
    B&amp; add();
    std::map&lt;int,B&gt; Bmap;
};

#endif
</code></pre>

<p>A.cpp</p>

<pre><code>#include ""A.h""
#include ""B.h"" // also required here
#include ""C.h""

C&amp; A::add()
{
    auto emplace_results = Cmap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    auto&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;
}


void A::dosomethingwithC()
{
    Cmap[3].add();
}
</code></pre>

<p>B.cpp</p>

<pre><code>#include ""A.h""
#include ""B.h""
#include ""C.h"" // also required here

A&amp; B::add()
{
    auto emplace_results = Amap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    auto&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;;
}
</code></pre>

<p>C.cpp</p>

<pre><code>#include ""A.h"" // also required here
#include ""B.h""
#include ""C.h""

B&amp; C::add()
{
    auto emplace_results = Bmap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    //auto&amp; emplaced_pair = *pair_iterator;
    std::pair&lt;const int,B&gt;&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;
}
</code></pre>

<p>Main.cpp</p>

<pre><code>#include ""A.h""
#include ""B.h""
#include ""C.h""

int main()
{
    C c;
    auto&amp; emplacedB = c.add();
    auto&amp; emplacedA = emplacedB.add();
    auto&amp; emplacedC = emplacedA.add();
    emplacedC.add();
    return 0;
}
</code></pre>
"
"<ol>
<li><p>B <em>is</em> used in C.cpp.  It is used in the definition of the member variable of C.</p></li>
<li><p>B.hpp doesn't contains a <em>declaration</em> of class B (which would be <code>class B;</code>).  It contains the <em>definition</em> of it (but not of its members).</p></li>
</ol>
"
"<p>Incomplete type (forward declaration) is not allowed in STL container, even though boost containers allow it. I think it would fix this issue if you include required header files instead of forward declarations.  </p>
"
"<p>You're using <code>""%f""</code> format but passing an integer. That's undefined behavior. If you look at the return value in the debugger you'll probably find that it's <em>not</em> zero.</p>
"
"<p>To handle <code>bimap</code> write/read to/from binary file, <a href=""http://www.boost.org/doc/libs/1_63_0/libs/serialization/doc/index.html"" rel=""nofollow noreferrer"">boost serialization</a> is very helpful. You need to include </p>

<pre><code>#include &lt;boost/archive/binary_oarchive.hpp&gt;
#include &lt;boost/archive/binary_iarchive.hpp&gt;
</code></pre>

<p>as header files. Then you need to have file streams for write and read, and use <code>boost::archive::binary_oarchive</code> to write and <code>boost::archive::binary_iarchive</code> to read back. Also make sure you compile the code using <code>-lboost_serialization</code>. The full code is given below.</p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;fstream&gt;
#include &lt;boost/bimap.hpp&gt;
#include &lt;boost/bimap/unordered_set_of.hpp&gt;
#include &lt;boost/bimap/unordered_multiset_of.hpp&gt;
#include &lt;boost/archive/binary_oarchive.hpp&gt;
#include &lt;boost/archive/binary_iarchive.hpp&gt;



namespace bimaps = boost::bimaps;
typedef boost::bimap&lt;bimaps::unordered_set_of&lt;unsigned long long int&gt;,
        bimaps::unordered_multiset_of&lt;unsigned long long int &gt; &gt; bimap_reference;
typedef bimap_reference::value_type position;
bimap_reference numbers;

int main()
{

    // insert elements into bimap and write to a binary file
    {
        numbers.insert(position(123456, 100000));
        numbers.insert(position(234567, 80000));
        numbers.insert(position(345678, 100000));
        numbers.insert(position(456789, 80000));

        std::ofstream ofs(""data"");
        boost::archive::binary_oarchive oa(ofs);
        oa &lt;&lt; const_cast&lt;const bimap_reference&amp;&gt;(numbers);
        const bimap_reference::left_iterator left_iter = numbers.left.find(123456);
        oa &lt;&lt; left_iter;
        const bimap_reference::right_iterator right_iter = numbers.right.find(100000);
        oa &lt;&lt; right_iter;
    }

    // load the bimap back to memory
    {
        std::ifstream ifs(""data"", std::ios::binary);
        boost::archive::binary_iarchive ia(ifs);
        ia &gt;&gt; numbers;
        assert( numbers.size() == 4 ); // to throw an error
        bimap_reference::left_iterator left_iter;
        ia &gt;&gt; left_iter;
        assert( left_iter-&gt;first == 123456 );
        bimap_reference::right_iterator right_iter;
        ia &gt;&gt; right_iter;
        assert( right_iter-&gt;first == 100000 );
    }

    // then perform the following operation
    using ritr = bimap_reference::right_const_iterator;
    std::pair&lt;ritr, ritr&gt; range = numbers.right.equal_range(80000);
    auto itr = range.first;
    std::cout&lt;&lt;""first: ""&lt;&lt;itr-&gt;first&lt;&lt; "" &lt;-&gt; "" &lt;&lt; itr-&gt;second&lt;&lt;std::endl;
    if(itr != numbers.right.end() &amp;&amp; itr-&gt;first ==80000){
        for (itr = range.first; itr != range.second; ++itr)
        {
            std::cout&lt;&lt;""numbers:""&lt;&lt;itr-&gt;second&lt;&lt;""&lt;-&gt;""&lt;&lt;itr-&gt;first&lt;&lt;std::endl;
        }
    }
    else {
        std::cout&lt;&lt;""Not found:""&lt;&lt;std::endl;
    }
    return 0;
}
</code></pre>
"
"<p>Assuming Java 8 and considering the fact that feedbackStatus may contain more than one element with the same ID.</p>

<ol>
<li>Transform the list into a Map using ID as key and having a list of elements.</li>
<li>Iterate the list and use the Map to find all messages.</li>
</ol>

<p>The code would be:</p>

<pre><code>final Map&lt;String, List&lt;Foo&gt;&gt; listMap =
objectsFromDB.stream().collect(
      Collectors.groupingBy(item -&gt; item.getMailId())
);

for (final Foo feedBackStatus : feedBackStatusFromCsvFiles) {
        listMap.getOrDefault(feedBackStatus.getMailId(), Colleactions.emptyList()).forEach(item -&gt; item.setStatus(feedBackStatus.getStatus()));
}
</code></pre>
"
"<p>Use maps from collections to avoid the nested loops.</p>

<pre><code>    List&lt;Foo&gt; aList = new ArrayList&lt;&gt;();
    List&lt;Foo&gt; bList = new ArrayList&lt;&gt;();
    for(int i = 0;i&lt;5;i++){
        Foo foo = new Foo();
        foo.setId((long) i);
        foo.setValue(""FooA""+String.valueOf(i));
        aList.add(foo);
        foo = new Foo();
        foo.setId((long) i);
        foo.setValue(""FooB""+String.valueOf(i));
        bList.add(foo);
    }

    final Map&lt;Long,Foo&gt; bMap = bList.stream().collect(Collectors.toMap(Foo::getId, Function.identity()));

    aList.stream().forEach(it-&gt;{
        Foo bFoo = bMap.get(it.getId());
        if( bFoo != null){
            it.setValue(bFoo.getValue());
        }
    });
</code></pre>

<p>The only other solution would be to have the DTO layer return a map of the MailId->Foo object, as you could then use the CVS list to stream, and simply look up the DB Foo object.  Otherwise, the expense of sorting or iterating over both of the lists is not worth the trade-offs in performance time.  The previous statement holds true until it definitively causes a memory constraint on the platform, until then let the garbage collector do its job, and you do yours as easy as possible.</p>
"
"<p>Given that your lists may contain tens of thousands of elements, you should be concerned that you simple nested-loop approach will be too slow.  It will certainly perform a lot more comparisons than it needs to do.</p>

<p>If memory is comparatively abundant, then the fastest suitable approach would probably be to form a Map from <code>mailId</code> to (list of) corresponding <code>Foo</code> from one of your lists, somewhat as @MichaelH suggested, and to use that to match mailIds.  If <code>mailId</code> values are not certain to be unique in one or both lists, however, then you'll need something a bit different than Michael's specific approach.  Even if <code>mailId</code>s are sure to be unique within both lists, it will be a bit more efficient to form only one map.</p>

<p>For the most general case, you might do something like this:</p>

<pre><code>// The initial capacity is set (more than) large enough to avoid any rehashing
Map&lt;Long, List&lt;Foo&gt;&gt; dbMap = new HashMap&lt;&gt;(3 * objectFromDb.size() / 2);

// Populate the map
// This could be done more effciently if the objects were ordered by mailId,
// which perhaps the DB could be enlisted to ensure.
for (Foo foo : objectsFromDb) {
    Long mailId = foo.getMailId();
    List&lt;Foo&gt; foos = dbMap.get(mailId);

    if (foos == null) {
        foos = new ArrayList&lt;&gt;();
        dbMap.put(mailId, foos);
    }
    foos.add(foo);
}

// Use the map
for (Foo fooStatus: feedBackStatusFromCsvFiles) {
    List&lt;Foo&gt; dbFoos = dbMap.get(fooStatus.getMailId());

    if (dbFoos != null) {
        String status = fooStatus.getStatus();

        // Iterate over only the Foos that we already know have matching Ids
        for (Foo fooDB : dbFoos) {
            fooDB.setStatus(status);
        }
    }
}
</code></pre>

<hr>

<p>On the other hand, if you are space-constrained, so that creating the map is not viable, yet it is acceptable to reorder your two lists, then you should still get a performance improvement by sorting both lists first.  Presumably you would use <code>Collections.sort()</code> with an appropriate <code>Comparator</code> for this purpose.  Then you would obtain an <code>Iterator</code> over each list, and use them to iterate cooperatively over the two lists.  I present no code, but it would be reminiscent of the merge step of a merge sort (but the two lists are not actually merged; you only copy status information from one to the other).  But this makes sense only if the <code>mailId</code>s from <code>feedBackStatusFromCsvFiles</code> are all distinct, for otherwise the expected result of the whole task is not well determined.</p>
"
"<p>your problem is merging Foo's last status into Database objects.so you can do it in two steps that will make it more clearly &amp; readable.</p>

<ol>
<li>filtering Foos that need to merge.</li>
<li><p>merging Foos with last status.</p>

<pre><code>//because the status always the last,so you needn't use groupingBy methods to create a complex Map.
Map&lt;String, String&gt; lastStatus = feedBackStatusFromCsvFiles.stream()
        .collect(toMap(Foo::getMailId, Foo::getStatus
                       , (previous, current) -&gt; current));
//find out Foos in Database that need to merge
Predicate&lt;Foo&gt; fooThatNeedMerge = it -&gt; lastStatus.containsKey(it.getMailId());
//merge Foo's last status from cvs.
Consumer&lt;Foo&gt; mergingFoo = it -&gt; it.setStatus(lastStatus.get(it.getMailId()));

objectsFromDB.stream().filter(fooThatNeedMerge).forEach(mergingFoo);
</code></pre></li>
</ol>
"
"<p><code>localtime</code> returns a list of values in list context.  See <a href=""http://perldoc.perl.org/functions/localtime.html"" rel=""nofollow noreferrer"">the localtime documentation</a> or <a href=""http://perldoc.perl.org/perlcheat.html"" rel=""nofollow noreferrer"">perlcheat</a>.  In your example, it looks like those all mushed together.  In scalar context, it returns a formatted string like <code>Mon Dec 29 03:16:33 2008</code>.  On most platforms, the file inode change time will be returned from <code>stat</code> as a number of seconds since some epoch.  You should be able to directly compare that to the result of <code>time()</code> (<em>not</em> <code>localtime()</code>).</p>
"
"<p>If you want to compare values, you might want to use the number you got from <a href=""http://perldoc.perl.org/functions/localtime.html"" rel=""noreferrer""><code>localtime</code></a> in scalar context and the inode change time that you can get from <a href=""http://perldoc.perl.org/functions/stat.html"" rel=""noreferrer""><code>stat</code></a>:</p>

<pre><code>               ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
                  $atime,$mtime,$ctime,$blksize,$blocks)
                      = stat($filename);
</code></pre>

<p>where:</p>

<pre>
                 0 dev      device number of filesystem
                 1 ino      inode number
                 2 mode     file mode  (type and permissions)
                 3 nlink    number of (hard) links to the file
                 4 uid      numeric user ID of file's owner
                 5 gid      numeric group ID of file's owner
                 6 rdev     the device identifier (special files only)
                 7 size     total size of file, in bytes
                 8 atime    last access time in seconds since the epoch
                 9 mtime    last modify time in seconds since the epoch
                10 ctime    inode change time in seconds since the epoch (*)
                11 blksize  preferred block size for file system I/O
                12 blocks   actual number of blocks allocated
</pre>

<p>So you want field 9:</p>

<pre>
<code>
$mtime = ( stat $filename )[9];
$current_time = time;

$diff = $current_time - $mtime;
</code>
</pre>
"
"<p>It's even easier than using stat() and time()/localtime().</p>

<pre><code>my $diff = -M $filename;
</code></pre>

<p>The -M operator returns the ""age"" of the file (in days since the start of the program). It's documented under the <a href=""http://perldoc.perl.org/functions/-X.html"" rel=""nofollow noreferrer"">-X functions</a> or in <code>perldoc -f -X</code>.</p>
"
"<p>These two functions are thanks to jimtut's answer.  fileage prints the number of seconds as an integer, perfect for usage in a shell, of a file from when it was created.  fileage is the answer to the above question, while dataage prints the same for the contents of a file as that's the answer I was looking for I'm sure these will both be useful.</p>

<pre><code>function fileage {
  perl -e 'printf ""%i\n"", 60 * 60 * 24 * -C ""'""${1:?Must provide a file name}""'""'
}

function dataage {
  perl -e 'printf ""%i\n"", 60 * 60 * 24 * -M ""'""${1:?Must provide a file name}""'""'
}
</code></pre>
"
"<p>I don't think ""timezone"" changes with daylight time. Try the ""daylight"" variable. On my system:</p>

<pre>
      The external variable timezone contains the difference, in seconds,
      between UTC and local standard time (for example, in the U.S. Eastern
      time zone (EST), timezone is 5*60*60).  The external variable daylight
      is non-zero only if a summer time zone adjustment is specified in the
      TZ environment variable.
</pre>
"
"<p>Look at tm.tm_isdst field after doing this:</p>

<pre><code>  time_t current_time;
  struct tm tm;

  current_time = time(NULL);
  localtime_r(&amp;current_time, &amp;tm);
</code></pre>

<p>According to the localtime_r(3) manpage, this does actually indicate whether DST is in effect at the time specified. I think you then need to assume that DST adds one hour to the timezone(3) variable you're already using, or do the diff trick against GMT.</p>

<p>Works for me in Australian AEST, hope it works for you.</p>
"
"<p>You can use <code>tm_gmtoff</code> mem ber of struct tm which is same as ::timezone but it considers DST and the sign is reversed. </p>

<p><a href=""http://www.gnu.org/s/libc/manual/html_node/Time-Zone-Functions.html#Time-Zone-Functions"" rel=""nofollow"">http://www.gnu.org/s/libc/manual/html_node/Time-Zone-Functions.html#Time-Zone-Functions</a></p>
"
"<p>Here is my code for this using tm_gmtoff if <strong>linux</strong> is defined, and using timezone.tz_minuteswest from gettimofday otherwise (here 'ltm' is the output of localtime):</p>

<pre><code>{
    int tz_offset;

#if defined(__linux__)
    tz_offset= ltm.tm_gmtoff;
#else
    tz_offset= -tz.tz_minuteswest*60 + ltm.tm_isdst*3600;
#endif

     printf (""LT = UTC +d sec\n"", tz_offset);
}
</code></pre>
"
"<p>You certainly have a race condition here. The most straitforward solution is to protect the use of the shared variable <code>currentTime</code> by using a lock. I am using the Boost.Threads mutex class here:</p>

<pre><code>class Foo
{
  boost::mutex _access;
  update()
  {
    boost::mutex::scoped_lock lock(_access);
    currentTime = currentTime + timeDelay;
  }

  restart(Time newTime)
  {
    boost::mutex::scoped_lock lock(_access);
    currentTime = newTime;
  }
};
</code></pre>
"
"<p>Add some printfs in each function to create a log of what is happening. </p>

<p>For example, what do you expect to happen if update() was executed in another thread immediately after ""currentTime=newTime;""? - or even worse - <strong>during</strong> the assignment in that line.</p>

<p>After you've done that, have a look at:
<a href=""http://en.wikipedia.org/wiki/Mutual_exclusion"" rel=""nofollow noreferrer"">http://en.wikipedia.org/wiki/Mutual_exclusion</a></p>
"
"<p>Accessing the same variable from two threads (as you are doing) requires some sort of syncronization. Use a mutex to guarenteed that only one thread is accessing that variable at a time, ie:</p>

<pre><code>update()
{
    // Lock mutex
    currentTime = currentTime + timeDelay;
    // unlock mutex
}
// Same idea for restart()
</code></pre>

<p>The problem is that access to the same variable, without a syncronization primitive such as a mutex, is problematic with threads. Say update() reads currentTime, does the addition, but before it can store the result, we switch threads, restart() does it's thing. Now we switch back to update(), which writes the (now invalid) result of the addition back into currentTime, overwriting restart()'s work. Mutex's prevent this by allowing you to guarentee an operation is atomic. Google for some tutorials - you'll need to know a lot of other things, such as deadlocks.</p>

<p>How exactly you create/lock a mutex depends on your OS/what libraries you want to use. Native solutions are pthreads on *nix systems, Critical sections on Win32. (pthreads implementations exist for Win32) The Boost library also has a threads section.</p>
"
"<p>Thread 1 calls update, gets a copy of currentTime and saves it in its thread local memory.
Thread 2 calls restart, sets currentTime to newTime. Thread 2 finishes.
Thread 1 continues, reassigns currentTime to the currentTime in its thread local memory (which is the old value of currentTime prior to your restart call) + the timeDelay. Thread 1 now finishes.</p>

<p>Hence your restart will have failed. There are many other situations which can occur resulting in unexpected behavior. Always synchronize variables shared amongst a different threads, to avoid such problems.</p>

<p>You should use a mutex suggested by others.</p>
"
"<p>The use of a mutex feels way too heavy to me in this situation.  I'd use InterlockedExchange and InterlockedAdd instead.</p>
"
"<p>You are having a race condition as there is no locking while entering the critical region and each are updating the current_time. Each thread has a memory, when a thread needs to obtain something from the shared memory it copies this into it's local memory. The first step is to obtain a lock first then clearing it's memory guaranteeing that the variable will be loaded from the shared memory. Now operate in the critical region and once done unlock the critical region guaranteeing the local variable will be written out to the shared memory. Since you do not have a lock you can not predict what is going to happen. </p>

<p>The use of a mutex would be what you need for your case as there is only one key for current_time variable. The other type of locking is a semaphore which allows for multiple keys.</p>
"
"<p>If currentTime is realy a <strong>global variable</strong> like you say it is, you'll need a <strong>global mutex</strong> to protect the variable. ( PTHREAD_MUTEX_INITIALIZER or BOOST.call_once construction )</p>

<p>In that case the BOOST.Threads example is incorrect because two instances of the Foo class living in different threads will have different instances of the _access mutex (I realy do not prefer the _ prefex!) and will lock their own instance and do not protect the currentTime variable.</p>

<p>If currentTime is a instance variable the BOOST.Threads example is correct.</p>
"
"<p>std C libraries provide <a href=""http://en.cppreference.com/w/cpp/chrono/c/time"" rel=""noreferrer""><code>time()</code></a>.
This is seconds from the epoch and can be converted to date and <code>H:M:S</code> using standard C functions. <strong>Boost</strong> also has <a href=""http://www.boost.org/doc/libs/1_38_0/doc/html/date_time.html"" rel=""noreferrer"">a time/date library</a> that you can check.</p>

<pre><code>time_t  timev;
time(&amp;timev);
</code></pre>
"
"<p>C++ shares its date/time functions with C. The <a href=""http://en.cppreference.com/w/cpp/chrono/c/tm"" rel=""noreferrer"">tm structure</a> is probably the easiest for a C++ programmer to work with - the following prints today's date:</p>

<pre><code>#include &lt;ctime&gt;
#include &lt;iostream&gt;
using namespace std;

int main() {
    time_t t = time(0);   // get time now
    struct tm * now = localtime( &amp; t );
    cout &lt;&lt; (now-&gt;tm_year + 1900) &lt;&lt; '-'
         &lt;&lt; (now-&gt;tm_mon + 1) &lt;&lt; '-'
         &lt;&lt;  now-&gt;tm_mday
         &lt;&lt; endl;
}
</code></pre>
"
"<p>the C++ standard library does not provide a proper date type. C++ inherits the structs and functions for date and time manipulation from C, along with a couple of date/time input and output functions that take into account localization.</p>

<pre><code>// Current date/time based on current system
time_t now = time(0);

// Convert now to tm struct for local timezone
tm* localtm = localtime(&amp;now);
cout &lt;&lt; ""The local date and time is: "" &lt;&lt; asctime(localtm) &lt;&lt; endl;

// Convert now to tm struct for UTC
tm* gmtm = gmtime(&amp;now);
if (gmtm != NULL) {
cout &lt;&lt; ""The UTC date and time is: "" &lt;&lt; asctime(gmtm) &lt;&lt; endl;
}
else {
cerr &lt;&lt; ""Failed to get the UTC date and time"" &lt;&lt; endl;
return EXIT_FAILURE;
}
</code></pre>
"
"<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main ()
{
  time_t rawtime;
  struct tm * timeinfo;

  time ( &amp;rawtime );
  timeinfo = localtime ( &amp;rawtime );
  printf ( ""Current local time and date: %s"", asctime (timeinfo) );

  return 0;
}
</code></pre>
"
"<p>You can try the following cross-platform code to get current date/time:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

// Get current date/time, format is YYYY-MM-DD.HH:mm:ss
const std::string currentDateTime() {
    time_t     now = time(0);
    struct tm  tstruct;
    char       buf[80];
    tstruct = *localtime(&amp;now);
    // Visit http://en.cppreference.com/w/cpp/chrono/c/strftime
    // for more information about date/time format
    strftime(buf, sizeof(buf), ""%Y-%m-%d.%X"", &amp;tstruct);

    return buf;
}

int main() {
    std::cout &lt;&lt; ""currentDateTime()="" &lt;&lt; currentDateTime() &lt;&lt; std::endl;
    getchar();  // wait for keyboard input
}
</code></pre>

<p>Output:</p>

<pre><code>currentDateTime()=2012-05-06.21:47:59
</code></pre>

<p>Please visit <a href=""http://en.cppreference.com/w/cpp/chrono/c/strftime"">here</a> for more information about date/time format</p>
"
"<p>The <a href=""http://code.google.com/p/ffead-cpp"" rel=""nofollow"">ffead-cpp</a> provides multiple utility classes for various tasks, one such class is the <a href=""http://code.google.com/p/ffead-cpp/source/browse/trunk/ffead-server-unix/include/Date.h"" rel=""nofollow"">Date</a> class which provides a lot of features right from Date operations to date arithmetic, there's also a <a href=""http://code.google.com/p/ffead-cpp/source/browse/trunk/ffead-server-unix/include/Timer.h"" rel=""nofollow"">Timer</a> class provided for timing operations. You can have a look at the same.</p>
"
"<p>(For fellow googlers)</p>

<p>There is also <a href=""http://www.boost.org/doc/libs/1_51_0/doc/html/date_time/posix_time.html#date_time.posix_time.ptime_class"" rel=""noreferrer"">Boost::date_time</a> :</p>

<pre><code>#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;

boost::posix_time::ptime date_time = boost::posix_time::microsec_clock::universal_time();
</code></pre>
"
"<p>You can also directly use <code>ctime()</code>: </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main ()
{
  time_t rawtime;
  struct tm * timeinfo;

  time ( &amp;rawtime );
  printf ( ""Current local time and date: %s"", ctime (&amp;rawtime) );

  return 0;
}
</code></pre>
"
"<p>Yes and you can do so with formatting rules specified by the currently-imbued locale:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;

class timefmt
{
public:
    timefmt(std::string fmt)
        : format(fmt) { }

    friend std::ostream&amp; operator &lt;&lt;(std::ostream &amp;, timefmt const &amp;);

private:
    std::string format;
};

std::ostream&amp; operator &lt;&lt;(std::ostream&amp; os, timefmt const&amp; mt)
{
    std::ostream::sentry s(os);

    if (s)
    {
        std::time_t t = std::time(0);
        std::tm const* tm = std::localtime(&amp;t);
        std::ostreambuf_iterator&lt;char&gt; out(os);

        std::use_facet&lt;std::time_put&lt;char&gt;&gt;(os.getloc())
            .put(out, os, os.fill(),
                 tm, &amp;mt.format[0], &amp;mt.format[0] + mt.format.size());
    }

    os.width(0);

    return os;
}

int main()
{
    std::cout &lt;&lt; timefmt(""%c"");
}
</code></pre>

<blockquote>
  <p>Output: <code>Fri Sep  6 20:33:31 2013</code></p>
</blockquote>
"
"<p>There's always the <code>__TIMESTAMP__</code> preprocessor macro.</p>

<pre><code>#include &lt;iostream&gt;

using namespace std

void printBuildDateTime () {
    cout &lt;&lt; __TIMESTAMP__ &lt;&lt; endl;
}

int main() {
    printBuildDateTime();
}
</code></pre>

<p>example: Sun Apr 13 11:28:08 2014</p>
"
"<pre><code>#include &lt;Windows.h&gt;

void main()
{
     //Following is a structure to store date / time

SYSTEMTIME SystemTime, LocalTime;

    //To get the local time

int loctime = GetLocalTime(&amp;LocalTime);

    //To get the system time

int systime = GetSystemTime(&amp;SystemTime)

}
</code></pre>
"
"<p><a href=""http://www.cplusplus.com/reference/ctime/strftime/"" rel=""nofollow"">http://www.cplusplus.com/reference/ctime/strftime/</a></p>

<p>This built-in seems to offer a reasonable set of options.</p>
"
"<p>In C++ 11 you can use <a href=""http://en.cppreference.com/w/cpp/chrono"" rel=""noreferrer"">std::chrono::system_clock::now()</a> </p>

<p>(Click on the link to see examples/usage.)</p>
"
"<p>This works with G++ I'm not sure if this helps you.
Program output: </p>

<pre><code>The current time is 11:43:41 am
The current date is 6-18-2015 June Wednesday
Day of month is 17 and the Month of year is 6,
also the day of year is 167 &amp; our Weekday is 3.
The current year is 2015.
</code></pre>

<p>Code :</p>

<pre><code>#include &lt;ctime&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

using namespace std;

const std::string currentTime() {
time_t now = time(0);
struct tm tstruct;
char buf[80];
tstruct = *localtime(&amp;now);
strftime(buf, sizeof(buf), ""%H:%M:%S %P"", &amp;tstruct);
return buf;
}

const std::string currentDate() {
time_t now = time(0);
struct tm tstruct;
char buf[80];
tstruct = *localtime(&amp;now);
strftime(buf, sizeof(buf), ""%B %A "", &amp;tstruct);
return buf;
}

int main() {
    cout &lt;&lt; ""\033[2J\033[1;1H"";
std:cout &lt;&lt; ""The current time is "" &lt;&lt; currentTime() &lt;&lt; std::endl;
    time_t t = time(0);   // get time now
    struct tm * now = localtime( &amp; t );
    cout &lt;&lt; ""The current date is "" &lt;&lt; now-&gt;tm_mon + 1 &lt;&lt; '-'
         &lt;&lt; (now-&gt;tm_mday  + 1) &lt;&lt; '-'
         &lt;&lt;  (now-&gt;tm_year + 1900)
         &lt;&lt; "" "" &lt;&lt; currentDate() &lt;&lt; endl;

 cout &lt;&lt; ""Day of month is "" &lt;&lt; (now-&gt;tm_mday)
      &lt;&lt; "" and the Month of year is "" &lt;&lt; (now-&gt;tm_mon)+1 &lt;&lt; "","" &lt;&lt; endl;
    cout &lt;&lt; ""also the day of year is "" &lt;&lt; (now-&gt;tm_yday)
         &lt;&lt; "" &amp; our Weekday is "" &lt;&lt; (now-&gt;tm_wday) &lt;&lt; ""."" &lt;&lt; endl;
    cout &lt;&lt; ""The current year is "" &lt;&lt; (now-&gt;tm_year)+1900 &lt;&lt; "".""
         &lt;&lt; endl;
 return 0;
}
</code></pre>
"
"<p>New answer for an old question:</p>

<p>The question does not specify in what timezone.  There are two reasonable possibilities:</p>

<ol>
<li>In UTC.</li>
<li>In the computer's local timezone.</li>
</ol>

<p>For 1, you can use <a href=""http://howardhinnant.github.io/date/date.html"" rel=""noreferrer"">this date library</a> and the following program:</p>

<pre><code>#include ""date.h""
#include &lt;iostream&gt;

int
main()
{
    using namespace date;
    using namespace std::chrono;
    std::cout &lt;&lt; system_clock::now() &lt;&lt; '\n';
}
</code></pre>

<p>Which just output for me:</p>

<pre><code>2015-08-18 22:08:18.944211
</code></pre>

<p>The date library essentially just adds a streaming operator for <code>std::chrono::system_clock::time_point</code>.  It also adds a lot of other nice functionality, but that is not used in this simple program.</p>

<p>If you prefer 2 (the local time), there is a <a href=""http://howardhinnant.github.io/date/tz.html"" rel=""noreferrer"">timezone library</a> that builds on top of the <a href=""http://howardhinnant.github.io/date/date.html"" rel=""noreferrer"">date library</a>.  Both of these libraries are <strong>open source</strong> and <strong>cross platform</strong>, assuming the compiler supports C++11 or C++14.</p>

<pre><code>#include ""tz.h""
#include &lt;iostream&gt;

int
main()
{
    using namespace date;
    using namespace std::chrono;
    auto local = make_zoned(current_zone(), system_clock::now());
    std::cout &lt;&lt; local &lt;&lt; '\n';
}
</code></pre>

<p>Which for me just output:</p>

<pre><code>2015-08-18 18:08:18.944211 EDT
</code></pre>

<p>The result type from <code>make_zoned</code> is a <code>date::zoned_time</code> which is a pairing of a <code>date::time_zone</code> and a <code>std::chrono::system_clock::time_point</code>.  This pair represents a local time, but can also represent UTC, depending on how you query it.</p>

<p>With the above output, you can see that my computer is currently in a timezone with a UTC offset of -4h, and an abbreviation of EDT.</p>

<p>If some other timezone is desired, that can also be accomplished.  For example to find the current time in Sydney , Australia just change the construction of the variable <code>local</code> to:</p>

<pre><code>auto local = make_zoned(""Australia/Sydney"", system_clock::now());
</code></pre>

<p>And the output changes to:</p>

<pre><code>2015-08-19 08:08:18.944211 AEST
</code></pre>
"
"<p>You could use <a href=""http://theboostcpplibraries.com/boost.datetime-calendar"" rel=""nofollow""><code>boost</code></a>:</p>

<pre><code>#include &lt;boost/date_time/gregorian/gregorian.hpp&gt;
#include &lt;iostream&gt;
using namespace boost::gregorian;

int main()
{
    date d = day_clock::universal_day();
    std::cout &lt;&lt; d.day() &lt;&lt; "" "" &lt;&lt; d.month() &lt;&lt; "" "" &lt;&lt; d.year();
}
</code></pre>
"
"<p>This compiled for me on Linux (RHEL) and Windows (x64) targeting g++ and OpenMP:</p>

<pre><code>#include &lt;ctime&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;locale&gt;

////////////////////////////////////////////////////////////////////////////////
//
//  Reports a time-stamped update to the console; format is:
//       Name: Update: Year-Month-Day_of_Month Hour:Minute:Second
//
////////////////////////////////////////////////////////////////////////////////
//
//  [string] strName  :  name of the update object
//  [string] strUpdate:  update descripton
//
////////////////////////////////////////////////////////////////////////////////

void ReportTimeStamp(string strName, string strUpdate)
{
    try
    {
        #ifdef _WIN64
            //  Current time
            const time_t tStart = time(0);
            //  Current time structure
            struct tm tmStart;

            localtime_s(&amp;tmStart, &amp;tStart);

            //  Report
            cout &lt;&lt; strName &lt;&lt; "": "" &lt;&lt; strUpdate &lt;&lt; "": "" &lt;&lt; (1900 + tmStart.tm_year) &lt;&lt; ""-"" &lt;&lt; tmStart.tm_mon &lt;&lt; ""-"" &lt;&lt; tmStart.tm_mday &lt;&lt; "" "" &lt;&lt; tmStart.tm_hour &lt;&lt; "":"" &lt;&lt; tmStart.tm_min &lt;&lt; "":"" &lt;&lt; tmStart.tm_sec &lt;&lt; ""\n\n"";
        #else
            //  Current time
            const time_t tStart = time(0);
            //  Current time structure
            struct tm* tmStart;

            tmStart = localtime(&amp;tStart);

            //  Report
            cout &lt;&lt; strName &lt;&lt; "": "" &lt;&lt; strUpdate &lt;&lt; "": "" &lt;&lt; (1900 + tmStart-&gt;tm_year) &lt;&lt; ""-"" &lt;&lt; tmStart-&gt;tm_mon &lt;&lt; ""-"" &lt;&lt; tmStart-&gt;tm_mday &lt;&lt; "" "" &lt;&lt; tmStart-&gt;tm_hour &lt;&lt; "":"" &lt;&lt; tmStart-&gt;tm_min &lt;&lt; "":"" &lt;&lt; tmStart-&gt;tm_sec &lt;&lt; ""\n\n"";
        #endif

    }
    catch (exception ex)
    {
        cout &lt;&lt; ""ERROR [ReportTimeStamp] Exception Code:  "" &lt;&lt; ex.what() &lt;&lt; ""\n"";
    }

    return;
}
</code></pre>
"
"<p>I found this link pretty useful for my implementation:
<a href=""https://www.tutorialspoint.com/cplusplus/cpp_date_time.htm"" rel=""nofollow noreferrer"">C++ Date and Time</a></p>

<p>Here's the code I use in my implementation, to get a clear ""YYYYMMDD HHMMSS"" output format. The param in is for switching between UTC and local time. You can easily modify my code to suite your need. </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;ctime&gt;

using namespace std;

/**
 * This function gets the current date time
 * @param useLocalTime true if want to use local time, default to false (UTC)
 * @return current datetime in the format of ""YYYYMMDD HHMMSS""
 */

string getCurrentDateTime(bool useLocalTime) {
    stringstream currentDateTime;
    // current date/time based on current system
    time_t ttNow = time(0);
    tm * ptmNow;

    if (useLocalTime)
        ptmNow = localtime(&amp;ttNow);
    else
        ptmNow = gmtime(&amp;ttNow);

    currentDateTime &lt;&lt; 1900 + ptmNow-&gt;tm_year;

    //month
    if (ptmNow-&gt;tm_mon &lt; 9)
        //Fill in the leading 0 if less than 10
        currentDateTime &lt;&lt; ""0"" &lt;&lt; 1 + ptmNow-&gt;tm_mon;
    else
        currentDateTime &lt;&lt; (1 + ptmNow-&gt;tm_mon);

    //day
    if (ptmNow-&gt;tm_mday &lt; 10)
        currentDateTime &lt;&lt; ""0"" &lt;&lt; ptmNow-&gt;tm_mday &lt;&lt; "" "";
    else
        currentDateTime &lt;&lt;  ptmNow-&gt;tm_mday &lt;&lt; "" "";

    //hour
    if (ptmNow-&gt;tm_hour &lt; 10)
        currentDateTime &lt;&lt; ""0"" &lt;&lt; ptmNow-&gt;tm_hour;
    else
        currentDateTime &lt;&lt; ptmNow-&gt;tm_hour;

    //min
    if (ptmNow-&gt;tm_min &lt; 10)
        currentDateTime &lt;&lt; ""0"" &lt;&lt; ptmNow-&gt;tm_min;
    else
        currentDateTime &lt;&lt; ptmNow-&gt;tm_min;

    //sec
    if (ptmNow-&gt;tm_sec &lt; 10)
        currentDateTime &lt;&lt; ""0"" &lt;&lt; ptmNow-&gt;tm_sec;
    else
        currentDateTime &lt;&lt; ptmNow-&gt;tm_sec;


    return currentDateTime.str();
}
</code></pre>

<p>Output (UTC, EST):</p>

<pre><code>20161123 000454
20161122 190454
</code></pre>
"
"<p>localtime_s() version:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main ()
{
  time_t current_time;
  struct tm  local_time;

  time ( &amp;current_time );
  localtime_s(&amp;local_time, &amp;current_time);

  int Year   = local_time.tm_year + 1900;
  int Month  = local_time.tm_mon + 1;
  int Day    = local_time.tm_mday;

  int Hour   = local_time.tm_hour;
  int Min    = local_time.tm_min;
  int Sec    = local_time.tm_sec;

  return 0;
}
</code></pre>
"
"<pre><code>auto time = std::time(nullptr);
std::cout &lt;&lt; std::put_time(std::localtime(&amp;time), ""%F %T%z""); // ISO 8601 format.
</code></pre>

<p>Get the current time either using <a href=""http://en.cppreference.com/w/cpp/chrono/c/time"" rel=""nofollow noreferrer""><code>std::time()</code></a> or <a href=""http://en.cppreference.com/w/cpp/chrono/system_clock/now"" rel=""nofollow noreferrer""><code>std::chrono::system_clock::now()</code></a> (or another <a href=""http://en.cppreference.com/w/cpp/concept/TrivialClock"" rel=""nofollow noreferrer"">clock type</a>).</p>

<p><a href=""http://en.cppreference.com/w/cpp/io/manip/put_time"" rel=""nofollow noreferrer""><code>std::put_time()</code></a> (C++11) and <a href=""http://en.cppreference.com/w/cpp/chrono/c/strftime"" rel=""nofollow noreferrer""><code>strftime()</code></a> (C) offer a lot of formatters to output those times.</p>

<pre><code>#include &lt;iomanip&gt;
#include &lt;iostream&gt;

int main() {
    auto time = std::time(nullptr);
    std::cout
        // ISO 8601: %Y-%m-%d %H:%M:%S, e.g. 2017-07-31 00:42:00+0200.
        &lt;&lt; std::put_time(std::gmtime(&amp;time), ""%F %T%z"") &lt;&lt; '\n'
        // %m/%d/%y, e.g. 07/31/17
        &lt;&lt; std::put_time(std::gmtime(&amp;time), ""%D"");
}
</code></pre>

<hr>

<p>The sequence of the formatters matters:</p>

<pre><code>std::cout &lt;&lt; std::put_time(std::gmtime(&amp;time), ""%c %A %Z"") &lt;&lt; std::endl;
// Mon Jul 31 00:00:42 2017 Monday GMT
std::cout &lt;&lt; std::put_time(std::gmtime(&amp;time), ""%Z %c %A"") &lt;&lt; std::endl;
// GMT Mon Jul 31 00:00:42 2017 Monday
</code></pre>

<p>The formatters of <code>strftime()</code> are similar:</p>

<pre><code>char output[100];
if (std::strftime(output, sizeof(output), ""%F"", std::gmtime(&amp;time))) {
    std::cout &lt;&lt; output &lt;&lt; '\n'; // %Y-%m-%d, e.g. 2017-07-31
}
</code></pre>

<p>Often, the capital formatter means ""full version"" and lowercase means abbreviation (e.g. Y: 2017, y: 17).</p>

<hr>

<p>Locale settings alter the output:</p>

<pre><code>#include &lt;iomanip&gt;
#include &lt;iostream&gt;
int main() {
    auto time = std::time(nullptr);
    std::cout &lt;&lt; ""undef: "" &lt;&lt; std::put_time(std::gmtime(&amp;time), ""%c"") &lt;&lt; '\n';
    std::cout.imbue(std::locale(""en_US.utf8""));
    std::cout &lt;&lt; ""en_US: "" &lt;&lt; std::put_time(std::gmtime(&amp;time), ""%c"") &lt;&lt; '\n';
    std::cout.imbue(std::locale(""en_GB.utf8""));
    std::cout &lt;&lt; ""en_GB: "" &lt;&lt; std::put_time(std::gmtime(&amp;time), ""%c"") &lt;&lt; '\n';
    std::cout.imbue(std::locale(""de_DE.utf8""));
    std::cout &lt;&lt; ""de_DE: "" &lt;&lt; std::put_time(std::gmtime(&amp;time), ""%c"") &lt;&lt; '\n';
    std::cout.imbue(std::locale(""ja_JP.utf8""));
    std::cout &lt;&lt; ""ja_JP: "" &lt;&lt; std::put_time(std::gmtime(&amp;time), ""%c"") &lt;&lt; '\n';
    std::cout.imbue(std::locale(""ru_RU.utf8""));
    std::cout &lt;&lt; ""ru_RU: "" &lt;&lt; std::put_time(std::gmtime(&amp;time), ""%c"");
}
</code></pre>

<p>Possible output (<a href=""http://coliru.stacked-crooked.com/a/903c2c31f8dbcc9a"" rel=""nofollow noreferrer"">Coliru</a>, <a href=""https://godbolt.org/g/drNoeH"" rel=""nofollow noreferrer"">Compiler Explorer</a>):</p>

<pre class=""lang-none prettyprint-override""><code>undef: Tue Aug  1 08:29:30 2017
en_US: Tue 01 Aug 2017 08:29:30 AM GMT
en_GB: Tue 01 Aug 2017 08:29:30 GMT
de_DE: Di 01 Aug 2017 08:29:30 GMT
ja_JP: 2017?08?01? 08?29?30?
ru_RU: ?? 01 ??? 2017 08:29:30
</code></pre>

<hr>

<p>I've used <a href=""http://en.cppreference.com/w/cpp/chrono/c/gmtime"" rel=""nofollow noreferrer""><code>std::gmtime()</code></a> for conversion to UTC. <a href=""http://en.cppreference.com/w/cpp/chrono/c/localtime"" rel=""nofollow noreferrer""><code>std::localtime()</code></a> is provided to convert to local time.</p>

<p>Heed that <a href=""http://en.cppreference.com/w/cpp/chrono/c/asctime"" rel=""nofollow noreferrer""><code>asctime()</code></a>/<a href=""http://en.cppreference.com/w/cpp/chrono/c/ctime"" rel=""nofollow noreferrer""><code>ctime()</code></a> which were mentioned in other answers are marked as deprecated now and <code>strftime()</code> should be preferred.</p>
"
"<p>you could use C++ 11 time class:</p>

<pre><code>    #include &lt;iostream&gt;
    #include &lt;iomanip&gt;
    using namespace std;

    int main() {

       time_t now = chrono::system_clock::to_time_t(chrono::system_clock::now());
       cout &lt;&lt; put_time(localtime(&amp;now), ""%F %T"") &lt;&lt;  endl;
      return 0;
     }
</code></pre>

<p>out put:</p>

<pre><code>2017-08-25 12:30:08
</code></pre>
"
"<p><code>gettimeofday()</code> returns microseconds so you can use it instead of <code>time()</code> - see definition of <code>struct timeval</code> this function fills.</p>

<p>Check out <code>man gettimeofday</code> for details.</p>
"
"<p>This returns the wall time since the application started in millisecs.  It uses the machines clock so it is quite possible that changing the clock's time while the app is running will confuse it.  In your case I would add a schedule time to my event object and fire when schedule time &lt;= msec()</p>

<pre><code> clock_t msec() {
    static struct timeval msec_base;
    struct timeval now;

    long seconds, useconds;
    if (!msec_base.tv_usec)
        gettimeofday(&amp;msec_base, NULL);
    gettimeofday(&amp;now, NULL);

    seconds  = now.tv_sec  - msec_base.tv_sec;
    useconds = now.tv_usec - msec_base.tv_usec;

    return ((seconds) * 1000 + useconds/1000.0);
}
</code></pre>
"
"<p>A complete solution based on Nick's answer:</p>

<pre><code>#include &lt;sys/time.h&gt;
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;

using namespace std;

int TOTAL_PROCESSES;
double TIMEOUT;
int process()
{

    static struct timeval msec_base;
    struct timeval now;

    long seconds, useconds;
    if (!msec_base.tv_usec)
        gettimeofday(&amp;msec_base, NULL);

    gettimeofday(&amp;now, NULL);

    seconds  = now.tv_sec  - msec_base.tv_sec;
    useconds = now.tv_usec - msec_base.tv_usec;

    double time_diff=seconds+ useconds/100000.0;

    if(TIMEOUT &lt; time_diff)
    {
        cout&lt;&lt;TIMEOUT &lt;&lt;"" seconds...\n"";
        msec_base=now;

        return 1;
    }
     return 0;

}

int main(int argc, char** argv)
{
    if(argc &lt; 3)
    {
        cout&lt;&lt;""Error: missing TIMOUT and total time to fire\n"";
        return -1;

    }

    TIMEOUT       = atof(argv[1]);
    TIMES_TO_FIRE = atoi(argv[2]);

    cout &lt;&lt; ""INFO: TIMEOUT=""&lt;&lt;TIMEOUT&lt;&lt;"", TIMES_TO_FIRE =""&lt;&lt; TIMES_TO_FIRE &lt;&lt;endl;


    int i=0;
    while (i&lt; TIMES_TO_FIRE)
      i+=process();

    return 0;
}
</code></pre>
"
"<p>You can use boost::asio for that, see the documentation here:</p>

<p><a href=""http://think-async.com/Asio/boost_asio_1_4_1/doc/html/boost_asio/reference/deadline_timer.html"" rel=""nofollow noreferrer"">http://think-async.com/Asio/boost_asio_1_4_1/doc/html/boost_asio/reference/deadline_timer.html</a></p>
"
"<p>I know this is not second based, but you can use the rdtsc register depending on your processor... More details <a href=""http://www.makelinux.net/ldd3/chp-7-sect-1.shtml"" rel=""nofollow noreferrer"">here</a> (for measuring time lapses in linux)</p>
"
"<p>If this is C, why not use <a href=""http://linux.die.net/man/2/setitimer"" rel=""nofollow noreferrer"">setitimer()</a> and <a href=""http://en.wikipedia.org/wiki/SIGALRM"" rel=""nofollow noreferrer"">SIGALRM</a>?</p>

<p>What setitimer() does it, at a certain interval (which you can specify up to the millisecond), it triggers the SIGALRM signal. Then, you can have your program set up so that it has a function which responds to that signal.</p>

<p>The alarm() function does the same thing as setitimer() - but alarm() only works for 1-second intervals (not 1.5 seconds, etc.) That said, <a href=""http://www.delorie.com/gnu/docs/glibc/libc_488.html"" rel=""nofollow noreferrer"">this page</a> gives a tutorial for how to handle the interrupt. You can save yourself a lot of time-calculating code using this method.</p>
"
"<p>@puzzlecracker</p>

<p>Isn't CPU load a concern? Your routine keeps checking a condition an unnecessary number of times. I'd use usleep() when it misses:</p>

<pre><code>...

 if(TIMEOUT &lt; time_diff)
{
    cout&lt;&lt;TIMEOUT &lt;&lt;"" seconds...\n"";
    msec_base=now;

    return 1;
} else usleep(10);

...
</code></pre>

<p>This yield time for others processes, and doesn't give any penalty to yours code responsiveness.</p>

<p>An even better solution would be to use clock_nanosleep() with a different approach, like a threaded timer.</p>
"
"<p>use a sleep function.. and a function pointer</p>

<p>using sleep function doesnt consume processor time... You can use the function pointer to notify when the timer expired. if you dont need events you can simply use sleep/delay function</p>

<p><strong>Edit</strong> do what smallduck has suggested. using macros for currectly calling the approperiate operating system call (if you want to avoid using boost)... using anything else then timer wont be accurate.</p>
"
"<p>You didn't mention the environment you're building a timer in. For example, microcontrollers usually have a timer/counter unit that raise interrupts at some intervals by counting the clock cycles and you can just handle their interrupts. </p>
"
"<p>Your best bet is to use an operating system primitive that suspends the program for a given amount of time (like Sleep() in Windows). The environment where the program will run will most likely have some mechanism for doing this or similar thing. That's the only way to avoid polling and consuming CPU time.</p>
"
"<p>If all you need is a code snippet that lets your program rest, a call to sleep is enough (if you're OK with second granularity).</p>
"
"<p>If you just want your program to wait a certain amount of time, you can use:</p>

<ul>
<li>Sleep (in Windows)</li>
<li>usleep (in Unix)</li>
<li>boost::this_thread::sleep (everywhere)</li>
</ul>

<p>If you wish to process or display the time going up until elapsed, your approach of using a while() loop is fine, but you should add a small sleep (20ms, for example, but ultimately that depends on the precision you require) in the while loop, as not to hog the CPU.</p>
"
"<p>If you need to run multiple timers with a single thread then maintaining a hash table holding active timers is a very good method. You use the expiry time to form the hash key. Each timer tick you then search the hash table for timers which have expired.</p>
"
"<blockquote>
<pre><code>  void SimpleTimer(int timeinterval)
  {
       int starttime, currenttime, difference;
       starttime = time(null);

       do
       {
            currenttime = time(null);
            difference = currenttime - starttime;
       }
       while (difference &lt; timeinterval);
  }
</code></pre>
</blockquote>
"
"<p>You can call time() multiple times and compare the values.</p>

<pre><code>#include &lt;time.h&gt;

int main ()
{
  time_t start_time;
  time_t current_time;

  start_time = time(NULL);
  current_time = time(NULL)

  while (current_time &lt; start_time + TIMEOUT)
  {
  /* Do what you want while you're waiting for the timeout */
  current_time = time(NULL);
  }

 ...
}
</code></pre>

<p>The advantage over sleep() is that you can still execute code while you are waiting. For example... polling for an external stop signal, etc.</p>
"
"<p>There are two ways:</p>

<p>One. Write your own timer which wraps the platform specific command. And stick to using it.
e.g. </p>

<pre><code>void MySleep::Sleep(int milliSec)
{
#ifdef WIN32
   sleep(milliSec) ;
#else
#ifdef LINUX
   usleep(milliSec*1000); //microseconds
#endif
#endif
}
</code></pre>

<p>Two. Choose libraries and toolkits that support all your target platforms. Toolkits like Qt and boost can be used to cover up platform specific goo.</p>

<p>Both boost and Qt have timers with high functionality and are extensible. I recommend you look them up.</p>
"
"<p>You could always play around with threads. One master thread could be scheduling tasks/jobs to be carried out at certain intervals. But then we are into the area of scheduling, which is something that the OS does. So as GMan said, you're suddenly in the realm of developing your own OS, or mimicing parts of the OS functionality.</p>
"
"<p><a href=""http://linux.die.net/man/2/alarm"" rel=""nofollow noreferrer"">http://linux.die.net/man/2/alarm</a></p>

<blockquote>
  <p>Description:<br>
  alarm() arranges for a SIGALRM signal to be delivered to the process in <code>seconds</code> seconds. </p>
</blockquote>

<p>and use cygwin on windows.</p>
"
"<p>it is not a trivial task because depending on  your requirements it can be quite complex.</p>

<p>the problem with timers is that if you want a good timer you may need to move beyond c++(/c) into the realm of OS calls causing you to end up with a OS specific solution or use some library like boost to wrap it.</p>

<p>I mainly program in Windows so my advice come from that realm:</p>

<p>In windows you can of course use a timer(NULL) as some suggested however mostly when you are waiting you don't want to blog down the CPU with a loop. Using sleep is one way but instead I usually take the approach of using an object to wait for. Either the object signals or a timeout occurs. E.g. in order to wait for 10 seconds:</p>

<pre><code>res = WaitForSingleObject( someobjecthandle, 10000 );
</code></pre>

<p>if the return value is timeout I know I waited 10s, otherwise the object signaled in some way and I didn't wait 10s. Now using that you can create an effective timer.</p>

<p>Another approach which is a bit more work is to create a separate timer thread (windows again) which periodically sends a message to your message loop. </p>

<p>A third approach is to create a thread that is the actual timer, you start the thread with an argument, the thread sleeps this time (ok i know u dont want to use that but u can use another MsgWaitForMultipleObjects function inside the thread to react if you want to kill the timer prematurely) and do a WaitForSingleObject on the handle of the thread, when it signals the time is up (or a timeout).</p>

<p>There are more ways to this but I hope I gave you at least some more ideas :)</p>
"
"<p>What you're already doing is the easiest.</p>

<p>It consumes too much CPU because it's going hard out doing your check (is timer expired?)
or whatever.</p>

<p>To fix that put usleep(1) or whatever the OS equivalent of a very short sleep in that main
loop and you'll have what you need.</p>
"
"<p>A lot of these answers include something known as ""busy waiting."" Checking the time over and over again in a while() loop is a bad idea 99% of the time. </p>

<p>I think you may want to step back and approach the problem a bit differently. </p>

<p>It sounds like you want a program to turn something off under a given set of conditions.</p>

<p>So you have a few options. You can ""wake up"" your background program every so often and check if conditions are met (using sleep / usleep, which are standard functions in all languages on all operating systems). </p>

<p>Or you can background the process indefinitely, until some type of event occurs. This would probably best be accomplished in C via signals or some type of wait function.</p>

<p>Its hard to tell exactly what you want, because its hard to tell how your standby / turn off conditions are met and how they are triggered. </p>

<p>You may want your battery monitor program to do some type of IPC or maybe write some type of dummy file to a known directory when it needs to standby. With IPC,  you can use some type of wait() function that activates when a signal or IPC is sent to your background process. With the file method, you could sleep(), and check for that files existence every wake-up. </p>

<p>You could also easily use networking / sockets to do this as well. Listen on the loopback interface (127.0.0.1) and on a predefined port. Now wait until data comes in on that socket. When the battery monitor needs to standby, he sends a simple message via loopback to your new process. This will use effectively 0 cpu.</p>

<p>There are probably other ways as well, but I think that should give you a general idea.</p>
"
"<p>There's a <code>set_timeout</code> API in OTL that might be useful for this.</p>

<p>Edit: Actually, ignore that.  <code>set_timeout</code> doesn't work with OCI.  Have a look at the <code>set_timeout</code> description from <a href=""http://otl.sourceforge.net/otl3_connect_class.htm"" rel=""nofollow noreferrer"">here</a> where it describes a technique that can be used with OCI</p>
"
"<p>There is a manual way to avoid this. You can open a firewall and do something like ping database after every specified duration of time. In this way the database connection will not get lost. </p>

<p>idea</p>

<pre><code>If (current_time - lastPingTime &gt; configuredPingTime)
{
     //Dummy query
     select 1 from dual;
}
</code></pre>
"
"<p>In all my DB schema i have a table with one constant record. Just poll such table periodically by simple SQL request. All other methods unreliable.  </p>
"
"<p>Sounds like you need to fire off a query to the database (eg <code>SELECT * FROM dual;</code>), then if the database hasn't responded within a specified amount of time, assume the server has died and react accordingly. I'm afraid I don't know C/C++, but can you use multi-threading to fire off the statement then wait for the response, without hanging the application?</p>
"
"<p>This works - I have done exactly what you are looking for.
Have a parent process (A) create a child process (B).  The child process (B) connects to the database,
performs a query (something like ""select 1 from a_table"" - you will get better performance if you avoid using ""dual"" for this and create your own table).  If (B) is successful then it writes out that it was successful and exits.  (A) is waiting for a specified amount of time.  I used 15 seconds.  If (A) detects that (B) is still running - then it can assume that the database is hung - it Kills (B) and takes necessary actions (Like calling me on the phone with a SMS).</p>

<p>If you configure SQL*NET to use a timeout you will probably notice that large queries will fail because of it.  The OCI set_timeout configuration will also cause this.</p>
"
"<p>This is a bug in Oracle ( or call it a feature ) till 11.1.0.6 and they said the patch on Oracle 11g release 1 ( patch 11.1.0.7 ) which has the fix. Need to see that.
If it happens you will have to cancel ( kill ) the thread performing this action.
Not good approach though</p>
"
"<p>Use <a href=""http://en.cppreference.com/w/c/chrono/time"" rel=""noreferrer""><code>time()</code></a> and <a href=""http://en.cppreference.com/w/c/chrono/localtime"" rel=""noreferrer""><code>localtime()</code></a> to get the time:</p>

<pre><code>#include &lt;time.h&gt;

time_t t = time(NULL);
struct tm tm = *localtime(&amp;t);

printf(""now: %d-%d-%d %d:%d:%d\n"", tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
</code></pre>
"
"<pre><code>time_t rawtime;
time ( &amp;rawtime );
struct tm *timeinfo = localtime ( &amp;rawtime );
</code></pre>

<p>You can also use <a href=""http://www.cplusplus.com/reference/clibrary/ctime/strftime/"" rel=""nofollow noreferrer""><code>strftime</code></a> to format the time into a string.</p>
"
"<p>instead of files use pipes and if u wana use C and not C++ u can use popen like this</p>

<pre><code>#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;

FILE *fp= popen(""date +F"",""r"");
</code></pre>

<p>and use *fp as a normal file pointer with fgets and all</p>

<p>if u wana use c++ strings, fork a child, invoke the command and then pipe it to the parent.</p>

<pre><code>   #include &lt;stdlib.h&gt;
   #include &lt;iostream&gt;
   #include &lt;string&gt;
   using namespace std;

   string currentday;
   int dependPipe[2];

   pipe(dependPipe);// make the pipe

   if(fork()){//parent
           dup2(dependPipe[0],0);//convert parent's std input to pipe's output
           close(dependPipe[1]);
           getline(cin,currentday);

    } else {//child
        dup2(dependPipe[1],1);//convert child's std output to pipe's input
        close(dependPipe[0]);

        system(""date +%F"");
    }
</code></pre>

<p>// make a similar 1 for date +T but really i recommend u stick with stuff in time.h GL</p>
"
"<p>The answers given above are good CRT answers, but if you want you can also use the Win32 solution to this. It's almost identical but IMO if you're programming for Windows you might as well just use its API (dunno if you are programming in windows actually but whatever)</p>

<pre><code>char* arrDayNames[7] = {""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"", ""Thursday"", ""Friday"", ""Saturday""}; // Jeez I hope this works, I haven't done this in ages and it's hard without a compiler..
SYSTEMTIME st;
GetLocalTime(&amp;st); // Alternatively use GetSystemTime for the UTC version of the time
printf(""The current date and time are: %d/%d/%d %d:%d:%d:%d"", st.wDay, st.wMonth, st.wYear, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);
printf(""The day is: %s"", arrDayNames[st.wDayOfWeek]);
</code></pre>

<p>Anyway, this is your windows solution. Hope it'll prove helpful for you sometime!</p>
"
"<p>you can get current date and time by using predefined macros in C, like<br>
   <strong>DATE</strong>
   <strong>TIME</strong>
also you can find current date by another way. <a href=""http://c-forbeginners.blogspot.in"" rel=""nofollow"">c-forbeginners.blogspot.in</a>  to get details    </p>
"
"<p><strong>strftime</strong> (C89)</p>

<p>Martin <a href=""https://stackoverflow.com/a/1442156/895245"">mentioned it</a>, here's an example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main() {
    time_t t = time(NULL);
    struct tm *tm = localtime(&amp;t);
    char s[64];
    strftime(s, sizeof(s), ""%c"", tm);
    printf(""%s\n"", s);
}
</code></pre>

<p>Sample output:</p>

<pre><code>Thu Apr 14 22:39:03 2016
</code></pre>

<p>The <code>%c</code> specifier produces the same format as <code>ctime</code>.</p>

<p>One advantage of this function is that it returns the number of bytes written, allowing for better error control in case the generated string is too long.</p>

<p><strong>asctime and ctime</strong> (C89)</p>

<p><code>asctime</code> is a convenient way to format a <code>struct tm</code>:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main() {
    time_t t = time(NULL);
    struct tm *tm = localtime(&amp;t);
    printf(""%s\n"", asctime(tm));
}
</code></pre>

<p>Which produces a fixed output format like:</p>

<pre><code>Wed Jun 10 16:10:32 2015
</code></pre>

<p>And there is also <code>ctime()</code> which the standard says is a shortcut for:</p>

<pre><code>asctime(localtime())
</code></pre>

<p>As mentioned <a href=""https://stackoverflow.com/questions/1442116/how-to-get-date-and-time-value-in-c-program/30759067#comment1287613_1442156"">by Jonathan Leffler</a>, the format has the shortcoming of not having timezone information.</p>

<p><a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/asctime.html"" rel=""nofollow noreferrer"">POSIX 7</a> marked those functions as ""obsolescent"" so they could be removed in future versions:</p>

<blockquote>
  <p>The standard developers decided to mark the asctime() and asctime_r() functions obsolescent even though asctime() is in the ISO C standard due to the possibility of buffer overflow. The ISO C standard also provides the strftime() function which can be used to avoid these problems.</p>
</blockquote>

<p>C++ version of this question: <a href=""https://stackoverflow.com/questions/997946/how-to-get-current-time-and-date-in-c"">How to get current time and date in C++?</a></p>
"
"<p>Take a look at the <a href=""http://www.cplusplus.com/reference/clibrary/ctime/strftime/"" rel=""nofollow noreferrer"">strftime</a> function, which allows you to write the time into a char array with a format of your choice.</p>
"
"<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

/* get seconds since the Epoch */
time_t secs = time(0);

/* convert to localtime */
struct tm *local = localtime(&amp;secs);

/* and set the string */
sprintf(timeString, ""%02d:%02d:%02d"", local-&gt;tm_hour, local-&gt;tm_min, local-&gt;tm_sec);
</code></pre>

<p>The important types for dealing with time (the wall-clock type of time, not process/thread time) are <code>time_t</code> and <code>struct tm</code>.<br>
With some work you can convert between one and the other, but you have to pay attention to local time versus UTC time.</p>

<p>Peruse the <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/time.h.html"" rel=""nofollow noreferrer"">description of <code>&lt;time.h&gt;</code></a>, try the functions there until you <em>grok</em> time in C.</p>

<p>Again, pay attention to UTC time and local time.</p>
"
"<p>You're getting garbage from this code:</p>

<pre><code>time_t current_time;
struct tm * time_info;
char timeString[8];

time(&amp;current_time);
time_info = localtime(&amp;current_time);

strftime(timeString, 8, ""%H:%M:%S"", time_info);
puts(timeString);
</code></pre>

<p>Because you're not allowing space for a null terminator (\0) on the string, so when the string it printed, it doesn't know where the end is and inteprets random garbage in the next bit of memory as part of the string.</p>

<p>Change it to this:</p>

<pre><code>time_t current_time;
struct tm * time_info;
char timeString[9];  // space for ""HH:MM:SS\0""

time(&amp;current_time);
time_info = localtime(&amp;current_time);

strftime(timeString, sizeof(timeString), ""%H:%M:%S"", time_info);
puts(timeString);
</code></pre>

<p>And it'll work correctly because <a href=""http://en.cppreference.com/w/c/chrono/strftime"" rel=""nofollow noreferrer""><code>strftime()</code></a> will have enough space to add a \0.  Note that I'm using sizeof(array) to avoid the risk forgetting to change the number in both places.</p>
"
"<p>You just need to store the date/time when application started. Whenever you need to display for how long your program is running get current date/time and subtract the when application started.</p>
"
"<p>A very simple method:</p>

<pre><code>#include &lt;time.h&gt;
time_t start = time(0);

double seconds_since_start = difftime( time(0), start);
</code></pre>

<p>The main drawback to this is that you have to poll for the updates.  You'll need platform support or some other lib/framework to do this on an event basis.</p>
"
"<p>You are approaching it backwards.  Instead of having a variable you have to worry about updating every second, just initialize a variable on program start with the current time, and then whenever you need to know how many seconds have elapsed, you subtract the now current time from that initial time.  Much less overhead that way, and no need to nurse some timing related variable update.  </p>
"
"<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;windows.h&gt;
using namespace std;
void wait ( int seconds );
int main ()
{
  time_t start, end;
  double diff;
  time (&amp;start); //useful call
  for (int i=0;i&lt;10;i++) //this loop is useless, just to pass some time.
  {
  printf (""%s\n"", ctime(&amp;start));
  wait(1);
  }
  time (&amp;end);//useful call

  diff = difftime(end,start);//this will give you time spent between those two calls.
  printf(""difference in seconds=%f"",diff); //convert secs as u like
  system(""pause"");
  return 0;
}
void wait ( int seconds )
{
  clock_t endwait;
  endwait = clock () + seconds * CLOCKS_PER_SEC ;
  while (clock() &lt; endwait) {}
}
</code></pre>

<p>this should work fine on solaris/unix also, just remove win refs</p>
"
"<p>Use <a href=""http://en.cppreference.com/w/cpp/chrono"" rel=""nofollow"" title=""chrono"">std::chrono</a>.</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;iostream&gt;

int main(int argc, char *argv[])
{
   auto start_time = std::chrono::high_resolution_clock::now();
   auto current_time = std::chrono::high_resolution_clock::now();

   std::cout &lt;&lt; ""Program has been running for "" &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(current_time - start_time).count() &lt;&lt; "" seconds"" &lt;&lt; std::endl;

   return 0;
}
</code></pre>

<p>If you only need a resolution of seconds, then <a href=""http://en.cppreference.com/w/cpp/chrono/steady_clock"" rel=""nofollow"">std::steady_clock</a> should be sufficient.</p>
"
"<p>To be honest a python app set up to run at start-up will do this quickly and efficiently.  Python has amazing OS support and its rather complete.</p>

<p>Running the script will likely work, but it will be troublesome to take care and manage. I take it you will run these as frequent cron jobs?</p>
"
"<p>I believe a much saner approach would be the use of a kernel-level filesystem notify item. Such as <a href=""http://www.ibm.com/developerworks/linux/library/l-inotify.html"" rel=""nofollow noreferrer"">inotify</a>. Get also the tools <a href=""http://inotify-tools.sourceforge.net/"" rel=""nofollow noreferrer"">here</a>.</p>
"
"<p>This isn't going to work for any length of time. In production, you will have network problems and other errors which can leave a partial file in the upload directory. I also don't like the idea of a ""trailer"" file. The usual approach is to upload the file under a temporary name and then rename it after the upload completes.</p>

<p>This way, you just have to list the directory, filter the temporary names out and and if there is anything left, use it.</p>

<p>If you can't make this change, then ask your boss for a written permission to implement something which can lead to arbitrary data corruption. This is for two purposes: 1) To make them understand that this is a real problem and not something which you make up and 2) to protect yourself when it breaks ... because it will and guess who'll get all the blame?</p>
"
"<p>To get you off your feet here is a small app I wrote which takes a path and looks at the binary output of jpeg files. I never quite finished it, but it will get you started and to see the structure of python as well as some use of os..</p>

<p>I wouldnt spend to much time worrying about my code.</p>

<pre><code>import time, os, sys

#analyze() takes in a path and moves into the output_files folder, to then analyze files

def analyze(path):
    list_outputfiles = os.listdir(path + ""/output_files"")
    print list_outputfiles
    for i in range(len(list_outputfiles)):
        #print list_outputfiles[i]
        f = open(list_outputfiles[i], 'r')
        f.readlines()

#txtmaker reads the media file and writes its binary contents to a text file.

def txtmaker(c_file):
    print c_file
    os.system(""cat"" + "" "" + c_file + ""&gt;"" + "" "" + c_file +"".txt"")
    os.system(""mv *.txt output_files"")

#parser() takes in the inputed path, reads and lists all files, creates a directory, then calls txtmaker.

def parser(path):
    os.chdir(path)
    os.mkdir(path + ""/output_files"", 0777)
    list_files = os.listdir(path)
    for i in range(len(list_files)):
        if os.path.isdir(list_files[i]) == True:
            print (list_files[i], ""is a directory"")
        else:
            txtmaker(list_files[i])
    analyze(path)

def main():
    path = raw_input(""Enter the full path to the media: "")
    parser(path)


if __name__ == '__main__':

    main()
</code></pre>
"
"<p><strong><a href=""http://inotify.aiken.cz/"" rel=""nofollow"">incron</a></strong> is an ""inotify cron"" system. It consists of a daemon and a table manipulator. You can use it a similar way as the regular cron. The difference is that the inotify cron handles filesystem events rather than time periods. </p>
"
"<p>First make sure <strong><code>inotify-tools</code></strong> in installed.</p>

<p>Then use them like this:</p>

<pre><code>logOfChanges=""/tmp/changes.log.csv"" # Set your file name here.

# Lock and load
inotifywait -mrcq $DIR &gt; ""$logOfChanges"" &amp; # monitor, recursively, output CSV, be quiet.
IN_PID=$$

# Do your stuff here
...

# Kill and analyze
kill $IN_PID
cat ""$logOfChanges"" | while read entry; do
   # Split your CSV, but beware that file names may contain spaces too.
   # Just look up how to parse CSV with bash. :)
   path=...
   event=...
   ...  # Other stuff like time stamps
   # Depending on the event?
   case ""$event"" in
     SOME_EVENT) myHandlingCode path ;;
     ...
     *) myDefaultHandlingCode path ;;
done
</code></pre>

<p>Alternatively, using <code>--format</code> instead of <code>-c</code> on <code>inotifywait</code> would be an idea.</p>

<p>Just <code>man inotifywait</code> and <code>man inotifywatch</code> for more infos.</p>
"
"<p>I'm currently researching the the API for a different reason, I need to retrieve the path or location being played, and I stumbled upon this question.</p>

<p>First things first, you'll want to activate the D-Bus Service Plugin (Edit -> Plugins) which will expose the <code>org.mpris.Totem</code> service. Then on the <code>/Player</code> object and the <code>org.freedesktop.MediaPlayer</code> interface you can use the <code>PositionGet()</code> method to retrieve the current position.</p>

<p>This returns <code>totem.props.current_time</code> you were talking about.</p>

<p>Here's some code:</p>

<pre><code>import dbus

T_SERVICE_NAME = ""org.mpris.Totem""
T_OBJECT_PATH = ""/Player""
T_INTERFACE = ""org.freedesktop.MediaPlayer""

session_bus= dbus.SessionBus()

totem = session_bus.get_object(T_SERVICE_NAME, T_OBJECT_PATH)
totem_mediaplayer = dbus.Interface(totem, dbus_interface=T_INTERFACE)

print totem_mediaplayer.PositionGet()
</code></pre>

<p>As for the whole <code>org.gnome.Totem</code> service and the Get/GetAll methods, I don't understand the entire purpose of those either. Looks like it has more to do with DBus itself than Totem specifically.</p>

<p><strong>References</strong></p>

<ol>
<li><a href=""http://git.gnome.org/browse/totem/tree/src/plugins/dbusservice/dbusservice.py"" rel=""nofollow"">http://git.gnome.org/browse/totem/tree/src/plugins/dbusservice/dbusservice.py</a></li>
<li><a href=""http://developer.gnome.org/totem/stable/TotemObject.html"" rel=""nofollow"">http://developer.gnome.org/totem/stable/TotemObject.html</a></li>
</ol>
"
"<p>your code</p>

<pre><code>sc.enter(10, 1, t.timestamp, (sc,)
</code></pre>

<p>is asking to be scheduled again in 10 seconds.  If you want to be scheduled once an hour,</p>

<pre><code>sc.enter(3600, 1, t.timestamp, (sc,)
</code></pre>

<p>seems better, since an hour is 3600 seconds, not 10!</p>

<p>Also, the line</p>

<pre><code>s.enter(1, 1, t.timestamp, (s,))
</code></pre>

<p>gets a timestamp 1 second after every tweet written -- what's the point of <em>that</em>?  Just schedule the first invocation of timestamp once, outside the loop, as well as changing its periodicity from 10 seconds to 3600.</p>
"
"<p>A more portable way to do this is to get the current time as a <code>time_t</code> struct:</p>

<pre><code>time_t mytime = time((time_t*)0);
</code></pre>

<p>Retrieve a <code>struct tm</code> for this <code>time_t</code>:</p>

<pre><code>struct tm *mytm = localtime(&amp;mytime);
</code></pre>

<p>Examine the <code>tm_sec</code> member of <code>mytm</code>. Depending on your C library, there's no guarantee that the return value of <code>time()</code> is based on a number of seconds since the start of a minute.</p>
"
"<p>I believe this is what you're after. If not, my apologies. :)</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

int main() {
    char secstr[128];
    struct tm current_time;
    time_t current_secs = time(NULL);

    memset(secstr, 0, sizeof(secstr));

    localtime_r(&amp;current_secs, &amp;current_time);
    strftime(secstr, sizeof(secstr), ""%S"", &amp;current_time);

    fprintf(stdout, ""The second: %s\n"", secstr);
    return(0);
}
</code></pre>
"
"<p>The following complete program shows you how to access the seconds value:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main (int argc, char *argv[]) {
    time_t now;
    struct tm *tm;

    now = time(0);
    if ((tm = localtime (&amp;now)) == NULL) {
        printf (""Error extracting time stuff\n"");
        return 1;
    }

    printf (""%04d-%02d-%02d %02d:%02d:%02d\n"",
        tm-&gt;tm_year+1900, tm-&gt;tm_mon+1, tm-&gt;tm_mday,
        tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);

    return 0;
}
</code></pre>

<p>It outputs:</p>

<pre><code>2010-02-11 15:58:29
</code></pre>

<p>How it works is as follows.</p>

<ul>
<li>it calls <code>time()</code> to get the best approximation to the current time (usually number of seconds since the epoch but that's not actually mandated by the standard).</li>
<li>it then calls <code>localtime()</code> to convert that to a structure which contains the individual date and time fields, among other things.</li>
<li>at that point, you can just de-reference the structure to get the fields you're interested in (<code>tm_sec</code> in your case but I've shown a few of them).</li>
</ul>

<p>Keep in mind you can also use <code>gmtime()</code> instead of <code>localtime()</code> if you want Greenwich time, or UTC for those too young to remember :-).</p>
"
"<p>You need to mask out the exponent and shift the mantissa.  The file you linked to shows how: </p>

<pre><code>v = (c &amp; 0x1fff) &lt;&lt; (((c &gt;&gt; 13) &amp; 0x7) * 3);
</code></pre>

<p>You could cast something in this to a larger type to ensure that the compiler uses the size you want, but be careful not to do it to the wrong part or you'll get wrong results.  It shouldn't be necessary, anyway, but it wouldn't hurt to try:</p>

<pre><code>v = (c &amp; 0x1fff) &lt;&lt; (((c &gt;&gt; 13) &amp; 0x7) * 3L);
</code></pre>
"
"<p>I think the problem is that you set <code>tm_isdst</code> to <code>0</code>, which means <code>no DST</code>, however <code>localtime()</code> uses system-wide DST settings.</p>

<p>If you set <code>tm_isdst</code> to <code>1</code>, everything should be ok. According to <code>man mktime</code>, you can set negative value for <code>tm_isdst</code> if you are not sure about it. <code>man</code> doesn't say it explicitly but I guess in this case <code>mktime()</code> will use system settings as well, just like <code>localtime()</code>.</p>
"
"<p>You just need to create <code>n * delta_time</code> particles in <code>GenerateParticles</code>.</p>
"
"<p>You need to be careful, the naive way of creating particles will have you creating fractional particles for low values of <code>n</code> (probably not what you want).  Instead create an accumulator variable that gets summed with your <code>delta_time</code> values each frame.  Each frame check it to see how many particles you need to create that frame and subtract the appropriate amounts:</p>

<pre><code>void GenerateParticles(double delta_time) {
  accumulator += delta_time;
  while (accumulator &gt; 1.0 / particles_per_second) {
    CreateParticle(...);
    accumulator -= 1.0 / particles_per_second;
  }
}
</code></pre>

<p>Make sure you put some limiting in so that if the time delta is large you don't create a million particles all at once.</p>
"
"<p>The number of particles emitted at a frame can be computed by:</p>

<pre><code>double n = delta_time * frequency
int i = (int)n;
f = n - i;
</code></pre>

<p>Basically you can emit <code>i</code> particles.</p>

<p>The fractional part <code>f</code> can be accumulated for the later frames. When it accumulates greater than one you can emit the integral number of particles:</p>

<pre><code>f_sum += f;
if (f_sum &gt; 1.0) {
    int j = (int)f_sum;
    f_sum -= j;
    i += j;
}
</code></pre>

<p>However, the following is another interesting solution for fractional number of particle.</p>

<p>By using a pseudo random number generator (PRNG), we can use it to determine whether a particle should be emitted:</p>

<pre><code>if (f &gt;= r()) // Assumes r() is a PRNG generating a random value in [0, 1)
    i++;
</code></pre>

<p>This approach is useful when the frequency changes respect to time. And it eliminates the need of storing an additional variable.</p>

<p>Another beauty of this approach is that, the particle system will look less uniform. For example, if the frequency is 1.5 and delta time is 1, using the first approach, the frames will emit a sequence of 1, 2, 1, 2, ... particles. The second approach can break this pattern.</p>

<p>Besides, you may use of <a href=""http://en.cppreference.com/w/cpp/numeric/math/modf"" rel=""nofollow""><code>modf()</code></a> to extract the integral and fractional part of a floating point number.</p>
"
"<p>You can use <code>datetime.strftime</code> to get the time in Epoch form, using the <code>%s</code> format string:</p>

<pre><code>def expires():
    future = datetime.datetime.now() + datetime.timedelta(seconds=5*60)
    return int(future.strftime(""%s""))
</code></pre>
"
"<p>Another way is to use <a href=""http://docs.python.org/3.3/library/calendar.html#calendar.timegm"" rel=""noreferrer""><code>calendar.timegm</code></a>:</p>

<pre><code>future = datetime.datetime.utcnow() + datetime.timedelta(minutes=5)
return calendar.timegm(future.timetuple())
</code></pre>

<p>It's also more portable than <code>%s</code> flag to <code>strftime</code> (which doesn't work on Windows).</p>
"
"<p>Just found this, and its even shorter.</p>

<pre><code>import time
def expires():
    '''return a UNIX style timestamp representing 5 minutes from now'''
    return int(time.time()+300)
</code></pre>
"
"<p>The key is to ensure all the dates you are using are in the utc timezone before you start converting. See <a href=""http://pytz.sourceforge.net/"" rel=""nofollow"">http://pytz.sourceforge.net/</a> to learn how to do that properly. By normalizing to utc, you eliminate the ambiguity of daylight savings transitions. Then you can safely use timedelta to calculate distance from the unix epoch, and then convert to seconds or milliseconds.</p>

<p>Note that the resulting unix timestamp is itself in the UTC timezone. If you wish to see the timestamp in a localized timezone, you will need to make another conversion.</p>

<p>Also note that this will only work for dates after 1970.</p>

<pre><code>   import datetime
   import pytz

   UNIX_EPOCH = datetime.datetime(1970, 1, 1, 0, 0, tzinfo = pytz.utc)
   def EPOCH(utc_datetime):
      delta = utc_datetime - UNIX_EPOCH
      seconds = delta.total_seconds()
      ms = seconds * 1000
      return ms
</code></pre>
"
"<pre><code>def in_unix(input):
  start = datetime.datetime(year=1970,month=1,day=1)
  diff = input - start
  return diff.total_seconds()
</code></pre>
"
"<p>Here's a less broken <code>datetime</code>-based solution to convert from datetime object to posix timestamp:</p>

<pre><code>future = datetime.datetime.utcnow() + datetime.timedelta(minutes=5)
return (future - datetime.datetime(1970, 1, 1)).total_seconds()
</code></pre>

<p>See more details at <a href=""https://stackoverflow.com/a/8778548/4279"">Converting datetime.date to UTC timestamp in Python</a>.</p>
"
"<pre><code>def expiration_time():
    import datetime,calendar
    timestamp = calendar.timegm(datetime.datetime.now().timetuple())
    returnValue = datetime.timedelta(minutes=5).total_seconds() + timestamp
    return returnValue
</code></pre>
"
"<p><strong>Now in Python >= 3.3</strong> you can just call the <a href=""http://docs.python.org/3.3/library/datetime.html#datetime.datetime.timestamp"" rel=""noreferrer"">timestamp() method</a> to get the timestamp as a float.</p>

<pre><code>import datetime
current_time = datetime.datetime.now(datetime.timezone.utc)
unix_timestamp = current_time.timestamp() # works if Python &gt;= 3.3

unix_timestamp_plus_5_min = unix_timestamp + (5 * 60)  # 5 min * 60 seconds
</code></pre>
"
"<p>This is what you need:</p>

<pre><code>import time
import datetime
n = datetime.datetime.now()
unix_time = time.mktime(n.timetuple())
</code></pre>
"
"<p>The following is based on the answers above (plus a correction for the milliseconds) and emulates <code>datetime.timestamp()</code> for Python 3 before 3.3 when timezones are used.</p>

<pre><code>def datetime_timestamp(datetime):
    '''
    Equivalent to datetime.timestamp() for pre-3.3
    '''
    try:
        return datetime.timestamp()
    except AttributeError:
        utc_datetime = datetime.astimezone(utc)
        return timegm(utc_datetime.timetuple()) + utc_datetime.microsecond / 1e6
</code></pre>

<p>To strictly answer the question as asked, you'd want:</p>

<pre><code>datetime_timestamp(my_datetime) + 5 * 60
</code></pre>

<p><code>datetime_timestamp</code> is part of <a href=""https://github.com/andrewcooke/simple-date"" rel=""nofollow"">simple-date</a>.  But if you were using that package you'd probably type:</p>

<pre><code>SimpleDate(my_datetime).timestamp + 5 * 60
</code></pre>

<p>which handles many more formats / types for my_datetime.</p>
"
"<p>Note that solutions with <code>timedelta.total_seconds()</code> work on python-2.7+.
Use <code>calendar.timegm(future.utctimetuple())</code> for lower versions of Python.</p>
"
"<p>Assuming you're dealing with unsigned types, you can check for wrapping pretty easily -- </p>

<pre><code>if (timestamp + shifftime &lt; timestamp)
    it_wrapped();
</code></pre>
"
"<p>The question is a bit vague. One possibility is to set a flag when you first notice that the time has elapsed. A surefire way would be add a second counter which is incremented when the first counter overflows. This will in effect create a 64 bit counter which won't overflow.</p>
"
"<p>The simplest way to do this is to make an ""epoch counter"", that explicitly counts rollovers.  (Example: you have a hardware counter that counts seconds 0..59.  Your epoch counter would count minutes, by incrementing each time it noticed that the seconds counter had rolled over.)</p>

<p>Your future_scheduler function then reads the current epoch and time,and computes a new epoch and time for your event.</p>

<p>Alternatively, you could just punt, and make your timing function count your event schedules down to zero on each timer tick.</p>
"
"<p>One of the possibilities is to cast both variables to 64-bit long and then do sum. After that compare with maximum 32-bit value to identify if it's wrapped.</p>
"
"<p>As you are embedded, you may have access to a CPU overflow bit.  This would be set when an add overflows it's register.  Useful for add AddCarry chaining.</p>
"
"<p>If you take two timestamp readings and your first reading is <em>greater</em> than the second, then your counter has wrapped.  That is the basic way to detect a wrapping counter.</p>

<p>This, however, won't detect if a counter has wrapped multiple times, or the case where a counter has wrapped and happens to be greater than the first reading.  Since you said this was an embedded system and your description makes your ""counter"" sound like a clock, see if you can set an interrupt to fire whenever the clock reaches zero (so that you will get an interrupt every time the clock resets).  When this interrupt fires, increment a separate counter.  This should effectively add extra precision to your clock and allow your counter to wrap without causing problems.</p>
"
"<p>It will not matter so long as the difference between the start and end count is less than (2^32)/2, and assuming 2's complement 32bit arithmetic is performed (almost universally true), even if the count value spans the wrap-point.  For example:</p>

<pre><code>Start count: 0xfffffff
End Count:   0x00000002 (incremented through 0,1,2 - i.e. three counts)

End - Start == 0x00000002 - 0xfffffff == 0x00000003
</code></pre>

<p>So the right answer is achieved so long as the counter is the bit width of a built-in integer type, and that type is used.  Where perhaps a counter register is not the width of a built-in integer type, you can achieve the same effect by masking the higher order ""overflow"" bits.</p>

<p>If you need the larger count for other reasons or if the difference between successive timestamps is too large, then you can simply use another integer that is incremented when the lower-order counter wraps.  This integer will form the high order bits of a larger integer, so the LSB of the second integer is the 33rd bit of this larger integer.</p>
"
"<p>Cast the result of unsigned subtraction to signed and compare to zero.  Should handle overflow when you check it often enough (and your timeout is less than half the range of your timer).</p>

<pre><code>uint32_t timer( void);             // Returns the current time value
uint32_t timeout;

timeout = timer() + offset;

// wait until timer() reaches or exceeds timeout value
while ((int32_t)(timeout - timer()) &gt; 0);
</code></pre>
"
"<p>If you use unsigned variables to store your counter and timer expiry time, then you can simply use this test:</p>

<pre><code>if (current_time - expiry_time &lt; 0x80000000UL)
    /* timer has expired */
</code></pre>

<p>This assumes that you test for expiry at least once every 0x80000000 ticks, and that your longest timer is set to expire less than 0x80000000 ticks into the future.</p>
"
"<p>I think one of the easiest ways to do this, would be to have another counter (lets call it Wrap counter, let this be a static global for the timer module), count up each time your original 32 bits counter wrapped. </p>

<p>In the function where your counter is ticking away, everytime this counter reaches its maximum count, you have your Wrap counter increment.
So when you are reading the function which returns whether or not the timer has elapsed, you also read the Wrap counter, to check how many times it wrapped over. The important thing is, to also do this: everytime you read the wrap counter, you want to clear it, for your next reading. </p>
"
"<p>lets assume the counter counts down (many count down to save on gates in the logic).</p>

<p>you need to first know the period of time it takes to get to 2^32 ticks and need to insure that you are well oversampling that.</p>

<p>If you want to find the time period between two events, say start and end</p>

<p>start = read timer
lasttime = start
rollover = 0</p>

<p>while waiting for thing to happen</p>

<p>nowtime = read timer
if(nowtime>lasttime) rollover+=1  (this is a down counter)
lasttime = nowtime</p>

<p>event happens:
end = read timer</p>

<p>total time = start - end (this is a down counter and note that this math works even when rolling over)</p>

<p>total time =  total time/ scaling factor to get from ticks to seconds, minutes, whatever
total time += rollover * seconds/minutes/whatever per 2^32 counts</p>

<p>if you have an up counter then nowtime

<p>If you can guarantee that your event will happen within 2^32 counts you dont need to do the rollover now time last time thing you only need start and end and the total ticks = start - end will work even if the counter rolls from 0x00000000 to 0xFFFFFFFF between start and end.</p>
"
"<p>See <a href=""http://en.cppreference.com/w/cpp/chrono/c/clock"" rel=""nofollow noreferrer""><code>std::clock()</code></a> &nbsp;&nbsp;&nbsp;</p>
"
"<p>This isn't C++ specific (nor portable), but you can do:</p>

<pre><code>SYSTEMTIME systemDT;
</code></pre>

<p>In Windows.</p>

<p>From there, you can access each member of the systemDT <code>struct</code>. </p>

<p>You can record the time when the program started and compare the current time to the recorded time (<code>systemDT</code> versus <code>systemDTtemp</code>, for instance).</p>

<p>To refresh, you can call <code>GetLocalTime(&amp;systemDT);</code></p>

<p>To access each member, you would do <code>systemDT.wHour</code>, <code>systemDT.wMinute</code>, <code>systemDT.wMilliseconds</code>.</p>

<p>To get more information on <a href=""http://msdn.microsoft.com/en-us/library/ms724950%28VS.85%29.aspx"" rel=""nofollow noreferrer"">SYSTEMTIME</a>.</p>
"
"<p>Include time.h, and then use the clock() function. It returns the number of clock ticks elapsed since the program was launched. Just divide it by ""CLOCKS_PER_SEC"" to obtain the number of seconds, you can then multiply by 1000 to obtain the number of milliseconds.</p>
"
"<p>Some cross platform solution. This code was used for some kind of benchmarking:</p>

<pre><code>#ifdef WIN32
  LARGE_INTEGER g_llFrequency = {0};
  BOOL g_bQueryResult = QueryPerformanceFrequency(&g_llFrequency);
#endif

//...

long long osQueryPerfomance()
{
#ifdef WIN32
  LARGE_INTEGER llPerf = {0};
  QueryPerformanceCounter(&llPerf);
  return llPerf.QuadPart * 1000ll / ( g_llFrequency.QuadPart / 1000ll);
#else
  struct timeval stTimeVal;
  gettimeofday(&stTimeVal, NULL);
  return stTimeVal.tv_sec * 1000000ll + stTimeVal.tv_usec;
#endif
}
</code></pre>
"
"<p>Do you want wall clock time, CPU time, or some other measurement?  Also, what platform is this?  There is no universally portable way to get more precision than <code>time()</code> and <code>clock()</code> give you, but...</p>

<ul>
<li>on most Unix systems, you can use <a href=""http://www.opengroup.org/onlinepubs/000095399/functions/gettimeofday.html"" rel=""nofollow noreferrer""><code>gettimeofday()</code></a> and/or <a href=""http://www.opengroup.org/onlinepubs/000095399/functions/clock_gettime.html"" rel=""nofollow noreferrer""><code>clock_gettime()</code></a>, which give at least microsecond precision and access to a variety of timers;</li>
<li>I'm not nearly as familiar with Windows, but one of <a href=""http://msdn.microsoft.com/en-us/library/ms725473%28v=VS.85%29.aspx"" rel=""nofollow noreferrer"">these functions</a> probably does what you want.</li>
</ul>
"
"<p>The most portable way is using the  <em>clock</em> function.It usually reports the time that your program has been using the processor, or an approximation thereof. Note however the following:</p>

<ul>
<li><p>The resolution is not very good for GNU systems. That's really a pity.</p></li>
<li><p>Take care of casting everything to <em>double</em> before doing divisions and assignations.</p></li>
<li><p>The counter is held as a 32 bit number in GNU 32 bits, which can be pretty annoying for long-running programs. </p></li>
</ul>

<p>There are alternatives using ""wall time"" which give better resolution, both in Windows and Linux. But as the libc manual states: <em>If you're trying to optimize your program or measure its efficiency, it's very useful to know how much processor time it uses. For that, calendar time and elapsed times are useless because a process may spend time waiting for I/O or for other processes to use the CPU.</em></p>
"
"<p><code>clock</code> has been suggested a number of times. This has two problems. First of all, it often doesn't have a resolution even close to a millisecond (10-20 ms is probably more common). Second, some implementations of it (e.g., Unix and similar) return CPU time, while others (E.g., Windows) return wall time.</p>

<p>You haven't really said whether you want wall time or CPU time, which makes it hard to give a really good answer. On Windows, you could use <a href=""http://msdn.microsoft.com/en-us/library/ms683223(VS.85).aspx"" rel=""noreferrer""><code>GetProcessTimes</code></a>. That will give you the kernel and user CPU times directly. It will also tell you when the process was created, so if you want milliseconds of wall time since process creation, you can subtract the process creation time from the current time (<a href=""http://msdn.microsoft.com/en-us/library/ms683223(VS.85).aspx"" rel=""noreferrer""><code>GetSystemTime</code></a>). <a href=""http://msdn.microsoft.com/en-us/library/ms644904(VS.85).aspx"" rel=""noreferrer""><code>QueryPerformanceCounter</code></a> has also been mentioned. This has a few oddities of its own -- for example, in some implementations it retrieves time from the CPUs cycle counter, so its frequency varies when/if the CPU speed changes. Other implementations read from the motherboard's 1.024 MHz timer, which does <em>not</em> vary with the CPU speed (and the conditions under which each are used aren't entirely obvious).</p>

<p>On Unix, you can use <a href=""http://www.manpagez.com/man/2/gettimeofday/"" rel=""noreferrer""><code>GetTimeOfDay</code></a> to just get the wall time with (at least the possibility of) relatively high precision. If you want time for a process, you can use <a href=""http://www.manpagez.com/man/3/times/"" rel=""noreferrer""><code>times</code></a> or <a href=""http://www.manpagez.com/man/2/getrusage/"" rel=""noreferrer""><code>getrusage</code></a> (the latter is newer and gives more complete information that may also be more precise).</p>

<p>Bottom line: as I said in my comment, there's no way to get what you want portably. Since you haven't said whether you want CPU time or wall time, even for a specific system, there's not one right answer. The one you've ""accepted"" (<code>clock()</code>) has the virtue of being <em>available</em> on essentially any system, but what it returns also varies just about the most widely.</p>
"
"<p>Here is a C++0x solution and an example why <code>clock()</code> might not do what you think it does.</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;

int main()
{
   auto start1 = std::chrono::monotonic_clock::now();
   auto start2 = std::clock();

   sleep(1);

   for( int i=0; i&lt;100000000; ++i);

   auto end1 = std::chrono::monotonic_clock::now();
   auto end2 = std::clock();

   auto delta1 = end1-start1;
   auto delta2 = end2-start2;

   std::cout &lt;&lt; ""chrono: "" &lt;&lt; std::chrono::duration_cast&lt;std::chrono::duration&lt;float&gt;&gt;(delta1).count() &lt;&lt; std::endl;

   std::cout &lt;&lt; ""clock: "" &lt;&lt; static_cast&lt;float&gt;(delta2)/CLOCKS_PER_SEC &lt;&lt; std::endl;
}
</code></pre>

<p>On my system this outputs:</p>

<pre><code>chrono: 1.36839
clock: 0.36
</code></pre>

<p>You'll notice the <code>clock()</code> method is missing a second.  An astute observer might also notice that <code>clock()</code> looks to have less resolution.  On my system it's ticking by in <strong>12 millisecond</strong> increments, terrible resolution.</p>

<p>If you are unable or unwilling to use C++0x, take a look at <a href=""http://www.boost.org/doc/libs/1_43_0/doc/html/date_time.html"" rel=""nofollow noreferrer"">Boost.DateTime</a>'s <code>ptime microsec_clock::universal_time()</code>.</p>
"
"<p>You can try this code (get from StockFish chess engine source code (GPL)):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdio&gt;

#if !defined(_WIN32) &amp;&amp; !defined(_WIN64) // Linux - Unix
    #  include &lt;sys/time.h&gt;
    typedef timeval sys_time_t;
    inline void system_time(sys_time_t* t) {
        gettimeofday(t, NULL);
    }
    inline long long time_to_msec(const sys_time_t&amp; t) {
        return t.tv_sec * 1000LL + t.tv_usec / 1000;
    }
    #else // Windows and MinGW
    #  include &lt;sys/timeb.h&gt;
    typedef _timeb sys_time_t;
    inline void system_time(sys_time_t* t) { _ftime(t); }
    inline long long time_to_msec(const sys_time_t&amp; t) {
        return t.time * 1000LL + t.millitm;
    }
#endif

struct Time {
    void restart() { system_time(&amp;t); }
    uint64_t msec() const { return time_to_msec(t); }
    long long elapsed() const {
        return long long(current_time().msec() - time_to_msec(t));
    }
    static Time current_time() { Time t; t.restart(); return t; }
private:
    sys_time_t t;
};

int main() {
    sys_time_t t;
    system_time(&amp;t);
    long long currentTimeMs = time_to_msec(t);
    std::cout &lt;&lt; ""currentTimeMs:"" &lt;&lt; currentTimeMs &lt;&lt; std::endl;

    Time time = Time::current_time();
    for (int i = 0; i &lt; 1000000; i++) {
        //Do something
    }
    long long e = time.elapsed();
    std::cout &lt;&lt; ""time elapsed:"" &lt;&lt; e &lt;&lt; std::endl;

    getchar();  // wait for keyboard input
}
</code></pre>
"
"<p>The simplest is  </p>

<pre><code>#include &lt;time.h&gt;
//...
time_t current_time = time (NULL);
struct tm* local_time = localtime (&amp;current_time);
printf (""the time is %s\n"", asctime (local_time));
</code></pre>
"
"<p>Just about the <em>only</em> way (that's standard, anyway) is to call <code>time</code> followed by <code>localtime</code> or <code>gmtime</code>.</p>
"
"<p>well, in general, directly accessing the OS's API to get the time is probably the most efficient,  but not so portable.....</p>

<p>the C time functions are ok.    </p>

<p>But really depends on your platform </p>
"
"<pre><code>/* ctime example */
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main ()
{
  time_t rawtime;

  time ( &amp;rawtime );
  printf ( ""The current local time is: %s"", ctime (&amp;rawtime) );

  return 0;
}
</code></pre>

<p>You can use <a href=""http://www.cplusplus.com/reference/clibrary/ctime/ctime/"" rel=""noreferrer"">ctime</a>, if you need it as a string.</p>
"
"<p>It really depends on what you mean by ""many"" :-)</p>

<p>I think you'll probably find that using the ISO standard <code>time()</code> and <code>localtime()</code> functions will be more than fast enough. For example, on my <code>""Intel(R) Core(TM)2 Duo CPU E6850 @ 3.00GHz""</code>, using unoptimised code, I can call <code>time()</code> ten million times in 1.045 seconds, and a <code>time()/localtime()</code> combination half a million times in 0.98 seconds. Whether that's fast enough for your needs, only you can decide, but I'm hard-pressed trying to come up with a use case that needs more grunt than that.</p>

<p>The <code>time()</code> function gives you the number of seconds since the epoch, while <code>localtime()</code> both converts it to local time (from UTC) and splits it into a more usable form, the <code>struct tm</code> structure.</p>

<pre><code>#include &lt;time.h&gt;
time_t t = time (NULL);
struct tm* lt = localtime (&amp;t);
// Use lt-&gt;tm_year, lt-&gt;tm_mday, and so forth.
</code></pre>

<p>Any attempt to cache the date/time and use other ways of finding out a delta to apply to it, such as with <code>clock()</code>, will almost invariably:</p>

<ul>
<li>be slower; and</li>
<li>suffer from the fact you won't pick up external time changes.</li>
</ul>
"
"<p>Standard C provides only one way to get the time - <code>time()</code> - which can be converted to a time/date/year with <code>localtime()</code> or <code>gmtime()</code>.  So trivially, that must be the most efficient way.</p>

<p>Any other methods are operating-system specific, and you haven't told us what operating system you're using.</p>
"
"<p>You can use gettimeofday() function to get time in seconds &amp; microseconds which is (I think) very fast (as there is a similar function in Linux kernel do_gettimeofday()) and then you can convert it to your required format (might possible to use functions mentioned above for conversion. </p>

<p>I hope this helps.</p>
"
"<p>Assuming a one second resolution is enough, the most efficient way on FreeBSD (or any POSIX system) is likely</p>

<ul>
<li>Install a one second interval timer with <code>setitimer (ITIMER_REAL, ...)</code></li>
<li>When it triggers the <code>SIGALRM</code>, update a static variable holding the currrent time</li>
<li>Use the value in the static variable whenever you need the time</li>
</ul>

<p>Even if signals get lost due to system overload this will correct itself the next time the process is scheduled.</p>
"
"<p>In order to make it accurate, there are two possibilities: </p>

<p>Using framerate from the streaming server. In this case, the client needs to keep the same framerate (calculate each time when you get frame, then show and sleep for a variable amount of time using feedback: if the calculated framerate is higher than on server -> sleep more; if lower -> sleep less; then, the framerate on the client side will drift around the original value from server). It can be received from server during the initialization of streaming connection (when you get picture size and other parameters) or it can be configured.</p>

<p>The most accurate approach, actually, is using of timestamps from server per each frame (which is either taken from file by demuxer or generated in image sensor driver in case of camera device). If MJPEG is packeted into RTP stream, these timestamps are already in RTP header. So, client's task is trivial: show picture using time calculating from time offset, current timestamp and time base.</p>

<p><strong>Update</strong>
For the first solution:</p>

<pre><code>time_to_sleep = time_to_sleep_base = 1/framerate;
number_of_frames = 0;
time = current_time();
while (1)
{
     get_image();
     show_image();
     sleep (time_to_sleep);

     /* update time to sleep */
     number_of_frames++;
     cur_time = current_time();
     cur_framerate = number_of_frames/(cur_time - time);
     if (cur_framerate &gt; framerate)
         time_to_sleep += alpha*time_to_sleep;
     else
         time_to_sleep -= alpha*time_to_sleep;
     time = cur_time;
}
</code></pre>

<p>, where alpha is a constant parameter of reactivity of the feedback (0.1..0.5) to play with. </p>

<p>However, it's better to organize queue for input images to make the process of showing smoother. The size of queue can be parametrized and could be somewhere around 1 sec time of showing, i.e. numerically equal to framerate.</p>
"
"<p>I don't know specifically using PyGTK but: <code>xdg-open</code> opens the default app for a file so running something like this should work:</p>

<pre><code>import os
os.system('xdg-open ./img.jpg')
</code></pre>

<p><strong>EDIT:</strong> I'd suggest using the <code>subprocess</code> module as in the comments. I'm not sure exactly how to use it yet so I just used <code>os.system</code> in the example to show <code>xdg-open</code>. </p>
"
"<p>GTK (>= 2.14) has <a href=""http://www.pygtk.org/docs/pygtk/class-gtkmountoperation.html#function-gtk--show-uri"" rel=""nofollow noreferrer"">gtk_show_uri</a>:</p>

<pre><code>gtk.show_uri(screen, uri, timestamp)
</code></pre>

<p>Example usage:</p>

<pre><code>gtk.show_uri(None, ""file:///etc/passwd"", gtk.gdk.CURRENT_TIME)
</code></pre>

<p><strong>Related</strong></p>

<ul>
<li><a href=""https://stackoverflow.com/questions/1679798/how-to-open-a-file-with-the-standard-application"">How to open a file with the standard application?</a></li>
</ul>
"
"<p>In GNU/Linux use <code>xdg-open</code>, in Mac use <code>open</code>, in Windows use <code>start</code>. Also, use <code>subprocess</code>, if not you risk to block your application when you call the external app.</p>

<p>This is my implementation, hope it helps: <a href=""http://goo.gl/xebnV"" rel=""nofollow"">http://goo.gl/xebnV</a></p>

<pre><code>import sys
import subprocess
import webbrowser

def default_open(something_to_open):
    """"""
    Open given file with default user program.
    """"""
    # Check if URL
    if something_to_open.startswith('http') or something_to_open.endswith('.html'):
        webbrowser.open(something_to_open)
        return 0

    ret_code = 0

    if sys.platform.startswith('linux'):
        ret_code = subprocess.call(['xdg-open', something_to_open])

    elif sys.platform.startswith('darwin'):
        ret_code = subprocess.call(['open', something_to_open])

    elif sys.platform.startswith('win'):
        ret_code = subprocess.call(['start', something_to_open], shell=True)

    return ret_code
</code></pre>
"
"<p>The <a href=""http://www.sqlite.org/lang_datefunc.html"" rel=""noreferrer"">docs</a> mention this method:</p>

<pre><code>SELECT strftime('%s', 'now');
1284248196
</code></pre>

<p>And this one which includes the fractional part:</p>

<pre><code>SELECT (julianday('now') - 2440587.5) * 86400.0;
1284248196.65098
</code></pre>

<p>Both represent <a href=""http://en.wikipedia.org/wiki/Unix_time"" rel=""noreferrer"">Unix Time</a>, the number of seconds passed since January 1, 1970.</p>
"
"<p>This can be done like so</p>

<pre><code>#include &lt;ctime&gt;
/*
your function here
*/

    int main()
    {
        double TimeToRunInSecs = ...;
        clock_t c = clock();
        while(double(clock()-c)/CLOCKS_PER_SEC &lt; TimeToRunInSecs)
       {
          myFunc();
       }
    }
</code></pre>

<p>the standard clock() function returns number of SOMETHING from the process start. In one second there are CLOCK_PER_SEC SOMETHINGs :)</p>

<p>HTH</p>
"
"<p>I could do a</p>

<p><code>time_t current_time = time(0);</code></p>

<p>and measure off of that ... but is there a preferred way ... mainly this is a best practices kind of question ....</p>

<p>x</p>
"
"<p>So is it something like this you want? This will repeatedly call myfunc() for the next 20 seconds. So could do 1 call (if myfunc takes at least 20 seconds to run) or hundreds of calls (of myfunc() takes a few milliseconds to complete):</p>

<pre><code>#include &lt;time.h&gt;

void myfunc()
{
    /* do something */
}

int main()
{
    time_t start = time(NULL);
    time_t now = time(NULL);
    while ((now - start) &lt;= 20) {
        myfunc();
        time_t now = time(NULL);
    }
}
</code></pre>

<p>It's probably worth asking what you're ultimately trying to achieve. If this is for profiling (e.g., what's the average amount of time function f takes to execute), then you might want to look at other solutions - e.g., using the built-in profiling that gcc gives you (when building code with the ""-pg"" option), and analyzing with gprof.</p>
"
"<p>Couple of things..</p>

<p>If you want to ensure that the function takes a Time X to complete, irrespective of how long the actual code within the function took, do something like this (highly pseudo code)</p>

<pre><code>class Delay
{
  public:
    Delay(long long delay) : _delay(delay) // in microseconds
    {
       ::gettimeofday(_start, NULL); // grab the start time...
    }

    ~Delay()
    {
      struct timeval end;

      ::gettimeofday(end, NULL); // grab the end time
      long long ts = _start.tv_sec * 1000000 + _start.tv_usec;
      long long tse = end.tv_sec * 1000000 + end.tv_usec;

      long long diff = tse - ts;
      if (diff &lt; _delay)
      {
        // need to sleep for the difference...
        // do this using select;
        // construct a struct timeval (same as required for gettimeofday)
        fd_set rfds;
        struct timeval tv;
        int retval;

        FD_ZERO(&amp;rfds);

        diff = _delay - diff; // calculate the time to sleep

        tv.tv_sec = diff / 1000000;
        tv.tv_usec = diff % 1000000;

        retval = select(0, &amp;rfds, NULL, NULL, &amp;tv);
        // should only get here when this times out...
      }
    }
  private:
    struct timeval _start;
};
</code></pre>

<p>Then define an instance of this Delay class at the top of your function to delay - should do the trick... (this code is untested and could have bugs in it, I just typed it to give you an idea..)</p>
"
"<p>This works for me:</p>

<pre><code>#include &lt;sys/time.h&gt;

static struct timeval tv_s, tv_e;

static void timer_start()
{
   gettimeofday( &amp;tv_s, NULL );
}

static unsigned long timer_stop()
{
   gettimeofday( &amp;tv_e, NULL );
   return (tv_e.tv_sec - tv_s.tv_sec ) * 1000000ul
      + ( tv_e.tv_usec - tv_s.tv_usec );
}
</code></pre>
"
"<p>Have you read the Boost.Asio asynchronous <a href=""http://www.boost.org/doc/libs/1_44_0/doc/html/boost_asio/tutorial/tuttimer2.html"" rel=""nofollow"">deadline timer tutorial</a>? It's fairly trivial to add <a href=""http://www.boost.org/doc/libs/1_44_0/doc/html/boost_asio/overview/core/threads.html"" rel=""nofollow"">multiple threads</a> by creating a thread pool to invoke <code>io_service::run</code>.</p>

<blockquote>
  <p>Multiple threads may call
  io_service::run() to set up a pool of
  threads from which completion handlers
  may be invoked. This approach may also
  be used with io_service::post() to use
  a means to perform any computational
  tasks across a thread pool.</p>

  <p>Note that all threads that have joined
  an io_service's pool are considered
  equivalent, and the io_service may
  distribute work across them in an
  arbitrary fashion.</p>
</blockquote>
"
"<p>You nearly have it, because you're creating a new thread to handle <code>io_service::run()</code>, your main thread will not block. Two things you need to do, </p>

<ol>
<li>ensure you call <code>Start()</code> before you <code>Initialize()</code> (using the same io_service instance), this way there is something for the io_service to do, else it will quit!</li>
<li>On your <code>HandleTimer()</code> method, call <code>async_wait</code> again to queue up the next tick, else io_service will quit as it has nothing to do..</li>
</ol>
"
"<p>What you want is something like <a href=""http://en.wikipedia.org/wiki/Select_%28Unix%29"" rel=""nofollow"">select(2)</a>, depending on the OS you are targeting.</p>
"
"<p>It sounds like you need a 'monitor', capable of signaling availability of resource to threads via a shared mutex (typically). In Boost.Thread a <a href=""http://www.boost.org/doc/libs/1_45_0/doc/html/thread/synchronization.html#thread.synchronization.condvar_ref"" rel=""nofollow"">condition_variable</a> could do the job.</p>
"
"<p>You might want to look at <a href=""http://www.boost.org/doc/libs/1_39_0/doc/html/thread/synchronization.html"" rel=""nofollow"">timed locks</a>: Your blocking method can aquire the lock before starting to wait and release it as soon as the data is availabe. You can then try to acquire the lock (with a timeout) in your timed wait method.</p>
"
"<p>Encapsulate the blocking call in a separate thread. Have an intermediate message buffer in that thread that is guarded by a condition variable (as said before). Make your main thread timed-wait on that condition variable. Receive the intermediately stored message if the condition is met.</p>

<p>So basically put a new layer capable of timed-wait between the API and your application. Adapter pattern.</p>
"
"<p>You could use <code>sigaction(2)</code> and <code>alarm(2)</code>, which are both POSIX.  You set a callback action for the timeout using sigaction, then you set a timer using alarm, then make your blocking call.  The blocking call will be interrupted if it does not complete within your chosen timeout (in seconds; if you need finer granularity you can use <code>setitimer(2)</code>).</p>

<p>Note that signals in C are somewhat hairy, and there are fairly onerous restriction on what you can do in your signal handler.</p>

<p>This page is useful and fairly concise:
<a href=""http://www.gnu.org/s/libc/manual/html_node/Setting-an-Alarm.html"" rel=""nofollow"">http://www.gnu.org/s/libc/manual/html_node/Setting-an-Alarm.html</a></p>
"
"<p>The return type for total_microseconds() is <code>tick_type</code>, not long.  Looks like you're compiling this with a compiler that has a 32-bit long type.  Much to small to store 40 years worth of microseconds.</p>
"
"<p>This seems to be a problem with the microseconds() not be ing able to handle such a large microseconds input. The following snippit is a fix to this problem:</p>

<pre><code>#define MICROSEC 1000000

uint64_t sec_epoch = microsec_since_epoch / MICROSEC;
uint64_t mod_micro_epoch= microsec_since_epoch % MICROSEC;

ptime new_method = UNIX_EPOCH  + seconds(sec_epoch) + microseconds(mod_micro_epoch);

std::cout &lt;&lt; ""Deserialization with new method: "" &lt;&lt; new_method &lt;&lt; std::endl;
</code></pre>
"
"<p>Use the <code>gmtime</code> or <code>localtime</code> and <code>strftime</code> functions.</p>
"
"<p>Use <code>gmtime(3)</code> or <code>localtime(3)</code> to convert it into a <code>struct tm</code>
(Or, better, the reentrant versions <code>gmtime_r</code> or <code>localtime_r</code>), and
then use <code>strftime(3)</code> to turn it into a string. For example, if you
want the output in UTC:</p>

<pre><code>struct tm tm;
char buf[9];
gmtime_r(&amp;my_time_t, &amp;tm);
strftime(buf, sizeof(buf), ""%Y%m%d"", tm);
printf(""The date is: %s\n"", buf);
</code></pre>
"
"<pre><code>void function ()
{
    time_t     current_time;
    struct tm *struct_time;

    time( &amp;current_time);

    struct_time = gmtime( &amp;current_time);

    /* Now, you can get the ISO date by
     * YYYY 'struct_time-&gt;tm_year+1900'
     * MM 'struct_time-&gt;tm_mon+1'
     * DD 'struct_time-&gt;tm_mday' */
}
</code></pre>

<p>Please look inside 'struct tm' structure.</p>
"
"<p>The following worked for me :</p>

<pre><code>int iso_date_from_time_t ( const time_t &amp; in_time_t_ )
{
     tm temp_this_tm_;

     { // the following to set local dst fields of struct tm ?
         time_t tvsec_ = time(NULL);
         localtime_r ( &amp; tvsec_, &amp; temp_this_tm_ ) ;
     }
     localtime_r ( &amp; in_time_t, &amp; temp_this_tm_ ) ;

     return ( ( ( ( 1900 + temp_this_tm_.tm_year ) * 100 + ( 1 + temp_this_tm_.tm_mon ) ) * 100 ) + temp_this_tm_.tm_mday ) ;
}
</code></pre>

<p>Thanks for your assistance.</p>
"
"<p>Same. It's all O(1), and clock time is negligible. You're basically accessing the memory address.</p>
"
"<p>Simple index operations compile to the same machine code on every compiler I've ever touched. By index is usually recommended for readability. </p>

<p>More complex cases that involve different logic for pointer access vs array indexing need to be examined on a case-by-case basis. If you are in doubt, profile your code - as always.  </p>
"
"<p>It's completely system-dependent which one is faster, but the two are functionally equivalent to one another and I'd be really surprised if one actually was faster.  That is, the code</p>

<pre><code>myArr[index]
</code></pre>

<p>Is completely equivalent to</p>

<pre><code>*(&amp;myArr[0] + index)
</code></pre>

<p>Similarly, writing</p>

<pre><code>*ptr
</code></pre>

<p>Is equivalent to writing</p>

<pre><code>ptr[0]
</code></pre>

<p>Most compilers are smart enough to figure this out, so I'd be amazed if one was faster than another.</p>

<p>More importantly, though, you probably shouldn't be too worried about this.  Worry about optimizations after you have everything else working.  If you find that array accesses really are killing you, then consider finding a faster alternative.  Otherwise, don't worry about it; it's infinitely more valuable to have clean, readable, maintainable code than it is to have optimized code unless you have a pressing need for optimization.</p>
"
"<p>At the lowest level, these operations mostly tend to compile to the same thing. If you're <em>really</em> interested, you should get your C compiler to generate assembly output (such as with <code>gcc -S</code>) so you can check, especially since it depends, at a bare minimum, on:</p>

<ul>
<li>your target platform.</li>
<li>your compiler.</li>
<li>your optimisation level.</li>
</ul>

<p>You'll find that, even if there <em>was</em> a difference (which is doubtful), that level of micro-optimisation is mostly not worth the effort you put into it. You're better off doing macro-optimisations such as improved algorithms since that's the sort of thing that offers more return on investment.</p>

<p>In these sorts of situations, where the effect is likely to be minimal, I always optimise for <em>readability.</em></p>
"
"<p>There's no meaningful answer to your question. Language-level operations have no specific ""speed"" associated to them. By themselves, they can't be ""faster"" or ""slower"". </p>

<p>Only CPU instructions can be faster or slower and only CPU instructions can consume CPU cycles. In order to somehow carry over this concept of ""speed"" from CPU instructions back to language-level operations [these CPU instructions were generated from] in general case you'll need to know the context. This is so because the same language-level operation can generate totally different CPU instructions in different contexts (not even mentioning that it might also depend on the compiler settings etc.)</p>

<p>In other words, post the actual code. As an abstract context-less question it simply makes no sense.</p>
"
"<p>When accessing an array through an index, you are actually performing two operations: an <em>addition</em> (adding the index to the base array address), then a <em>memory access</em> (actually reading or writing what is at the resulting address). I suppose that when you are talking about ""accessing by pointer"" then you mean that you already have the pointer to the target element. So, logically, using the pointer saves the ""addition"" part, and thus should be faster, or at least no slower.</p>

<p>However...</p>

<p>As a rough approximation, in a modern computer, the memory access is much more expensive than an addition (especially if it falls out of the caches), so the difference, if any, will be slight. On some architectures (e.g. x86 or PowerPC), the addition and memory access can be combined into a single opcode. Things will also be different, depending on whether the array address is a compile-time constant (i.e. the array is not constant data, but is declared as a global variable, <em>vs</em> a block obtained with <code>malloc()</code>). Using an array may help the compiler find better code, with regards to a generic pointer (in particular when the <code>restrict</code> keyword is used). The context has a huge influence (e.g. how many free registers there are at that point ?).</p>

<p>So:</p>

<ul>
<li>There is no absolute answer to your question. You have to try and make measures.</li>
<li>If there is a detectable difference (chances are that there will be none), it is hard to predict in which direction, and it depends on a huge set of external factors, including the specific compiler version and optimization flags, processor architecture and model, memory layout and so on.</li>
<li>You will not be able to make any reliable optimization gain without having some rather in-depth knowledge of assembly, and a bit of theory of compilation.</li>
<li>You should concentrate on making a <em>correct</em> code first, and then only worry about optimization; and there is no performance issue until it has been duly measured in realistic conditions.</li>
</ul>
"
"<p>templatetypedef has summed it up.  To add some support to his response.  Take these example functions:</p>

<pre>
unsigned int fun1 ( unsigned int *x )
{
    unsigned int ra,rb;

    rb=0;
    for(ra=0;ra&lt;1000;ra++) rb+=*x++;
    return(rb);
}

unsigned int fun2 ( unsigned int *x )
{
    unsigned int ra,rb;
    rb=0;
    for(ra=0;ra&lt;1000;ra++) rb+=x[ra];
    return(rb);
}
</pre>

<p>Now gcc produced this:</p>

<pre>
00000000 fun1:
   0:   e52d4004    push    {r4}        ; (str r4, [sp, #-4]!)
   4:   e1a03000    mov r3, r0
   8:   e2804efa    add r4, r0, #4000   ; 0xfa0
   c:   e3a00000    mov r0, #0
  10:   e1a02003    mov r2, r3
  14:   e492c004    ldr ip, [r2], #4
  18:   e5931004    ldr r1, [r3, #4]
  1c:   e2823004    add r3, r2, #4
  20:   e080000c    add r0, r0, ip
  24:   e1530004    cmp r3, r4
  28:   e0800001    add r0, r0, r1
  2c:   1afffff7    bne 10
  30:   e49d4004    pop {r4}        ; (ldr r4, [sp], #4)
  34:   e12fff1e    bx  lr

00000038 fun2:
  38:   e3a03000    mov r3, #0
  3c:   e1a02003    mov r2, r3
  40:   e790c003    ldr ip, [r0, r3]
  44:   e2833004    add r3, r3, #4
  48:   e7901003    ldr r1, [r0, r3]
  4c:   e2833004    add r3, r3, #4
  50:   e082200c    add r2, r2, ip
  54:   e3530efa    cmp r3, #4000   ; 0xfa0
  58:   e0822001    add r2, r2, r1
  5c:   1afffff7    bne 40
  60:   e1a00002    mov r0, r2
  64:   e12fff1e    bx  lr
</pre>

<p>The code is different, but I am surprised at the missed opportunities for optimization.</p>

<p>Clang/llvm produced this:</p>

<pre>

00000000 fun1:
   0:   e3a01000    mov r1, #0
   4:   e3a02ffa    mov r2, #1000   ; 0x3e8
   8:   e1a03001    mov r3, r1
   c:   e2522001    subs    r2, r2, #1
  10:   e490c004    ldr ip, [r0], #4
  14:   e08c3003    add r3, ip, r3
  18:   e2c11000    sbc r1, r1, #0
  1c:   e182c001    orr ip, r2, r1
  20:   e35c0000    cmp ip, #0
  24:   1afffff8    bne c
  28:   e1a00003    mov r0, r3
  2c:   e12fff1e    bx  lr

00000030 fun2:
  30:   e3a01000    mov r1, #0
  34:   e3a02ffa    mov r2, #1000   ; 0x3e8
  38:   e1a03001    mov r3, r1
  3c:   e2522001    subs    r2, r2, #1
  40:   e490c004    ldr ip, [r0], #4
  44:   e08c3003    add r3, ip, r3
  48:   e2c11000    sbc r1, r1, #0
  4c:   e182c001    orr ip, r2, r1
  50:   e35c0000    cmp ip, #0
  54:   1afffff8    bne 3c
  58:   e1a00003    mov r0, r3
  5c:   e12fff1e    bx  lr
</pre>

<p>You might notice that the compiler produced the exact same code, pointer or offset.  And by changing compilers I was better off than changing pointer vs array indexing.  I think llvm could have done a little better, I will need study this some more to understand what my code did to cause this.</p>

<p>EDIT:</p>

<p>I was hoping to get the compiler to at a minimum use the ldr rd,[rs],#4 instruction which favors pointers, and hoped the compiler would see that it could destroy the array address thus treating it like a pointer rather than an offset into an array (and use the above instruction, which is basically what clang/llvm did).  Or if it did the array thing that it would use the ldr rd,[rm,rn] instruction.  Basically was hoping one of the compilers would generate one of these solutions:</p>

<pre>

funa:
    mov r1,#0
    mov r2,#1000
funa_loop:
    ldr r3,[r0],#4
    add r1,r1,r3
    subs r2,r2,#1
    bne funa_loop
    mov r0,r1
    bx lr

funb:
    mov r1,#0
    mov r2,#0
funb_loop:
    ldr r3,[r0,r2]
    add r1,r1,r3
    add r2,r2,#4
    cmp r2,#0x4000
    bne funb_loop
    mov r0,r1
    bx lr

func:
    mov r1,#0
    mov r2,#4000
    subs r2,r2,#4
func_loop:
    beq func_done
    ldr r3,[r0,r2]
    add r1,r1,r3
    subs r2,r2,#4
    b func_loop
func_done:
    mov r0,r1
    bx lr

</pre>

<p>Didnt quite get there but got pretty close.  This was a fun exercise.  Note the above is all ARM assembler. </p>

<p>In general, (not my specific C code example and not necessarily an ARM), a number of the popular architectures you will have a load from a register based address (ldr r0,[r1]) and a load with a register index/offset (ldr r0,[r1,r2]) where the address is the sum of the two registers.  one register ideally is the base address of the array and the second the index/offset.  The former load from register lends itself to pointers, the latter to arrays. if your C program is NOT going to change or move the pointer or index, then in both cases that means a static address which is computed then a normal load is used, both array and pointer should produce the same instructions.  For the more interesting case of changing the pointer/index.</p>

<pre>
Pointer

ldr r0,[r1]
...
add r1,r1,some number

Array index

ldr r0,[r1,r2]
...
add r2,r2,some number
</pre>

<p>(replace the load with a store and the add with a sub as needed)</p>

<p>Some architectures do not have a three register register index instruction so there you have to do something like</p>

<pre>
array index:
mov r2,r1
...
ldr r0,[r2]
...
add r2,r2,some number
</pre>

<p>Or depending on the compiler it can get really bad, esp if you compile for debugging or without optimizations, and assuming you dont have a three register add</p>

<pre>
array index:
mov r2,#0
...
mov r3,r1
add r3,r2
ldr r4,[r3]
...
add r2,some number
</pre>

<p>So it is quite possible that the two approaches are equal.  As seen on the ARM, it can combine the two (within limits for the immediate) pointer instructions into one, making that a little faster.  The array index solution burns more registers, and depending on the number of available registers for the architecture that pushes you toward having to swap registers out to the stack sooner and more often (than you would with pointers), slowing you down even more.  If you dont mind destroying the base address, the bottom line is the pointer solution <em>might</em> give you an advantage from a performance perspective.  It has a lot to do with your code and the compiler.  For me it readability comes into play and I feel arrays are easier to read and follow, and second do I need to preserve that pointer to free a malloc or to go through that memory again, etc.  If so I will probably use an array with an index, if it is a one time pass and I dont care about destroying the base address I will use a pointer.  As you saw above with the compiler generated code, if performance is critical, then hand code the solution in assembler anyway (based on suggested approaches by letting the compilers try it first).</p>
"
"<p>Explicitly eliminating common subexpressions might work for you. There may be a difference if you are using x86 or RISC architecture and optimizer quality.</p>

<p>When I write a routine which has to run through an array or indexed structure I compute a pointer to the base of the array/structure member and use that to address. The basic case</p>

<pre><code>struct SOMETHING list[100];

int find_something (...)
{
  int i;

  i=0;
  while (i&lt;(sizeof(list)/sizeof(struct SOMETHING)))
  {
    if (list[i].active &amp;&amp; list[i].last_access+60&lt;current_time) return i;

    ++i;
  }
  return -1;
}
</code></pre>

<p>can be refined to (i e helping the compiler to produce better code):</p>

<pre><code>int find_something (...)
{
  int i;
  struct SOMETHING *pList;

  i=0;
  while (i&lt;(sizeof(list)/sizeof(struct SOMETHING)))
  {
    pList=&amp;list[i];
    if (pList-&gt;active &amp;&amp; pList-&gt;last_access+60&lt;current_time) return i;

    ++i;
  }
  return -1;
}
</code></pre>

<p>This is just to illustrate and the simplicity of the code would probably generate the pointer implicitly but if the routine is more complex that might not be the case. Using ""list[i]."" as in the first example you'd run (on the x86) the risk (RISC haha) of the compiler not having enough registers to generate and store the address once, instead generating it for every single reference. For the x86-case a local variable is necessary to store the pointer and few compilers will create stack variables unless explicitly directed to. On RISC the compiler has lots of registers at its disposal and will usually decide that it is worthwhile to create (and keep) the pointer once for every iteration.</p>

<p>The loop can be refined further:</p>

<pre><code>  pList=list;
  i=0;
  while (i&lt;(sizeof(list)/sizeof(struct SOMETHING)))
  {
    if (pList-&gt;active &amp;&amp; pList-&gt;last_access+60&lt;current_time) return i;

    pList+=1;
    ++i;
  }
</code></pre>

<p>This construction is devoid of any address calculation overhead. ""pList+=1"" (others might prefer ""++pList"") causes a constant value (equal to the size of an individual row/member) to be added to pList.</p>

<p>And further:</p>

<pre><code>  pList=list;
  pEndList=&amp;list[sizeof(list)/sizeof(struct SOMETHING)];
  while (pList!=pEndList)
  {
    if (pList-&gt;active &amp;&amp; pList-&gt;last_access+60&lt;current_time) return pList-list;

    pList+=1;
  }
</code></pre>

<p>Which eliminates the index increment and replaces it with one multiplication outside and one division inside the loop (executed just once, in the return construct).</p>

<p>Now before all you don't-optimizers out there start screaming bloody murder my point is that what constructs are acceptable is determined by the size and complexity of the function in which they reside. I would probably not consider this construct in a 300-line function that is complex enough to begin with but in a situation such as the above? If the searches are a significant part of overall processing? If the speed-ups are large enough?</p>

<p>So why not? Pros and cons. It's always pros and cons. Making the best of them. Absolutes? Rarely (if ever).</p>
"
"<p><strong>No, its not possible the way you like</strong></p>

<p>But You can achieve something close with inheritance.</p>

<pre><code> class Vehicle {
       function __construct() {
              $this-&gt;hookFunction();
       }

       function hookFunction() {
              //
       }
 }

 class Car extends Vehicle {

 }

 Class Toyota extends Car {

 }

 new Toyota(); // will you hook function
 // this exclude static call to member functions, or other inline functions.
</code></pre>
"
"<p>What you looking for is called profiler. And <a href=""http://particletree.com/features/php-quick-profiler/"" rel=""nofollow"">PQP</a> looks like one, which is standalone.</p>
"
"<p>Instead of polluting the code, you should use a real Profiler, like that one provided by <a href=""http://www.xdebug.org/docs/profiler"" rel=""nofollow"">xdebug</a></p>
"
"<p>It's possible with <strong><a href=""http://pt2.php.net/manual/en/function.register-tick-function.php"" rel=""noreferrer""><code>register_tick_function()</code></a></strong>, also <a href=""http://pt2.php.net/manual/en/control-structures.declare.php#85290"" rel=""noreferrer"">check this comment on the PHP manual</a>:</p>

<pre><code>$script_stats = array();
$time = microtime(true);

function track_stats(){
    global $script_stats,$time;
    $trace = debug_backtrace();
    $exe_time = (microtime(true) - $time) * 1000;
    $func_args = implode("", "",$trace[1][""args""]);
    $script_stats[] = array(
        ""current_time"" =&gt; microtime(true),
        ""memory"" =&gt; memory_get_usage(true),
        ""file"" =&gt; $trace[1][""file""].': '.$trace[1][""line""],
        ""function"" =&gt; $trace[1][""function""].'('.$func_args.')',
        ""called_by"" =&gt; $trace[2][""function""].' in '.$trace[2][""file""].': '.$trace[2][""line""],
        ""ns"" =&gt; $exe_time
        );
    $time = microtime(true);
    }

declare(ticks = 1);
register_tick_function(""track_stats"");

// the rest of your project code

// output $script_stats into a html table or something
</code></pre>

<p>This ""hooks"" to everything, not just functions but I think it fits your purpose.</p>
"
"<p>Not sure if the Topic Starter needs this anymore, but perhaps others can still benefit from this.</p>

<p>There is a PHP lib, written completely in PHP, that allows you to do exactly what you want.</p>

<p>Here's an article about how it works, including the source code:
<a href=""http://phpmyweb.net/2012/04/26/write-an-awesome-plugin-system-in-php/"" rel=""nofollow"">http://phpmyweb.net/2012/04/26/write-an-awesome-plugin-system-in-php/</a></p>

<p>It allows you to register a function from a class to be hooked. So it basically executes your code first, and then you determine wether you want to call the original function too after your code has been executed.</p>
"
"<p>Replace <code>strtotime(time('1298039664'))</code> with <code>1298039664</code>?</p>

<p>time() does not take any parameters.</p>
"
"<p>As struct timespec uses a time_t value for seconds, the complete range that can be covered is at least 68 years. Given the definition of CLOCK_MONOTONIC as starting at some arbitrary point, in theory clock_gettime could overrun anytime. In practice, you only need to worry about this if your app runs for some decades. But, if you're paranoid, make a wrapper function that complains loudly and kills the application if a timer wraparound happens.</p>
"
"<p>CLOCK_MONOTONIC, as implied by the ""monotonic"" name never goes back in time, it is always growing. Will not change if the user or another process (like NTP) changes the ""wall"" clock on the machine.
CLOCK_MONOTONIC is the right timescale to use in timers. It can eventually roll over but even that can be handled cleanly if you do it carefully. Use the same type of variable for the internal timer.</p>

<p>For example the following code will work OK eve if the clock wraps around.
Note: kDelayInterval has to be smaller than the wrap around period (this is normally not a problem).</p>

<pre>
struct timespec current_time;
struct timespec last_update = {0,0};
  .
  .
  clock_gettime(CLOCK_MONOTONIC, &current_time);
  if((current_time.tv_sec - last_update.tv_sec) > kDelayInterval)
  {
    .
    .
    .
    clock_gettime(CLOCK_MONOTONIC, &last_update);
  }
</pre>
"
"<p>Depending on your target platform, using floating-point types such as <code>double</code> can significantly interfere with the performance you're trying to measure. I'd change your code to use pure integer operations throughout.</p>
"
"<p>There are several ways to do bandwidth tests and they all measures different things.  Search for the stream benchmarks for instance or look at <a href=""http://www.akkadia.org/drepper/cpumemory.pdf"" rel=""nofollow"">http://www.akkadia.org/drepper/cpumemory.pdf</a> which gives pointer to some other tool.</p>

<p>One basic test is to have an inner loop like:</p>

<pre><code>void** ptr = ...;

while (ptr != NULL) {
    ptr = (void**)*ptr;
}
</code></pre>

<p>and initialize your memory beforehand with the access pattern you want to test.  (Measure for instance with different stride, going forward/backward,...)</p>
"
"<p>There are expert timings for these things, with code, here: <a href=""http://www.agner.org/optimize/#testp"" rel=""nofollow"">http://www.agner.org/optimize/#testp</a></p>

<p>That site is well worth a read - you may get your numbers there, rather than writing or running your own tests!</p>
"
"<p>Google for Memcache, that should put you in the right direction.</p>
"
"<p>If this is a straight array, then you could use <a href=""http://php.net/manual/en/function.var-export.php"">var_export()</a> rather than serialize (wrapping it with the appropriate """" and write it to a .php file; then <a href=""http://php.net/manual/en/function.include.php"">include()</a> that in your script. Best done if you can write it outside the htdocs tree, and only really appropriate for large volumes of data that memory caches would consider excessive.</p>
"
"<p><a href=""http://www.google.ca/#hl=en&amp;biw=1024&amp;bih=361&amp;q=memcached&amp;aq=f&amp;aqi=g3g-s1g6&amp;aql=f&amp;oq=&amp;fp=3e41beee0f6b4c75"">Memcached</a>.</p>

<p>I always try to create my own solution at least once, to grasp better what's going on under the hood in most situations. When I created my own caching solution, I essentially did what you're talking about.</p>

<pre><code>// serialize an array of all results
$serialzedData = serialize($resultData);

// set TTL (60 seconds) and create cache filename with timestamp
$ttl = 60;
$cacheFilename = $ttl . '_' . time() . '_' . md5($sqlQuery)

// dump
file_put_contents($cacheFilename, $serializedData);
</code></pre>

<p>Prior to a query firing, it would search the <code>cache</code> directory for files with a matching query hash. If it does, it tests <code>timestamp + ttl &lt;= current_time</code>, and if true, returns the unserialized file contents. Otherwise, overwrite it.</p>
"
"<p>Mysql caches result of query, may be you should increase mysql query cache size? Or cache result of big query in standalone table?</p>
"
"<p>If you are calling strtotime() on $modified, I guess it is not a UNIX timestamp already.
time() does return a UNIX timestamp.</p>

<p>Shouldn't the check, then, be as follows:</p>

<pre><code>if(strtotime($modified) &lt; $previous_day)
</code></pre>

<p>That way you are comparing UNIX timestamps and, given that $item->last_modified returns the correct value, your code should work.</p>

<p>If not, make sure there are no time or timezone differences between what time() returns, and the software setting the last_modified value on your $items (easy to check with some debug output)</p>
"
"<p>The <code>localtime()</code> function dates back to when <code>(int)</code> was 16 bits and passing <code>(long)</code> on the stack was not widely supported; as such, it was specified to pass <code>(long *)</code>, which at the time was 16 bits.  It's been left as is because changing it would break enormous amounts of code.  You'll find that most of the time-related functions do this, since they were the only functions at the time that used <code>(long)</code>.  (<code>lseek()</code> came later.  Care to guess what non-<code>(long)</code>-using function it replaced?)</p>
"
"<p>localtime requires an argument of ""time_t*"" which is a pointer. So you have to put the &amp; there.</p>
"
"<p>You can use <code>microtime(TRUE);</code> and get a whole number back, these days. No need for explode() and addition.</p>

<p>Regarding your times, you should be looking at fairly low execution times for a script like this (assuming this is all the script is actually doing). However, execution may take some more time depending on the I/O load on the system. Judging from the given script, and the execution time, I'm guessing the system you're trying to do this on might be doing a fair bit of I/O work and there's not much you can do to improve it from your PHP script.</p>
"
"<p>I'm not sure if I get you right, but it seems to me you basically don't know if you have performance problem yet or not, correct? If so - you don't. No need wasting time building pointless benchmarks. Focus on actual code. Come back to profiling  when the app starts to feel slow for real.</p>
"
"<p>Though I am not sure I got your question right, everything is starting from 0.0 is okay. So, you have to watch the ascipt running 0,1 more closely</p>

<p>just to refactor your code a bit to make it less ancient-looking.</p>

<pre><code>//at the beginning
$start_time = microtime(1);

/at the end
$cpu_time = microtime(1) - $start_time;
$data = date('m-d-Y H:m').""\t"".$cpu_time.""\t"".$_SERVER['SERVER_NAME'].""\t"".$_SERVER['PHP_SELF'].""\t"".$_SERVER['REMOTE_ADDR'].""\n"");
file_put_contents('/home/mcbeav/cpu_usage.log',$data,FILE_APPEND);
</code></pre>
"
"<p>it depends on what you are doing. is a lot happening?</p>

<p>Here is a benchmarking class I made a long time ago. You make markers where ever in your code (start, end, etc) with a static method, then print out a report at the bottom of your page with another static method. also keeps track of memory usage. this is somewhat messy since it uses static methods. The better thing might be to profile your code using XDebug:</p>

<pre><code>&lt;?php

    // time and memory benchmarking library
    class benchmark {

        // benchmark marker array
        protected static $benchmark_markers = array();
        // benchmark total duration
        protected static $total_duration = 0;

        // prevents new implimentation
        protected function __construct() {}

        // create new benchmark marker
        public static function create_benchmark_marker($marker_name) {
            $current_time = self::get_microtime();
            // get duration since last marker
            $duration = 0;
            if (self::$benchmark_markers) {
                $last_time = end(self::$benchmark_markers);
                $duration = $current_time - $last_time['end_time'];
            }
            // add to total duration
            self::$total_duration += $duration;
            // add benchmark marker to static array
            self::$benchmark_markers[] = array('name' =&gt; $marker_name, 'end_time' =&gt; $current_time, 'duration' =&gt; $duration, 'memory' =&gt; memory_get_usage());
        }

        // report benchmarking
        public static function print_report() {
            self::print_report_head();
            // output each marker line
            foreach (self::$benchmark_markers as $marker_values) {
                if ($marker_values['duration']) {
                    self::print_marker($marker_values, $last_marker_name);
                }
                $last_marker_name = $marker_values['name'];
            }
            self::print_report_foot();
        }

        // get high-precision microtime
        protected static function get_microtime() {
            return preg_replace('/^0(.+?) (.+?)$/', '$2$1', microtime());
        }

        protected static function print_report_head() {
            echo '&lt;table style=""clear: both; border-style: none; border-spacing: 1px; background-color: #ccc; font-family: Arial, Helvetica, sans-serif; font-size: 12px;""&gt;
                &lt;tr&gt;
                &lt;th style=""background-color: #ddd;""&gt;Benchmark Range&lt;/th&gt;
                &lt;th style=""background-color: #ddd;""&gt;Seconds&lt;/th&gt;
                &lt;th style=""background-color: #ddd;""&gt;% of Total&lt;/th&gt;
                &lt;th style=""background-color: #ddd;""&gt;Memory Usage&lt;/th&gt;
                &lt;/tr&gt;';
        }

        protected static function print_marker($marker_values, $last_marker_name) {
            echo '&lt;tr&gt;
                &lt;td style=""background-color: #eee;""&gt;' . $last_marker_name . ' -&gt; ' . $marker_values['name'] . '&lt;/td&gt;
                &lt;td style=""text-align: right; background-color: #eee;""&gt;' . round($marker_values['duration'], 6) . '&lt;/td&gt;
                &lt;td style=""text-align: right; background-color: #eee;""&gt;' . round(($marker_values['duration'] / self::$total_duration) * 100, 2) . '%&lt;/td&gt;
                &lt;td style=""text-align: right; background-color: #eee;""&gt;' . number_format($marker_values['memory']) . '&lt;/td&gt;
                &lt;/tr&gt;';
        }

        protected static function print_report_foot() {
            echo '&lt;tr&gt;
                &lt;td style=""background-color: #eee;""&gt;Total/Peak&lt;/td&gt;
                &lt;td style=""text-align: right; background-color: #eee;""&gt;' . round(self::$total_duration, 6) . '&lt;/td&gt;
                &lt;td style=""text-align: right; background-color: #eee;""&gt;100%&lt;/td&gt;
                &lt;td style=""text-align: right; background-color: #eee;""&gt;' . number_format(memory_get_peak_usage()) . '&lt;/td&gt;
                &lt;/tr&gt;
                &lt;/table&gt;';
        }
    }
?&gt;
</code></pre>
"
"<p>If your input buffer is defined to be 64 characters, then I would recommend using a <code>char</code> array instead of a <code>char*</code>.  Something like <code>char input_buffer[65];</code> should serve your purposes (add an extra character for the trailing <code>'\0'</code>).</p>

<p>As far as command history goes, you can use a two-dimensional array for that.  Something like <code>char command_history[20][65];</code> should let you store 20 old commands of 64 characters each.</p>

<p>Allocating these buffers statically should make things a bit easier for you, as you won't have to worry about <code>malloc</code> and friends.</p>

<p>It's hard to give you too much specific advice without seeing your code.  I have a feeling that you are making the same type of mistakes that are typical to people first learning C.  Can you post the part of your code that is giving you problems so that we can learn more about what you are doing?</p>

<p><strong>Update after posted provided code:</strong></p>

<p>One problem I'm seeing is that the function <code>takeInput</code> doesn't have a return statement. When you use <code>input = takeInput();</code> inside your main function, the value of <code>input</code> isn't being set to what you think it is. It's probably not a valid pointer, which is causing your line that says <code>input[j]</code> to segfault.</p>

<p>Your usage of <code>cmdHistory</code> also needs revisiting.  You allocate it with <code>cmdHistory = (char**)calloc(21,sizeof(int));</code>, which gives you enough space to store 21 integers.  In the function <code>printHistory</code>, you pass elements of <code>cmdHistory</code> to <code>printw</code> as if they were strings (they're only integers).  This is most definitely not doing what you want it to do.  Instead, your allocation logic for <code>cmdHistory</code> needs to look more like your de-allocation logic (except backwards).  Allocate an array of <code>char**</code>, then iterate through the array, assigning each pointer to a newly-allocated buffer.  Just like you have one <code>free</code> statement for each element in the array plus a <code>free</code> for the array as a whole, you should have one <code>malloc</code> for each element plus one <code>malloc</code> for the array as a whole.</p>

<p>Even if you can't use a statically-allocated stack, try writing your program using one anyway.  This will let you work the kinks out of your key detection logic, etc without having to worry about the dynamic memory part of the program.  Once the rest of it is working, go back in and swap out the static memory for dynamic memory allocation.  That way, you're only having to debug a little bit at a time.</p>
"
"<p>Have you looked at the Readline library? It's ideal for use in your project.</p>

<p><a href=""http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html"" rel=""nofollow"">http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html</a></p>
"
"<p>Here's some sample code which:</p>

<ol>
<li><p>Performs dynamic memory allocation.</p></li>
<li><p>Reads from the console in non-blocking mode.</p></li>
<li><p>Uses VT100 codes to print a frame buffer to the console.</p></li>
</ol>

<p>It compiles on Linux using GCC without warnings or errors. It's far from bug free, but it should give you some ideas of what's possible. Compile and run it, pressing [up] and [down] will print messages, typing characters and hitting [enter] will ""execute"" the command. </p>

<pre><code>#include &lt;poll.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

/** VT100 command to clear the screen. Use puts(VT100_CLEAR_SCREEN) to clear
 *  the screen. */
#define VT100_CLEAR_SCREEN ""\033[2J""

/** VT100 command to reset the cursor to the top left hand corner of the
 *  screen. */
#define VT100_CURSOR_TO_ORIGIN ""\033[H""

struct frame_s
{
    int x;
    int y;
    char *data;
};

static int draw_frame(struct frame_s *frame)
{
    int row;
    char *data;
    int attrib;

    puts(VT100_CLEAR_SCREEN);
    puts(VT100_CURSOR_TO_ORIGIN);

    for (row = 0, data = frame-&gt;data; row  &lt; frame-&gt;y; row++, data += frame-&gt;x)
    {
        /*  0 for normal, 1 for bold, 7 for reverse. */
        attrib = 0;

        /*  The VT100 commands to move the cursor, set the attribute, and the
         *  actual frame line. */
        fprintf(stdout, ""\033[%d;%dH\033[0m\033[%dm%.*s"", row + 1, 0, attrib, frame-&gt;x, data);
        fflush(stdout);
    }

    return (0);
}

int main(void)
{
    const struct timespec timeout = { .tv_sec = 1, .tv_nsec = 0 };
    struct frame_s frame;
    struct termios tty_old;
    struct termios tty_new;
    unsigned char line[128];
    unsigned int count = 0;
    int ret;
    struct pollfd fds[1];
    sigset_t sigmask;
    struct tm *tp;
    time_t current_time;

    /*  Set up a little frame. */
    frame.x = 80;
    frame.y = 5;
    frame.data = malloc(frame.x * frame.y);

    if (frame.data == NULL)
    {
        fprintf(stderr, ""No memory\n"");
        exit (1);
    }

    memset(frame.data, ' ', frame.x * frame.y);

    /*  Get the terminal state. */
    tcgetattr(STDIN_FILENO, &amp;tty_old);
    tty_new = tty_old;

    /*  Turn off ""cooked"" mode (line buffering) and set minimum characters
     *  to zero (i.e. non-blocking). */
    tty_new.c_lflag &amp;= ~ICANON;
    tty_new.c_cc[VMIN] = 0;

    /*  Set the terminal attributes. */
    tcsetattr(STDIN_FILENO, TCSANOW, &amp;tty_new);

    /*  Un-mask all signals while in ppoll() so any signal will cause
     *  ppoll() to return prematurely. */
    sigemptyset(&amp;sigmask);

    fds[0].events = POLLIN;
    fds[0].fd = STDIN_FILENO;

    /*  Loop forever waiting for key presses. Update the output on every key
     *  press and every 1.0s (when ppoll() times out). */
    do
    {
        fds[0].revents = 0;
        ret = ppoll(fds, sizeof(fds) / sizeof(struct pollfd), &amp;timeout, &amp;sigmask);

        if (fds[0].revents &amp; POLLIN)
        {
            ret = read(STDIN_FILENO, &amp;line[count], sizeof(line) - count);

            if (ret &gt; 0)
            {
                line[count + ret] = '\0';

                if (strcmp(&amp;line[count], ""\033[A"") == 0)
                {
                    snprintf(frame.data, frame.x, ""up"");
                    count = 0;
                }
                else if (strcmp(&amp;line[count], ""\033[B"") == 0)
                {
                    snprintf(frame.data, frame.x, ""down"");
                    count = 0;
                }
                else if (line[count] == 127) // backspace
                {
                    if (count != 0) { count -= ret;}
                }
                else if (line[count] == '\n')
                {
                    snprintf(frame.data, frame.x, ""entered: %s"", line);
                    count = 0;
                }
                else
                {
                    count += ret;
                }
            }
        }

        /*  Print the current time to the output buffer. */
        current_time = time(NULL);
        tp = localtime(&amp;current_time);
        strftime(&amp;frame.data[1 * frame.x], frame.x, ""%Y/%m/%d %H:%M:%S"", tp);

        /*  Print the command line. */
        line[count] = '\0';
        snprintf(&amp;frame.data[(frame.y - 1) * frame.x], frame.x, ""$ %s"", line);

        draw_frame(&amp;frame);
    }
    while (1);

    /*  Restore terminal and free resources. */
    tcsetattr(STDIN_FILENO, TCSANOW, &amp;tty_old);
    free(frame.data);

    return (0);
}
</code></pre>
"
"<p>You don't have to use find to get this info. You can use <code>stat</code> like so:</p>

<p><code>stat --printf=%Y dirname</code></p>
"
"<p>If you want the number of seconds ago:</p>

<pre><code>echo $[$(date +%s)-$(stat --printf ""%Y"" /tmp/log)]
</code></pre>
"
"<p>Change:</p>

<pre><code>find /tmp/log/ -exec stat \{} --printf=""%y\n""
</code></pre>

<p>to:</p>

<pre><code>find /tmp/log/ -exec stat \{} --printf=""%T@\n""
</code></pre>
"
"<p>You aren't using either sub-millisecond timeouts, a timeout that would overflow an <code>(int)</code>, or a nonempty <code>sigmask</code>, so <code>poll()</code> is fine for this.</p>
"
"<p>The reason you can replace the <code>ppoll()</code> with a <code>poll()</code> here at the moment is <strong>not</strong> because the signal mask provided to <code>ppoll()</code> is empty - this is actual the usual case - but because the signal mask prior to <code>ppoll()</code> is likely empty as well.</p>

<p>This is only possible because the shell currently does not try to handle any signals.  As soon as you want to make the shell handle signals, you will need to use the following sequence:</p>

<pre><code>/* Block all signals */
sigprocmask(SIG_SETMASK, all_signals);

/* Check and handle any signals that have occured. */
check_signals();

/* Wait for activity on a file descriptor or a signal */
ppoll(..., empty_set);
</code></pre>

<p><code>ppoll()</code> is necessary here because otherwise there is a race condition - a signal may arrive between <code>check_signals();</code> and the <code>poll()</code> call, which would be missed.  Hence signals are blocked for this duration, then <em>atomically</em> unblocked in the <code>ppoll()</code>.</p>

<p>Since <code>ppoll()</code> is a GNU extension which Solaris does not provide, you will need to change the code to use <code>pselect()</code>, which is a POSIX standard function.</p>

<hr>

<p>To convert your code to use <code>pselect()</code>, replace the start of the loop with:</p>

<pre><code>do
{
    fd_set rdset;
    int nfds = STDIN_FILENO + 1;

    FD_ZERO(&amp;rdset);
    FD_SET(STDIN_FILENO, &amp;rdset);
    ret = pselect(nfds, &amp;rdset, NULL, NULL, &amp;timeout, &amp;sigmask);

    if (ret &lt; 0) {
        if (errno == EINTR)
            continue;
        else
            break;
    }

    if (FD_ISSET(STDIN_FILENO, &amp;rdset))
    {
        ret = read(STDIN_FILENO, &amp;line[count], sizeof(line) - count);

    /* ... */
</code></pre>

<p>You can then remove the variable <code>fds</code>, since it is no longer needed.</p>

<p>Note that I've added code to check the return value of <code>pselect()</code> for error too - the old code should have been doing the same for <code>ppoll()</code>.</p>
"
"<p>It looks to me it <strong><em>already is</em></strong> going to STDOUT</p>

<pre><code>fprintf(    stdout,
        ""\033[%d;%dH\033[0m\033[%dm%.*s"",
        row + 1,
        0,
        attrib, frame-&gt;x, data);
fflush(stdout);
</code></pre>
"
"<p>You can call a class method using something like <a href=""http://www.boost.org/doc/libs/1_46_1/libs/bind/bind.html#with_member_pointers"" rel=""nofollow"">boost bind</a></p>

<p>Apart from that I wouldn't recommend to use signals for that, they are not that reliable, and could, for example, make one of your syscalls to return prematurely.</p>

<p>I would spawn a thread, assuming your monocore doesn't mean no threads, that waits 60 seconds, takes locks, makes calcs, outputs and releases locks.</p>

<p>As they have already suggested, if you have an async compatible system(driven by events) you could use timerfd to generate events.</p>
"
"<p>Your solution using <code>alarm</code> will work, both <code>open</code> and <code>write</code> being asynchronous-signal-safe. Though you have to be aware that interactions between <code>alarm</code> and <code>sleep</code> are undefined, so don't use them in the same program.</p>

<p>A different solution, especially in case you already use an <code>epoll</code>, would be to have a <code>timerfd</code> trigger the <code>epoll</code>. That will avoid possible undefined interactions.</p>

<p>As for the actual saving, consider forking. This is a technique that I learned from <a href=""http://code.google.com/p/redis/"" rel=""nofollow"">redis</a> (maybe someone else invented it, but that's where I learned it from), and which I consider totally cool. The point being that the forked process can take all time in the universe to finish writing as much data as you want to disk. It can access the snapshot at the time of forking while the other process keeps running and modifying data. And thanks to page magic done in the kernel, it still all works seamlessly without any risk of corruption, without ever stalling, and without ever needing to look at something like asynchronous IO, which is great.</p>
"
"<p>Saving data from a signal handler is a <strong>very bad idea</strong>. Even if <code>open</code> and <code>write</code> are async-signal-safe, your data could very well be in an inconsistent state due to a signal interrupting a function that was modifying it.</p>

<p>A much better approach would be to add to all functions which modify the data:</p>

<pre><code>if (current_time &gt; last_save_time + 60) save();
</code></pre>

<p>This will avoid useless saves when the data has not been modified, too. If you don't want the overhead of making a system call to determine the current time on every operation, you could instead install a timer/signal handler that updates <code>current_time</code>, as long as you declare it <code>volatile</code>.</p>

<p>Another good approach would be to use threads instead of signals. Then you should use a mutex (or better, rwlock) to synchronize access to the data.</p>
"
"<p>Usually GUI program has so called ""message pump"" loop. Check of that timer should be a part of your loop:</p>

<pre><code>while(running)
{
  if( current_time() &gt; end_time )
  {
    // time is over ...
    break;
  }
  if( next_ui_message(msg) )
    dispatch(msg);
}
</code></pre>
"
"<p>Without reference to a particular framework or even the OS this is unanswerable.</p>

<p>In SDL there is <code>SDL_GetTicks()</code> which suits the purpose.</p>

<p>On linux, there is the general purpose <code>clock_gettime</code> or <code>gettimeofday</code> that should work pretty much everywhere (but beware of the details).</p>

<p>Win32 API has several function calls related to this, including Timer callback mechanisms, such as <a href=""http://msdn.microsoft.com/en-us/library/ms724408%28VS.85%29.aspx"" rel=""nofollow""><code>GetTickCount</code></a>, <a href=""http://msdn.microsoft.com/en-us/library/ms644900%28v=VS.85%29.aspx"" rel=""nofollow""><code>Timers</code></a> etc. (<a href=""http://blogs.msdn.com/b/larryosterman/archive/2005/09/08/apis-you-never-heard-of-the-timer-apis.aspx"" rel=""nofollow"">article</a>)</p>

<p>Using timers is usually closely related to the meme of 'idle' processing. So you'd want to search for that topic as well (and this is where the message pump comes in, because the message pump decides when (e.g.) <code>WM_IDLE</code> messages get sent; Gtk has a similar concept of Idle hooks and I reckon pretty much every UI framework does)</p>
"
"<p>In C++11 there is easy access to timers.  For example:</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; ""begin\n"";
    std::chrono::steady_clock::time_point tend = std::chrono::steady_clock::now()
                                               + std::chrono::minutes(1);
    while (std::chrono::steady_clock::now() &lt; tend)
    {
        // do your game
    }
    std::cout &lt;&lt; ""end\n"";
}
</code></pre>

<p>Your platform may or may not support <code>&lt;chrono&gt;</code> yet.  There is a <a href=""http://www.boost.org/"" rel=""noreferrer"">boost</a> implementation of <code>&lt;chrono&gt;</code>.</p>
"
"<p>Try this one out:</p>

<pre><code>//Creating Digital Watch in C++
#include&lt;iostream&gt;
#include&lt;Windows.h&gt;
using namespace std;

struct time{

int hr,min,sec;
};
int main()
{
time a;
a.hr = 0;
a.min = 0;
a.sec = 0;

for(int i = 0; i&lt;24; i++)
{
    if(a.hr == 23)
    {
        a.hr = 0;
    }

    for(int j = 0; j&lt;60; j++)
    {
        if(a.min == 59)
        {
            a.min = 0;
        }

        for(int k = 0; k&lt;60; k++)
        {
            if(a.sec == 59)
            {
                a.sec = 0;
            }

            cout&lt;&lt;a.hr&lt;&lt;"" : ""&lt;&lt;a.min&lt;&lt;"" : ""&lt;&lt;a.sec&lt;&lt;endl;
            a.sec++;
            Sleep(1000);
            system(""Cls"");
        }
    a.min++;

}

    a.hr++;
}

}
</code></pre>

<ul>
<li>See the details at: <a href=""http://www.programmingtunes.com/creating-timer-c/#sthash.j9WLtng2.dpuf"" rel=""nofollow"">http://www.programmingtunes.com/creating-timer-c/#sthash.j9WLtng2.dpuf</a></li>
</ul>
"
"<p>You don't need a timer for this, you save the timestamp at start of the app with <code>time(0)</code>. And the you do the same each time you want to measure the time and you can just to init_time - current_time and you'll get the time lapse.</p>
"
"<p><strong>C++ 11:</strong>  </p>

<pre><code>#include &lt;iostream&gt;
#include &lt;chrono&gt;

auto start = std::chrono::system_clock::now();
auto end = std::chrono::system_clock::now();
std::chrono::duration&lt;double&gt; elapsed_seconds = end - start;
std::cout &lt;&lt; ""elapsed time: "" &lt;&lt; elapsed_seconds.count() &lt;&lt; ""s\n"";
</code></pre>

<p><em>Code taken from <a href=""http://en.cppreference.com/w/cpp/chrono"" rel=""nofollow noreferrer"">en.cppreference.com</a> and simplified</em>.  </p>

<p><strong>Old answer:</strong><br>
<code>GetTickCount()</code> in <code>windows.h</code> returns ticks(miliseconds) elapsed.
When your app starts, call this function and store its value, then whenever you need to know elapsed time since your program start, call this method again and subtract its value from start value.</p>

<pre><code>int start = GetTickCount(); // At Program Start

int elapsed = GetTickCount() - start; // This is elapsed time since start of your program
</code></pre>
"
"<p>You have the seconds, so just do something like</p>

<pre><code>SELECT secondsField / 3600 as 'hours' FROM tableName
</code></pre>
"
"<p>Here is an example of finding the difference between two timestamps in days. </p>

<pre><code>//Get current timestamp.
$current_time = time();

//Convert user's create time to timestamp.
$create_time  = strtotime('2011-09-01 22:12:55');

echo ""Current Date \t"".date('Y-m-d H:i:s', $current_time).""\n"";
echo ""Create Date \t"".date('Y-m-d H:i:s', $create_time).""\n"";

echo ""Current Time \t "".$current_time."" \n"";
echo ""Create Time \t "".$create_time."" \n"";

$time_diff = $current_time - $create_time;
$day_diff = $time_diff / (3600 * 24);

echo ""Difference \t "".($day_diff).""\n"";
echo ""Quote Index \t "".intval(floor($day_diff)).""\n"";
echo ""Func Calc \t "".get_passed_days($create_time).""\n"";

function get_passed_days($create_time)
{
    return intval(floor((time() - $create_time) / 86400));
}
</code></pre>

<p>To convert to hours, instead of 86400 put 3600 instead.</p>

<p>Hope this helps.</p>
"
"<p>You have to convert MARKER_ID to string, then append it to the first part of your query and filanny append the rest of it.</p>

<pre><code>char *query = malloc(80);
char num[11];

num = atoi(MARKER_ID);

strcpy(query, ""INSERT INTO markerherkenning ("");
strcat(query, num);
strcat(query, "", DATETIME) values(1, CURRENT_TIME())"");
</code></pre>
"
"<p>Something like this:</p>

<pre><code>
sprintf(request, ""INSERT INTO markerherkenning (%d, DATETIME) values(1, CURRENT_TIME())"", marker_id);
</code></pre>

<p>At first, you make a string with your request with sprintf (or snprintf), and then use it for sql query.</p>
"
"<p>If this is something you need to execute more than once, you might want to use a <a href=""http://dev.mysql.com/doc/refman/5.1/en/c-api-prepared-statements.html"" rel=""nofollow"">prepared statement</a>.  It's a bit more work, but it buys you some safety and performance.  Not to mention you don't have to convert between strings and other types all the time.  </p>
"
"<p>Do not use a pointer to a <code>vector</code>, use a reference instead:</p>

<pre><code>void Function(std::vector&lt;type&gt;&amp; aa)
</code></pre>

<p>inside the function you can now access the vectors contents as usual.</p>

<pre><code>void Function(std::vector&lt;type&gt;&amp; aa)
{
    std::vector&lt;type&gt;&amp; temp = aa;

    // if you now append something to temp, it is also appended to aa
    aa.push_back(type());
}
</code></pre>

<p>I don't know why you want two references to one vector, but hey, you asked :)</p>

<p>EDIT: removed typo, see comments. thanx</p>
"
"<p>I think you may be having trouble communicating your intentions, so this calls for a psychic answer.</p>

<pre><code>void Func(std::vector&lt;type&gt; &amp; aa)
{
    std::vector&lt;type*&gt; temp;

    // I wish &lt;algorithm&gt; had a 'transform_if'
    for(int i=0; i&lt;aa.size(); ++i)
    {
        if( some_test(aa[i]) )
            temp.push_back(&amp;aa[i])
    }

    // This leaves temp with pointers to some of the elements of aa.
    // Only those elements which passed some_test().  Now any modifications
    // to the dereferenced pointers in temp will modify those elements
    // of aa.  However, keep in mind that if elements are added or
    // removed from aa, it may invalidate the pointers in temp.
}
</code></pre>
"
"<p>As an aside, start formatting your code better. Messy code is difficult to understand and makes it harder for you to figure out what you're trying to do.</p>

<p>This will do what you want:</p>

<pre><code>void Oglos_Wydarzenie(std::vector&lt;Wydarzenie&gt;&amp; zmienna)
{
    std::vector&lt;Wydarzenie *&gt; obecne;
    tm AktualnyCzas = {0,0,0,0,0,0,0,0,0};
    time_t czas;
    czas = time(NULL);
    localtime_s(&amp;AktualnyCzas,&amp;czas);
    for (unsigned i = 0; i &lt; zmienna.size(); ++i) {
        if (zmienna[i].dzien == AktualnyCzas.tm_mday &amp;&amp;
            zmienna[i].miesiac ==  AktualnyCzas.tm_mon &amp;&amp;
            zmienna[i].rok == AktualnyCzas.tm_year+1900)
        {
            obecne.push_back(&amp;zmienna[i]);
        }
    }
    std::cout &lt;&lt; obecne.size() &lt;&lt; std::endl;
    obecne[0]-&gt;tytul = ""Changed""; //&lt;-- this is suppose to change value.
}
</code></pre>

<p>You could do this with all pointers and no references at all, but then it looks much more confusing:</p>

<pre><code>void Oglos_Wydarzenie(std::vector&lt;Wydarzenie&gt;* zmienna)
{
    std::vector&lt;Wydarzenie *&gt; obecne;
    tm AktualnyCzas = {0,0,0,0,0,0,0,0,0};
    time_t czas;
    czas = time(NULL);
    localtime_s(&amp;AktualnyCzas,&amp;czas);
    for (unsigned i = 0; i &lt; zmienna-&gt;size(); ++i) {
        if ((*zmienna)[i].dzien == AktualnyCzas.tm_mday &amp;&amp;
            (*zmienna)[i].miesiac ==  AktualnyCzas.tm_mon &amp;&amp;
            (*zmienna)[i].rok == AktualnyCzas.tm_year+1900)
        {
            obecne.push_back(&amp;((*zmienna)[i]));
        }
    }
    std::cout &lt;&lt; obecne.size() &lt;&lt; std::endl;
    obecne[0]-&gt;tytul = ""Changed""; //&lt;-- this is suppose to change value.
}
</code></pre>
"
"<p>I did a quick test here, the following works assuming you have /bin/bash on your machine:</p>

<p>my /tmp/test.sh:</p>

<pre><code>#!/bin/bash
echo `ls`
</code></pre>

<p>my java code:</p>

<pre><code>try {
    InputStream is = Runtime.getRuntime().exec(""/bin/bash /tmp/test.sh"").getInputStream();
    int i = is.read();
    while(i &gt; 0) {
        System.out.print((char)i);
        i = is.read();
    }
} catch (IOException e) {
    e.printStackTrace();
}
</code></pre>

<p>output: all files in current directory</p>

<p>edit: i kinda overlooked that ""execute from windows"" comment. I don't know what you mean with that.</p>
"
"<p>Here is my code. As the comment says, works on Linux, fails on Windows (XP). AFAIK the problem with Windows is that cmd.exe is weird regarding it's parameters. For your specific sub-task you probably can get it to work by playing with quotes and maybe embedding the sub-task parameters in the subtask itself.</p>

<pre><code>/** Execute an abritrary shell command.
  * returns the output as a String.
  * Works on Linux, fails on Windows,
  * not yet sure about OS X.
  */
public static String ExecuteCommand( final String Cmd ) {
    boolean DB = false ;
    if ( DB ) {
        Debug.Log( ""*** Misc.ExecuteCommand() ***"" );
        Debug.Log( ""--- Cmd"", Cmd );
    }
String Output = """";
String ELabel = """";
    String[] Command = new String[3];
    if ( Misc.OSName().equals( ""WINDOWS"" ) ) {
        Command[0] = System.getenv( ""ComSPec"" );
        Command[1] = ""/C"";
    } else {
        Command[0] = ""/bin/bash"";
        Command[1] = ""-c"";
    }
Command[2] = Cmd;
    if (DB ) {
        Debug.Log( ""--- Command"", Command );
    }
    if ( Misc.OSName().equals( ""WINDOWS"" ) ) {
        Debug.Log( ""This is WINDOWS; I give up"" );
        return """";
    }
try {
        ELabel = ""new ProcessBuilder()"";
        ProcessBuilder pb = new ProcessBuilder( Command );
        ELabel = ""redirectErrorStream()"";
        pb.redirectErrorStream( true );
        ELabel = ""pb.start()"";
        Process p = pb.start();
        ELabel = ""p.getInputStream()"";
        InputStream pout = p.getInputStream();
        ELabel = ""p.waitFor()"";
        int ExitCode = p.waitFor();
        int Avail;
        while ( true ) {
            ELabel = ""pout.available()"";
            if ( pout.available() &lt;= 0 ) {
                break;
            }
            ELabel = ""pout.read()"";
            char inch = (char) pout.read();
            Output = Output + inch;
        }
        ELabel = ""pout.close()"";
        pout.close();
    } catch ( Exception e ) {
        Debug.Log( ELabel, e );
    }

    if ( DB ) {
        Debug.Log( ""--- Misc.ExecuteCommand() finished"" );
    }
    return Output;
}
</code></pre>

<p>}</p>
"
"<p>To execute a <code>.sh</code> script on Windows, you would have to have a suitable command interpreter installed. For example, you could install the <a href=""http://www.cygwin.com/"" rel=""nofollow"">Cygwin</a> environment on your Windows box and use it's <code>bash</code> interpreter.</p>

<p>However, Windows is not Linux even with Cygwin. Some scripts will not port from one environment to the other without alterations. If I had a problem executing a script via Java in Linux environment, I would prefer to debug the issue in that environment.</p>

<p>Remember, you could start your Java process on Linux in debug mode and attach your IDE debugger in Windows to that remote process.</p>
"
"<p>Thanks everybody for your responses. I found a solution to the problem. For this kind of situation we need to bind my Windows machine to Linux system. Here is the code that worked:</p>

<pre><code>public String executeSHFile(String Username, String Password,String  Hostname)
    {
        String hostname = Hostname;
        String username = Username;
        String password = Password;
        try{
            Connection conn = new Connection(hostname);
               conn.connect();
               boolean isAuthenticated = conn.authenticateWithPassword(username, password);
               if (isAuthenticated == false)
                throw new IOException(""Authentication failed."");
               Session sess = conn.openSession();
              sess.execCommand(""sh //full path/file name.sh"");

               System.out.println(""Here is some information about the remote host:"");
               InputStream stdout = new StreamGobbler(sess.getStdout());
               BufferedReader br = new BufferedReader(new InputStreamReader(stdout));
               while (true)
                {
                    String line = br.readLine();
                    if (line == null)
                        break;
                    current_time=line;
                    System.out.println(line);
                }

               System.out.println(""ExitCode: "" + sess.getExitStatus());
               /* Close this session */

                sess.close();

                /* Close the connection */

                conn.close();
        }catch(IOException e)
        {
            e.printStackTrace(System.err);
            System.exit(2);
        }finally{

        }
}
</code></pre>

<p>Thank you.</p>
"
"<p>you may make a .bat file(batch file), that can run on windows.
put the content of the .sh file in the .bat file
start a process from your application like :</p>

<pre><code>Process.Start(""myFile.bat"");
</code></pre>
"
"<p>You can do <code>stat /proc/{processid}</code> to see the creation time at the shell.</p>

<p>EDIT: <a href=""http://linux.die.net/man/2/stat"" rel=""nofollow"">fstat</a> on that folder should give you what you want (the creation time).</p>
"
"<p>The time command will give you that info:</p>

<pre><code>&gt; man 1 time
</code></pre>

<p>Command-line arguments will make it return</p>

<pre><code>%S     Total number of CPU-seconds that the  process  spent  in  kernel mode.
%U     Total number of CPU-seconds that the process spent in user mode.
%P     Percentage of the CPU that this job got
</code></pre>

<p>You can call <code>system( char *command )</code> to execute the command from your prog.</p>
"
"<p>Let's break down what you're trying to do:</p>

<ol>
<li>Get the time the file was modified.</li>
<li>Convert the time into Unix time.</li>
<li>Subtract the two times.</li>
</ol>

<p>So, in order to get the current time, we can run:</p>

<pre><code>#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
char *command;
int process_number = 1; // init process.
SYSTEM (""mkfifo time_pipe"");
sprintf (command, ""stat /proc/%d -printf=""%%X"" &gt; time_pipe"", process_number); // get the command to run.
// since this directory is created once it starts, we know it is the start time (about)
// note the %%, which means to print a literal %
SYSTEM (command); // run the command.
</code></pre>

<p>Now, the next step is parsing it to Unix time -- but we don't have to! The %X specifier actually converts it to Unix Time. So next step would be to (a) get the current time (b) subtract the times:</p>

<pre><code>timeval cur_time;
double current_time, time_passed;
char read_time[11]; // 32 bit overflows = only 11 digits.
FILE *ourpipe;
gettimeofday(&amp;cur_time, NULL);
current_time = cur_time.tv_sec + (cur_time.tv_usec * 1000000.0);
// usec stands for mu second, i.e., a millionth of a second. I wasn't there when they named this stuff.
ourpipe = fopen (""time_pipe"", ""rb"");
fread(read_time, sizeof (char), 10, ourpipe);
time_passed = current_time - atoi (read_time);
fclose (ourpipe);
</code></pre>

<p>So yeah, that's pretty much it. The pipe is needed to get the input from one to the other.</p>
"
"<p>Okay guys, so after reading the <code>top</code> command's source code, I figured out a non-hacky way of getting the start time of a process. The formula that they use is:</p>

<pre><code>Process_Time = (current_time - boot_time) - (process_start_time)/HZ.
</code></pre>

<p>(You have to divide by HZ because process_start_time is in jiffies)</p>

<p>Obtaining these values:</p>

<ul>
<li><code>current_time</code> - You can get this from the C command <code>gettimeofday()</code>.</li>
<li><code>boot_time</code> - This value is located in <code>/proc/uptime</code>. This file contains two numbers: the uptime of the system (seconds), and the amount of time spent in idle process (seconds). Take the first.</li>
<li><code>process_start_time</code> - This value is located in <code>/proc/[PID]/stat</code>. The time difference (in jiffies) between system boot and when the process started. (The 22nd value in the file if you split on whitespace).</li>
</ul>

<p>The code (Sorry, I sometimes mix c and c++):</p>

<pre><code>  int fd;
  char buff[128];
  char *p;
  unsigned long uptime;
  struct timeval tv;
  static time_t boottime;


  if ((fd = open(""/proc/uptime"", 0)) != -1)
  {
    if (read(fd, buff, sizeof(buff)) &gt; 0)
    {
      uptime = strtoul(buff, &amp;p, 10);
      gettimeofday(&amp;tv, 0);
      boottime = tv.tv_sec - uptime;

    }
    close(fd);
  }


ifstream procFile;
procFile.open(""/proc/[INSERT PID HERE]/stat"");

char str[255];
procFile.getline(str, 255);  // delim defaults to '\n'


vector&lt;string&gt; tmp;
istringstream iss(str);
copy(istream_iterator&lt;string&gt;(iss),
     istream_iterator&lt;string&gt;(),
     back_inserter&lt;vector&lt;string&gt; &gt;(tmp));

process_time = (now - boottime) - (atof(tmp.at(21).c_str()))/HZ;
</code></pre>

<p>Happy Coding!</p>
"
"<blockquote>
  <p>/proc/{processid}  # Good idea!</p>
</blockquote>

<p>But why not just read /proc/{processid}/stat, and simply get whatever statistics you want?</p>

<p>from ""man proc"":</p>

<p><code><pre>
...
       stat   kernel/system statistics</p>

<pre><code>          cpu  3357 0 4313 1362393
                 The number of jiffies (1/100ths of a second)
                 that the system spent in user mode, user
                 mode with low priority (nice), system mode,
                 and the idle task, respectively.  The last
                 value should be 100 times the second entry
                 in the uptime pseudo-file.

          disk 0 0 0 0
                 The four disk entries are not implemented at
                 this time.  I'm not even sure what this
                 should be, since kernel statistics on other
                 machines usually track both transfer rate
                 and I/Os per second and this only allows for
                 one field per drive.
</code></pre>

<p>...</pre></code></p>
"
"<p>Old topic this, but since I was working on the same issues, I thought I might post my response. Perhaps it would be useful for someone else. Note, this code should not be used in a serious production environment, but as a quick and dirty way to get what the OP is looking for, I think this would be sufficient. Note that this code is the same code as OP posted in response to his own question, but it is modified to be able to be directly compiled when you copy it from stackexchange, his code was not directly able to compile.</p>

<p>This code compile, and I've added a few extra functions.</p>

<p>Instructions: Start any program, then do a 'ps aux | programname' to get its pid. It's the second column from the left. Now input that number to pid in the main function and compile the program. Now, when running the program, the output will be something like:</p>

<p>Lapsed: days: 0 , hours: 0 , min: 5 , seconds: 58</p>

<pre><code>//Original code credit by kmdent.
//http://stackoverflow.com/questions/6514378/how-do-you-get-how-long-a-process-has-been-running
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;vector&gt;
#include &lt;cstring&gt;
#include &lt;cerrno&gt;
#include &lt;ctime&gt;
#include &lt;cstdio&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/time.h&gt;

#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string&gt;
#include ""/usr/include/x86_64-linux-gnu/sys/param.h""

using namespace std;


template &lt;class T&gt;
inline std::string to_string (const T&amp; t)
{
    std::stringstream ss;
    ss &lt;&lt; t;
    return ss.str();
}

//Return the number of seconds a process has been running.
long lapsed(string pid) {

    int fd;
    char buff[128];
    char *p;
    unsigned long uptime;
    struct timeval tv;
    static time_t boottime;


    if ((fd = open(""/proc/uptime"", 0)) != -1) {
    if (read(fd, buff, sizeof(buff)) &gt; 0) {
      uptime = strtoul(buff, &amp;p, 10);
      gettimeofday(&amp;tv, 0);
      boottime = tv.tv_sec - uptime;
    }
        close(fd);
    }

    ifstream procFile;
    string f = ""/proc/""+pid+""/stat"";
    procFile.open(f.c_str());

    char str[255];
    procFile.getline(str, 255);  // delim defaults to '\n'

    vector&lt;string&gt; tmp;
    istringstream iss(str);
    copy(istream_iterator&lt;string&gt;(iss),
         istream_iterator&lt;string&gt;(),
         back_inserter&lt;vector&lt;string&gt; &gt;(tmp));

    std::time_t now = std::time(0);
    std::time_t lapsed = ((now - boottime) - (atof(tmp.at(21).c_str()))/HZ);
    return lapsed;

}

string human_readable_lapsed(long input_seconds) {
    //Credit: http://www.cplusplus.com/forum/beginner/14357/
     long days = input_seconds / 60 / 60 / 24;
     int hours = (input_seconds / 60 / 60) % 24;
     int minutes = (input_seconds / 60) % 60;
     int seconds = input_seconds % 60;

     return ""days: "" + to_string(days) + "" , hours: "" + to_string(hours) + "" , min: "" + to_string(minutes) + "" , seconds: "" + to_string(seconds);
}

int main(int argc, char* argv[])
{
    //Pid to get total running time for.
    string pid = ""13875"";
    std::cout &lt;&lt; ""Lapsed: "" &lt;&lt; human_readable_lapsed(lapsed(pid)) &lt;&lt; std::endl;
    return 0;
}
</code></pre>
"
"<p>OpenGL is not a scene graph, it's a drawing API. You don't <em>""add""</em> objects, you <strong>draw</strong> them in the drawing routine. You just called a bunch of OpenGL drawing functions in the <code>WinMain</code> where they don't belong. Even if those had some effect (which they probably didn't) you'd see their result only shortly, namely until the next window redraw.</p>

<p>In the message handler in the WM_PAINT message some <code>OpenGL_*</code> functions are called. You must put your sun drawing code there/in one of those.</p>
"
"<p>You can create a recurring <a href=""http://www.kernel.org/doc/man-pages/online/pages/man2/timerfd_create.2.html"" rel=""nofollow""><code>timerfd</code></a> and add it to your epoll set.  It will wake you up however often you like, at which point you can check all your client connections and drop the ones you think are stale.</p>

<p>If your Linux is too old to support timerfd, you could try the older <a href=""http://www.kernel.org/doc/man-pages/online/pages/man2/timer_create.2.html"" rel=""nofollow""><code>timer_create</code></a>.</p>
"
"<p>Keep a list of the sockets sorted by the time remaining until they time out (if the timeout period is the same for all sockets, then this is equivalent to sorting them by the time of the last recieved message).  Each time you call <code>epoll_wait()</code>, select the socket with the shortest remaining time until it times out (which will be at the front of your list).  Use that time as the timeout in <code>epoll_wait()</code>.</p>

<p>When <code>epoll_wait()</code> returns, after processing any active sockets, go through the sorted list of sockets pruning all the expired ones (which will be at the start of the sorted list).</p>

<hr>

<p>At <code>epoll_wait()</code> time:</p>

<pre><code>timeout = expirylist-&gt;expire_time - current_time();
n_events = epoll_wait(epfd, events, maxevents, timeout);

handle_events(events, n_events);

for (client = expirylist; client != NULL &amp;&amp; client-&gt;expire_time &lt; current_time(); client = client-&gt;expire_next)
{
    do_timeout(client);
}
</code></pre>
"
"<p>Just use libevent* or similar; this will save the effort of implementing your own queues and checking timeouts. It may also make your use of epoll easier, and as an added benefit be somewhat more portable (say you want to run your app on FreeBSD, which has no epoll but has something conceptually similar called kqueue)</p>

<p>* other similar libraries are available.</p>
"
"<p>Your problem is due to rounding.</p>

<p>For your ""dude"" you are using a SDL_Rect, that uses integer coordinates (short int if I remember correct).</p>

<p>You configured your dude speed to 50 and if your game is running at 60fps (probably due to its simplicity and it may be much more if vsync is off) you will get each frame a movement value of 0.83333.</p>

<p>This value will be truncated to a int and the result will be zero, for example, if dude.x is 10 and you press right, the calculated value will be 10.83 and when truncated this will result in 10.</p>

<p>For left, it works because the value is rounded down, assuming again dude.x is 10, when left is pressed, on the first iteration the calculated value would be 9.17, truncating this will give you 9.</p>

<p><strong>Simple, bad and Hack Solution</strong></p>

<p>Increase AMOUNT_OF_PIXELS_TO_MOVE to a higher value that forces the int to increase, this will fix the problem.</p>

<p><strong>Good Solution</strong></p>

<p>Does not use SDL_Rect for storing your characters position, create a ""MyRect"" and use float values in it and only does rounding when drawing the character. Actually you only need to store the character position, so I would create a Point2D struct with only x and y and use this to keep track of characters position.</p>
"
"<p>It looks like you're setting up the server socket and the client socket the same way.  The initialization looks good for a server, but for the client, you'll want to bind to port 0. </p>

<p>In fact, for both of them you can do INADDR_ANY (IP 0.0.0.0), which doesn't bind to a specific interface, but instead allows any connection on the correct port.</p>
"
"<p>There are a variety of ways that <code>sendto</code> can fail.  Some, such as arp failure, will cause an error during <code>sendto</code>.  Other, such as <code>ICMP port unreachable</code>, may be reported when you next use the socket.</p>

<p>Your <code>recvfrom</code> call could actually be fetching the ICMP packet sent in response to your outgoing packet.</p>

<p>Does a second <code>recvfrom</code> block as expected?</p>
"
"<p>Socket required to be set BLOCKING/NON-BLOCKING.</p>

<ol>
<li>Set BLOCKING</li>
</ol>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-css lang-css prettyprint-override""><code>     int nMode = 0; // 0: BLOCKING
  if (ioctlsocket (objSocket, FIONBIO, &amp;nMode) == SOCKET_ERROR)
  {
   closesocket(SendingSocket);
   WSACleanup();
        return iRet;
  }</code></pre>
</div>
</div>
</p>

<ol start=""2"">
<li>Set NON-BLOCKING</li>
</ol>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-css lang-css prettyprint-override""><code>         int nMode = 1; // 1: NON-BLOCKING
      if (ioctlsocket (objSocket, FIONBIO, &amp;nMode) == SOCKET_ERROR)
      {
       closesocket(SendingSocket);
       WSACleanup();
            return iRet;
      }</code></pre>
</div>
</div>
</p>
"
"<p>Is your goal to get a single big sorted output file?  Take a look at sort's <code>--merge</code> option.  You can sort the small input files individually, and then merge them all into the large sorted output.  If you delete each unsorted input file immediately after producing its sorted counterpart, you won't use more than 4MB of space on intermediate results.</p>
"
"<p>This can not be done as easily as you think. Since you are running on one thread only, you cannot have any checks. If this thread is blocking, it is blocking.</p>

<p>You need to create some sort of multi-threaded environment where you run one worker thread for the execution of <code>parse_html()</code> (to increase speed and take advantage of multi-core processors you could even spawn more worker threads) and another thread that checks and kills the workers if they are taking too much time.</p>
"
"<p>Taking what <a href=""https://stackoverflow.com/questions/7533485/stop-running-php-function-if-exceed-a-given-time/7533591#7533591"">@klaus said</a> into account, you <em>would</em> be able to perform this check if you can edit the <code>parse_html()</code> function. Within the function, there are likely either a number of calls to various subfunctions or a large number of <code>for</code> repeat loops. You want to add a check somewhere in the functions, or at the head of the <code>for</code> loops, to see whether the function is taking too long to execute.</p>

<p>Simple pseudocode example:</p>

<pre><code>function parse_html()
    start_time = 0;

    read file

    foreach element_to_be_parsed
        runtime = current_time - start_time
        if runtime &gt; (whatever)
            break
        end

        ...do parsing stuff
    end
end
</code></pre>
"
"<pre><code>-&gt;include time.h
-&gt;take two variable for start time &amp; current time of type time_t
like time_t start_time,current_time
-&gt; take start time
   time(&amp;start_time);
now in while loop continuisly check for
   time(&amp;current_time)
   difftime(current_time,start_time)
if difftime's return value is 15ms break while loop &amp; close your program
</code></pre>
"
"<p>I do not know that architecture so I can give you only a general hint. I would try something similar to old Symbian TRAP mechanism.</p>

<ol>
<li><p>In the main routine:</p>

<ul>
<li>start a timer.</li>
<li>put away a stack pointer</li>
<li>put away a program counter.</li>
<li>call your function.</li>
</ul></li>
<li><p>In timer exception (interrupt) handling routine.
This is a bit tricky because you need to know where in given architecture stack pointers and program counters are kept (processor's datasheet) when exception handling kicks in. Program counter was most likely pushed to the main routine stack.
So  your steps are:</p>

<ul>
<li>replace the stack pointer value (for main routine) with your copied value.</li>
<li>replace the program counter value with your copied value + offset (because you want to return to execution after your function call - best to check the assembly code to be sure how big is it).</li>
<li>return from exception (interrupt) handling routine.</li>
</ul></li>
</ol>
"
"<p>I think the nicest way to do this involves pthreads.  Start the calculation that potentially may need to be cancelled in its own thread, and in the main thread use pthread_cond_timedwait:</p>

<pre><code>#include &lt;time.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
/* for ETIMEDOUT */
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

pthread_mutex_t calculating = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t done = PTHREAD_COND_INITIALIZER;

void *expensive_call(void *data)
{
        int oldtype;

        /* allow the thread to be killed at any time */
        pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &amp;oldtype);

        /* ... calculations and expensive io here, for example:
         * infinitely loop
         */
        for (;;) {}

        /* wake up the caller if we've completed in time */
        pthread_cond_signal(&amp;done);
        return NULL;
}

/* note: this is not thread safe as it uses a global condition/mutex */
int do_or_timeout(struct timespec *max_wait)
{
        struct timespec abs_time;
        pthread_t tid;
        int err;

        pthread_mutex_lock(&amp;calculating);

        /* pthread cond_timedwait expects an absolute time to wait until */
        clock_gettime(CLOCK_REALTIME, &amp;abs_time);
        abs_time.tv_sec += max_wait-&gt;tv_sec;
        abs_time.tv_nsec += max_wait-&gt;tv_nsec;

        pthread_create(&amp;tid, NULL, expensive_call, NULL);

        /* pthread_cond_timedwait can return spuriously: this should
         * be in a loop for production code
         */
        err = pthread_cond_timedwait(&amp;done, &amp;calculating, &amp;abs_time);

        if (err == ETIMEDOUT)
                fprintf(stderr, ""%s: calculation timed out\n"", __func__);

        if (!err)
                pthread_mutex_unlock(&amp;calculating);

        return err;
}

int main()
{
        struct timespec max_wait;

        memset(&amp;max_wait, 0, sizeof(max_wait));

        /* wait at most 2 seconds */
        max_wait.tv_sec = 2;
        do_or_timeout(&amp;max_wait);

        return 0;
}
</code></pre>

<p>you can compile and run this on linux with:</p>

<pre><code>$ gcc test.c -pthread -lrt &amp;&amp; ./a.out
do_or_timeout: calculation timed out
</code></pre>
"
"<p>If you're not using pthreads you can also do a similar timeout function using the Apache Portable Runtime: <a href=""http://apr.apache.org/docs/apr/1.4/group__apr__thread__proc.html"" rel=""nofollow"">http://apr.apache.org/docs/apr/1.4/group__apr__thread__proc.html</a></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include ""apr.h""
#include ""apr_thread_proc.h""
#include ""apr_time.h""

void *APR_THREAD_FUNC expensive_call(apr_thread_t *thread, void *data)
{
    (void)thread;
    bool *done = data;

    /* ... calculations and expensive io here, for example:
     * infinitely loop
     */
    for (;;) {}

    // signal caller that we are done
    *done = true;
    return NULL;
}

bool do_or_timeout(apr_pool_t *pool, apr_thread_start_t func, int max_wait_sec)
{
    apr_thread_t *thread;
    bool thread_done = false;
    apr_thread_create(&amp;thread, NULL, func, &amp;thread_done, pool);
    apr_time_t now = apr_time_now();
    for (;;) {
        if (thread_done) {
            apr_thread_join(NULL, thread);
            return true;
        }
        if (apr_time_now() &gt;= now + apr_time_make(max_wait_sec, 0)) {
            return false;
        }
        // avoid hogging the CPU in this thread
        apr_sleep(10000);
    }
}

int main(void)
{
    // initialize APR
    apr_initialize();
    apr_pool_t *ap;
    if (apr_pool_create(&amp;ap, NULL) != APR_SUCCESS) {
        exit(127);
    }

    // try to do the expensive call; wait up to 3 seconds
    bool completed = do_or_timeout(ap, expensive_call, 3);
    if (completed) {
        printf(""expensive_call completed\n"");
    } else {
        printf(""expensive_call timed out\n"");
    }

    apr_terminate();
    return 0;
}
</code></pre>

<p>Compile using a command like this</p>

<p>gcc -o example example.c -lapr-1</p>
"
"<p>I believe there is no good reason to make your process wake up if it has nothing to do. Simply set the timeout to when you first <em>need</em> to do something. For example, if your server has a semantic of disconnecting a client after N seconds of inactivity, set the epoll timeout to the time after the first client would have to be disconnected assuming no activity. In other words, set it to:</p>

<p>min{expire_time(client); for each client} - current_time</p>

<p>Or, if that's negative, you can disconnect at least one client immediately. In general, this works not only for disconnecting clients; you can abstract the above into ""software timers"" within your application.</p>

<p>I'm failing to see this compromise you've mentioned. If you use a timeout any smaller than you have to, you'll wake up before you <em>have</em> to, then, presumably, go back to sleep because you have nothing to do. What good does that do? On the other hand, you <em>must not</em> use a timeout any larger than what you have to - because that would make your program not respect the disconnect timeout policy.</p>

<p>If your program is not waiting for any time-based event (like disconnecting clients), just give epoll_wait() timeout value -1, making it wait forever.</p>

<p><strong>UPDATE</strong> If you're worried that this process being given less CPU when other processes are active, just give it lower nice value (scheduler priority). On the other hand, if you're worried that your server process will be swapped out to disk in favour of other processes when it's idle, it is possible to <a href=""https://unix.stackexchange.com/questions/10214/per-process-swapiness-for-linux"">avoid swapping it out</a>. (or you can just lower /proc/sys/vm/swappiness, affecting all processes)</p>
"
"<p>You can print the question, and instead of waiting for an answer in a blocking call (like <code>scanf</code>) you loop while polling for new input, and use <a href=""http://en.wikipedia.org/wiki/ANSI_escape_code"" rel=""nofollow"">ANSI escape codes</a> to print the time at another position.</p>

<p>Something like the following pseudo-code:</p>

<pre><code>print(question)
while (current_time &lt; timer_end)
{
    if (have_input())
        break

    save_current_cursor_position()
    move_cursor_position(x, y)
    print(timer)
    restore_saved_cursor_position()

    very_short_sleep()
}
</code></pre>
"
"<p>What you want with threads, can't be accomplished with the line oriented functions, something like ncurses would be necessary for multithreaded console read/write operation.</p>

<p>What Joachim Pileborg, wrote is your best chance, the limitation is that your clock can't be ticking while you wait for input., if you poll every 1 second, writing the time and then waiting for the answer, most humans would not be able to reply on 1 second, so every 10 seconds would perhaps be the most sensible.</p>

<p>An alternate method to present the time ticking every second while still polling every second would be to save the input of that second on a accumulative buffer, and rewrite it on the screen on next input polling, besides the time ticking. This does have the danger of missing some input done while the loops alternate and is more complicated to code.</p>

<p>This is a case where a Graphical interface would be better suited for your needs.</p>

<p>Y seria buena idea que traduzcas al ingl?s tus nombres de variables para ayudar a una m?s r?pida comprensi?n del contenido de tu programa, ya que es lo que entiende la mayor?a por ac?.</p>
"
"<p>As i know there is no way to write to console from different threads at the same time. Altough it looks two thread are writing at the same time, actually one of them that write at a time (Which catch the console to write). In this way altough two thread is running at the same time, it does not make sense. </p>

<p>I think you can solve your problem as a little tricky in one thread but it is not not good. But i think you can gui components and from two different threads, you can set field of this component and this satisfy your requirement.</p>
"
"<p>Since you didn't define the language you're talking about, I assumed it to be C++.</p>

<blockquote>
  <p>In computer programming, a global variable is a variable that is accessible in every scope (unless shadowed). Interaction mechanisms with global variables are called global environment (see also global state) mechanisms. The global environment paradigm is contrasted with the local environment paradigm, where all variables are local with no shared memory (and therefore all interactions can be reconducted to message passing). <a href=""http://en.wikipedia.org/wiki/Global_variable"" rel=""nofollow"">Wikipedia</a>.</p>
</blockquote>

<hr>

<blockquote>
  <p>In principle, a variable defined outside any function (that is, global, namespace, and class static variables) is initialized before main() is invoked. Such nonlocal variables in a translation unit are initialized in their declaration order (?10.4.9). If such a variable has no explicit initializer, it is by default initialized to the default for its type (?10.4.2). The default initializer value for built-in types and enumerations is 0. [...] There is no guaranteed order of initialization of global variables in different translation units. Consequently, it is unwise to create order dependencies between initializers of global variables in different compilation units. In addition, it is not possible to catch an exception thrown by the initializer of a global variable (?14.7). It is generally best to minimize the use of global variables and in particular to limit the use of global variables requiring complicated initialization. <a href=""http://www.cplusplus.com/forum/general/7280/"" rel=""nofollow"">See</a>.</p>
</blockquote>
"
"<p>(Quick answer: The C standard doesn't support this kind of initialization; you'll have to consult your compiler's documentation.)</p>

<p>Now that we know the language is C, we can see what the standard has to say about it.</p>

<p><a href=""http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"" rel=""nofollow"">C99</a> 6.7.8 paragraph 4:</p>

<blockquote>
  <p>All the expressions in an initializer for an object that has static
  storage duration shall be constant expressions or string literals.</p>
</blockquote>

<p>And the new 2011 standard (at least the draft I has) says:</p>

<blockquote>
  <p>All the expressions in an initializer for an object that has static
  storage duration shall be constant expressions or string literals.</p>
</blockquote>

<p>So initializing a static object (e.g., a global such as your <code>current_time</code>) with a function call is a constraint violation.  A compiler can reject it, or it can accept it with a warning and do whatever it likes if it provides an language extension.</p>

<p>The C standard doesn't say when the initialization occurs, because it doesn't permit that kind of initialization.  Basically none of your code can execute before the <code>main()</code> function starts executing.</p>

<p>Apparently your compiler permits this as an extension (assuming you've actually compiled this code).  You'll have to consult your compiler's documentation to find out what the semantics are.</p>

<p>(Normally <code>main</code> is declared as <code>int main(void)</code> or <code>int main(int argc, char *argv[])</code> or equivalent, or in some implementation-defined manner.  In many cases <code>void main()</code> indicates a programmer who's learned C from a poorly written book, of which there are far too many.  But this applies only to hosted implementations.  Freestanding implementations, typically for embedded systems, can define the program's entry point any way they like.  Since you're targeting the Arduino, you're probably using a freestanding implementation, and you should declare <code>main()</code> however the compiler's documentation tells you to.)</p>
"
"<p>That looks a little disorganized. I guess the basic mistake to remedy the immediate problem without delving into multithreading would be to do something like this:</p>

<pre><code>//pseudo-code to get the idea
void draw(){
    // clear Buffers and setup matricies
    ....
    //calculate the time that has pased since the last time that the physics have been calculated
    time_t current_time = getCurrentTime();
    time_t since_update = current_time - last_update;

    //if enough time has passed since the last redraw calculate physics
    if(since_update&gt;timestep)
    {
        dynamicsWorld-&gt;stepSimulation(timestep,10);
        last_update = current_time;
    }
    btTransform trans;
    fallRigidBody-&gt;getMotionState()-&gt;getWorldTransform(trans);

    fallY = trans.getOrigin().getY();

    //draw various object
    ....
    fallingBall();
    //swap buffers or flush()
    glSwapBuffers();
}
</code></pre>

<p>Unless there is a distinct reason for using OpenGL directly I'd suggest that you use a higher level toolkit. Also the usual disclaimer that you are currently using an old version of OpenGL.</p>
"
"<ol>
<li>Copy the return of <code>ctime()</code> to a temporary string, remove the <code>'\n'</code> from that temporary string, then print the temporary string.</li>
<li>Print just the 1st 24 characters of the return from <code>ctime()</code> by using the (field width and) precision of the printf conversion.</li>
</ol>
"
"<p>You can use a combination of <a href=""http://linux.die.net/man/3/strftime"" rel=""noreferrer""><code>strftime()</code></a> and <a href=""http://linux.die.net/man/3/ctime"" rel=""noreferrer""><code>localtime()</code></a> to create a custom formatted string of your timestamp:</p>

<pre><code>char s[1000];

time_t t = time(NULL);
struct tm * p = localtime(&amp;t);

strftime(s, 1000, ""%A, %B %d %Y"", p);

printf(""%s\n"", s);
</code></pre>

<p>The format string used by <code>ctime</code> is simply <code>""%c\n""</code>.</p>
"
"<p>Just copy 'length - 1' bytes to another string.</p>

<pre><code>strncpy( newString, draw_No, strlen(draw_no) - 1 );
</code></pre>
"
"<p>How about:</p>

<pre><code>char *p;
int len;

/* ... */

p = ctime(&amp;t);
len = strlen(p);
fprintf(file,""|     %.*s"", len - 1, p);
</code></pre>

<p>That way it only prints the string minus the last character (i.e. the <code>\n</code>).</p>
"
"<p>Simply:</p>

<pre><code>    c_time_string = ctime(&amp;current_time);
    len_of_new_line = strlen(c_time_string) - 1;
    c_time_string[len_of_new_line] = '\0';
</code></pre>

<p>What this will actually do is it replaces strlen - 1 char (new line char in this case) of ctime array with null-terminator character - it cuts out new line character from end '\n' and shorten array of 1 character.</p>

<p>If strlen was 25 before, after this it should be 24.</p>
"
"<p>I did this after obtaining the ctime string:</p>

<pre><code>#include &lt;string.h&gt;
...
myctime[ strlen(myctime) - 1 ] = '\0';
</code></pre>

<p>This just overwrites the ctime carriage return with a string termination character, effectively terminating the string with two '\0' characters instead of one.  (It seems weird that ctime does that in the first place.)</p>
"
"<p>Just use %.19s :
    struct timeb timebuf;
    char *now;</p>

<pre><code>ftime( &amp;timebuf );
now = ctime( &amp;timebuf.time );

/* Note that we're cutting ""now"" off after 19 characters to avoid the \n
that ctime() appends to the formatted time string.   */
snprintf(tstring, 30, ""%.19s"", now);  // Mon Jul 05 15:58:42
</code></pre>
"
"<p>You can use <code>strtok()</code> to replace <code>\n</code> with <code>\0</code>. Here's a minimal working example:</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

int main() {
    char *ctime_no_newline;
    time_t tm = time(NULL);

    ctime_no_newline = strtok(ctime(&amp;tm), ""\n"");
    printf(""%s - [following text]\n"", ctime_no_newline);

    return 0;
}
</code></pre>

<p><strong>Output:</strong></p>

<pre class=""lang-none prettyprint-override""><code>Sat Jan  2 11:58:53 2016 - [following text]
</code></pre>
"
"<p>in c++11 you can do this like this:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;iomanip&gt;
using namespace std;
using namespace chrono;

// Prints UTC timestamp
void printTime() {
    time_point&lt;system_clock&gt; now = system_clock::now();
    time_t now_time = system_clock::to_time_t(now);

    auto gmt_time = gmtime(&amp;now_time);
    auto timestamp = std::put_time(gmt_time, ""%Y-%m-%d %H:%M:%S"");
    cout &lt;&lt; timestamp &lt;&lt; endl;
}
</code></pre>

<p><strong>Output:</strong></p>

<blockquote>
  <p>2017-06-05 00:31:49</p>
</blockquote>
"
"<p>The thing is that <code>pygame.time.delay(10)</code> will always wait the same time, no matter how long the drawing of the boxes and other things that you do in the game loop took. So the total time waited is  <code>10+render_time</code>.</p>

<p>Fortunately, PyGame comes with a solution to this: the <code>pygame.time.Clock</code> class and it's <code>.tick(framerate)</code> method, which remembers the time when it was last used and waits a smaller or larger amount of time depending on it, to keep the frame rate constant.</p>
"
"<p>I think you need to use the clock object that pygame.time provides:</p>

<pre><code>c = pygame.time.Clock()

while True:

    dt = c.tick(framerate) # 0 for framerate removes the cap

    ...

    ex_box.update(dt)
</code></pre>

<p>and the update method looks like this:</p>

<pre><code>def update(self, miliseconds_passed):

    self.pos[0] += self.spped[0] * dt # Speed must be in pixels_per_millisecond
    self.pos[1] += self.spped[1] * dt
</code></pre>

<p>Note:</p>

<p>If you want the speed to be in pixels per second you must do "" * dt / 1000."" insead of just "" * dt"".</p>

<p>And if you want to make the speed in m/s if have to set a constant 'pixels per meter' and multiply the speed by dt/1000. * ppm</p>
"
"<p>This man page describes it quite well:</p>

<p><a href=""http://pubs.opengroup.org/onlinepubs/009604499/functions/mq_receive.html"" rel=""nofollow"">http://pubs.opengroup.org/onlinepubs/009604499/functions/mq_receive.html</a></p>

<blockquote>
  <p>If more than one thread is waiting to receive a message when a message arrives at an empty queue and the Priority Scheduling option is supported, then the thread of highest priority that has been waiting the longest shall be selected to receive the message. Otherwise, it is unspecified which waiting thread receives the message. </p>
</blockquote>

<p>This allows you to use POSIX message queues to implement producer/consumer threads. </p>
"
"<p>The kernel does that locking for you.</p>

<p>Look at the implementation in ipc/mqueue.c:</p>

<pre><code>SYSCALL_DEFINE5(mq_timedreceive, mqd_t, mqdes, char __user *, u_msg_ptr,
                size_t, msg_len, unsigned int __user *, u_msg_prio,
                const struct timespec __user *, u_abs_timeout)
{
    ...
    struct mqueue_inode_info *info;
    ...
    filp = fget(mqdes);
    if (unlikely(!filp)) {
        ret = -EBADF;
        goto out;
    }

    inode = filp-&gt;f_path.dentry-&gt;d_inode;
    ...
    spin_lock(&amp;info-&gt;lock);
    if (info-&gt;attr.mq_curmsgs == 0) {
        if (filp-&gt;f_flags &amp; O_NONBLOCK) {
            spin_unlock(&amp;info-&gt;lock);
...
    } else {
        msg_ptr = msg_get(info);

        inode-&gt;i_atime = inode-&gt;i_mtime = inode-&gt;i_ctime =
                            CURRENT_TIME;

        /* There is now free space in queue. */
        pipelined_receive(info);
        spin_unlock(&amp;info-&gt;lock);
        ret = 0;
    }
</code></pre>

<p>Each mqueue has a spinlock, which is acquired before checking for new messages.</p>

<p>The last else (pipelined_receive) is where the message is dequeued. This is protected by the info->lock so there's no way two threads could get the same message.</p>
"
"<p>What you have is exactly what you need, other than replacing <code>do something</code> with some actual code.</p>

<p>For example, this program waits three seconds:</p>

<pre><code>#include &lt;time.h&gt;

int main(void) {
    time_t base = time (0);
    time_t now = base;
    while (now - base &lt; 3)
        now = time (0);
    return 0;
}
</code></pre>

<p>It simply loops in the <code>while</code> statement until the difference between the base time and the current time is three or more (there are almost certainly better ways to wait for <code>N</code> seconds, this is just meant to illustrate the calculation).</p>
"
"<p>check out time.h you will find the needed function to get current system time.</p>

<p>Or the Wiki Page: <a href=""http://en.wikipedia.org/wiki/System_time"" rel=""nofollow"">http://en.wikipedia.org/wiki/System_time</a></p>
"
"<p>You could try fopen:</p>

<pre><code>&lt;?php
$handle = fopen(""http://www.example.com/test.xml"", ""rb"");
$contents = stream_get_contents($handle);
fclose($handle);
?&gt;
</code></pre>
"
"<p>You need to have a scheduled, offline task (e.g., cronjob).  The solution you are pursuing is just plain wrong.</p>

<p>The simplest thing that could possibly work is a php script you run every hour (scheduled via cron, most likely) that downloads the file and processes it.</p>
"
"<p>There will be a <code>/proc/[pid]/task</code> (since Linux 2.6.0-test6) directory for every thread belonging to process [pid]. Look at <a href=""http://linux.die.net/man/5/proc"" rel=""nofollow noreferrer"">man proc</a> for documentation. Assuming you know the pid of your thread pool you could just count those directories.</p>

<p>You could use boost::filesystem to do that from c++, as described here:</p>

<p><a href=""https://stackoverflow.com/questions/6050298/how-do-i-count-the-number-of-files-in-a-directory-using-boostfilesystem"">How do I count the number of files in a directory using boost::filesystem?</a></p>

<p>I assumed you are using Linux. </p>
"
"<p>Okay, if you know the TID of the thread in use by the connection then you can wait on that object in a separate thread which can then decrement the counter.</p>

<p>At least I know that you can do it with MSVC...</p>

<pre><code>bool createConnection()
{
    if( ConnectionMonitor::connectionsMaxed() )
    {
        LOG( ""Connection Request failed due to over-subscription"" );
        return false;
    }
    ConnectionThread&amp; connectionThread = ThreadFactory::createNewConnectionThread();
    connectionThread.startConnection();
    ThreadMonitorThread&amp; monitor = ThreadFactory::createThreadMonitor(connectionThread);
    monitor.monitor();
}
</code></pre>

<p>and in ThreadMonitorThread</p>

<pre><code>ThreadMonitorThread( const Thread&amp; thread )
{
    this.thread = thread;
}

void monitor()
{
    WaitForSingleObject( thread.getTid() );
    ConnectionMonitor::decrementThreadCounter();
}
</code></pre>

<p>Of course ThreadMonitorThread will require some special privileges to call the decrement and the ThreadFactory will probably need the same to increment it.</p>

<p>You also need to worry about properly coding this up... who owns the objects and what about exceptions and errors etc... </p>
"
"<p>Your code is very difficult to read. It looks like you have written the program as a single big chunk before you started to test it. That way of working is common but very wrong. You should start by implementing a small part of the program and testing that before you add a little more functionality, test again, and so on. That way you won't be overwhelmed with fixing many problems at once in a large untested program.</p>

<p>It would also help you a lot if you added <code>use warnings</code> to your <code>use strict</code> at the top of the program. It helps to catch simple errors that you may overlook.</p>

<p>Also, are you aware that <code>File::Find</code> will call your <code>wanted</code> callback subroutine every time it encounters a file? It doesn't pass all the files at once.</p>

<p>The problem seems to be that you are reading all the way through the <code>yagya.txt</code> file when you should be stopping when you find the record that matches the current file that <code>File::Find</code> has found. What you need to do is to check whether the current record in the <code>ls</code> output ends with the name of the current file. If you write the loop like this</p>

<pre><code>while (&lt;MYFILE&gt;) {
  if (/\Q$files\E$/) {
    my @fields = (split)[5,6,7];
    $fields = join('',@fields);
    last;
  }
}
</code></pre>

<p>then <code>$fields</code> will end up with the modification date of the current file, which is what you want.</p>

<p><strong>But</strong> this would be a thousand times easier if you used Perl to read the file modification date for you.</p>

<p>Instead of writing an <code>ls</code> listing to a file and reading it back, you should do something like this</p>

<pre><code>use File::stat;

my $mtime = localtime(stat($files)-&gt;mtime);
</code></pre>

<p>which will give you a string like <code>Wed Jun 13 11:25:23 2012</code>. The date from my <code>ls</code> output includes only the month name, day of month, and time of day, like <code>Jun  8 12:37</code>. That isn't very specific and you perhaps should at least include a year, but to generate the same string from this <code>$mtime</code> you can write</p>

<pre><code>my $fields = join '', (split ' ', $mtime)[1,2,3];
</code></pre>

<p>There is a lot more I could say about your program, but I hope this gets it going for you for now.</p>

<hr>

<p>Another couple of things I have noticed:</p>

<ul>
<li><p>The line <code>$current_time = s/\s+//g</code> should be <code>$current_time =~ s/\s+//g</code> to remove all spaces from the current time string</p></li>
<li><p>A value like <code>Sun Jun  3 11:50:54 2012</code> will be reduced to <code>SunJun311:53:552012</code>, and <code>$daytime</code> will then take the value <code>SunJun31</code> which is incorrect</p></li>
</ul>
"
"<p>I'm usually not recommending using bash instead of perl, but sometimes it is much shorter</p>

<p>this problem has 2 parts:</p>

<ol>
<li>rename files into another directory and adding timestamp into the filenames</li>
<li>archive them by every minutes or hours, days ... etc..</li>
</ol>

<p>for 1.)</p>

<pre><code> find ./scripts -name \*[_.]log\* -type f  -printf ""%p\0./logs/%TY%Tm%Td-%TH%Tk%TM-%f\0"" | xargs -0 -L 2 mv
</code></pre>

<p>The above will find all plain files with [_.]log in their names and rename them into the <code>./logs</code> directory with timestamp prefix. e.g.</p>

<pre><code>./scripts/aaa.log12 get renamed into ./logs/20120403-102233-aaa.log12
</code></pre>

<p>2.) archiving</p>

<pre><code>ls logs | sed 's/\(........-....\).*/\1/' | sort -u | while read groupby
do
    ( cd logs &amp;&amp; echo tar cvzf ../$groupby.tgz $groupby* )
done
</code></pre>

<p>this will create tar archives by timestamp-prefix. (Assumed than the <code>./logs</code> contain only files with valid (timestamped) filenames)</p>

<p>Of course, the above sed pattern is not nice, but clearly shows deleting <code>seconds</code> from the timestamp - so it is creating archives by minutes. If want another grouping, you can use:</p>

<pre><code>sed 's/\(........-..\).*/\1/'  - by hours
sed 's/\(........\).*/\1/' - by days
</code></pre>

<p>Other:</p>

<ul>
<li>the <code>-printf</code> for find is supported only in gnu version of find - common in Linux</li>
<li>usually not a good practice working directly in '/', like <code>/scripts</code>, therefore my example uses <code>./</code></li>
<li>if in your ./scrips subtree exists the same filename with the same timestamp, the mv will overwrite the first, e.g. both of ./scripts/a/a.log and ./scripts/x/a.log with the same timestamp will be renamed into ./logs/TIMESTAMP-a.log</li>
</ul>
"
"<p>I think the problem is here:</p>

<p><a href=""http://pubs.opengroup.org/onlinepubs/009604599/functions/mktime.html"" rel=""nofollow""><code>The mktime() function shall convert the broken-down time, expressed as local time, in the structure pointed to by timeptr, into a time since the Epoch value...</code></a></p>

<p>Note the words <code>local time</code>. The C standard has them too in the description of <code>mktime()</code>:</p>

<p><code>The mktime function converts the broken-down time, expressed as local time, in the
structure pointed to by timeptr into a calendar time value with the same encoding as
that of the values returned by the time function.</code></p>

<p><code>gmtime()</code>, on the other hand, produces time in GMT/UTC and not in your time zone:</p>

<p><a href=""http://pubs.opengroup.org/onlinepubs/009604599/functions/gmtime.html"" rel=""nofollow""><code>The gmtime() function shall convert the time in seconds since the Epoch pointed to by timer into a broken-down time, expressed as Coordinated Universal Time (UTC).</code></a></p>

<p><strong>EDIT</strong>: If you just want 19:00 of the previous GMT/UTC day, you can do this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main(void)
{
    time_t currentTime;
    struct tm *brokenDownTime;

    time(&amp;currentTime);

    // get the time in GMT as we are in PDT
    brokenDownTime = gmtime(&amp;currentTime);
    printf(""Current Time (GMT): %2d:%02d\n""
           ""  seconds since Epoch: %ld\n"",
           brokenDownTime-&gt;tm_hour,
           brokenDownTime-&gt;tm_min,
           (long)currentTime);

    // ""Unwind"" time to 0:00:00 (assuming time_t is an integer):
    currentTime /= 24 * (time_t)3600;
    currentTime *= 24 * (time_t)3600;

    brokenDownTime = gmtime(&amp;currentTime);
    printf(""Time at the beginning of the current GMT day: %2d:%02d\n""
           ""  seconds since Epoch: %ld\n"",
           brokenDownTime-&gt;tm_hour,
           brokenDownTime-&gt;tm_min,
           (long)currentTime);

    // Add 19 hours:
    currentTime += 19 * (time_t)3600;

    brokenDownTime = gmtime(&amp;currentTime);
    printf(""Time at 19:00:00 of the current GMT day: %2d:%02d\n""
           ""  seconds since Epoch: %ld\n"",
           brokenDownTime-&gt;tm_hour,
           brokenDownTime-&gt;tm_min,
           (long)currentTime);

    // Subtract 1 day:
    currentTime -= 24 * (time_t)3600;

    brokenDownTime = gmtime(&amp;currentTime);
    printf(""Time at 19:00:00 of the previous GMT day: %2d:%02d\n""
           ""  seconds since Epoch: %ld\n"",
           brokenDownTime-&gt;tm_hour,
           brokenDownTime-&gt;tm_min,
           (long)currentTime);

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>Current Time (GMT): 13:23
  seconds since Epoch: 1341235429
Time at the beginning of the current GMT day:  0:00
  seconds since Epoch: 1341187200
Time at 19:00:00 of the current GMT day: 19:00
  seconds since Epoch: 1341255600
Time at 19:00:00 of the previous GMT day: 19:00
  seconds since Epoch: 1341169200
</code></pre>
"
"<p><code>mktime(3)</code> uses <em>current</em> timezone to perform the conversion. This is somewhat cryptically written in <a href=""http://pubs.opengroup.org/onlinepubs/007904875/functions/mktime.html"" rel=""nofollow"">the standard</a>:</p>

<blockquote>
  <p>Local timezone information shall be set as though <code>mktime()</code> called <code>tzset()</code>.</p>
</blockquote>
"
"<p>The <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/mktime.html"" rel=""nofollow"">mktime specification</a> states that its argument represents ?broken-down time, <strong>expressed as local time</strong>?. So anything you pass to mktime has to be in local time, not GMT. Your variable <code>localTime</code> has <code>local</code> in its name, but was in fact obtained from <code>gmtime</code>, so its result describes the curretn time <strong>in GMT</strong>. Passing that to <code>mktime</code> is inconsistent.</p>
"
"<p>You didn't state whether you're working on a POSIX(-like) target or some oddball system, but in the former case, you can just use the POSIX formula to convert broken down time to <code>time_t</code>:</p>

<pre><code>tm_sec + tm_min*60 + tm_hour*3600 + tm_yday*86400 +
    (tm_year-70)*31536000 + ((tm_year-69)/4)*86400 -
    ((tm_year-1)/100)*86400 + ((tm_year+299)/400)*86400
</code></pre>

<p>Source: <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15"" rel=""nofollow"">http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_15</a></p>
"
"<p>On some systems there is also a <a href=""http://man7.org/linux/man-pages/man3/timegm.3.html"" rel=""nofollow noreferrer"">timegm</a> function which should do the right thing.<br>
I've just checked on Linux and it produces the correct value (e.g. timegm (gmtime (time)) == time).</p>

<p><a href=""https://stackoverflow.com/a/22557778/257568"">Here's</a> how to use it in Windows.<br>
And here's a <a href=""https://stackoverflow.com/a/4682556/257568"">similar answer</a>.</p>
"
"<p>I think the <code>tm_gmtoff</code> field should be available on you system.</p>

<pre><code>std::time_t current_time;
std::time(&amp;current_time);
struct std::tm *timeinfo = std::localtime(&amp;current_time);
long offset = timeinfo-&gt;tm_gmtoff;
</code></pre>
"
"<p>Replace all glm::vec3(0, 1, 0); by glm::vec3(0.0f, 1.0f, 0.0f);</p>

<p>As for the vec-mac multiplication, AquilaRapax is right in that you can only multiply a mat4 with a vec4. But since you're multiplying directions, the 4rth coordinate should be 0.0f, not 1.0f. This will have the effect to ignore the translations (1.0 will teke them into account, which you don't want)</p>

<p>See <a href=""http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/"" rel=""noreferrer"">http://www.opengl-tutorial.org/beginners-tutorials/tutorial-3-matrices/</a> for details on matrices.</p>

<p>However, it's often a good idea to keep vec3 instead of vec4's, mostly for clarity purposes (i.e., glm::vec3 mPosition instead of glm::vec4 mPosition). It is thus handy to have 2 functions like these (untested) :</p>

<pre><code>glm::vec3 TransformDirection(glm::vec3 pDirection, glm::mat4 pMatrix){
    return pMatrix * glm::vec4(pDirection, 0.0f);
}

glm::vec3 TransformPosition(glm::vec3 pDirection, glm::mat4 pMatrix){
    return pMatrix * glm::vec4(pDirection, 1.0f);
}
</code></pre>
"
"<p>At the end of <code>process::mouse</code> you save the coordinates in <code>old_mouse_x</code> and <code>old_mouse_y</code> but then you move the cursor to the middle of the screen. If you do this <code>old_mouse_x</code> and <code>old_mouse_y</code> becomes invalid. What you need to do is set these variables after repositioning the cursor:</p>

<pre><code>app-&gt;SetCursorPosition(app-&gt;GetWidth() / 2, app-&gt;GetHeight() / 2);
this-&gt;old_mouse_x = app-&gt;GetWidth() / 2;
this-&gt;old_mouse_y = app-&gt;GetHeight() / 2;
</code></pre>
"
"<p>Ok, I have achieved it :D.</p>

<pre><code>#!/usr/bin/env python

import sys
from select import select

def main(argv):
    timeout = 3
    prompt = '&gt; '
    max_chars = 3

    # set raw input mode if relevant
    # it is necessary to make stdin not wait for enter
    try:
        import tty, termios

        prev_flags = termios.tcgetattr(sys.stdin.fileno())
        tty.setraw(sys.stdin.fileno())
    except ImportError:
        prev_flags = None

    buf = ''
    sys.stderr.write(prompt)

    while True: # main loop
        rl, wl, xl = select([sys.stdin], [], [], timeout)
        if rl: # some input
            c = sys.stdin.read(1)
            # you will probably want to add some special key support
            # for example stop on enter:
            if c == '\n':
                break

            buf += c
            # auto-output is disabled as well, so you need to print it
            sys.stderr.write(c)

            # stop if N characters
            if len(buf) &gt;= max_chars:
                break
        else:
            # timeout
            break

    # restore non-raw input
    if prev_flags is not None:
        termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, prev_flags)
    # and print newline
    sys.stderr.write('\n')

    # now buf contains your input
    # ...

if __name__ == ""__main__"":
    main(sys.argv[1:])
</code></pre>

<p>It's fairly incomplete; I just put a few values to test it. A few words of explanation:</p>

<ol>
<li>You need to switch the tty to 'raw' mode ? otherwise you wouldn't be able to get input without it being confirmed by enter key,</li>
<li>in raw mode the typed in characters are no longer output by default ? you need to output them yourself if you want user to see what he is typing,</li>
<li>you probably want to handle special keys like enter and backspace ? I've added enter handling here. Maybe you could reuse parts of <code>curses</code> for that,</li>
<li>I've assumed the timeout is '3 seconds after last key'. If you want timeout for whole process, I think the easiest way would be to get current time, increase it by timeout (i.e. get <code>end_time</code>), and then pass <code>end_time - current_time</code> in seconds as timeout to <code>select()</code>,</li>
<li>I've made unix-specific imports optional. I don't know whether it will work on Windows correctly, though.</li>
</ol>
"
"<p>I suggest using separate documents for each queue entry, it will allow you to avoid conflicts. </p>

<p>If you just need an <strong>queue</strong> with the interface <code>push()</code>, <code>pop()</code>, <code>top()</code> for adding inserting an element and taking one then the solution may be very simple (if you want the <strong>list</strong> with <code>next()</code>, or accessing n-th element, it gets <a href=""http://guide.couchdb.org/draft/recipes.html#Ordering%20Lists"" rel=""nofollow"">more complicated</a>). For scheduling algorithm with linear order (like FIFO, FILO) you can implement <code>push()</code> as insertion of the new document:</p>

<pre><code>{ type: ""queue"", inserted: CURRENT_TIME, ... }
</code></pre>

<p><code>top()</code> as the map:</p>

<pre><code>function (doc) {
  if (doc.type == ""queue"" &amp;&amp; doc.inserted) {
    emit(doc.inserted, doc);
  }
}
</code></pre>

<p>and reduce as an aggregation (eg. max for FILO, min for FIFO).
For <code>pop()</code> you can ask view for the <code>top()</code> and then delete the document.
Map/reduce has to be deterministic, so if you want to choose the random element you can make the reduce dependent on the pseudo-random (chosen by the server) <code>_id</code>.</p>

<p>I expect two problems:</p>

<ol>
<li><p>Mind the concurrency: two processes can ask for the same document with <code>top()</code>, first will delete the document as part of the <code>pop()</code>, and second will try to fetch the deleted document.</p></li>
<li><p>CouchDB never really deletes the document, only marks as deleted. Adding and deleting for each <code>push()</code>/<code>pop()</code> will grow the database. You will have to reuse the documents somehow. Perhaps you have some poll of the tasks, which are inserted and removed, or reordered in the queue. Then you can add <code>queued: true</code> to the task document, instead of separate documents with <code>type: ""queue""</code>.</p></li>
</ol>
"
"<p>Use one document per element in the queue, and keep one queue database.</p>

<p>I recommend a field to order the elements, for example <code>.created_at</code> with a timestamp in ISO 8601 format.</p>

<p>You can toggle an element's visibility with a <code>.visible</code> flag.</p>

<p>I recommend a map/reduce view, something like this</p>

<pre><code>function(doc) {
  if(doc.visible)
    emit(doc.created_at, doc)
}
</code></pre>

<p>Now you can query this view, either oldest-first, or newest-first (<code>?descending=true</code>). You can mark an element complete by updating it, setting <code>visible = false</code>.</p>

<p>I wrote a CouchDB queue, <a href=""https://github.com/iriscouch/cqs"" rel=""nofollow"">CQS</a> which is identical to the Amazon SQS API. It is similar to what I describe, except there is a checked-out state messages can be, not visible in the queue for a timeout period. I have used CQS in production for about two years, with hundreds of millions of updates.</p>
"
"<p>It looks like your <code>Date: ...</code> header is not newline terminated, therefore the MESSAGE_BREAK is swallowed. Also, I am unsure why you add +1 to all string lengths.</p>
"
"<p>There several instances of this mistake:</p>

<pre><code>memset(buffer, '\0', sizeof(buffer));
</code></pre>

<p>when the type of the first argument is a <code>char*</code>, which means the buffer will not be filled with null characters but only the first <code>sizeof(char*)</code> bytes (typically 4 or 8). In this case, it means that <code>buffer</code> may not be null terminated (as <code>recv()</code> does not append null characters). Both <code>printf()</code> and <code>strtok()</code> require string arguments to be null terminated. It is common to see garbage characters printed after a string with a call to <code>printf(""%s"", p);</code> with a non-null terminated string.</p>

<p>Fix all <code>memset()</code> calls by explicitly specifying the size of the buffer pointed to by the first argument:</p>

<pre><code>const size_t BUFFER_SIZE      = 512;
const size_t SCRATCH_PAD_SIZE = 256;
buffer                        = malloc(BUFFER_SIZE);     /*Check return value*/
scratch_pad                   = malloc(SCRATCH_PAD_SIZE);/*to ensure success.*/
memset(buffer,      0, BUFFER_SIZE);
memset(scratch_pad, 0, SCRATCH_PAD_SIZE);
</code></pre>

<p>The <code>sizeof(char)</code> is guaranteed to be <code>1</code> so it can be omitted from the <code>malloc()</code> argument.</p>

<hr>

<p>Other misuse of <code>memset()</code>:</p>

<pre><code>memset(message, '0', sizeof(message));
</code></pre>

<ul>
<li><code>'0'</code> is a the character zero, not null</li>
<li><code>sizeof(message)</code> is the <code>sizeof(char*)</code></li>
</ul>

<p>change to:</p>

<pre><code>memset(message, 0, /* the actual size of message*/ );
</code></pre>
"
"<p>There are several things in your code that don't look too good.</p>

<p>Here:</p>

<pre><code>   buffer = malloc(sizeof(char)*512);
   scratch_pad = malloc(sizeof(char)*256);
</code></pre>

<p>scratch_pad is a pointer to an allocated area.</p>

<p>But then you lose your pointer to that area and set scratch_pad to point into buffer:</p>

<pre><code>   printf(""request:\n%s\n"", buffer);
   scratch_pad = strtok(buffer, ""/"");
</code></pre>

<p>Then here:</p>

<pre><code>   if (!strncmp(scratch_pad, ""HTTP"", 4)) {
       scratch_pad = ""index.html"";
       printf(""request was for root directory\n"");
   }
</code></pre>

<p>you point scratch_pad to a constant string.</p>

<p>When you did</p>

<pre><code>free(scratch_pad);
</code></pre>

<p>I'd have expected for all Hell to get loose.</p>

<p>Your approach to tokenisation is a bit risky. The first consequence I see is that you would accept a <code>GETLOST</code> method as a synonym for <code>GET</code>, and you would have problems handling paths (e.g. <code>GET /js/main.js HTTP/1.0</code>):</p>

<pre><code>scratch_pad = strtok(buffer, ""/"");
printf(""pulling request type\n"");

if (!strncmp(scratch_pad, ""GET"", 3)) {
  printf(""this is a Get\n"");
  scratch_pad = strtok(NULL, "" "");
  printf(""pulling file name: &gt;%s&lt;\n"", scratch_pad);
  if (!strncmp(scratch_pad, ""HTTP"", 4)) {
    scratch_pad = ""index.html"";
    printf(""request was for root directory\n"");
  }
  printf(""requested file: %s\n"", scratch_pad);
}
</code></pre>

<p>As for <code>access()</code>, if scratch_pad has the correct file <strong>and the server is running in the web root</strong>, then <code>access()</code> ought to return 0. If it does not, verify the value of <code>errno</code>.</p>

<p><strong>UPDATE</strong></p>

<p>As I was writing above, <code>scratch_pad</code> is (or may be) a pointer <em>inside</em> <code>buffer</code>. So when you do:</p>

<pre><code>free(buffer);
if(!access(scratch_pad, R_OK)) {
</code></pre>

<p>it <em>might</em> happen (shouldn't, not for some milliseconds at least, but hey...) that the area pointed by <code>buffer</code> is trashed. Then also whatever <code>scratch_pad</code> points to will be.</p>

<p>And at that point, <code>access</code> (which might well be the one doing the trashing, now that I think about it) will work on garbage, and refuse proceeding.</p>

<p>To check, just do:</p>

<p>if (access(scratch_pad, R_OK))
   {
      printf(""Cannot access file '%s'\n"", scratch_pad);
   }
   else
   {
      ...</p>

<p>To avoid this, tokenise differently <code>buffer</code>.</p>

<p>For example:</p>

<p>char *space;
   char *http;</p>

<p>// Buffer is GET /this/path/to/file/name HTTP/1.0...
   if (!strncmp(buffer, ""GET "", 4))
      // Not a GET
   if (NULL == (space = strchr(buffer+4, ' ')))
      // ERROR: there is no second space.
   if (!strncmp(space + 1, 'HTTP/1.', 7))
      // ERROR: the GET doesn't end with HTTP/1.something
   // Now all buffer between buffer+4 and space is the file name
   len = space-buffer-4;
   strncpy(scratch_pad, buffer + 4, len);
   // Terminate string
   scratch_pad[len] = 0x0;</p>

<p>// Now scratch_pad contains the filename complete with /, but it is relative
   // to the wrong path; we want it to start from our document root.
   // So instead</p>

<p>#define DOCUMENT_ROOT ""./""
   len = space-buffer-4;
   strcpy(scratch_pad, DOCUMENT_ROOT);
   strncpy(scratch_pad + strlen(DOCUMENT_ROOT), buffer + 4, len);
   len += strlen(DOCUMENT_ROOT);
   // Terminate string. Now it is: .//path/to/file
   scratch_pad[len] = 0x0;
   // We actually ought to run realpath() here...</p>
"
"<p>two things that looked strange to me:</p>

<ol>
<li>why are you always sending 404 message before coming to the real content of the file?</li>
<li>the second send() is wrong, why are you sending the file descriptor? where is your buffer? you should provide the buffer pointer and update it with each loop. </li>
</ol>

<p>hint: gcc -Wall is your friend.</p>
"
"<p><code>time()</code> returns the number of seconds since epoch. <strike>Which is equal to UTC (aka GMT)</strike></p>

<p>Epoch was 1.1.1970, 00:00:00 in Greenwich, UK.</p>

<p>So in fact <code>time()</code> does not return a time, but a time <strong>difference</strong>.</p>
"
"<p>A time_t type holds a value representing the number of seconds since the UNIX epoch.
A tm type holds a calendar value.</p>

<p>gmtime() just converts system time (which is always UTC) from time_t to tm. That's why the values are the same. If you want a representation of your local time (GMT+1), that's what localtime() is for.</p>
"
"<p>Run the debugger over these two lines:</p>

<pre><code>struct tm* gmt = gmtime(&amp;current_time);

struct tm* loc = localtime(&amp;current_time);
</code></pre>

<p>Break on the second line, watch members of gmt and when you execute the second line - you will see that some gmt members change value. Apparently some static memory is used by the library. So save the results of the first statement before running the second</p>
"
"<p>For the first question:  Could you create a class or struct representing the collection of data, and put the entire struct into your container?</p>

<p>(Edit: Customer is now a class, has a constructor; added example of instantiation)
You'll want to clean this up a little, but something like:</p>

<pre><code>class Customer {
private:
  std::string m_name;
  int m_card_number;
  int m_arrival_time;
public:
  Customer() : m_card_number(0), m_arrival_time(0) { } // might need default ctor

  Customer(const std::string name, int card_number, int_arrival time)
  : m_name(name), m_card_number(card_number), m_arrival_time(arrival_time)
  { }
};

std::dequeue&lt;Customer&gt; service_queue; // or your container here

Customer c = Customer(name, card_num, current_time);
service_queue.push_back(c);
</code></pre>

<p>For the second question; if you don't need to persist the time, and only need to work with differences, one solution is to use <a href=""http://www.cplusplus.com/reference/clibrary/ctime/clock/"" rel=""nofollow"">clock</a>.  Just don't forget to divide by CLOCKS_PER_SECOND once you take your time difference (in ticks) and need to convert to seconds.</p>
"
"<p>I would push structs into your queue, each struct will hold the necessary elements needed.</p>

<pre><code>struct Customer
{
    string name;
    int ID;
    double change;
}

//in add function...
Customer newCustomer
cin &gt;&gt; newCustomer.name &gt;&gt; newCustomer.ID &gt;&gt; newCustomer.change;
queue.push_back(newCustomer);


retreiving data is simply asking for each element
//in a loop printing out the queue
std::cout &lt;&lt; iter-&gt;name &lt;&lt; iter-&gt;ID &lt;&lt; iter-&gt;change
</code></pre>
"
"<p><strong>busy-waiting</strong> or <strong>spinning</strong> is a technique in which a process repeatedly checks to see if a condition is <code>true</code>, such as whether keyboard input is available, or if a lock is available.</p>

<p>so the assignment says to wait for <strong>Ptime*100000</strong> time before producing next element and enqueue x different elements after the condition is <strong>true</strong> </p>

<p>similarly Each Consumer thread
should Dequeue <code>P*X/C</code> items from the queue and wait for ctime*100000 after every consumption of item</p>
"
"<p>I'm guessing it means busy-waiting; repeatedly checking the loop condition and consuming unnecessary CPU power in a tight loop:</p>

<pre><code>while (current_time() &lt;= wake_up_time);
</code></pre>

<p>One would ideally use something that suspends your thread until it's woken up externally, by the scheduler (so resources such as the CPU can be diverted elsewhere):</p>

<pre><code>sleep(2 * 60 * 1000 ms);
</code></pre>

<p>or at least give up <em>some</em> CPU (i.e. not be <em>so</em> tight):</p>

<pre><code>while (current_time() &lt;= wake_up_time)
    sleep(100 ms);
</code></pre>

<p>But I guess they don't want you to manually invoke the scheduler, hinting the OS (or your threading library) that it's a good time to make a context switch.</p>

<p>I'm not sure what <strong>cycles</strong> are; in assembly they might be CPU cycles but given that your question is tagged C, I'll bet that they're simply loop iterations:</p>

<pre><code>for (int i=0; i&lt;Ptime*100000; ++i); //spin-wait for Ptime*100,000 cycles
</code></pre>

<p>Though it's always safest to ask whoever issued the homework.</p>
"
"<p>I suspect that your professor is being a complete putz - by actually ASKING for the worste ""busy waiting"" technique in existance:</p>

<pre><code>int n = pTime * 100000;
for ( int i=0; i&lt;n; ++i) ; // waste some cycles.
</code></pre>

<p>I also suspect that he still uses a pterosaur thigh-bone as a walking stick, has a very nice (dry) cave, and a partner with a large bald patch.... O/S guys tend to be that way. It goes with the cool beards.</p>

<p>No wonder his thoroughly modern students misunderstand him. He needs to (re)learn how to grunt IN TUNE.</p>

<p>Cheers. Keith.</p>
"
"<p>It seems to me like you just need a simple timer you could use <code>alarm()</code> for that:</p>

<pre><code>#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

volatile unsigned stop_working = 0;

void alarm_handler(int signum)
{
    stop_working = 1;
    //alarm(1); //reschedule alarm
}

int main()
{
    signal(SIGALRM, alarm_handler);
    alarm(1); //schedule alarm in seconds

    while (!stop_working) {
      //do some work
    }
}
</code></pre>

<p>If however, you want to have something like coroutines you should look into user-level threads (or <a href=""http://en.wikipedia.org/wiki/Fiber_%28computer_science%29"" rel=""nofollow"">fibers</a>) using functions like <code>makecontext()</code> and <code>swapcontext()</code></p>

<p>Note: this example is UNIX/Linux specific, for MinGW you will need to use winapi, using functions like <code>CreateWaitableTimer()</code>, <code>SetWaitableTimer()</code>, and so on.  See MSDN for details.</p>
"
"<p>A concurrency model (simulated or not) would make sense if you had multiple tasks that you need to run at the same time. In this case it appears you only have one task to run.</p>

<p>If the only requirement that you have is that your calculations stop at 12:00 and restart at 12:30 then all you need is to make sure your calculations can be divided into small steps, so that you have a chance to check the conditions for starting and stopping in between steps. Here is some pseudo-code:</p>

<pre><code>while (true) {
    current_time = get_current_time();
    if (current_time &gt;= 12:00 and current_time &lt; 12:30)
        sleep(12:30 - current_time);
    else
        perform_calculation_step();
}
</code></pre>

<p>If the starting and stopping conditions are more complex than what you indicated in your example you could abstract the start/stop logic into a separate function. Example:</p>

<pre><code>while (true) {
    wait_if_necessary(); // this blocks when the app is not allowed to run
    perform_calculation_step()
}
</code></pre>

<p>I hope this helps!</p>
"
"<p>What about modify write_function like this?</p>

<pre><code>time_t start_time = time(0);
size_t bytes_downloaded = 0;

size_t write_data(void *ptr, size_t size, size_t nmemb, FILE *stream) {
    time_t current_time = time(0);
    time_t elapsed_time = current_time - start_time;

    // do you still need it?
    // size_t written;
    // written = fwrite(ptr, size, nmemb, stream);

    bytes_downloaded += (size * nmemb);

    printf(""Bytes downloaded %u in %u seconds at %u bytes/sec\n"",
            bytes_downloaded, elapsed_time, bytes_downloaded / elapsed_time);

    return (size * nmemb);
}
</code></pre>
"
"<p>As qrdl posted the answer is in this link:</p>

<p>curl.haxx.se/libcurl/c/getinmemory.html </p>
"
"<p>Have you tried <a href=""http://search.cpan.org/~drolsky/DateTime/lib/DateTime.pm"" rel=""nofollow"">DateTime</a>? </p>

<pre><code>my $now = DateTime-&gt;now( time_zone =&gt; 'local' );
my $a_while_ago = DateTime-&gt;now( time_zone =&gt; 'local' )-&gt;subtract( days =&gt; 45 );
print $a_while_ago-&gt;strftime(""%Y, %m, %d, %H, %M, %S\n"");
</code></pre>
"
"<p>Here's a simple solution using <a href=""https://metacpan.org/module/DateTime"" rel=""nofollow""><code>DateTime</code></a>:</p>

<pre><code>use strict;
use warnings;
use DateTime;

my $forty_five_days_ago = DateTime-&gt;now(time_zone=&gt;""local"")-&gt;subtract(days =&gt; 45);

my $output = $forty_five_days_ago-&gt;ymd("", "");

$output .= "", "" . $forty_five_days_ago-&gt;hms("", "");

print ""$output\n"";
</code></pre>
"
"<pre><code>use DateTime;

my $now = DateTime-&gt;now( time_zone=&gt;'local' );
my $then = $now-&gt;subtract( days =&gt; 45 );
print $then-&gt;strftime(""%Y, %m, %d, %H, %M, %S"");
</code></pre>

<p>Set the time_zone, it's important here.</p>
"
"<p>Preferably use DateTime, DateManip, or Date::Calc, but you can also:</p>

<pre><code>use POSIX 'strftime', 'mktime';

my ($second,$minute,$hour,$day,$month,$year) = localtime();
my $time_45_days_ago = mktime($second,$minute,$hour,$day-45,$month,$year);
print strftime(""%Y-%m-%d %H:%M:%S"", localtime $time_45_days_ago), ""\n"";
</code></pre>
"
"<p>there is no integrate routine for this task at the moment. Nevertheless, you have several options:</p>

<p><strong>First,</strong> use an observer in integrate() and throw an exception there if you exceed the number of maximal steps. Of course, this is not very elegant:</p>

<pre><code>struct write_lorenz_and_check_steps
{
    size_t m_steps;
    write_lorenz_and_check_steps( void ) : m_steps( 0 ) { }
    void operator()( const state_type &amp;x , const double t ) const {
       cout &lt;&lt; t &lt;&lt; '\t' &lt;&lt; x[0] &lt;&lt; '\t' &lt;&lt; x[1] &lt;&lt; '\t' &lt;&lt; x[2] &lt;&lt; endl;
       ++m_steps;
       if( m_steps &gt; max_steps ) throw runtime_error( ""Too much steps"" );
    }
};

// ...

size_t steps = 0;
try {
    steps = integrate( lorenz , x , 0.0 , 25.0 , 0.1 , write_lorenz );
} catch( ... ) { steps = max_steps; }
cout &lt;&lt; steps &lt;&lt; endl;
</code></pre>

<p><strong>Second</strong>, you can write the stepping loop yourself:</p>

<pre><code>// Attention: the code has not been check to compile
double tmax = 25.0;
size_t imax = 1000;
size_t i = 0;
auto stepper = make_dense_output( 1.0e-6 , 1.0e-6 , runge_kutta_dopri5&lt; state_type &gt;() );
stepper.initialize( x , t , dt );
while ( ( stepper.current_time() &lt; tmax ) &amp;&amp; ( i &lt; imax ) )
{
    observer( stepper.current_state() , stepper.current_time() );
    stepper.do_step( lorenz() );
    ++i;
}
x = stepper.current_state();
</code></pre>

<p>In this example you also work directly with <code>stepper.current_state()</code> and <code>stepper.current_time()</code> instead of calling the observer. Furthermore, if you compiler does not support auto, i.e. you have a C++03 compiler just use</p>

<pre><code>typedef runge_kutta_dopri5&lt; state_type &gt; stepper_type;
result_of::make_dense_output&lt; stepper_type &gt;::type stepper =
    make_dense_output( 1.0e-6 , 1.0e-6 , stepper_type() );
</code></pre>

<p>We are also developing a special integrate routine exactly for this task. But it will still take some weeks until it is finished. Furthermore, we develop ode iterators which could also be used and which will be ready very soon (I hope at the next of next week).</p>
"
"<p>What is <code>it</code>?</p>

<pre><code>it_empty = new list&lt;data&gt;::iterator[n];
for(int i=0; i&lt; n; i++)
{
    auto it = (list_empty[i]).begin();
    while(it != (list_empty[i]).end())
    {
        cout&lt;&lt;""PROBLEM HERE: size=""&lt;&lt;it-&gt;process.size&lt;&lt;endl;
        //cout&lt;&lt;""log file i=""&lt;&lt;i&lt;&lt;endl;
        log_file_start(current_time, it,""list of empty"");
        it++;
    }
}
</code></pre>
"
"<p>This works for me:</p>

<pre><code>#include &lt;list&gt;
using std::list;

const int n = 10;

typedef struct {
    int size;
    int pid;//prosdiorisths diergasias
}vp;


typedef struct data{
    int position;
    vp process;
    int delay;
    int current_life;
    int time_start;
    int time_stop;
    int part_of_memory;
    bool operator ==(const data&amp; st)
    {
    return process.pid == st.process.pid;
    }
}data;

int main()
{

    list&lt;data&gt;* list_empty = new list&lt;data&gt;[n];
    list&lt;data&gt;::iterator it;
    for(int i=0; i&lt; n; i++)
    {
        it = (list_empty[i]).begin();
        while(it != (list_empty[i]).end())
        {
            cout&lt;&lt;""PROBLEM HERE: size=""&lt;&lt;it-&gt;process.size&lt;&lt;endl;
            //cout&lt;&lt;""log file i=""&lt;&lt;i&lt;&lt;endl;
            //log_file_start(current_time, it,""list of empty"");
            it++;
        }
    }
}
</code></pre>
"
"<p>Try remembering the current position of the button, and only take action when its state changes from off to on.</p>

<p>Depending on the hardware, you might also get a signal as though it flipped back and forth several times in a millisecond.  If that's an issue, you might want to also store the timestamp of the last time the button was activated, and then ignore repeat events during a short window after that.</p>
"
"<p>You could connect the button to an interrupt and then make the necessary change in the interrupt handler. </p>

<p>This might not be the best approach, but it will be the simplest.</p>

<hr>

<p>From The <a href=""http://www.vexrobotics.com/276-2194.html"" rel=""nofollow"">Vex Robotics catalogue</a> :</p>

<blockquote>
  <p>(12) Fast digital I/O ports which can be used as interrupts</p>
</blockquote>

<p>So, most probably which ever micro-controller of Vex you are using will support Interrupts.</p>
"
"<p>Your question is a bit vague<br>
I m not sure why u need this variable to increment and how things exactly work...but i ll make a try.Explain a bit more how things work for the robot to move...and we will be able to help more.  </p>

<pre><code>task autonomous()
{
    int buttonPressed=0;
    while(true)
    {
        if(SensorValue[positionSelectButton] == 1)
        {
            positionSelect = positionSelect +1;
            buttonPressed=1;
        }
        else{
            buttonPressed = 0;
        }


        //use your variables here
        if( buttonPressed  == 1){
            //Move robot front a little
        }

    }
}
</code></pre>

<p>The general idea is :<br>
First you detect all buttons pressed and then you do things according to them<br>
All these go in your while loop...that will(and should) run forever(at least as long as your robot is alive :) )<br>
Hope this helps!  </p>
"
"<p>assuming that the <code>SensorValue</code> comes from a physical component that is asynchronous to the while loop, and is a push button (i.e. not a toggle button)</p>

<pre><code>task autonomous()
{
    while(true)
    {
        // check whether
        if(current_time &gt;= next_detect_time &amp;&amp; SensorValue[positionSelectButton] == 1)
        {
            positionSelect = positionSelect + 1;

            // no waiting here
            next_detect_time = current_time + 0350;
        }

        // carry on to other tasks
        if(enemy_is_near)
        {
            fight();
        }

        // current_time
        current_time = built_in_now()
    }
}
</code></pre>

<p>Get the current time either by some built-in function or incrementing an integer and wrap around once reach max value.</p>

<p>Or if you are in another situation:</p>

<pre><code>task autonomous()
{
    while(true)
    {
        // check whether the flag allows incrementing
        if(should_detect &amp;&amp; SensorValue[positionSelectButton] == 1)
        {
            positionSelect = positionSelect + 1;

            // no waiting here
            should_detect = false;
        }

        // carry on to other tasks
        if(enemy_is_near)
        {
            if(fight() == LOSING)
               should_detect = true;
        }
    }
}
</code></pre>
"
"<p>One possible problem may arise from the fact that <code>time()</code> is timezone independent - it always returns the UTC time (this fact is buried in <a href=""http://www.php.net/manual/en/function.time.php#100220"" rel=""nofollow"">the comments</a>). More robust handling of timezones can be handled with the <a href=""http://www.php.net/manual/en/book.datetime.php"" rel=""nofollow""><code>DateTime</code></a> object:</p>

<pre><code>$date = new DateTime('now', new DateTimeZone($_SESSION['timezone']));
$current_time = $date-&gt;format(""U"");
</code></pre>

<p>Either way, the next step would be to verify your <code>$current_time</code> variable and the <code>time_from_t</code> to see where the maths is going wrong.</p>
"
"<p><code>time_t</code> is just an integer in seconds, so you simply add 10 to it:</p>

<pre><code>time_wanted = time(NULL) + 10;
loc_time=localtime(&amp;time_wanted);
</code></pre>
"
"<p><code>time</code> returns the time in seconds, so you could simply add as in</p>

<pre><code>time_t soon = current_time + 10;
</code></pre>
"
"<p>Since <a href=""http://linux.die.net/man/2/time"" rel=""nofollow""><code>time()</code></a> <em>""returns the time as the number of seconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).""</em>, all you need to do is just add <code>10</code> to its return value:</p>

<pre><code>time_t timeNow;
struct tm* time_info;
time(&amp;timeNow);
time_info = localtime(&amp;timeNow);
char timeStr[sizeof""HH:MM:SS""];
strftime(timeStr, sizeof(timeStr), ""%H:%M:%S"", time_info);
printf(""Time now: %s\n"", timeStr);

// add 10 seconds:
timeNow += 10;
time_info = localtime(&amp;timeNow);
strftime(timeStr, sizeof(timeStr), ""%H:%M:%S"", time_info);
printf(""New time: %s\n"", timeStr);
</code></pre>

<p>See <a href=""http://ideone.com/yS7FwM"" rel=""nofollow"">full example</a></p>
"
"<p>The problem is that ""localtime()"" API only has granularity of seconds (not milliseconds).</p>

<p>Try <a href=""http://linux.die.net/man/2/gettimeofday"" rel=""nofollow noreferrer""><code>gettimeofday()</code></a></p>

<p>See also:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/3756323/getting-the-current-time-in-milliseconds"">Getting the current time in milliseconds</a></li>
</ul>

<p>If you're on Windows, you can also try QueryPerformanceCounter():</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/3729169/how-can-i-get-the-windows-system-time-with-millisecond-resolution"">How can I get the Windows system time with millisecond resolution?</a></li>
</ul>
"
"<p>Remember that the <code>tv_usec</code> field of the <code>timeval</code> structure never goes to (or over) one million, instead the number of seconds is increased.</p>

<p>You have to use the <code>tv_sec</code> field as well in your calculation.</p>
"
"<p><code>usleep</code> is specified to sleep at least the amount you give it, but it can sleep much longer. There's almost no upper bound on how long it will sleep because the operating system doesn't have to run your process if it has more important processes to run.</p>

<p>In practice the resolution of how long <code>usleep</code> will sleep is decided by the clocks the operating system uses. Up until a few years ago most unix-like systems used a static 100Hz timer (or 1024Hz in some rarer cases) to drive timers like this, so your usleep would always get rounded up to the nearest 10ms.</p>

<p>There has been some work done recently on some systems to remove the static clock, although this hasn't been driven as much by the need for higher resolution sleeps, but rather by the fact that constantly waking up the cpu for a static clock tick is bad for power consumption. It can have a side effect of improving the timer resolution, but that in turn exposes bugs in applications that used very short sleeps and appeared to behave correctly. Suddenly with a higher resolution of timeouts in <code>usleep</code>/<code>nanosleep</code>/<code>poll</code>/<code>select</code> those short sleeps lead to applications spinning on the cpu rescheduling their sleeps all the time.</p>

<p>I'm not sure what the state of this is today, but from your 10ms it looks like your system still uses a 100Hz clock for its internal timers or that it deliberately slows down timeouts to a 10ms resolution to prevent applications from breaking.</p>
"
"<p>I'm sure there are many bugs (starting with not caring if the user wants to enter 11 or more processes even though your array of processes is limited to 10).</p>

<p>However; I spent 10 minutes trying to decipher your code and still don't really know what it thinks it's doing - there's no comments at all and the variable names and function names don't help (e.g. <code>no</code> is not a boolean ""yes/no"" variable, <code>checkprocess()</code> doesn't check one process but checks all processes to see if all processes have finished, etc). Mostly, if I were being paid to fix this code I'd simple throw it out and rewrite it from scratch to save time. I thought about rewriting it from scratch and just posting the resulting code; but that's not going to help you with your homework.</p>

<p>My advice is, rewrite it from scratch instead of fixing it.</p>

<p>It should have a global <code>currently_running_process</code> variable, a global <code>current_time</code> variable, one function to increase the current time, and one function for the scheduler itself.</p>

<p>The function to increase the current time would:</p>

<ul>
<li>for each process on the scheduler's linked list, increase the waiting time</li>
<li>do <code>current_time++</code></li>
<li>find any processes that should be started (<code>current_time == arrival_time</code>) and append any started processes to the end of the scheduler's linked list</li>
</ul>

<p>The scheduler function should:</p>

<ul>
<li>remove the first process from the scheduler's linked list</li>
<li>determine how much time that process should use (the time slice length or the process' remaining time, whichever is lower)</li>
<li>subtract that amount of time from the process' remaining time</li>
<li>call the <code>increase_time()</code> function in a loop, until that amount of time has passed</li>
<li>if the process' remaining time is not zero; put the process back onto the end of the linked list</li>
<li>if the process` remaining time was zero, check if the scheduler's linked list is empty and exit the program if it is</li>
</ul>

<p>Note: I'd start with <code>current_time = -1;</code> and call the function to increase the current time once before calling the scheduler function; so that any processes with <code>arrival_time == 0</code> would be added to the scheduler's linked list before the scheduler starts working (and so that the scheduler function doesn't see an empty list as soon as it's started).</p>
"
"<pre><code>/* The following code doesn't take the arrival time of the processes in account.
                              HAPPY CODING */
#include&lt;stdio.h&gt;
void main()
{
int b[10],br[10],wo[10];
int n,i,bt,q,count;
float awt=0,att=0;
for (i=0;i&lt;10;i++)
     wo[i]=0;
printf(""Input the nmbr of processes running...."");
scanf(""%d"",&amp;n);
printf(""\n Input their burst tym in order.."");
for(i=0;i&lt;n;i++)
    scanf(""%d"",&amp;b[i]);
printf(""\n Input the quantum time for the algorithm.."");
scanf(""%d"",&amp;q);
for(i=0;i&lt;n;i++)
    br[i]=b[i];
bt=0;
for(i=0;i&lt;n;i++)
    bt=bt+b[i];
count=0;
printf(""\nThe Gantt Chart is as follows:\n"");
printf(""\n 0"");
do
{
for(i=0;i&lt;n;i++)
{
  if(br[i]==0)
   {}
  else
  {
   if(br[i]&gt;=q)
   {
     br[i]=br[i]-q;
     if(br[i]==0)
        wo[i]=count;
     count=count+q;
     printf(""\t(P%d)"",i);
     printf(""\t%d"",count);
   }
   else
   {
     if(br[i]&lt;q)
    {
       count=count+br[i];
       br[i]=0;
       wo[i]=count;
       printf(""\t(P%d)"",i);
       printf(""\t%d"",count);
     }
   }
 }
}
}while(count&lt;bt);
for(i=0;i&lt;n;i++)
    awt=awt+(wo[i]-b[i]);
awt=awt/n;
printf(""\n The average waiting time is....%f"",awt);
for(i=0;i&lt;n;i++)
    att=att+wo[i];
att=att/n;
printf(""\n The average turnaround time is....%f"",att);
}
</code></pre>
"
"<p>You can use queue for doing the same, i am pasting a link which is written in ANSI CPP
You can check this link for more info. I was having same problem like you had but the code on the link helped me a lot it also contains many other Scheduling program but i extracted only round robin from it.
<a href=""http://www.codingdevil.com/2014/01/scheduling.html"" rel=""nofollow"">click here to see the code for round robin Scheduling</a></p>
"
"<h2>Round Robin Scheduling program in C</h2>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;

main(){

    int i, j, k, n, so, tq, sob, sum, swt, stat, tata, temp, count;
    int bt[10], bth[10], wt[10], tat[10];
    float awt=0.0, atat=0.0;
    char new;

    // i = loop controller
    // j = loop controller
    // k = loop controller
    // n = number of process
    // so = (burst time holder divided by time quantum) and added by one
    // tq = time quantum
    // awt =average waiting time
    // new = hold the value of start command
    // sob = gantt chart size from so
    // swt = summation of waiting time              l
    // bt[] = burst time
    // wt[] = waiting time
    // atat = average turn around time
    // gcps = gantt chart process sequence
    // stat = summation of turn around time
    // tata = accumulator of turn around time
    // temp = time quantum holder
    // count = counter
    // bth[] = burst time holder
    // tat[] = turn around time



    printf(""\n\n\n\n   To start round robin scheduling press any key: "");

    k = 0;
    new = getche();
    system(""cls"");

    while(k &lt; 7){

        j = 0; sob = 0; count = 0; sum = 0; swt = 0; stat = 0; tata = 0;

        printf(""\n\n\n\t\t\t      ROUND-ROBIN SCHEDULING"");
        printf(""\n\t\t\t      ======================"");
        printf(""\n\n\n\n\n   Enter number of processes: "");
        scanf(""%d"", &amp;n);
        printf(""\n"");

        for(i = 0; i &lt; n; i++){

            printf(""\n   Enter burst time for Process P%d: "", i+1);
            scanf(""%d"", &amp;bt[i]);
            bth[i] = bt[i];
        }

        printf(""\n\n   Enter time quantum: "");
        scanf(""%d"", &amp;tq);
        system(""cls"");
        printf(""\n\n\n\t\t\t      ROUND-ROBIN SCHEDULING"");
        printf(""\n\t\t\t      ======================"");
        printf(""\n\n\n\n\n   Time quantum: %d"", tq);

        for(i = 0; i &lt; n; i++){

            if(bth[i] % tq == 0){

                so = bth[i] / tq;
            }
            else{so = (bth[i] / tq) +1;}
            sob = sob + so;
        }

        int gc[sob], gcps[sob];

        while(1){

            for(i = 0,count = 0; i &lt; n; i++){

                temp = tq;
                if(bth[i] == 0){

                    count++;
                    continue;
                }

                if(bth[i] &gt; tq){

                    gc[j] = tq;
                    gcps[j] = i+1; j++;
                    bth[i] = bth[i] - tq;
                }

                else if(bth[i] &gt;= 0){

                    if(bth[i] == tq){gc[j] = tq; gcps[j] = i+1; j++;}
                    else{gc[j] = bth[i]; gcps[j] = i+1; j++;}
                    temp = bth[i];
                    bth[i] = 0;
                }

                tata = tata + temp;
                tat[i ]= tata;
            }

            if(n==count){

                break;
            }
        }

        for(i = 0; i &lt; n; i++){

            wt[i] = tat[i] - bt[i];
            swt = swt + wt[i];
            stat = stat + tat[i];
        }

        awt = (float)swt/n;
        atat = (float)stat/n;

        printf(""\n\n   Process   Burst time   Waiting time   Turn around time\n"");
        printf(""   -------   ----------   ------------   ----------------\n"");

        for(i = 0; i &lt; n; i++){

            printf(""\n\n      P%d\t %d\t       %d \t        %d"", i+1, bt[i], wt[i], tat[i]);
        }

        printf(""\n\n\n\n   Gantt Chart:\n"");
        printf(""   ------------\n\n"");
        for(j = 0; j &lt; sob; j++){

            printf(""\tP%d"", gcps[j]);
        }
        printf(""\n   0"");
        for(j = 0; j &lt; sob; j++){

            sum = sum + gc[j];
            if(j == 0){printf(""        %d"", sum);}
            else{printf(""\t    %d"", sum);}
        }
        printf(""\n\n\n\n   Average waiting time: %.2f \n\n   Average turn around time: %.2f"",awt,atat);
        printf(""\n\n\n\n   To start again press S and to exit press any key: "");

        new = getche();
        system(""cls"");

        if(new == 'S'|| new == 's'){k++;}
        else{printf(""\n\n\n   Program was terminated successfully\n\n   Thank you\n\n\n""); break;}

    }

}
</code></pre>
"
"<p>This code will read data from file whose format should have one process info in a single line, <em>arrival time</em>, <em>burst time</em>, spaced, and file should terminate with  -1. File name and time slice must be passed in command arguments. Like:</p>

<pre><code>0 3
1 2
2 1
-1
</code></pre>

<p>The code is in C and variable names are self-descriptive.</p>

<pre><code>#include&lt;stdio.h&gt;

int main(int argc, char *argv[])
{
int flag = 0;

int timeSlice = atoi(argv[2]);

printf(""%d\n\n"", timeSlice);

int arrivalTime[10], burstTime[10], responseTime[10], finishTime[10];
int remainingProcesses, processCount = 0;

FILE * file = fopen(argv[1], ""r"");

if (!(file == NULL))
{
    while (fscanf(file, ""%d"", &amp;arrivalTime[processCount]))
    {
        if (arrivalTime[processCount] == -1)
            break;

        fscanf(file, ""%d"", &amp;burstTime[processCount]);

        responseTime[processCount] = burstTime[processCount];

        processCount++;
    }

    remainingProcesses = processCount;

    fclose(file);
}

printf(""Process\t|  Arrival time\t|  Finish Time\t|     Burst\t|   Turnaround\t|\n"");
printf(""-------------------------------------------------------------------------\n"");

int i = 0; int time = 0;

while (remainingProcesses != 0)
{
    if (responseTime[i] &lt;= timeSlice &amp;&amp; responseTime[i]&gt;0)
    {
        time += responseTime[i];
        responseTime[i] = 0;
        flag = 1;
    }
    else if (responseTime[i] &gt; 0)
    {
        responseTime[i] -= timeSlice;
        time += timeSlice;
    }

    if (responseTime[i] == 0 &amp;&amp; flag == 1)
    {
        finishTime[i] = time;
        remainingProcesses--;

        printf(""P[%d]\t|\t%d\t|\t%d\t|\t%d\t|\t%d\t|\n"", i + 1, arrivalTime[i], finishTime[i], burstTime[i], finishTime[i] - arrivalTime[i]);
        flag = 0;
    }


    if (i == processCount - 1) // If its the last process go back to slicing process 1
    {
        i = 0;
    }

    else if (arrivalTime[i + 1] &lt;= time) // If the next process has kicked in
    {
        i++;
    }

    else // If the process haven't kicked in yet
    {
        time++;
        i = 0;
    }
}

return 0;
}
</code></pre>
"
"<p><code>i_zone[0]</code> through <code>i_zone[6]</code> store the addresses of 7 data blocks.  These are ""direct"" blocks.</p>

<p><code>i_zone[7]</code> stores the address of a block which itself stores the addresses of 512 data blocks.  This is an ""indirect"" block.</p>

<p><code>i_zone[8]</code> stores the address of a block which itself stores the address of 512 indirect blocks, which each store the addresses of 512 data blocks.  This is a ""double indirect"" block.</p>
"
"<p>The string returned by <code>ctime</code> ends with a newline. See <code>ctime(3)</code>.</p>

<p>Also, you're trying to modify the string returned by <code>ctime</code>, which is a static buffer used by the C library. This can lead to a buffer overflow.</p>
"
"<p>How about</p>

<pre><code>fprintf(lf, ""%.*s %s\n"", strlen(time_string) - 1, time_string, activity);
</code></pre>

<p>The <code>%.*s</code> will will remove the trailing new-line of time_string since the specified precision is the string length - 1.</p>
"
"<p>From <a href=""http://linux.die.net/man/3/ctime"" rel=""nofollow"">man ctime</a>:</p>

<blockquote>
  <p>The call <code>ctime(t)</code> is equivalent to <code>asctime(localtime(t))</code>.
  It converts the calendar time <code>t</code> into a null-terminated string of the form
      <strong>""Wed Jun 30 21:49:08 1993\n""</strong> </p>
</blockquote>

<p>so a <code>\n</code> character is included in the resulting string. You must remove the new line character:</p>

<pre><code>char* nl = strrchr(time_string, '\n');
if (nl) *nl = '\0';
</code></pre>

<p>Also worth noting, from the same linked reference page:</p>

<blockquote>
  <p>The return value points to a statically allocated string which might be overwritten by subsequent calls to any of the date and time functions.</p>
</blockquote>

<p>This is important for the reason stated <em>and</em> it is unknown how large that buffer is so using it as the target in a <code>strcat()</code> is unsafe due to possible buffer overrun. Instead of performing a <code>strcat()</code> remove the new line character and perform two writes to the file; one for the <code>time_string</code> and one for the <code>activity\n</code>.</p>
"
"<pre><code>void write_log(char *activity)
{

     FILE *lf;
     time_t current_time;
     char *time_string;
     int length = 0;
     char *line = NULL;

     current_time = time(NULL);
     time_string = ctime(&amp;current_time);
     length = strlen(time_string) + strlen(activity) + 1;
     line = (char *)malloc(length);
     if(line){
        memset(line,'\0',length);
        strncpy(line,time_string, strlen(time_string)-1);
        strcat(line,"" "");
        strcat(line,activity);
        lf = fopen(""logs1.txt"", ""a+"");
        fprintf(lf, ""%s\n"", line);
        fclose(lf);
        free(line);
     }
 }
</code></pre>
"
"<p>Yo do:</p>

<ol>
<li>Take the current time in start_time.</li>
<li>Perform your job</li>
<li>Take the current time in end_time</li>
<li>Wait for (1 second + start_time - end_time)</li>
</ol>

<p>That way, you can perform your tasks every seconds reliably. If the task takes less time, you will wait longer and vice versa. Note however that this assumes that your task takes always less than 1 sec. to execute. In the real code, you want to check for that before the sleep statement.</p>

<p>Implementation details depend on the platform.</p>

<p>Note that using this method still results in a small drift due to the time it takes to compute step 4. A more accurate alternative would be to synchronize on integer multiple of one second. That way, over 1000s of cycles you would not drift. </p>

<p>It depends on the level of accuracy you need.</p>
"
"<p>If you want a brute, easy to code solution, you can get the time before first run of the function and save it in some variable (start_time). Create repeat index count variable (repeat_number) that stores next repeat number. Then you can do kinda this:</p>

<pre><code>1) next_run_time = ++repeat_number*1sec + start_time;
2) func();
3) wait_time = next_run_time - current_time;
4) sleep(wait_time)
5) goto 1;
</code></pre>

<p>This approach disables accumulation of time error on each iteration.</p>

<p>But for the real application you should find some event framework or library.</p>
"
"<p>Copy <a href=""http://read.pudn.com/downloads182/sourcecode/comm/849441/maodv-code/node.h__.htm"" rel=""nofollow"">node.h</a> to the directory </p>

<blockquote>
  <p>ns-allinone-2.35/ns-2.35/common</p>
</blockquote>

<p>As the function is defined in the ""node.h"" of MAODV code but not in simple ""node.h"" that is already present.</p>
"
"<p>I have done a few assignments in networking and one thing that i noticed it is that it wouldn't work the way you are trying to. We have to complete a send-receive for the server to receive again and there are other factors that prevent us from doing it ... from MTUs to buffer sizes etc. I have used is <a href=""http://www.netperf.org/netperf/"" rel=""nofollow"">netperf</a> to benchmark bandwidths before[is this the speed you are talking about ?]. The code is open source.</p>
"
"<p>On the server, when you receive the first data from the client, record the current time to a variable.  </p>

<p>Also on the server, whenever you receive data from the client, add the number of bytes received to a counter variable.</p>

<p>Then at any time you want, you can calculate the cumulative average bytes-per-second speed of the connection by calculating (total_bytes_received)/(current_time - first_data_received_time);   (Watch out for a potential divide by zero if current_time and first_data_received_time are equal!)</p>

<p>If you want to do something more elaborate, like a running average over the last 10 seconds, that's a little more involved, but computing the cumulative average is pretty easy.</p>
"
"<p>Your approach is good. You can do something like this:</p>

<pre><code>#include &lt;time.h&gt;

void http_post(const char *vzuuid)
{
  static time_t last_time = 0;
  time_t cur_time;

  cur_time = time(NULL);
  if (cur_time - last_time &lt; 10)
    return; /* nothing to do */

  last_time = cur_time;

  /* ... */
}
</code></pre>

<p>I do not use a global, but a static variable, to hold the last time of last request.</p>
"
"<p>I all of you variable are going to be static then it makes sense to have to member functions static. However if not than you should not have all static functions. If you want it to be thread safe than you should also lock for all the functions. I think you may also want to implement the singleton design pattern.<a href=""http://en.wikipedia.org/wiki/Singleton_pattern"" rel=""nofollow"">http://en.wikipedia.org/wiki/Singleton_pattern</a></p>
"
"<p>I finally decided do this, I think this is much safer and useful</p>

<pre><code>  struct bad_event_scheduling : std::logic_error
  {
     bad_event_scheduling() :
         std::logic_error(""bad_event_scheduling"") {}
  };

  template &lt;class Clock&gt;
   class simulator
   {
      public:

        using clock = Clock;
        using time_point = typename clock::time_point;
        using duration = typename clock::duration;
        using event_type = event&lt;clock&gt;;

      private:

       using calendar_type = std::priority_queue&lt;event_type,
                             std::vector&lt;event_type&gt;, later_event&gt;;

      public:

        void reset()
        {
          CurrentTime = time_point();
          EventsList = calendar_type();
        }

        time_point current_time() const noexcept
        {
           return CurrentTime;
        }

        ///Constructs an event ""in-place"" and inserts it in the events list
        template &lt;typename... OtherArgs&gt;
         void schedule(const time_point&amp; et, OtherArgs&amp;&amp;... other_args_)
         {
           if(et &lt; CurrentTime) throw bad_event_scheduling();
           EventsList.emplace(et, std::forward&lt;OtherArgs&gt;(other_args_)...);
         }

      bool has_pending_events() const noexcept
      { return not EventsList.empty(); }


      ///Advances the clock until the next event time and then the event
      ///is performed, if the events list was empty the behavior is undefined.
      void next_event()
      {
         auto Event = EventsList.top();
         EventsList.pop();
         CurrentTime = Event.time();
         Event.perform();
      }

      ///Calls next_event() while the events list is not empty.
      void simulate()
      { while (has_pending_events()) next_event();}


      ///if t &gt;= current_time(), performs all of events whose time is scheduled
      ///before or just at the moment t, and then advances the current time until t.

      void simulate_until(const time_point&amp; t)
      {
        if( t &gt;= CurrentTime)
        {
          while(has_pending_events() and EventsList.top().time() &lt;= t)
            next_event();
          CurrentTime = t;
        }
      }

      void simulate_for(const duration&amp; d)
      {  simulate_until(CurrentTime + d); }

      private:

        calendar_type EventsList;
        time_point CurrentTime;
   };
</code></pre>
"
"<p>The error message is clear.</p>

<blockquote>
  <p>no match for 'operator==' in 'receiver_iface == 169082900'</p>
</blockquote>

<p>means, the compiler does not understand what you mean by <code>==</code> in</p>

<pre><code>receiver_iface == 169082900
</code></pre>

<p>That is, it does not know how to compare <code>receiver_iface</code> and <code>169082900</code>.</p>

<p><code>receiver_iface</code> is of type <code>nsaddr_t</code> (whatever that is) and <code>169082900</code> is of type <code>int</code>.</p>

<p>So you should define the following function before the code that causes the error:</p>

<pre><code>bool operator== (const nsaddr_t &amp;left, int right)
{
    // whatever you consider appropriate
}
</code></pre>
"
"<p>That is a blocking read, i.e. it won't return from the function until the read has succeeded.</p>

<p>If no data is waiting, it will block for a very long time.</p>

<p>You need to use e.g. <a href=""http://linux.die.net/man/2/select"" rel=""nofollow noreferrer""><code>select()</code></a> to detect when data is available, or <a href=""https://stackoverflow.com/questions/10794999/enable-non-blocking-socket"">make the socket non-blocking</a>.</p>

<p>Also, if your packet rate is going to be 1,000 Hz, that is (way) too fast for this kind of application, in general.</p>
"
"<p>U are probably using a 64 bit pc</p>

<p>At Noxim_explorer.cpp</p>

<p>change </p>

<p>///////////////////////////////</p>

<p>uint pos;</p>

<p>pos = line.find(RPACKETS_LABEL);</p>

<p>///////////////////////////////</p>

<p>to ...</p>

<p>///////////////////////////////</p>

<p>std::size_t pos = line.find(RPACKETS_LABEL);</p>

<p>///////////////////////////////</p>

<p>It should work .. and generate the matlab file</p>
"
"<p>The <a href=""http://www.cplusplus.com/reference/ctime/tm/"" rel=""nofollow""><code>struct tm</code></a> contains member <code>tm_wday</code> that holds the day of the week, where 0 is sunday and 6 is saturday. </p>
"
"<p>Could you not encapsulate your weekday image-changing code so that you could then create a set of Saturday image-changing code and Sunday image-changing code, and then branch to the proper set of image-changing code when entering this routine by determining the day of the week and then branching appropriately.</p>
"
"<p>Unless you are implementing some synchronization mechanism or could guarantee somehow atomic read and write, I think you are calling for race condition and subtle bugs here.</p>

<p>Imagine the ""reader"" accessing the file whereas the ""writer""  hasn't completed its write cycle. There is a risk of reading incomplete/inconsistent data. In ""modern"" systems, you could also hit the cache -- and not seeing file modifications ""live"" as they appends.</p>
"
"<p>I can think of two possible solutions:</p>

<ol>
<li>You forgot the parentheses on the close in the else of the infinite loop.<br />
<code>infile.close</code> --> <code>infile.close()</code></li>
<li>The program that is changing the JSON file is not closing the file, and therefore it is not actually changing.</li>
</ol>
"
"<p><strong>Two problems I see:</strong></p>

<ol>
<li>Are you sure your file is really updated on filesystem? I do not know on what operating system you are playing with your code, but caching may kick your a$$ in this case, if the files is not flushed by <em>producer</em>.</li>
<li>Your problem is worth considering <em>pipe</em> instead of file, however I cannot guarantee what <code>transmission</code> will do if it stuck on writing to pipe if your <em>consumer</em> is dead.</li>
</ol>

<p>Answering your problems, consider using one of the following:</p>

<ul>
<li><a href=""http://pyinotify.sourceforge.net/"" rel=""nofollow"">pynotifyu</a></li>
<li><a href=""http://pypi.python.org/pypi/watchdog/0.5.4"" rel=""nofollow"">watchdog</a></li>
<li><a href=""http://pypi.python.org/pypi/watcher"" rel=""nofollow"">watcher</a></li>
</ul>

<p>These modules are intended to monitor changes on filesystem and then call proper actions. Method in your example is primitive, has big performance penalty and couple other problems mentioned already in other answers.</p>
"
"<p>Ilya, would it help to check(<strong>os.path.getmtime</strong>), whether <em>stats.json</em> changed before you process the file?</p>

<p>Moreover, i'd suggest to make advantage of the fact it's JSON file:</p>

<pre><code>import json
import os
import sys

dir_name ='/home/klaus/.config/transmission/'
# stats.json of daemon might be elsewhere

file_name ='stats.json'
full_path = os.path.join(dir_name, file_name)

with open(full_path) as fp:
    json.load(fp)
    data = json.load(fp)
    print data['uploaded-bytes']
</code></pre>
"
"<p>Thanks for all the answers, unfortunately my error was in the shell, and not in the script with Python.</p>

<p>The cause of the problem turned out to be the way I was putting the script in the background. I was doing: <code>Ctrl+Z</code> which I thought would put the task in the background. But it does not, <code>Ctrl+Z</code> only suspends the task and returns you to the shell, a subsequent <code>bg</code> command is necessary for the script to run on infinite loop in the background</p>
"
"<p>It seems like the obvious structure would be something like this:</p>

<pre><code>while (current_time &lt; end_time) {
    current_number = *next_number++;
    if (meets_conditions(current_number))
       output(current_number);
}
</code></pre>
"
"<p>The signature to return <B>struct string_vars</B> as out parameter would be as following</p>

<pre><code>&lt;method name=""req_meta_data""&gt;
    &lt;arg type=""s"" name=""song_path"" direction=""in""&gt;
    &lt;arg type=""(ssssxx)"" name=""label_data"" direction=""out""&gt;
&lt;/method&gt;
</code></pre>

<p>I removed the additional <B>""i""</B>.</p>

<p>Now coming to your problem, looks like your build system is configured to autogenerate server side stubs from dbus introspection file named ""value-dbus-music.xml"". <BR>Configure build system to look for correct XML file.</p>
"
"<p>Use something like this:</p>

<pre><code>function delete_all($filename) {
    // files listed in this array will not being deleted
    $exceptions = array (
        'file1',
        'file2', ...
    );

    if(!in_array($filename, $exceptions)) {
        unlink($filename);
    }
}

// !!! attention !!! this will delete all files except those listed above
// from this folder. Make sure you know what you are doing
array_map('delete_all', glob(""path/to/temp/*""));
</code></pre>
"
"<blockquote>
  <p>read the class structure, you will get some useful features</p>
</blockquote>

<pre><code>&lt;?php
// this will call your given callback with the file or folder informations, so you can use your logic to delete/copy/move the file/folder
// note: this is a recursive function
$literator  = new ipDirLiterator(
  ""your/path/to/root/or/anyfolder/"", // for getting root path, you can use $_SERVER[""DOCUMENT_ROOT""]
  array(
    ""file""  =&gt;  function( $file ) { // your callback to delete files
      if ( basename( $file[""pathname""] ) !== basename( __FILE__ ) ) {
        unlink( $file[""pathname""] );
      }
    }
  ),
  true
);

class ipDirLiterator {
  protected $basepath   = false;
  protected $callbacks  = false;

  protected $checked    = array();

  public function __construct( $basepath = false, $callbacks = false, $init = false ) {
    $this-&gt;basepath   = ( $basepath ) ? realpath( $basepath ) : false;
    $this-&gt;callbacks  = $callbacks;
    if ( $init ) {
      $this-&gt;literate();
    }
  }

  public function literate( $dir = false ) {
    if ( !$this-&gt;basepath ) {
      return false;
    }
    if ( $dir === $this-&gt;basepath ) {
      return false;
    }
    if ( !$dir ) {
      $dir  = $this-&gt;basepath;
    }

    $dir  = realpath( $dir );

    if ( strstr( $dir, basename( $this-&gt;basepath ) ) === false ) {
      return false;
    }
    if ( in_array( $dir, $this-&gt;checked ) ) {
      return false;
    }

    $this-&gt;checked[]  = $dir;
    $items  = new DirectoryIterator( $dir );

    foreach( $items as $item ) {
      if ( $item-&gt;isDot() ) {
        if ( $item-&gt;getFilename() === "".."" ) {
          $this-&gt;literate( dirname( $item-&gt;getPath() ) );
        }
        $this-&gt;callback( ""dot"", $this-&gt;info( $item ) );
        continue;
      }
      if ( $item-&gt;isFile() || $item-&gt;isLink() ) {
        $this-&gt;callback( ""file"", $this-&gt;info( $item ) );
      }
      if ( $item-&gt;isDir() &amp;&amp; !$item-&gt;isLink() ) {
        $this-&gt;literate( $item-&gt;getPathname() );
        $this-&gt;callback( ""dir"", $this-&gt;info( $item ) );
      }
    }
  }

  private function info( $item ) {
    $info = array(
      ""filename""  =&gt;  $item-&gt;getFilename(),
      ""extension"" =&gt;  pathinfo( $item-&gt;getFilename(), PATHINFO_EXTENSION ),
      ""pathname""  =&gt;  $item-&gt;getPathname(),
      ""path""  =&gt;  $item-&gt;getPath(),
      ""readable""  =&gt;  (bool)$item-&gt;isReadable(),
      ""writable"" =&gt;  (bool)$item-&gt;isWritable(),
      ""executable""  =&gt;  (bool)$item-&gt;isExecutable(),
      ""created_on"" =&gt;  $item-&gt;getCTime(),
      ""last access"" =&gt;  $item-&gt;getATime(),
      ""modified_on"" =&gt;  $item-&gt;getMTime(),
      ""inode"" =&gt;  $item-&gt;getInode(),
      ""permissions"" =&gt;  $item-&gt;getPerms(),
      ""is_dir"" =&gt;  (bool)$item-&gt;isDir(),
      ""is_dot"" =&gt;  (bool)$item-&gt;isDot(),
      ""type""  =&gt;  $item-&gt;getType(),
      ""group"" =&gt;  $item-&gt;getGroup(),
      ""owner"" =&gt;  $item-&gt;getOwner(),
      ""size""  =&gt;  $item-&gt;getSize()
    );
    return $info;
  }

  private function callback( $callback = ""file"", $args = null ) {
    if ( $this-&gt;callbacks ) {
      if ( isset( $this-&gt;callbacks[$callback] ) ) {
        call_user_func( $this-&gt;callbacks[$callback], $args );
      }
    }
  }
}
?&gt;
</code></pre>

<p>Detailed example:  </p>

<pre><code>&lt;?php
/**
 * It will recursively go through the all directories and files under the directory you have given.
 * Here we are going to delete all the files order than 1 hour
**/
/**
 * Path to the folder you want to process
**/
$basepath = ""any/path/to/files/or/folder/"";
/**
 * Callbacks
**/
$file_callback  = function( $file /* information of current file in the loop */ ) { // your callback for files
  $modified_time  = filemtime( $file[""pathname""] );
  $current_time   = time();
  $time_differnce = ( $current_time - $modified_time );
  if ( $time_differnce &gt; 3600 ) {
    unlink( $file[""pathname""] );
  }
};
$folder_callback  = function( $file /* information of current folder in the loop */ ) { // your callback for folders
  // proceess your folder here
};
/**
 * Initialize the class
**/
$literator  = new ipDirLiterator( $basepath, array( ""file"" =&gt; $file_callback, ""dir"" =&gt; $folder_callback ) );
$literator-&gt;literate();
?&gt;
</code></pre>
"
"<p>There may be some misconceptions on how <a href=""http://linux.die.net/man/2/time"" rel=""nofollow""><code>time()</code> works</a>: </p>

<ol>
<li>epoch time as given by <code>time()</code> is expressed in seconds, not millseconds</li>
<li><p>time returns the current time value and can optionally set current time in the variable given as its sole argument.  This means that</p>

<p>long currentSystemTime = time(&amp;currentSellingTime); </p></li>
</ol>

<p>will set both <code>currentSystemTime</code> and <code>currentSellingTime</code> to the current time, and that's probably not what you intend to do...  You should probably do</p>

<pre><code>long currentSystemTime = time(NULL);
</code></pre>

<p>or</p>

<pre><code>time(&amp;currentSellingTime);
</code></pre>

<p>but the ""double form"" you are using is quite suspicious.  For completeness' sake the <a href=""http://msdn.microsoft.com/en-us/library/1f4c8f33%28v=vs.100%29.aspx"" rel=""nofollow"">MS Help reference for time()</a></p>
"
"<p>You want to use another function, as as previously pointed out, <code>time()</code> returns seconds. Try:</p>

<pre><code>#include &lt;time.h&gt;


long current_time() {
    struct timespec t;
    clock_gettime(CLOCK_REALTIME, &amp;t);

    return t.tv.sec * 1000l + t.tv_nsec / 1000000l;
}
</code></pre>

<p>Your code should work then. This approach is also POSIX compatible. Example usage:</p>

<pre><code>const long TTL = 100;
long start_time = current_time();

while (!(current_time() &gt; start_time + TTL))
{
    // do the stuff that can expire
}
</code></pre>

<p>note: I know that the condition in the  <code>while</code> loop can be constructed differently, but this way it is more like ""until not expired"".</p>
"
"<p>//i think it should be like this:</p>

<pre><code>if (dbDate &lt; CurrentDate) {
    $(""#updateTrainingButton"").hide();
    $(""#sendInvitationButton"").hide();
    $(""#cancelTrainingButton"").hide();
}else if(dbDate == CurrentDate){
    if ((end_Time[0].end_time) &lt; Current_Time) {
        $(""#updateTrainingButton"").hide();
        $(""#sendInvitationButton"").hide();
        $(""#cancelTrainingButton"").hide();
    }
}
</code></pre>
"
"<p>This is a function that might help you:</p>

<pre><code>from datetime import datetime
from os import path
from glob import glob
from time import time as current_time

def get_files(pattern, start=0, end=None):
    """"""
    returns a list of all files in pattern where the files creation date is between start and end
    pattern = the pattern to retrieve files using glob
    start = the start date in seconds since the epoch (default: 0)
    end = the end date in seconds since the epoch (default: now)
    """"""
    start = datetime.fromtimestamp(start)
    end = datetime.fromtimestamp(current_time() if end is None else end)
    result = []
    for file_path in glob(pattern):
        if start &lt;= datetime.fromtimestamp(path.getctime(file_path)) &lt;= end:
            result.append(file_path)
    return result
</code></pre>

<p>Example:</p>

<pre><code>&gt;&gt;&gt; get_files('C:/Python27/*')
['C:/Python27\\DLLs', 'C:/Python27\\Doc', 'C:/Python27\\include', 'C:/Python27\\Lib', 'C:/Python27\\libs', 'C:/Python27\\LICENSE.txt', 'C:/Python27\\NEWS.txt', 'C:/Python27\\python.exe', 'C:/Python27\\pythonw.exe', 'C:/Python27\\README.txt', 'C:/Python27\\tcl', 'C:/Python27\\Tools']
</code></pre>
"
"<p>This is sort of a duplicate question, but I'll try to answer it here anyway to the best of my ability.</p>

<p>The sleep function is an OS call that differs from busy wait in that it doesn't block the thread. If you have a multi-threaded script though, it shouldn't block the other threads.
The sleep function is inaccurate in Windows because it is not a realtime OS (not sure what that means). If you are looking strictly for accuracy of the wait, busy wait is the way to go. Otherwise, <code>time.sleep()</code> is probably preferred. The reason the OS call to sleep is inaccurate is probably because it relies on the OS to return at the correct time, and is reliant on the precision of the OS's scheduler.</p>
"
"<p>On Windows the OS Sleep function (which Python necessarily uses) can only wake up a thread on a multiple of the current timer interval. Typically this ranges between 1.0 ms and 15.6 ms. Lowering the timer interval can be handy because it allows for shorter sleeps, but it wastes electricity, as I wrote about in this article:</p>

<p><a href=""http://randomascii.wordpress.com/2013/07/08/windows-timer-resolution-megawatts-wasted/"" rel=""nofollow"">http://randomascii.wordpress.com/2013/07/08/windows-timer-resolution-megawatts-wasted/</a></p>

<p>Busy waiting may give better accuracy but is generally a horrible idea since it wastes even more electricity and steals CPU time from more deserving tasks:</p>

<p><a href=""https://randomascii.wordpress.com/2012/06/05/in-praise-of-idleness/"" rel=""nofollow"">https://randomascii.wordpress.com/2012/06/05/in-praise-of-idleness/</a></p>

<p>Finally, the accuracy of busy waiting will depend on what timer function you are using to get the current time, and may also depend on the timer interval:</p>

<p><a href=""https://randomascii.wordpress.com/2013/05/09/timegettime-versus-gettickcount/"" rel=""nofollow"">https://randomascii.wordpress.com/2013/05/09/timegettime-versus-gettickcount/</a></p>

<p>Why do you want to sleep for such short time periods? Usually it would be better to wait for something to happen -- waiting on an event -- rather than waiting for such short time periods.</p>
"
"<p>The srand function has unsigned int as a type of argument, time_t is long type. the upper 4 bytes from long are stripped out, but there's no problem in it.
srand will randomize the rand algorithm with 4 lower bytes of time, so you're supplying more data than is needed.</p>

<p>if you get an error, try to just explicitly cast the time_t type to unsigned int:</p>

<pre><code>srand( (unsigned int) time(NULL) );
</code></pre>

<p>Another interesting thing is that if you run your program twice in the same second, you'll get the same random number, which can be sometimes undesired, that's because if you seed the rand algorithm with the same data, it will generate the same random sequence. Or it can be desirable when you debug some piece of code and need to test the same behaviour again... then you simply use something like <code>srand(123456)</code></p>
"
"<blockquote>
  <p>""implicit conversion loses integer precision: 'time_t' (aka 'long') to 'unsigned int'""</p>
</blockquote>

<p>You're losing precision implicitly because <code>time()</code> returns a <code>long</code> which is larger than an <code>unsigned int</code> on your target.  In order to workaround this problem, you should explicitly cast the result (thus removing the ""implicit precision loss""):</p>

<pre><code>srand( static_cast&lt;unsigned int&gt;(time(NULL)));
</code></pre>

<hr>

<p>Given that it's now 2017, I'm editing this question to suggest that you consider the features provided by <code>std::chrono::*</code> defined in <code>&lt;chrono&gt;</code> as a part of C++11.  Does your favorite compiler provide C++11?  If not, it really should!</p>

<p>To get the current time, you should use:</p>

<pre><code>#include &lt;chrono&gt;

void f() {
    const std::chrono::time_point current_time = std::chrono::system_clock::now();
}
</code></pre>

<p><strong>Why should I bother with this when <code>time()</code> works?</strong></p>

<p>IMO, just one reason is enough: clear, explicit types.   When you deal with large programs among big enough teams, knowing whether the values passed around represent time intervals or ""absolute"" times, and what magnitudes is critical.  With <code>std::chrono</code> you can design interfaces and data structures that are portable and skip out on the is-that-timeout-a-deadline-or-milliseconds-from-now-or-wait-was-it-seconds blues.</p>
"
"<p>This is <strong>not</strong> an error. The code is valid and its meaning is well defined; if a compiler refuses to compile it, the compiler does not conform to the language definition. More likely, it's a <strong>warning</strong>, and it's telling you that the compiler writer thinks that you might have made a mistake. If you insist on eliminating warning messages you could add a cast, as others have suggested. I'm not a big fan of rewriting valid, meaningful code in order to satisfy some compiler writer's notion of good style; I'd turn off the warning. If you do that, though, you might overlook other places where a conversion loses data that you didn't intend.</p>
"
"<p>As mentioned by ""nio"", a clean workaround would be to explicitly type cast.</p>

<p><strong>Deeper explanation:</strong></p>

<p>The srand() requires an unsigned int as parameter (<code>srand(unsigned int)</code>) but time() returns a long int (<code>long int time()</code>) and this is not accepted by the srand() so in order to fix this, the compiler has to simply typecast (convert) the ""long int"" to ""unsigned int"".</p>

<p>BUT in your case the compiler warns you about it instead  (as the designers of the compiler thought you should be aware that's all).</p>

<p>So a simple </p>

<p><code>srand( (unsigned int) time(NULL) );</code></p>

<p>will do the trick!</p>

<p>(forgive me if i have done something wrong, this is my first answer on stackoverflow)</p>
"
"<pre><code>#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;         //rand
#include &lt;time.h&gt;       //time

float randomizer(int VarMin, int VarMax){
    srand((unsigned)time(NULL));
        int range = (VarMax - VarMin);
        float rnd = VarMin + float(range*(rand()/(RAND_MAX + 1.0)));
return rnd;
}
</code></pre>
"
"<p>If you want an accurate age calculation based on the current date, then you should try something like:</p>

<pre><code>where date_of_birth between date(now()) - interval 30 years and date(now()) - interval 25 year
</code></pre>

<p>In this case, you are <em>not</em> doing any transformation of <code>date_of_birth</code>, so an index can be used for the query.</p>

<p>Also, you shouldn't use expressions like:</p>

<pre><code>DATE_FORMAT(current_time, '%Y') - DATE_FORMAT(date_of_birth, '%Y')
</code></pre>

<p><code>DATE_FORMAT()</code> converts the argument to a string.  You want a number, so just use:</p>

<pre><code>year(now()) - year(date_of_birth)
</code></pre>

<p>It saves the conversion from a date to a string to an int and just goes directly to an int.</p>

<p>EDIT:</p>

<p>To handle the case of ""25"" really meaning ""up to 26"", implement the logic with explicit comparisons:</p>

<pre><code>where date_of_birth &gt;= date(now()) - interval 30 years and
      date_of_birth &lt; date(now()) - interval 26 year
</code></pre>
"
"<p>It's not really about the performance of UDFs or stored procedures. Whenever you use a function around a column MySQL cannot use indexes on it. </p>

<p>If you don't expect Highlander to be in your database a tinyint unsigned column for age will be enough (0-255). This costs 1 byte / row. You can put an index on it. The overhead what this column adds to the table is insignificant. Don't be afraid of storage space. Storage performance on the other hand is much bigger concern. A full scan search costs much more than this 1 byte extra column.</p>

<p>You can update this column with a trigger on the date_of_birth column. And of course if you put proper indexes on the table the nightly cronjob can efficiently select the row where date_of_birth = DATE(NOW()) and increase the age by one. (I would do this with a stored procedure so everything could be done in MySQL).</p>

<p>ps.: The function you wrote seems to be a stored function rather not a UDF. Stored function are written in SQL and stored in MySQL. UDF are written in C compiled to .so or .dll files and loaded to MySQL. For more info you can check: <a href=""https://stackoverflow.com/questions/5888527/help-with-sp-and-udf"">Help with SP and UDF?</a></p>
"
"<p>This is a simple example to how use infiniband, I hope it can help u:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/select.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;

#define AF_INET_SDP 27


typedef struct
{
    pthread_attr_t threadattr;
    pthread_t threadid;
    int seq;
    int  fd;
    double sendbytes;
    double runtimes;
}CLIENTTHREADPARA;

CLIENTTHREADPARA * g_pClientThreadPara;


void signal_func(int no);
int SetSignal();

int g_listensock;
int g_bIsExit=0;

int g_packetsize;
int g_totalthread;
char * g_szIp;
int g_iPort;
int g_nDelayUsecs;

pthread_mutex_t g_mutex;


typedef struct
{
    pthread_attr_t threadattr;
    pthread_t threadid;
    int fd;
}THREADDATA;

static double time_so_far();
void * ThreadProc(void * pPara);
int RunServ(int iPort);
int RunClient(char * Ip,int iPort);
void * ClientThreadProc(void * pPara);

int main(int argc,char * argv[])
{
    int iPort;
    int thread_nums;

    SetSignal();

    if(argc != 3 &amp;&amp; argc!=6)
    {
        goto err_out;
    }

    g_packetsize=atoi(argv[1]);

    if(argc==3)
    {
        iPort=atoi(argv[2]);
        if(iPort==0)
        {
            printf(""socket port can not zero\n"");
            return -1;
        }
        RunServ(iPort);
    }
    else if(argc==6)
    {
        g_szIp=argv[2];
        g_iPort=atoi(argv[3]);
        g_totalthread=atoi(argv[4]);
        g_nDelayUsecs=atoi(argv[5]);
        RunClient(argv[2],iPort);
    }
    return 0;

err_out:
    printf(""For Server: sdptest &lt;packet size&gt; &lt;port&gt;\n"");
    printf(""For Client: sdptest &lt;packet size&gt; &lt;ip&gt; &lt;port&gt; &lt;thread_nums&gt; &lt;delay microsecond&gt;\n"");
    return -1;
}

int RunClient(char * Ip,int iPort)
{
    int i;
    pthread_mutex_init(&amp;g_mutex, (pthread_mutexattr_t *)0);

    g_pClientThreadPara=(CLIENTTHREADPARA *)malloc(sizeof(CLIENTTHREADPARA)*g_totalthread);
    for(i=0;i&lt;g_totalthread;i++)
    {
        g_pClientThreadPara[i].seq=i;
        pthread_attr_init(&amp;g_pClientThreadPara[i].threadattr);
        pthread_create(&amp;g_pClientThreadPara[i].threadid, &amp;g_pClientThreadPara[i].threadattr,ClientThreadProc,(void *)&amp;g_pClientThreadPara[i]);
    }

    double sendbytes = 0;
    double pre_sendbytes=0;
    double pre_time = time_so_far();
    double current_time = time_so_far();

    while(!g_bIsExit)
    {
        sleep(1);
        pthread_mutex_lock(&amp;g_mutex);
        sendbytes = g_pClientThreadPara[0].sendbytes;
        pthread_mutex_unlock(&amp;g_mutex);
        current_time = time_so_far();
        printf(""speed is %10.2fMbytes/s,\n"",(sendbytes - pre_sendbytes)/1024/1024/(current_time - pre_time));
        pre_sendbytes = sendbytes;
        pre_time = current_time;
    }

    for(i=0;i&lt;g_totalthread;i++)
    {
        pthread_join(g_pClientThreadPara[i].threadid, NULL);
    }

    double totalspeed=0;
    double totaltimes=0;

    for(i=0;i&lt;g_totalthread;i++)
    {

        totalspeed+=(double)g_pClientThreadPara[i].sendbytes/g_pClientThreadPara[i].runtimes;
    }
    printf(""speed is %10.2fMbytes/s,total times is %.2f seconds\n"",totalspeed/1024/1024,totaltimes/g_totalthread);
}

void * ClientThreadProc(void * pPara)
{

    CLIENTTHREADPARA * pThreadPara= (CLIENTTHREADPARA *)pPara;

    struct sockaddr_in  sin;
    int nRet;
    double starttime,endtime;
    int cnt_per_usec;
    char * buf;

    memset(&amp;sin,0,sizeof(sin));
    sin.sin_family=AF_INET_SDP;
    sin.sin_port=htons(g_iPort);

    if((sin.sin_addr.s_addr = inet_addr(g_szIp)) == INADDR_NONE)
    {
        printf(""Ip address %s is invalid!\n"",g_szIp);
        return (void *)-1;
    }

    pThreadPara-&gt;fd = socket(AF_INET_SDP,SOCK_STREAM,0);
    if(pThreadPara-&gt;fd &lt; 0)
    {
        perror(""Create socket error"");
        return (void *)-1;
    }

    nRet=connect(pThreadPara-&gt;fd,(struct sockaddr *)&amp;sin,sizeof(sin));
    if(nRet&lt;0)
    {

        printf(""Can't connect to %s:%d\n"",g_szIp,g_iPort);
        perror(""sock error:"");
        close(pThreadPara-&gt;fd);
        return (void *)-1;
    }

    buf=malloc(g_packetsize);
    starttime=time_so_far();

    pThreadPara-&gt;sendbytes=0;
    while(!g_bIsExit)
    {
        nRet=send(pThreadPara-&gt;fd,buf,g_packetsize,0);
        if(nRet&lt;=0)
        {
            if(errno==EINTR)
            {
                continue;
            }
            else
            {
                printf(""thread %d "",pThreadPara-&gt;seq);
                perror(""sock error:"");
                break;
            }
        }
        else
        {
            pthread_mutex_lock(&amp;g_mutex);
            pThreadPara-&gt;sendbytes+=nRet;
            pthread_mutex_unlock(&amp;g_mutex);
        }
        if (g_nDelayUsecs&gt;0)
        {
            usleep(g_nDelayUsecs);
        }
    }
    endtime=time_so_far();
    pThreadPara-&gt;runtimes=endtime-starttime;
    close(pThreadPara-&gt;fd);
    free(buf);
    //printf(""speed is %10.2fM/s\n"",g_totalbytes/1024/1024/(endtime - starttime));
    return (void *)0;
}

int RunServ(int iPort)
{
    struct sockaddr_in my_addr;
    struct linger li;
    int nRet;
    int fromclientfd;

    //0.init
    memset ((char *)&amp;my_addr, 0, sizeof(struct sockaddr_in));
    my_addr.sin_family = AF_INET_SDP;
    my_addr.sin_port = htons(iPort);
    my_addr.sin_addr.s_addr = htonl(INADDR_ANY);

    //1.create
    g_listensock = socket(AF_INET_SDP, SOCK_STREAM, 0);
    if (g_listensock==-1)
    {
        return -1;
    }

    li.l_onoff = 1;
    li.l_linger = 0;

    int option=1;
    setsockopt(g_listensock,SOL_SOCKET, SO_REUSEADDR, (char*)&amp;option, sizeof(option));
    setsockopt(g_listensock,SOL_SOCKET, SO_LINGER, (char *) &amp;li, sizeof(li));

    //2.bind
    nRet = bind(g_listensock, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr));
    if (nRet==-1)
    {
        printf(""bind %d port error\n"",iPort);
        return -1;
    }

    //3.listen
    nRet = listen(g_listensock, 10);
    if (nRet==-1)
    {
        printf(""listen in port %d error!\n"",iPort);
        return -1;
    }

    struct sockaddr_in from;
#if AIX || Linux
        socklen_t fromlen=sizeof(from);
#else
        int fromlen=sizeof(from);
#endif


    li.l_onoff = 1;
    li.l_linger = 3;
    while(!g_bIsExit)
    {
        fromclientfd = accept(g_listensock,(struct sockaddr *)&amp;from,&amp;fromlen);
        if (fromclientfd==-1)
        {
            close(g_listensock);
            printf(""server is stoped.\n"");
            break;;
        }

        setsockopt(fromclientfd,SOL_SOCKET, SO_LINGER, (char *) &amp;li, sizeof(li));
        THREADDATA * pThreadData=(THREADDATA *)malloc(sizeof(THREADDATA));
        pThreadData-&gt;fd=fromclientfd;
        pthread_attr_init(&amp;pThreadData-&gt;threadattr);
        pthread_create (&amp;pThreadData-&gt;threadid, &amp;pThreadData-&gt;threadattr,ThreadProc,(void *)pThreadData);
    }
}

void * ThreadProc(void * pPara)
{
    THREADDATA * pThreadPara;
    pThreadPara=(THREADDATA *)pPara;
    int nRet;
    char * buf;
    double starttime,endtime;
    double totalbytes;

    buf=malloc(g_packetsize);
    if(buf==NULL)
    {
        close(pThreadPara-&gt;fd);
        printf(""Canot not allocate memory!\n"");
        return 0;
    }

    nRet=1;
    starttime=time_so_far();
    totalbytes=0;
    while (nRet&gt;0 &amp;&amp; !g_bIsExit)
    {
        nRet=recv(pThreadPara-&gt;fd ,buf,g_packetsize,0);
        if (nRet&lt;=0)
        {
            break;
        }
        totalbytes+=nRet;
    }
    endtime=time_so_far();
    free(buf);
    free(pThreadPara);
    printf(""speed is %10.2fM/s\n"",totalbytes/1024/1024/(endtime - starttime));
    return 0;
}

static double time_so_far()
{
#if defined(SysV)
    int        val;
    struct tms tms;

    if ((val = times(&amp;tms)) == -1)
    {
        printf(""Call times() error\n"");
    }
    return ((double) val) / ((double) sysconf(_SC_CLK_TCK));

#else

    struct timeval tp;

    if (gettimeofday(&amp;tp, (struct timezone *) NULL) == -1)
    {
        printf(""Call gettyimeofday error\n"");
    }
    return ((double) (tp.tv_sec)) +
           (((double) tp.tv_usec) / 1000000.0);
#endif
}


int SetSignal()
{
    signal(SIGHUP, signal_func);
    signal(SIGQUIT, signal_func);
    signal(SIGBUS, SIG_DFL);

    signal(SIGURG,signal_func);

    signal(SIGPIPE,SIG_IGN);

    signal(SIGABRT,SIG_IGN);

    signal(SIGTRAP,SIG_IGN);

    signal(SIGILL,signal_func);
    //signal(SIGSEGV,signal_func);

    //signal(SIGCHLD,SIG_IGN)

    signal(SIGTERM,signal_func);
    signal(SIGINT, signal_func); //Ctrl+C

    return 0;
}


void signal_func(int no)
{
    switch (no)
    {
    case 1:
        printf(""Receive signal SIGHUP.\n"");
        break;
    case SIGINT:
        close(g_listensock);
        //printf(""Receive Ctrl+C or signal SIGINT, server is stoping....\n"");
        g_bIsExit=1;
        break;
    case SIGTERM:
        close(g_listensock);
        printf(""Receive kill signal,server is stoping...\n"");
        g_bIsExit=1;
        break;
    case SIGQUIT:
        printf(""Receive SIGQUIT signal.\n"");
        break;

    case SIGABRT:
        close(g_listensock);
        printf(""Receive SIGABRT signal.\n"");
        break;

    case SIGILL:
        printf(""Receive SIGILL signal.\n"");
        break;

    case SIGSEGV:
        close(g_listensock);
        printf(""Receive SIGSEGV signal.\n"");
        g_bIsExit=1;
        break;

    case SIGPIPE:
        printf(""Receive SIGPIPE signal.\n"");
        break;

    default:
        printf(""Receive %d sigial!\n"",no);
        break;
    break;
    }
}
</code></pre>
"
"<p>Use <code>date +%s</code> to get Unix time - the number of seconds since 00:00:00 Coordinated Universal Time (UTC), Thursday, 1 January 1970 - and then use arithmetic expansion:</p>

<pre><code>current_time=$(date +%s)
elapsed_time=$(( $(date +%s) - $current_time ))
</code></pre>

<p><code>$elapsed_time</code> is then the number of seconds since <code>$current_time</code>. You can then check if <code>$elapsed_time &gt; 600</code> in your loop.</p>

<p><strong>Edit:</strong> For completeness:</p>

<pre><code>if [[ $elapsed_time &gt; 600 ]]; then
   echo ""sorry 10 min was ended""
fi
</code></pre>

<p>This should work in both bash and ksh.</p>
"
"<p><code>bash</code> has something like a built-in timer. The parameter <code>$SECONDS</code> is updated continuously with the number of seconds elapsed since the shell was started. You can assign to this variable, in which case its value is essentially incremented each second.</p>

<p>Some examples:</p>

<pre><code>$ SECONDS=0
$ sleep 10
$ echo $SECONDS
10

$ SECONDS=0
$ while (( SECONDS &lt; 600 )); do
&gt;  sleep 10
&gt; done
</code></pre>
"
"<p>Since <code>time(NULL)</code> returns the time in seconds from the <a href=""http://en.wikipedia.org/wiki/Unix_epoch"" rel=""nofollow"">epoch (usually the Unix epoch)</a> i.e. <strong>00:00:00 UTC on 1 January 1970 (or 1970-01-01T00:00:00Z ISO 8601)</strong>:</p>

<pre><code>#include &lt;time.h&gt;
#include &lt;stdio.h&gt;

time_t current_time;
time_t tenMinutesAgo;

int main() {
  char* c_time_string;
  current_time = time(NULL);
  tenMinutesAgo = current_time - 10*60;//the time 10 minutes ago is 10*60

  c_time_string = ctime(&amp;tenMinutesAgo);//convert the time tenMinutesAgo into a string format in the local time format

  printf(""The time 10 minutes ago in seconds from the epoch is: %i\n"", (int)tenMinutesAgo);
  printf(""The time 10 minutes ago from the epoch in the local time format is: %s\n"", c_time_string);

  return 0;
}
</code></pre>

<p>EDIT:</p>

<p>@PaulGriffiths makes a good point in that my solution isn't guaranteed to be portable. If you want portability, then check his answer. <strong>But</strong>, if you're writing code on any of most popular OS flavors (*nix, Solaris, Windows), this solution will work.</p>
"
"<p>The first answer is not guaranteed to be portable, since the C standard does not require that <code>time_t</code> be measured in seconds. </p>

<p><code>time_t</code> is a real type, though, so you can do arithmetic on it, and this does give us a route to do it. You can set up two <code>struct tm</code>s a second apart:</p>

<pre><code>struct tm first;
struct tm second;
time_t ts_first;
time_t ts_second;
double sec_diff;

first.tm_year = 100;
first.tm_mon = 0;
first.tm_mday = 2;
first.tm_hour = 1;
first.tm_minute = 20;
first.tm_second = 20;
first.tm_isdst = -1;

second.tm_year = 100;
second.tm_mon = 0;
second.tm_mday = 2;
second.tm_hour = 1;
second.tm_minute = 20;
second.tm_second = 21;
second.tm_isdst = -1;
</code></pre>

<p>turn them into <code>time_t</code> values:</p>

<pre><code>ts_first = mktime(&amp;first);
if ( ts_first == -1 ) {
    /* Do your error checking  */
}

ts_second = mktime(&amp;second);
if ( ts_second == -1 ) {
    /* Do your error checking  */
}
</code></pre>

<p>call <code>difftime()</code> on them:</p>

<pre><code>sec_diff = difftime(ts_second, ts_first);
</code></pre>

<p>and then you can multiply <code>sec_diff</code> by the number of seconds you want, and subtract that from the value returned by <code>time</code>. </p>

<p>Of course, if your available system time resolution is greater than one second, this won't work, and you could try changing the <code>tm_min</code> member instead since you're looking for minutes, but this'll be pretty unlikely.</p>
"
"<p>The problem is in the server code:</p>

<pre><code>n=write(newfd,buff,sizeof(buff));
</code></pre>

<p>should be</p>

<pre><code>n=write(newfd,buff,strlen(buff) + 1);
</code></pre>

<p><code>sizeof(buff)</code> will not return the length of <code>buff</code>, but the size of its type. <code>buff</code> is a pointer, so <code>sizeof(buff)</code> will be equal to 4 (this is your case I guess) or 8, depending on your system.</p>

<p>If <code>sizeof(buff) == 4</code>, you will send the first 4 characters of <code>buff</code>, which will be '<code>Fri</code>' (notice the space, which is a character too).</p>

<p><code>strlen()</code> will return you the length of the string, and that's what you want.</p>

<p><strong>EDIT:</strong> <em>alk</em>'s comment is right : You can have some trouble with <code>read</code>. See <em>ZanLynx</em>'s comment on the question.</p>
"
"<p>Couple of problems, path has no memory allocated (you're writing stuff to some random memory address which is bad). You also should check the return values of <code>fwrite</code> <code>fopen</code> for errors. If there is one use <code>perror</code> so you know what the problem is. It's likely the fopen is failing or you're corrupting your stack by writing to <code>path</code>.</p>

<p>Also use <code>snprintf</code> it's much safter than just <code>sprintf</code> which is vulnerable to buffer overflow.</p>

<p>EDIT: just saw your comment that it's c++. Why not use <code>std::string</code> and <code>fstream</code> instead? They are much safer than what you're currently doing (and probably easier).</p>
"
"<p>Your MAIN problem is that <code>char * path;</code> has no memory assigned to it. This means that you are writing to some RANDOM [1] location in memory. </p>

<p>I would suggest that you use <code>char path[PATH_MAX];</code> - that way you don't have to worry about allocating and later deallocating the storage for your path. </p>

<p>Alternatively, you could use:</p>

<pre><code>stringstream ss;

ss &lt;&lt; DATA_DIR &lt;&lt; currentDateTime() &lt;&lt; "".log"";
string path = ss.str();
fopen(path.c_str(), ""wb+"")
</code></pre>

<p>which is a more C++ style solution. </p>

<p>[1] By random, I don't mean truly a random number, but some unknown value that happens to be in that location on the stack. It is almost always NOT a good place to store a string. </p>
"
"<p>Your debugger isn't smart enough to evaluate time(NULL), there isn't any fix except don't type 'time(NULL)' into the expressions window.</p>
"
"<p>You can try:</p>

<pre><code>  time_t timer;
  time(&amp;timer);  /* get current time; same as: timer = time(NULL)  */
</code></pre>

<p>example from <a href=""http://www.cplusplus.com/reference/ctime/time/"" rel=""nofollow"">here</a></p>
"
"<p>To apply the formula you need a constant acceleration or you need to know the average acceleration over the period of time between sensor readings.   The sensor in your phone gives you the instantaneous acceleration, but it does not integrate that value over time, so this technique is unlikely to generate accurate speed values.</p>

<p>The other effect you are seeing -- changing values when the device is stationary -- may well be the normal noise in real-world sensors.  They rarely behave exactly the way they theory says they should, so the signals need to be conditioned (smoothed, scaled, calibrated, etc.) </p>
"
"<p>Find command should solve your problem, did you give a try?</p>

<pre><code>$ find . -mmin 10 -print
</code></pre>

<p>-mmin n (modification time in minutes)</p>
"
"<p>To know if <code>somefile</code> was modified in the last ten minutes, you can run this command:</p>

<pre><code>file=somefile
if [ -n $(find . -name $file -mmin +10 2&gt;/dev/null) ]; then
    echo "" $file was just modified""
else
    echo "" $file stayed unchanged""
fi
</code></pre>
"
"<p><code>prod_file</code> not initialized.</p>

<pre><code>// int threadid = pthread_self ( );
pthread_t threadid = pthread_self ( );

// prod_file not initialized
// FILE *prod_file ;
FILE *prod_file = stdout;

// fprintf(prod_file,""thread %d is ... \n"",threadid,...);
fprintf(prod_file,""thread %lX is ... \n"",(unsigned long) threadid);
</code></pre>

<p>Output</p>

<pre><code>thread 80051EE0 is producing donuts of type :1 , serial number of donut: 78
thread 80051EE0 is producing donuts of type :0 , serial number of donut: 83
thread 80051EE0 is producing donuts of type :2 , serial number of donut: 82
thread 80051EE0 is producing donuts of type :1 , serial number of donut: 79
thread 80051EE0 is producing donuts of type :1 , serial number of donut: 80
thread 80051EE0 is producing donuts of type :3 , serial number of donut: 96
thread 80051EE0 is producing donuts of type :0 , serial number of donut: 84
thread 80051EE0 is producing donuts of type :0 , serial number of donut: 85
Elapsed consumer time is 5 sec and 335063 usec


 ALL CONSUMERS FINISHED, KILLING  PROCESS
</code></pre>

<hr>

<p>Other</p>

<p>1 Problem <em>really</em> should have been reduced before posting.</p>

<p>2 Could use better formatting.</p>

<p>3 Lots of unused variables.</p>

<p>4</p>

<pre><code>// rand_donuts = nrand48 ( xsub1 ) &amp; 3
rand_donuts = nrand48 ( xsub1 ) % NUMFLAVORS

// char fileid[10];
// char cons_filename[10]=""cons_"";
char fileid[3*sizoef(int) + 3];  // Big enough for any int
// char cons_filename[5 + sizeof fileid]=""cons_"";
</code></pre>
"
"<p>The last argument of select is the amount of time to wait for events in the file descriptor set. You could use that to wait for a predefined period of time for events, say 100 ms. If that timeout passed without any events being received, select will return 0 and no descriptors will be set.</p>

<p>Now you need to think about what an 'active' connection means from the perspective of the server. Normally, you should keep a separate timestamp for each fd of when data was last <em>received</em> on that connection. Sending can happen without any problem and does not indicate the connection is still active.</p>

<p>So the code should be structured like this - some rough pseudocode:</p>

<pre><code>select with timeout
did select return 0:
  (this means that no data was received for the timeout on any descriptor)
  (this is the place to check if any descriptor went past its 'active' limit)
  iterate over all fds:
    if last_received_timestamp[current_fd] + deadline &gt; current_time:
      remove fd or do something else
else:
  (there is something to read)
  iterate over descriptors in readfds:
    read data and process it
    last_received_timestamp[current_fd] = current_time
</code></pre>

<p>Hope this helps.</p>

<p>Additional information:</p>

<p>If you want a more uniform way of dealing with this, try looking into timerfd_create. That can be used to create timers that look like file descriptors and so you can use select for them to get notified of certain events. For example, you can create one such timerfd for each normal fd you have and have it set to expire when the deadline is reached. The key here is to rearm the timer whenever you receive data.</p>

<p>A classic problem with single threaded loops like this that wait for events then process all of them sequentially is that if the server becomes too busy or if data processing for a connection takes too much, all connections will see delays. A better architecture is to use a thread pool for handling reading/writing on sockets. This frees up the event loop and gives better response times for all clients. However, this is more complex and probably outside the scope of what you are trying to achieve.</p>
"
"<p>Unless you do the rounding in your application layer, do not expect MySQL to be smart enough to use the query cache. <a href=""http://dev.mysql.com/doc/refman/5.1/en/query-cache-operation.html"" rel=""nofollow"">Any query that includes NOW() (and many other functions) will never be cached.</a></p>

<p>That said, if you do compute the nearest hour in the application layer, it should work fine.</p>
"
"<p>If you have query that cannot be cached, you can split it into two simpler queries. The first query will return row IDs based on non-cacheable functions; the second query will do the rest. So at least the second query will be cached.</p>

<p>Using your example, you can make two queries:</p>

<ol>
<li>SELECT ID FROM table WHERE appointment_date >= NOW();</li>
</ol>

<p>... so your application will collect IDs. If there are any IDs returned, combine them to a coma-separated string and run the second query:</p>

<ol start=""2"">
<li>SELECT * FROM table WHERE ID IN ("".$ids."");""</li>
</ol>

<p>Of course, your query is quite simple, but if you have very complex and large queries, you can split them programmatically. For example, you may use a regular expression and a function to find out whether the query is non-cacheable and it is worth splitting it. For example, you can use the following PHP function for that purpose:</p>

<pre><code>function query_cannot_be_cached($query)
{
  return preg_match(""/\b(?:AES_DECRYPT|AES_ENCRYPT|BENCHMARK|CONNECTION_ID|CONVERT_TZ|CURDATE|CURRENT_DATE|CURRENT_TIME|CURRENT_TIMESTAMP|CURRENT_USER|CURTIME|DATABASE|ENCRYPT|FOUND_ROWS|GET_LOCK|IS_FREE_LOCK|IS_USED_LOCK|LAST_INSERT_ID|LOAD_FILE|MASTER_POS_WAIT|NOW|PASSWORD|RAND|RANDOM_BYTES|RELEASE_ALL_LOCKS|RELEASE_LOCK|SLEEP|SYSDATE|UNIX_TIMESTAMP|USER|UUID|UUID_SHORT)\b *\(/i"", $query);
}
</code></pre>

<p>Another solution is just to avoid server-side comparison (Now()) and use client-side comparison only. We use this approach in our server. If a query return just a few data, you can not split it. But if it returns lot of data split it as I have explained below. So your query will be like that:</p>

<ul>
<li>SELECT appointment_date, id FROM table;</li>
</ul>

<p>or you can set a date granularity (say, one month, one-day or one-hour) and add it to the comparison. This granular date should be calculated in advance by your software, for example: </p>

<ul>
<li>SELECT appointment_date, id FROM table WHERE appointment_date > '2017-05-10';</li>
</ul>

<p>(this '2017-05-10' value should be calculated by your software, it changes only once a day).</p>

<p>and then you receive the appointment_date and compare it with current time on client side. If the time matches, you run the second query as shown in the example #2 above.</p>

<p>Of course, these examples are very simple, we are using much more complex queries in our server.</p>
"
"<p>opencv output format is rgb, but vp8enc sink caps is follows :</p>

<pre><code> SINK template: 'sink'
    Availability: Always
    Capabilities:
      video/x-raw-yuv
                 format: I420
                  width: [ 1, 2147483647 ]
                 height: [ 1, 2147483647 ]
              framerate: [ 0/1, 2147483647/1 ]
</code></pre>

<p>You need to convert rgb -> yuv, I made convert yuv2rgb and back between opencv and gstreamer, If you need I can share my code with you.</p>
"
"<p>The problem here is that you set video/x-raw-rgb,width=640,height=480,framerate=0/1 as caps. That's not complete, you also need to provide the red, green and blue masks, the endianness and the alpha mask if this is ARGB. Check e.g. the ffmpegcolorspace sink template caps as an example and chose the correct format from that.</p>

<p>Also consider using GStreamer 1.x instead of the old and unmaintained 0.10 version. There it's also easier to specify the caps as it just has to be video/x-raw,format=ARGB,width=640,height=480,framerate=0/1 for this case (assuming it's ARGB and not BGRA or BGRx or whatever).</p>

<p>IIRC opencv uses RGB or RGBA.</p>
"
"<p>I believe the problem is because of an error in one of the following fields: the SQL query, not valid path used for storing the file or incorrect directory permissions where you want to store that file to.</p>

<p>For either of these errors you need to do a little bit debugging. First you need to enable error reporting in PHP, because it seems to be disabled in your case. Take a look at this question on how to enable it:
<a href=""https://stackoverflow.com/questions/1053424/how-do-i-get-php-errors-to-display"">How do I get PHP errors to display?</a>
<br><br>
Basically you can try inserting:<br></p>

<pre><code>error_reporting(E_ALL);&lt;br&gt;
ini_set('display_errors', 1);
</code></pre>

<p>at the beginning of your PHP code, right after the opening &lt;?php tag but it might not work for some situations so you better enable it in the php.ini file and then restart the web server.</p>

<p>Your php.ini should have</p>

<pre><code>display_errors = on
</code></pre>

<p>Then after you see what the real error is you'll be able to solve it really quickly.</p>
"
"<p>You <code>#define time (SEC_PER_DAY*180)</code>, then later you call `time(&amp;current_time);'</p>

<p>The preprocessor will expand</p>

<pre><code>time(&amp;current_time);
</code></pre>

<p>as per your <code>#define:</code>:</p>

<pre><code>(SEC_PER_DAY*180)(&amp;current_time);
</code></pre>

<p>and then</p>

<pre><code>(24*60*60*180)(&amp;current_time);
</code></pre>

<p>Note that this happens before the actual compiler sees anything (the preprocessor runs before the compiler).  So as far as the compiler is concerned, you're trying to call <code>24*60*60*180</code> = <code>15552000</code>.</p>
"
"<p>Your:</p>

<pre><code>#include &lt;time.h&gt;
</code></pre>

<p>is defining some time variable that you redefine with your </p>

<pre><code>#define time (SEC_PER_DAY*180)
</code></pre>

<p>and that's where the problem is, change that define name and it will work.</p>
"
"<p>The line <code>#define time (SEC_PER_DAY*180)</code> at the top causes all occurrences of the word ""<code>time</code>"" in the code to be replaced with <code>(SEC_PER_DAY*180)</code>, which then becomes <code>((24 * 60 * 60)*180)</code>, which evaluates to <code>15552000</code>.  Thus, when you try to call the <code>time</code> function later, what the compiler actually sees is <code>15552000(&amp;current_time)</code>, which is an error.  The solution is simple, and applies to all code, not just this case: <em>don't name anything after standard functions</em> ? change the <code>#define time</code> to use a different name.</p>
"
"<p>Updating the whole DB every <code>n</code> seconds is not a good idea. RDBMS in general (and Postgres specifically) are not designed for such loads.</p>

<p>Try updating the field only when you need them. something like:</p>

<ol>
<li>User wants to see the amount of gold.</li>
<li>System gets the <code>last_gold_amount</code> and <code>last_gold_updated</code> from DB.</li>
<li>System calculates <code>current_gold_amount = last_gold_amount + interest_rate * (current_time - last_gold_updated)</code></li>
<li>System stores <code>current_gold_amount</code> as <code>last_gold_amount</code> and stores <code>last_updated</code>.</li>
<li>Display <code>current_gold_amount</code> to user.</li>
</ol>

<p>Similar calculations can be performed for any ""currency"" you have.</p>

<p>Additionaly, step 4 can be performed only when user spends the currency or changes the interest rate to futher lower the load on DB.</p>

<p>Also, all the calculation can be hidden inside Postgres in a <code>VIEW</code> or set of stored procedures so that you can get/modify the amounth of ""currency"" with simple SQL queries.</p>
"
"<p>Your year should be an offset since 1900. That's most probably the culprit.</p>

<p>Try:</p>

<pre><code>licence_expiry_time_struct.tm_year = gtime_to / 10000 - 1900;
</code></pre>

<p>In general, when using <code>mktime()</code> it's highly recommended to start with a valid <code>tm</code> structure in the first place (i.e. by calling <code>localtime()</code>) and then changing the fields.</p>
"
"<p>You allocated a memory for temp but in the third line of function inserNode you assigned the address of addedNode into temp.</p>

<p>At the end of the function insertNode, you did the same thing with the global variable AlarmData where you allocated a memory for it but then assigned the address of head to AlarmData. In the end it is always the address of head that AlarmData ends up with, not a copy of head as you intended.</p>

<p>You should copy the contents of head to the allocated memory of AlarmData. Same with temp at the beginning of the code.</p>

<p>Note that pointers contain addresses, not values. Assigning a pointer address to another pointer is not the same as copying the values of the variables pointed by pointers.</p>
"
"<p>There are a few issues with your code.</p>

<pre><code>temp = (node*)malloc(sizeof(node));
head = AlarmData;
temp = addedNode;
</code></pre>

<p>In the above snippet you allocate memory for a new node and point <code>temp</code> at it. Two lines down you then point <code>temp</code> at <code>addedNode</code>. The memory you allocated in the first line is now lost, as you have overwritten your pointer to that memory. You probably intended to use <code>*temp = *addedNode</code> to copy the data in <code>addedNode</code> into <code>temp</code>.</p>

<p>You do not need to allocate a new node for <code>AlarmData</code> at the end of function. You simply need to update the AlarmData pointer to point to the new head (if head has indeed changed). </p>
"
"<p>Use fixed width print specifiers.</p>

<pre><code>#include &lt;inttypes.h&gt;
char buf[9];
sprintf(buf, ""%08"" PRIX32,total_cycles);
</code></pre>
"
"<p>Cast to an <code>int</code> or <code>unsigned</code> first. This is the type expected by <code>%X</code>:</p>

<pre><code>sprintf(str_cycles, ""%08X"", (unsigned) total_cycles);
</code></pre>
"
"<p>You should be getting an error because <code>str_cycles</code> is shown as <code>volatile char str_cycles;</code> (a single character).</p>

<p>You should be using <code>&lt;inttypes.h&gt;</code> and:</p>

<pre><code>char str_cycles[16];

snprintf(str_cycles, sizeof(str_cycles), ""%08"" PRIX32, total_cycles);
</code></pre>

<p>Generally, <code>snprintf()</code> should be preferred over <code>sprintf()</code>, but if you have enough space allocated it is perfectly OK to use <code>sprintf()</code>.</p>

<p>I'm not convinced about the <code>volatile</code> qualifier either; it is your job to determine why you have that and whether it is correct and whether it matters.  Generally, you do not want a volatile string; it makes using it unreliable. (This answer first omitted the <code>volatile</code> on <code>str_cycles</code>, then added it, and has now omitted it again.)</p>
"
"<p>Assuming that you posted the complete code - there is no implementation for:</p>

<pre><code>Integrator (const C&amp;, const T, const T,
        void (*)(const C&amp;, const T, C&amp;)); //Question: why use void(*) in place of void (*return_derivs)?
</code></pre>

<p>in the .hpp file you have provided. Since the <code>Integrator</code> is a class template, you either have to:</p>

<ol>
<li>Put the implementation in the header file (which will make the constructor inline)</li>
<li>Explicitly instantiate the <code>Integrator</code> class for some parameters, and implement the constructor for these specific arguments in the .cpp file.</li>
</ol>

<p>I'm guessing that you want the first option.</p>

<p>As for the question posted in the comment above - not entirely sure what you're asking. It's a declaration of a constructor that takes a pointer to function returning void and accepting <code>const C&amp;</code>, <code>const T&amp;</code>, and <code>C&amp;</code> as arguments. It seems that it would then be used to initialize return_derivs. How would you want to use a variable in a constructor that's supposed to set it?</p>
"
"<p>Boy, that CUJ paper was a long time ago! tsuki is right, you're missing an implementation of the Integrator base class. CUJ stopped publishing a long time ago, but their code archives are still available on the Dr Dobb's web site if you want to see our full code: <a href=""ftp://ftp.drdobbs.com/sourcecode/cuj/"" rel=""nofollow"">ftp://ftp.drdobbs.com/sourcecode/cuj/</a>. Our article appeared in the Nov. 2003 issue. I have also put our code up on my research web site: <a href=""http://people.uleth.ca/~roussel/data/"" rel=""nofollow"">http://people.uleth.ca/~roussel/data/</a>.</p>
"
"<p><code>tm_year</code> will set the year on the basis of the <code>1900</code>. (E.g <code>str_bday.tm_year = numbyear -1900;</code>) </p>

<p>also You should be checked as follows the return value of <code>mktime</code>.</p>

<pre><code>if(time_bday == (time_t)-1)
    printf(""error"");
</code></pre>

<p>It returns an error if a year earlier because it is based on the 1970 on many systems.</p>

<p>Must be processed as of the date yourself if such.</p>

<hr>

<p>Test code</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
int main(){
    struct tm str_bday = {0};
    time_t time_bday;

    str_bday.tm_year = 2012 - 1900;
    str_bday.tm_mon = 3 - 1;
    str_bday.tm_mday = 1;
    time_bday = mktime(&amp;str_bday);
    if(time_bday == (time_t)-1)
        printf(""error\n"");
    else
        printf(""%s\n"", ctime(&amp;time_bday));//Thu Mar 01 00:00:00 2012
    return 0;
}
</code></pre>
"
"<p>The problem is <code>strtok</code>, not <code>strrchr</code>. <code>strtok</code> puts a null byte after the token <em>in the original buffer</em>.</p>
"
"<p>Instead of strtok use sscanf to parse the string:</p>

<pre><code>int month = 0, day = 0, year = 0;
sscanf( birthday, ""%d/%d/%d"", &amp;month, &amp;day, &amp;year );
</code></pre>

<p>that way you don't mess up the argument</p>
"
"<pre><code>char* calcage(char *individual){
    time_t now = time(NULL);
    struct tm *local = localtime(&amp;now);

    char *temp = strdup(strrchr(individual, ',')+1);//make copy
    char *birthday = temp;
    int bmonth, bday, byear;
    bmonth = atoi(strtok(temp, ""/""));
    bday   = atoi(strtok(NULL, ""/""));
    byear   = atoi(strtok(NULL, ""/""));
    int age = local-&gt;tm_year + 1900 - byear -1;
    int lm = local-&gt;tm_mon + 1;
    if(bmonth &lt;= lm &amp;&amp; bday &lt;= local-&gt;tm_mday)
        ++age;
    int mtemp = lm - bmonth;
    if(mtemp &lt; 0 || mtemp == 0 &amp;&amp; bday &gt; local-&gt;tm_mday)
        mtemp += 12;
    int mage = age * 12 + mtemp;
    char *calculatedAge = realloc(temp, 50);
    snprintf(calculatedAge, 50, ""You are %d years and %d months old."", age, mage);
    return calculatedAge;
}
</code></pre>
"
"<p><code>%</code> in C is not modulus but remainder. Don't use it on signed types like <code>int</code> if you don't know what it is doing. Perhaps your worries would cease if you'd change your <code>int</code> members to <code>unsigned</code>. On <code>unsigned</code> you have a guarantee that <code>a % b</code> always falls in the range <code>0</code>..<code>b-1</code>.</p>
"
"<p>Try this:</p>

<pre><code>@echo off
set hour=%time:~0,2%
set min=%time:~3,2%

if %hour% GEQ 22 (
    xcopy /Y a\1.txt c\1.txt
) ELSE (
   if %hour% LEQ 3 (
       if %hour% EQU 3 if %min% GTR 30 (
           xcopy /Y b\1.txt c\1.txt
           goto :END
       )
       xcopy /Y a\1.txt c\1.txt
   ) ELSE (
       xcopy /Y b\1.txt c\1.txt
       goto :END
   )
)

:END
</code></pre>

<p>And I'm rather sure that will do what you want. Manual <code>if</code> statements for the win! Note it would be a lot easier if it was <code>22:00</code> to <code>4:00</code> or <code>3:00</code>. I had to incorperate the <code>:30</code> minute checker.</p>

<p>But yea, it might not work, so just check it before you put it up on your server.</p>

<p>Monacraft. </p>
"
"<pre class=""lang-dos prettyprint-override""><code>@echo off
    setlocal enableextensions disabledelayedexpansion

    set ""now=%time: =0%""

    set ""task=day""
    if ""%now%"" lss ""03:30:00,00"" ( set ""task=night"" )
    if ""%now%"" geq ""22:00:00,00"" ( set ""task=night"" )

    call :task_%task%

    endlocal
    exit /b

:task_day
    :: do daily task
    goto :eof

:task_night
    :: do nightly task
    goto :eof
</code></pre>

<p>EDITED - The previous code should work under the conditions in the original question. But will fail in different time configurations. This should solve the usual problems</p>

<pre class=""lang-dos prettyprint-override""><code>@echo off
    setlocal enableextensions disabledelayedexpansion

    call :getTime now

    set ""task=day""
    if ""%now%"" lss ""03:30:00,00"" ( set ""task=night"" )
    if ""%now%"" geq ""22:00:00,00"" ( set ""task=night"" )

    call :task_%task%

    echo %now%

    endlocal
    exit /b

:task_day
    :: do daily task
    goto :eof

:task_night
    :: do nightly task
    goto :eof

:: getTime
::    This routine returns the current (or passed as argument) time
::    in the form hh:mm:ss,cc in 24h format, with two digits in each
::    of the segments, 0 prefixed where needed.
:getTime returnVar [time]
    setlocal enableextensions disabledelayedexpansion

    :: Retrieve parameters if present. Else take current time
    if ""%~2""=="""" ( set ""t=%time%"" ) else ( set ""t=%~2"" )

    :: Test if time contains ""correct"" (usual) data. Else try something else
    echo(%t%|findstr /i /r /x /c:""[0-9:,.apm -]*"" &gt;nul || (
        set ""t=""
        for /f ""tokens=2"" %%a in ('2^&gt;nul robocopy ""|"" . /njh') do (
            if not defined t set ""t=%%a,00""
        )
        rem If we do not have a valid time string, leave
        if not defined t exit /b
    )

    :: Check if 24h time adjust is needed
    if not ""%t:pm=%""==""%t%"" (set ""p=12"" ) else (set ""p=0"")

    :: Separate the elements of the time string
    for /f ""tokens=1-5 delims=:.,-PpAaMm "" %%a in (""%t%"") do (
        set ""h=%%a"" &amp; set ""m=00%%b"" &amp; set ""s=00%%c"" &amp; set ""c=00%%d""
    )

    :: Adjust the hour part of the time string
    set /a ""h=100%h%+%p%""

    :: Clean up and return the new time string
    endlocal &amp; if not ""%~1""=="""" set ""%~1=%h:~-2%:%m:~-2%:%s:~-2%,%c:~-2%"" &amp; exit /b
</code></pre>
"
"<p>What should work:</p>

<pre><code>@echo off
:loop
set hour=%time:~0,2%
set min=%time:~3,2%

cls
ECHO %hour%
ECHO %min%
ECHO This %I%

IF %hour% == 14 GOTO Test2
goto loop

:Test2
IF %min% == 58 GOTO YUP
IF %min% == 59 GOTO LATE
Goto loop
:YUP
SET I=0
GOTO loop

:LATE
SET I=NOPE
GOTO loop
</code></pre>
"
"<p>You can use a timestamp provided through the date and time facilities of C++11. In particular, the <code>now()</code> function of the <code>std::chrono</code> namespace will return what you want:</p>

<pre><code>#include &lt;chrono&gt;

std::ostringstream oss;
oss &lt;&lt; ""myfile"" &lt;&lt; std::chrono::system_clock::now() &lt;&lt; "".txt"";
//                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

std::ofstream out(oss.str(), std::ios_base::app);
</code></pre>
"
"<p>Try something like this:</p>

<pre><code>std::time_t t = std::time(NULL);
std::tm *ptm = std::localtime(&amp;t);
std::stringstream ss;
ss &lt;&lt; ptm-&gt;tm_year+1900 &lt;&lt; std::setw(2) &lt;&lt; ptm-&gt;tm_mon+1 &lt;&lt; ptm-&gt;tm_mday &lt;&lt; ptm-&gt;tm_hour+1 &lt;&lt; ptm-&gt;tm_min+1 &lt;&lt; ptm-&gt;tm_sec+1;
outfile.open((""C:/Users/Admin/Documents/MATLAB/datafile_""+ss.str()+"".txt"").c_str(), std::ios::app);
</code></pre>
"
"<p>Sure, you can do something like this:</p>

<pre><code>// Calculate the path
time_t current_time = time(nullptr);
std::ostringstream path_out(prefix);
path_out &lt;&lt; ""-"" &lt; &lt; current_time &lt;&lt; "".txt"";
std::string path = path_out.str();

// Open a file with the specified path.
std::ofstream out(path.c_str(), std::ios::app);

// do stuff with ""out""
</code></pre>

<p>That being said, if you are trying to use the time for the filename in order to create temporary files, then the solution you are looking for is likely platform-specific. On UNIX-based systems, <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/mkstemp.html"" rel=""nofollow"">mkstemp</a> is the preferred way to create temporary files (I'm not sure what the preferred way to do this is on Windows, but who cares ;)).</p>
"
"<pre><code>#include &lt;ctime&gt;
#include &lt;stdexcept&gt;
#include &lt;sstream&gt;

std::string getTimestampedFilename(const std::string &amp;basePathname) {
   std::ostringstream filename;
   filename &lt;&lt; basePathname &lt;&lt; '.' &lt;&lt; static_cast&lt;unsigned long&gt;(::time(0));
   return filename.str();
}
</code></pre>

<p>Now, you can use this elsewhere...</p>

<pre><code>template&lt;class T&gt;
void writeToFile(const std::string &amp;basePathname, T data) {
    std::string filename = getTimestampedFilename(basePathname);
    std::ofstream outfile(filename.c_str());

    if (outfile) {
       outfile &lt;&lt; data;
    }
    else {
       throw std::runtime_error(""Cannot open '"" + filename + ""' for writing."");
    }
}
</code></pre>
"
"<p>Here's code:</p>

<pre><code>time_t currentTime = time(0);
tm* currentDate = localtime(&amp;currentTime);
char filename[256] = {0};

strcpy(filename, ""C:/Users/Admin/Documents/MATLAB/datafile"");
strcat(filename, fmt(""-%d-%d-%d@%d.%d.%d.txt"",
       currentDate-&gt;tm_hour, currentDate-&gt;tm_min, currentDate-&gt;tm_sec,
       currentDate-&gt;tm_mday, currentDate-&gt;tm_mon+1,
       currentDate-&gt;tm_year+1900).c_str());

outfile.open(filename, std::ios::app);
</code></pre>

<p>tm* and time_t are in ctime header. fmt is just function like sprintf, which formats string. Implementation(not mine, found on stackoverflow IIRC):</p>

<pre><code>#include &lt;cstdarg&gt;
std::string fmt(const std::string&amp; fmt, ...) {
    int size = 200;
    std::string str;
    va_list ap;
    while (1) {
        str.resize(size);
        va_start(ap, fmt);
        int n = vsnprintf((char*)str.c_str(), size, fmt.c_str(), ap);
        va_end(ap);
        if (n &gt; -1 &amp;&amp; n &lt; size) {
            str.resize(n);
            return str;
        }
        if (n &gt; -1)
            size = n + 1;
        else
            size *= 2;
    }
    return str;
}
</code></pre>
"
"<p><code>system_date</code> is <code>char *</code> in <code>main</code> and <code>struct tm system_date</code> in the function call.
Change the function call to</p>

<pre><code>int parse_system_date(char *system_date, date * parsed_date)
</code></pre>
"
"<p>localtime returns a pointer to the struct:</p>

<p><a href=""http://www.cplusplus.com/reference/ctime/localtime/"" rel=""nofollow"">http://www.cplusplus.com/reference/ctime/localtime/</a></p>
"
"<p>The function <code>localtime</code> is <a href=""http://www.cplusplus.com/reference/ctime/localtime/"" rel=""nofollow""><strong>documented</strong></a> to return a <code>struct tm*</code>  (that is, a Pointer to a Structure).</p>

<p>You are trying to assign that to variable <code>t</code>, which has type <code>struct tm</code> (note: no pointer in there).</p>

<p>You cannot assign a pointer to a non-pointer.</p>

<p>I recommend changing to:</p>

<pre><code>int parse_system_date(struct tm system_date, date * parsed_date) {
     struct tm* pt;
     [....]
     pt = localtime(&amp;ts);
</code></pre>

<hr>

<p>Now I'll leave it up to you to look up the documentation of <code>sscanf</code>, and YOU tell US what param #1 to <code>sscanf</code> should be, and what you are actually passing.</p>
"
"<p>As <code>man localtime</code> states:</p>

<blockquote>
  <p>struct tm *localtime(const time_t *timep);</p>
</blockquote>

<p>Your <code>t</code> in <code>t = localtime(&amp;ts)</code> is a <code>struct tm</code> not <code>struct tm*</code>, and <code>localtime</code> returns a pointer.</p>

<p>For second thing you didn't really show us how does <code>parsed_date</code> look (no definition of <code>date</code> structure). Also <code>system_date</code> is a <code>struct tm</code> then why would you expect it would be taken as <code>const char*</code> in <code>sscanf</code>?</p>
"
"<p>A working solution for you</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

/* Parses a system date structure 'system_date' into a structure date 'parsed_date'.*/
void parse_system_date(char* system_date, struct tm **parsed_date) {
     time_t ts;

     int ret;
     int year;
     int month;
     int day;

     ts = time(NULL);
     *parsed_date = localtime(&amp;ts);

     sscanf(system_date,""%d/%d/%d"",&amp;day,&amp;month,&amp;year);
     (*parsed_date)-&gt;tm_mday = day;
     (*parsed_date)-&gt;tm_mon = month + 1;
     (*parsed_date)-&gt;tm_year = year + 1900;

}

int main(){

   struct tm* t;
   char system_date[20]={'\0'};

   fgets(system_date, 20, stdin);
   parse_system_date(system_date, &amp;t);
   printf(""Today's date is: %s\ndd = %d, mm = %d, yy = %d\n"", system_date, t-&gt;tm_mday, t-&gt;tm_mon, t-&gt;tm_year);

return 0;
}
</code></pre>

<p>Input : 11/03/2014</p>

<p>Output: Today's date is: 11/03/2014</p>

<p>dd = 11, mm = 4, yy = 3914</p>

<p>I modified your code to get a meaningful output but I did not understand the requirement of your program. Because you have few unused variables and operations like, </p>

<pre><code> time_t ts;
 struct tm t;

 ts = time(NULL);
 t = localtime(&amp;ts);
</code></pre>

<p>and function signature also wrong.</p>
"
"<p>This program works just fine when I compile and run it.</p>

<p>The ""badly placed ()"" error is one of the shell, so I think you're not running the program correctly, but feeding the source code directly into the shell.</p>

<p>Also look at: <a href=""https://stackoverflow.com/questions/19753406/c-badly-placed-s"">C - Badly Placed ()&#39;s?</a></p>

<p>I've done this:<br />
- Put your code in stacko.c<br />
- Execute gcc -g -Wall stacko.c<br />
- Run program with ./a.out 10 1 2 10 10 3 7<br /></p>

<p>Output:</p>

<pre><code>[09:24:34]  Parent process started(process 11277).
[09:24:35]   ~First Child process started(process 11278). The process will last for 10 seconds.
[09:24:36]   ~Second Child process started(process 11279). The process will last for 10 seconds.
[09:24:36]   Second Child process ended(process 11279). iData is 11
[09:24:36]    Grand-Child process started(process 11280). The process will last for 7 seconds.
[09:24:43]    Grand-Child process ended(process 11280). iData is 11
[09:24:45]   ~First Child process ended(process 11278). iData is 11
[09:24:45]  Parent process ended(process 11277). iData is 11
</code></pre>
"
"<p>Did you try using -lglfw3? You are using glfw3, I would try that</p>
"
"<p>In my case after building glfw i've got file <code>libglfw.3.dylib</code> and when build my client code i've come with the similar link error. Solution was to rename dylib file to <code>lglfw.3.dylib</code>. I saw that previously for different libs, when cmake for some reason provide different lib name than expected. Hope that will help someone)</p>
"
"<p>In the above code it the break only breaks out of the while loop, so the while loop will break when x is non-zero, however the for-loop that is encasing it will increment and continue anyway, breaking only when loopcnt is 54 (above 53) at which point addr will always be 53.</p>
"
"<p>In your child, after the call to <code>execvp</code> you need to call <code>exit(EXIT_FAILURE);</code> instead of <code>return -1;</code>. Otherwise your child will continue running, and will interpret the next command (that is why you need to exit <code>N</code> times where <code>N</code> is the number of inexistant commands you tried to invoke).</p>

<p>After the change, your parent process will see that the child terminated with a non-zero return code and should interpret the error code. There is no real way to distinguish between a failure from the <code>execvp</code> (due to a non-existent command) or from the invoked process. I would recommend printing the error from <code>execvp</code> if there is one in the child before the <code>exit</code>.</p>

<p>Note that if <code>execvp</code> succeed, it will never return, so the code following a call to <code>execvp</code> can only be executed if the command failed.</p>

<p>So, my recommendation is doing this:</p>

<pre><code>if(child_pid == 0)
{
    int file;
    if(redirect_stdout == true)
    {
        file = open(argument[index + 1], O_WRONLY|O_CREAT|O_TRUNC, 0666);
        dup2(file, 1);
        edit_arguments(argument, index);
        execvp(argument[0], argument);
        perror(""execvp"");
        exit(EXIT_FAILURE);
    }
    else if(redirect_stderr == true)
    {
        file = open(argument[index + 1], O_WRONLY|O_CREAT|O_TRUNC, 0666);
        dup2(file, 2);
        edit_arguments(argument, index);
        execvp(argument[0], argument);
        perror(""execvp"");
        exit(EXIT_FAILURE);
    }

    execvp(argument[0], argument);
    perror(""execvp"");
    exit(EXIT_FAILURE);
}
else
{
    wait(&amp;child_status);
}
</code></pre>
"
"<p>You should be doing <code>exit(1);</code> or equivalent instead of <code>return(-1);</code>.  You might want to use <code>_exit(1);</code>, or <code>_exit(255);</code> (or <code>_exit(-1);</code>, but it is equivalent to <code>_exit(255);</code>).  You might well want to print an error message to standard error before you exit.</p>

<p>When you don't exit, you end up with two, then three, then N shells all trying to read input from the terminal.  You have to make each one quit separately by indicating EOF with <kbd>Control-D</kbd>.  If you tried typing commands, then it would become a lottery which shell gets each character, and that leads to chaos (and grave danger; you may have thought you typed <code>grep fungible form.file | tr -d 'fr' &gt; /tmp/x33</code> but if one of the shells got <code>rm -fr /</code>, you've got trouble!).</p>
"
"<p>Instead of return -1, you can use exit(1) or exit (-1) to exit from that portion if it fails to execute due to some error.</p>
"
"<p>I found the error:</p>

<pre><code>&lt;joint type=""revolute"" name=""left_ankle_hinge""&gt;
    &lt;physics&gt;
         &lt;ode&gt;
       &lt;provide_feedback&gt;true&lt;/provide_feedback&gt;
         &lt;/ode&gt;
    &lt;/physics&gt;
    &lt;pose&gt;0 0 0.04 0 0 0&lt;/pose&gt;
    &lt;child&gt;left_foot&lt;/child&gt;
    &lt;parent&gt;leftlower_leg&lt;/parent&gt;
    &lt;axis&gt;
    &lt;xyz&gt;1 0 0&lt;/xyz&gt;
    &lt;/axis&gt;
  &lt;/joint&gt;
</code></pre>

<p>should be changed to:</p>

<pre><code>&lt;joint type=""revolute"" name=""left_ankle_hinge""&gt;
    &lt;physics&gt;
          &lt;provide_feedback&gt;true&lt;/provide_feedback&gt;
    &lt;/physics&gt;
    &lt;pose&gt;0 0 0.04 0 0 0&lt;/pose&gt;
    &lt;child&gt;left_foot&lt;/child&gt;
    &lt;parent&gt;leftlower_leg&lt;/parent&gt;
    &lt;axis&gt;
     &lt;xyz&gt;1 0 0&lt;/xyz&gt;
    &lt;/axis&gt;
  &lt;/joint&gt;
</code></pre>
"
"<p>include widows.h file in header..</p>
"
"<p>Before querying time, read the <a href=""http://man7.org/linux/man-pages/man7/time.7.html"" rel=""nofollow"">time(7)</a> man page (and read it again).</p>

<p>The, I suggest using <a href=""http://man7.org/linux/man-pages/man2/clock_gettime.2.html"" rel=""nofollow"">clock_gettime(2)</a> with e.g. <code>CLOCK_MONOTONIC</code> or <code>CLOCK_REALTIME</code>, and preferably use <code>double</code> for time calculations (since a <code>struct timespec</code> is generally larger than any integral type).</p>

<p>Don't use <code>uint16_t</code> for such time calculations.</p>

<p>Try using </p>

<pre><code>inline double double_gettime (clockid_t cid) {
  struct timespec ts = {0,0};
  clock_gettime(cid, &amp;ts);
  return (double)ts.tv_sec + 1.0e-9*ts.tv_nsec;
}
</code></pre>

<p><sup>You might want to make that function fancier, by testing if <code>clock_gettime</code> is failing and giving <code>NAN</code> when it fails! This is left as an exercise to the reader. You could also, for <code>CLOCK_REALTIME</code> etc, measure the <em>difference</em> between some time at start of process and the current time (i.e. compute a <code>struct timespec</code> of differences and convert that difference to a <code>double</code>)</sup></p>

<p>Then things like</p>

<pre><code>double tstart = double_gettime(CLOCK_REALTIME);
some_long_computation();
double tend = double_gettime(CLOCK_REALTIME);
printf (""needed %f seconds to compute\n"", tend-tstart);
</code></pre>

<p>See also <a href=""http://man7.org/linux/man-pages/man3/clock.3.html"" rel=""nofollow"">clock(3)</a></p>
"
"<p><code>difftime()</code> is of use on systems where <code>time_t</code> supports time to a higher resolution than integral seconds.  Although allowed, I've never encountered such a system - I don't imagine one exists.  On POSIX systems specifically, <code>time_t</code> is measured in integral seconds, and <code>difftime()</code> is equivalent to arithmetic subtraction of its arguments, so in fact you are better off simply using:</p>

<pre><code>commlost_secs_cur += current_time - previous_time ;
</code></pre>

<p>That said, your implementation is somewhat over-complex, rather than accumulating time since the previous call, which may be smaller than the clock resolution, you could simply time-stamp the last heartbeat observed and return time since then:</p>

<pre><code>int commlost(uint16_t heartbeat_read_cur)
{
    time_t current_time = time(0) ;
    static time_t heartbeat_timestamp = 0 ;
    static uint16_t heartbeat_read_prev  ;

    // If first time, or heartbeat changed...
    if( heartbeat_timestamp == 0 || heartbeat_read_prev != heartbeat_read_cur)
    {
        // ... timestamp heartbeat
        heartbeat_timestamp = time(0) ;

        // ... keep last heartbeat
        heartbeat_read_prev = heartbeat_read_cur ;
    }

    // Return seconds since last heartbeat timestamp
    return current_time - heartbeat_timestamp ;
}
</code></pre>

<p>I am not sure why you would use <code>uint16_t</code> for this; there is little or no advantage unless it is for compatibility with some specific protocol or file format. </p>
"
"<p>John,</p>

<p>Your problem comes from the difficulty to play with pointers on pointers. We could fix this code but it will probably break later in your scripts because of its complexity. </p>

<p>For the long term, a simpler solution should be used to avoid bugs.</p>

<p>The structure attached to <code>US_SERVER_DATA</code> can be made simpler:</p>

<pre><code>typedef struct
{
   char *name;
   kv_t *kv_1;
   kv_t *kv_2;
   void *callback;
   u32   current_time;
}
</code></pre>

<p>This is the way to go: allocate memory with <code>calloc(sizeof(my_struct));</code>, and attach this structure to your <code>US_SERVER_DATA</code> pointer.</p>

<p>Then, providing you do all this in a G-WAN handler <code>init()</code> call (or in the <code>gwan/main.c</code> maintenance script, or even in the recently added <code>gwan/init.c</code> script), you will have exclusive access (one single thread is doing the initialization) and you will be able to attack G-WAN KV stores (and other objects) as needed.</p>

<p>If, later, G-WAN servlets or handlers are modifying these structure pointers then you will have to use a lock, spinlock, etc. or atomic variables for the pointers themselves.</p>

<p>Hope this helps.</p>
"
"<p>I just attach a kv store that contain all the kv stores I need to the persistence pointer. G-WAN kv is fast, plus the number of records is small, it should not hurt performance. </p>

<pre><code>  xbuf_t *reply = get_reply(argv);
  kv_t **kv_db = (kv_t **)get_env(argv, US_VHOST_DATA);

  if (!kv_db[0])
  {
     kv_db[0] = (kv_t*) malloc(sizeof(kv_t));

     if (!kv_db[0])
     {
        puts(""Could not allocate memory for the v-host kv store"");
        return 500;
     }

     kv_init(kv_db[0], ""kv_db"", 10, 0, 0, 0);
  }

  kv_t *blog_db = (kv_t *) kv_get(kv_db[0], ""blog_db"", 7);

  if (blog_db)
  {
     xbuf_cat(reply, ""Blog already installed. GTFO."");
     return 200;
  }

  blog_db = (kv_t *) malloc(sizeof(kv_t));
  kv_init(blog_db, ""blog_db"", 0, 0, 0, 0);

  if (!blog_db)
  {
     puts(""Could not allocate memory for the blog kv store"");
     return 500;
  }

  _KV_ADD(kv_db[0], item, blog_db-&gt;name, blog_db, 0);
</code></pre>

<p>(_KV_ADD is a custom macro)</p>
"
"<p>Without knowing what your program is doing, this might help.</p>

<p>I came across this article when working on a project a while back:
<a href=""http://chase-seibert.github.io/blog/2013/08/03/diagnosing-memory-leaks-python.html"" rel=""nofollow"">http://chase-seibert.github.io/blog/2013/08/03/diagnosing-memory-leaks-python.html</a>
Which says, ""Long running Python jobs that consume a lot of memory while running may not return that memory to the operating system until the process actually terminates, even if everything is garbage collected properly.""</p>

<p>I ended up using the multiprocessing module to have my project fork a separate process and return when it needed to do work, and I haven't noticed any memory issues since.</p>

<p>That or try it in Python 3.3 <a href=""http://bugs.python.org/issue11849"" rel=""nofollow"">http://bugs.python.org/issue11849</a></p>
"
"<p>You need to use a timer.  There are several APIs to do this.</p>

<p>Just using <code>alarm</code> is the simpliest.</p>

<p>There is <code>setitimer/getitimer</code>.</p>

<p>There is the <code>timer_create/timer_destroy/timer_settime</code> family.</p>

<p>Each has their own strengths offset by their own complexities.</p>
"
"<p>you can use <code>strtotime</code> for it.</p>

<pre><code>$current_time = strtotime(date('d-M-Y g:i:s A'));

$one_week = 3600 * 24 * 7;

// your file code
$fword =  $arr[0]; // assuming that $fword has file date.

// $fword = str_replace(""/"", ""-"", $fword);
$file_time = strtotime($fword);

$diff = $current_time - $file_time;
if($diff&gt;$one_week)
{
   echo "" date : "".$fowrd."" is older than one week &lt;br/&gt;"";
}
else
{
   echo "" date : "".$fowrd."" is not older than one week &lt;br/&gt;"";
}
</code></pre>
"
"<p>Just use date and strtotime methods</p>

<pre><code>$t = '05/02/2014 10:18:28 am';
$aWeekLater = date('Y-m-d H:i:s', strtotime($t.' -1 week'));
$curDate = date('Y-m-d H:i:s');

if ($curDate &lt; $aWeekLater) {
    echo 'xxx';
} else {
    echo 'yyy';
}
</code></pre>
"
"<pre><code>if (60*60*24*7+time() &lt; strtotime(trim($line))) {
    // greater than 1 week in future
} else {
    // within 1 week from now
}
</code></pre>
"
"<p>Forget about string manipulation and date functions, use DateTime class instead - it's designed for this kind of tasks.</p>

<pre><code>//Current time
$now = new DateTimeImmutable();
//One week ago
$oneWeekAgo = $now-&gt;sub(new DateInterval('P1W'));

//Read whole file into array
$lines = file('test.txt', \FILE_SKIP_EMPTY_LINES | \FILE_IGNORE_NEW_LINES);

foreach ($lines AS $line) {
    $date = DateTime::createFromFormat('m/d/Y h:i:s a+', $line);
    //Here you can compare your dates like any other variables
    if ($date &gt; $oneWeekAgo) {
        //Current date is less than 1 week ""old""
    }
    if ($date &lt; $oneWeekAgo) {
        //Current date is more than 1 week ""old""
    }
}
</code></pre>

<p>For different date/time periods see <a href=""http://www.php.net/manual/en/dateinterval.construct.php"" rel=""nofollow"">http://www.php.net/manual/en/dateinterval.construct.php</a>. For example, if you would like to do same thing for ""1 day ago"", it would be ->sub(new DateInterval('P1D')), ""1 year into the future"" would be ->add(new DateInterval('P1Y')).</p>
"
"<p>I am also working in fluent , wannt to make a UDF for dynamic mesh, so need a udf.h header file for C++.
I got one from google. but it shows lots of error:</p>

<pre><code> /* $OpenBSD: udf.h,v 1.20 2014/11/18 10:42:15 dlg Exp $    */

    /*
     * Copyright (c) 2001, 2002 Scott Long &lt;scottl@freebsd.org&gt;
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions
     * are met:
     * 1. Redistributions of source code must retain the above copyright
     *    notice, this list of conditions and the following disclaimer.
     * 2. Redistributions in binary form must reproduce the above copyright
     *    notice, this list of conditions and the following disclaimer in the
     *    documentation and/or other materials provided with the distribution.
     *
     * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
     * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
     * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
     * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     * SUCH DAMAGE.
     *
     * $FreeBSD: src/sys/fs/udf/udf.h,v 1.9 2004/10/29 10:40:58 phk Exp $
     */

    /*
     * Ported to OpenBSD by Pedro Martelletto in February 2005.
     */

    #define UDF_HASHTBLSIZE 100
    #include &lt;iostream&gt;
    #include &lt;windows.h&gt;
    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    #include &lt;time.h&gt;
    #include &lt;cstdlib&gt;
    #include &lt;ctime&gt;
    #include &lt;cmath&gt;
    #include &lt;fstream&gt;

    #define u_diroff    un_u.u_diroff
    #define u_vatlen    un_u.u_vatlen

    typedef unsigned __int32 uint32_t;
    typedef uint32_t udfino_t;

    struct unode {
        struct LIST_ENTRY *u_le;
        struct vnode *u_vnode;
        struct vnode *u_devvp;
        struct umount *u_ump;
        struct lock u_lock;
        dev_t u_dev;
        udfino_t u_ino;
        union {
            long u_diroff;
            long u_vatlen;
        } un_u;
        struct extfile_entry *u_fentry;
    };

    struct umount {
        int um_flags;
        struct mount *um_mountp;
        struct vnode *um_devvp;
        dev_t um_dev;
        int um_bsize;
        int um_bshift;
        int um_bmask;
        uint32_t um_start;
        uint32_t um_realstart;
        uint32_t um_len;
        uint32_t um_reallen;
        uint32_t um_meta_start;
        uint32_t um_meta_len;
        struct unode *um_vat;
        struct long_ad um_root_icb;
        LIST_HEAD(udf_hash_lh, unode) *um_hashtbl;
        SIPHASH_KEY um_hashkey;
        u_long um_hashsz;
        struct mutex um_hashmtx;
        int um_psecs;
        int um_stbl_len;
        struct udf_sparing_table *um_stbl;
    };

    #define UDF_MNT_FIND_VAT    0x01    /* Indicates a VAT must be found */
    #define UDF_MNT_USES_VAT    0x02    /* Indicates a VAT must be used */
    #define UDF_MNT_USES_META   0x04    /* Indicates we are using a Metadata partition*/

    #define VTOU(vp)    ((struct unode *)((vp)-&gt;v_data))

    #ifdef _KERNEL

    struct udf_dirstream {
        struct unode    *node;
        struct umount   *ump;
        struct buf  *bp;
        uint8_t     *data;
        uint8_t     *buf;
        int     fsize;
        int     off;
        int     this_off;
        int     offset;
        int     size;
        int     error;
        int     fid_fragment;
    };

    #define VFSTOUDFFS(mp)  ((struct umount *)((mp)-&gt;mnt_data))

    /*
     * The block layer refers to things in terms of 512 byte blocks by default.
     * btodb() is expensive, so speed things up.
     * Can the block layer be forced to use a different block size?
     */
    #define RDSECTOR(devvp, sector, size, bp) \
        bread(devvp, \
            ((daddr_t)(sector) &lt;&lt; ump-&gt;um_bshift) / DEV_BSIZE, size, bp)

    static __inline int
    udf_readlblks(struct umount *ump, int sector, int size, struct buf **bp)
    {
        return (RDSECTOR(ump-&gt;um_devvp, sector,
                 (size + ump-&gt;um_bmask) &amp; ~ump-&gt;um_bmask, bp));
    }

    /*
     * Produce a suitable file number from an ICB.  The passed in ICB is expected
     * to be in little endian (meaning that it hasn't been swapped for big
     * endian machines yet).
     * If the fileno resolves to 0, we might be in big trouble.
     * Assumes the ICB is a long_ad.  This struct is compatible with short_ad,
     *     but not ext_ad.
     */
    static __inline udfino_t
    udf_getid(struct long_ad *icb)
    {
        return (letoh32(icb-&gt;loc.lb_num));
    }

    int udf_allocv(struct mount *, struct vnode **, struct proc *);
    int udf_hashlookup(struct umount *, udfino_t, int, struct vnode **);
    int udf_hashins(struct unode *);
    int udf_hashrem(struct unode *);
    int udf_checktag(struct desc_tag *, uint16_t);

    typedef uint16_t unicode_t;

    #endif /* _KERNEL */

the following are error:
Error   1   error C2079: 'unode::u_lock' uses undefined struct 'lock'   h:\5990\cfd validation\rcm\sample udf file\velocity\velocity\velocity\udf.h 57  1   VELOCITY
Error   2   error C2143: syntax error : missing ';' before '.'  h:\5990\cfd validation\rcm\sample udf file\velocity\velocity\velocity\udf.h 61  1   VELOCITY
Error   3   error C2238: unexpected token(s) preceding ';'  h:\5990\cfd validation\rcm\sample udf file\velocity\velocity\velocity\udf.h 61  1   VELOCITY
Error   4   error C2143: syntax error : missing ';' before '.'  h:\5990\cfd validation\rcm\sample udf file\velocity\velocity\velocity\udf.h 62  1   VELOCITY
Error   5   error C2086: 'long unode::&lt;unnamed-tag&gt;::un_u' : redefinition   h:\5990\cfd validation\rcm\sample udf file\velocity\velocity\velocity\udf.h 62  1   VELOCITY
Error   6   error C2238: unexpected token(s) preceding ';'  h:\5990\cfd validation\rcm\sample udf file\velocity\velocity\velocity\udf.h 62  1   VELOCITY
Error   7   error C2079: 'umount::um_root_icb' uses undefined struct 'long_ad'  h:\5990\cfd validation\rcm\sample udf file\velocity\velocity\velocity\udf.h 82  1   VELOCITY
Error   8   error C2061: syntax error : identifier 'udf_hash_lh'    h:\5990\cfd validation\rcm\sample udf file\velocity\velocity\velocity\udf.h 83  1   VELOCITY
Error   9   error C2143: syntax error : missing ';' before '*'  h:\5990\cfd validation\rcm\sample udf file\velocity\velocity\velocity\udf.h 83  1   VELOCITY
Error   10  error C4430: missing type specifier - int assumed. Note: C++ does not support default-int   h:\5990\cfd validation\rcm\sample udf file\velocity\velocity\velocity\udf.h 83  1   VELOCITY
Warning 11  warning C4183: 'LIST_HEAD': missing return type; assumed to be a member function returning 'int'    h:\5990\cfd validation\rcm\sample udf file\velocity\velocity\velocity\udf.h 83  1   VELOCITY
Error   12  error C2146: syntax error : missing ';' before identifier 'um_hashkey'  h:\5990\cfd validation\rcm\sample udf file\velocity\velocity\velocity\udf.h 84  1   VELOCITY
Error   13  error C4430: missing type specifier - int assumed. Note: C++ does not support default-int   h:\5990\cfd validation\rcm\sample udf file\velocity\velocity\velocity\udf.h 84  1   VELOCITY
Error   14  error C2079: 'umount::um_hashmtx' uses undefined struct 'mutex' h:\5990\cfd validation\rcm\sample udf file\velocity\velocity\velocity\udf.h 86  1   VELOCITY
</code></pre>
"
"<p>You can set time zone and use <a href=""http://www.php.net/manual/en/datetime.diff.php"" rel=""nofollow"">DateTime::diff()</a> function and <a href=""http://www.php.net/manual/en/dateinterval.format.php"" rel=""nofollow"">DateInterval::format()</a>:</p>

<pre><code>date_default_timezone_set('Europe/Brussels');
$dateNow = new DateTime();
$dateBefore = new DateTime('2014-05-25 20:41') ;
$interval = $dateNow-&gt;diff($dateBefore);
echo $interval-&gt;format('%h hours %i min ago') . PHP_EOL;
</code></pre>

<p>Which shows:</p>

<pre><code>0 hours 37 min ago
</code></pre>

<p>And to just convert date to unix time <a href=""http://www.php.net/manual/en/datetime.format.php"" rel=""nofollow"">DateTime::format('U')</a> or <a href=""http://www.php.net/manual/en/datetime.gettimestamp.php"" rel=""nofollow"">DateTime::getTimestamp()</a> like that:</p>

<pre><code>echo $dateNow-&gt;format('U') . PHP_EOL
echo $dateNow-&gt;getTimestamp() . PHP_EOL;
</code></pre>
"
"<p>The best practice would depend on the libraries and general architecture you're using. That being said a naive implementation which I sometimes use would go somewhat like this:</p>

<pre><code>while( playing) {

    if( !paused) {
        logic();
    }
    rendering();
    input();
}
</code></pre>

<p>When doing small game projects, inside the main while loop I scatter logic, rendering and input in to different parts. In the input part there's the button that toggles the pause flag. In the main loop, the logic is simply enclosed in an if statement.</p>

<p>If you still need to do something inside the logic, you could pass it as a parameter or make it visible in some other way. Additionally you can do some special when-paused-graphics in the rendering section.</p>

<p>Details would vary but I hope this would at least give you a nudge to the right direction. That being said it is a common thing to implement and shouldn't be too hard to google.</p>
"
"<p>The problem ended up being in the sjf function, the for loop for assignment was incorrect, should have been </p>

<pre><code>for(i=counter; i&lt;num_pid; i++){
        if(array[i].arrival_time&lt;=current_time){
            to_sort[num_valid_process]=array[i];
            num_valid_processes++;
            counter++;
        }
...
</code></pre>
"
"<p>The problem occurs at time 12 -- pid 6 shows up needing 3 seconds and pid 5 is running with 3 seconds left.  How do you resolve the tie between processes that need the same remaining time?  In favor of pid 6 gives you the result on the left and in favor of pid 5 gives you the result on the right.  Given your weak problem definition, either could be correct.</p>
"
"<p><code>localtime</code> converts a Unix timestamp (seconds since epoch, which is about 1.4 billion now) to a list of values. The <code>time</code> function conveniently provides that timestamp. From <code>perldoc -f localtime</code>:</p>

<pre><code>Converts a time as returned by the time function to a 9-element
        list with the time analyzed for the local time zone. Typically
        used as follows:

            #  0    1    2     3     4    5     6     7     8
            ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                        localtime(time);
</code></pre>

<p>For your time comparison you could do:</p>

<pre><code>$Time = join ':', (localtime(time))[2, 1, 0];
if ($Time eq '17:30:00') {
    ...
}
</code></pre>

<p>Since Perl allows the postcircumfix <code>[...]</code> operator to index into lists just like it does with arrays, we can use it to remove the slice of the (localtime(time)) list that contains hours, minutes, and seconds, join them with colons, and assign the resulting string to $Time.</p>

<p>Note that because $Time now holds a string, you should compare it to <code>'17:30:00'</code> rather than the bareword <code>17:30:00</code>, which isn't a valid numeric form and should result in a compilation error. And since we're comparing strings instead of numbers, we use the <code>eq</code> operator. <code>==</code> forces numeric context on its operands, and since 17:30:00 isn't a valid number, Perl will treat it as 0 and warn you with</p>

<pre><code>Argument ""foo"" isn't numeric in numeric eq (==) at ....
</code></pre>
"
"<p>Several things here:</p>

<p>First, use <code>Time::Piece</code>. It's now included in Perl.</p>

<pre><code>use Time::Piece;
for (;;) {                   # I prefer using ""for"" for infinite loops
    my $time = localtime;    # localtime creates a Time::Piece object

    # I could also simply look at $time
    if ( $time-&gt;hms eq ""17:30:00"" ) {
        my $cmd $ssh-&gt;exec(""cmd"");
        print ""$cmd\n"";
    }
    else {
        print ""Didn't execute command\n"";
    }
}
</code></pre>

<p>Second, you shouldn't use a loop like this because you're going to be tying up a process just looping over and over again. You can try sleeping until the correct time:</p>

<pre><code>use strict;
use warnings;
use feature qw(say);
use Time::Piece;

my $time_zone = ""-0500"";    # Or whatever your offset from GMT
my $current_time = local time;
my $run_time = Time::Piece(
    $current_time-&gt;mdy . "" 17:30:00 $time_zone"",   # Time you want to run including M/D/Y
     ""%m-%d-%Y %H:%M:%S %z"");                      # Format of timestamp
sleep $run_time - $current_time;
$ssh-&gt;(""cmd"");
...
</code></pre>

<p>What I did here was calculate the difference between the time you want to run your command and the time you want to execute the command. Only issue if I run this script after 5:30pm local time. In that case, I may have to check for the next day.</p>

<p>Or, even better, if you're on Unix, look up the <a href=""http://man.cx/crontab%285%29"" rel=""nofollow"">crontab</a> and use that. The crontab will allow you to specify exactly when a particular command should be executed, and you don't have to worry about calculating it in your program. Simply create an entry in the crontab table:</p>

<pre><code>30 17 * * *  my_script.pl
</code></pre>

<p>The <code>30</code> and <code>17</code> say you want to run your script everyday at 5:30pm. The other asterisks are for day of the month, the month, and the day of the week. For example, you only want to run your program on weekdays:</p>

<pre><code>30 17 * * 1-5  my_script.pl  # Sunday is 0, Mon is 1...
</code></pre>

<p>Windows has a similar method called the Schedule Control Panel where you can setup jobs that run at particular times. You might have to use <code>perl my_scipt.pl</code>, so Windows knows to use the Perl interpreter for executing your program.</p>

<p>I highly recommend using the <em>crontab</em> route. It's efficient, guaranteed to work, allows you to concentrate on your program an not finagling when to execute your program. Plus, it's flexible, everyone knows about it, and no one will kill your task while it sits there and waits for 5:30pm.</p>
"
"<p>If i understand what you say, you want to create a subscription system for those messages right ?</p>

<p>You can use a new table in your DB with 3 cols : id, client_id, sub_time</p>

<p>It look pretty easy to check if the client is still subscriber of the messages like this i think. You just have to compare sub_time and current time, and see if ( $sub_time + 3600*24* $nb_of_day_in_last_month ) >= $current_time, or something like that ... :D</p>
"
"<p>So, the new method i have is this one, hope it will work fine for you</p>

<p>The file for exemple named : subscribes.txt (i used a ',' delimitor, you can change it as it fit to you)</p>

<pre><code>; a comment line
43,1404399704
75,1404406800
104,1404399200
6,1404399500
</code></pre>

<p>And the little script</p>

<pre><code>$file = 'subscribes.txt';
$delim= ','; // set the delimitor of your cols

$time = time(); // get time to use it in all the script

// this part is to get the last month number of days
$y  = date('Y'); // year
$lm = date('n') - 1; // last month
$y  = ($lm == 0) ? $y - 1 : $y; // if we are in jan., year - 1
$lm = ($lm == 0) ? 12 : $lm; // if we are in jan., last month was dec.
$lm = mktime( 0, 0, 0, $lm, 1, $y ); // so, the last month
$lm_days = intval(date(""t"",$lm)); // get the number of days in last month

// you can get the current month number of days with :
// $lm_days = intval(date('t'));

// end of the part


$file = file_get_contents($file); // read file content

$file = explode(PHP_EOL, $file); // transform it in array

foreach( $file as $lk =&gt; $line ){

    if( !empty($line) &amp;&amp; !preg_match('/^;(.*)/', $line) ){ // if line not empty and don't start with ;

        $cid= null;
        $st = null;

        list($cid,$st) = explode($delim, trim($line)); // explode the 3 cols of the line

        $st = $st + 3600*24*$lm_days;

        if( $time &gt;= $st ){

            // send notifications etc etc ... (eg: your script)
        }
        else{

            // else we will delete the line to light the file
            unset($file[$lk]);
        }
    }
}

// once done, letz write the lighted file
$file = implode(PHP_EOL, $file); // convert array to string

file_put_contents($file, $file); // put it back in the file
</code></pre>

<p>And when you want to add a subscribe you just have to run this</p>

<pre><code>$file_name = 'subscribes.txt';
$delim= ','; // set the delimitor of your cols

$time = time(); // get time to use it in all the script

$file = file_get_contents($file_name); // read file content

$file = explode(PHP_EOL, $file); // transform it in array

$file[] = $cid.$delim.time(); // add to array a new entry
// there you can add multiple entries, let it fit to you :P

$file = implode(PHP_EOL, $file); // convert array to string

file_put_contents($file, $file); // put it back in the file
</code></pre>

<p>Tell me if it still hangs or something, i'll try to find other solutions :)</p>
"
"<p>You can do a few things though you will never get something 100% fool proof.</p>

<p>The easiest would probably be just require an internet connection. But we've seen how well that was received with the XBox and other game companies.</p>

<p>If you can't count on an internet connection to perform a check you could watch for ""suspicious"" activity. For instance, keep a record of the last run time of the application. If for some reason the system clock reports a time before the last recorded run time then prompt the user to establish an internet connection and validate.</p>

<p>Keep in mind there may be legitimate reasons for a user setting their clock back. Daylight savings time being one. Perhaps use a threshold like ignore the clock being set back an hour or day or whatever.</p>
"
"<p>You could make the following procedure:</p>

<ol>
<li>when the program starts, you have to store the current time and save it in an
encrypted file. At the first time t0 (first sw execution) this file
must contain a null time value. Note this file must be mandatory. If
the current time is minor of the last stored time (anomalous
situation) increment your elapsed time as follow: last_time += last_time -
current_time;</li>
<li>during program execution, trace the time elapsed adding the time
stored in the encrypted file (you could use the ""time()"" function). Do
some checks during the program execution: the elapsed time must be
minor of the license time. This is useful if the program is always
in running for a period superior to the license time</li>
<li>Before closing program, you have to update time info in the encrypted file (1)</li>
</ol>

<p>Although this method is not accurate, it can protect you from a improper use of your program. </p>

<p>Note that: if the program will be conected to internet you can restore all info about the correct elapsed time in the encryped file.</p>

<p>Sorry for my english!</p>
"
"<p>We have already list algorithm I won't repeat that, It does solve problem now BIOS check we just need to make sure that it's not going back. That each time program starts we record current time, if user has to bi-pass license he needs to set his which if he does post installation program could detect that</p>

<p>Now if user change bios time before installation we are still ok, because program will treat that as correct time and will calculate year from that time.</p>
"
"<p>The return value doesn't mean the reactor ends running. In order to have <code>run_reactor_event_loop()</code> to return you have to call somewhere <code>ACE_Reactor::instance ()-&gt;end_reactor_event_loop ()</code>, see for example the ACE examples under <a href=""https://svn.dre.vanderbilt.edu/viewvc/Middleware/trunk/ACE/examples/Reactor/"" rel=""nofollow"">ACE_wrappers/examples/APG/Reactor</a></p>
"
"<p>What you want to do is daemonize the process.  <a href=""https://stackoverflow.com/questions/473620/how-do-you-create-a-daemon-in-python"">This will be helpful in creating a daemon.</a></p>

<p>Daemonizing the process will allow it to run in background mode, so as long as the server is running (even if a user isn't logged in) it will continue running. </p>

<p>Here is an example daemon that writes the time to a file. </p>

<pre><code>import daemon
import time

def do_something():
    while True:
        with open(""/tmp/current_time.txt"", ""w"") as f:
            f.write(""The time is now "" + time.ctime())
        time.sleep(5)

def run():
    with daemon.DaemonContext():
        do_something()

if __name__ == ""__main__"":
    run()
</code></pre>
"
"<pre><code>#!/bin/bash
base_name=""some_text_""
year_month=`date +%Y.%m.`
today=$(date +%d)
yesterday=`expr $today - 1`
pattern=""$base_name$year_month$yesterday"" #concatenation
find . -name ""$pattern"" -exec some commands ..
</code></pre>

<p>Try this</p>
"
"<p>I could rewrite your script as, </p>

<pre><code>#!/bin/bash
base_name=""some_text""
today=$(date +%d)
yesterday=$((today-1))
pattern=""${base_name}*${yesterday}*"" #concatenation
find . -name $pattern -exec ...some commands
</code></pre>

<p>output is like,</p>

<pre><code>[root@giam39 ~]# ./temp.sh
./some_text.2014.08.19_01
</code></pre>
"
"<p>If I understand right, you don't need worry about spaces and/or newlines in the filenames, so tne next simple script should done the job</p>

<pre><code>prefix=""some_""

#generate the pattern for yesterday (current_time - 86400 seconds)
ypatt=$(date --date @$(($(date +%s) - 86400)) +""%Y.%m.%d"")   #linux - gnu date
#ypatt=$(date -j -f %s $(($(date +%s) - 86400)) +""%Y.%m.%d"")  #for OS X

find . -print | grep ""/${prefix}${ypatt}""
</code></pre>

<p>e.g. for the next filenames:</p>

<pre><code>some_2014.08.18_00.txt some_2014.08.19_02.txt some_2014.08.20_10.txt
some_2014.08.18_23.txt some_2014.08.19_05.txt some_2014.08.20_11.txt
</code></pre>

<p>will print</p>

<pre><code>./some_2014.08.19_02.txt
./some_2014.08.19_05.txt
</code></pre>

<p>and the next</p>

<pre><code>find . -print | grep ""/${prefix}${ypatt}"" | xargs commands -args
</code></pre>

<p>will execute <code>commands -args ...found_filenames...</code></p>
"
"<p>You may use ctime.h library functions. </p>

<p>time_t time(time_t *) returns the current time to you. </p>

<p>To convert it into a formatted time string, consider using struct tm * gmtime(time_t *).</p>

<p>Then use int sprintf(char *, const char * ...) to format your file name string.</p>

<p>Spend some time on reading these library documents:</p>

<p>time (<a href=""http://www.cplusplus.com/reference/ctime/time/"" rel=""nofollow"">http://www.cplusplus.com/reference/ctime/time/</a>)</p>

<p>gmtime (<a href=""http://www.cplusplus.com/reference/ctime/gmtime/"" rel=""nofollow"">http://www.cplusplus.com/reference/ctime/gmtime/</a>)</p>

<p>sprintf (<a href=""http://www.cplusplus.com/reference/cstdio/sprintf/?kw=sprintf"" rel=""nofollow"">http://www.cplusplus.com/reference/cstdio/sprintf/?kw=sprintf</a>)</p>
"
"<p>Using predefined <a href=""http://www.cplusplus.com/reference/ctime/ctime/"" rel=""nofollow"">ctime</a> function:</p>

<pre><code>#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char* argv[])
{
    time_t current_time;
    FILE* file;

    current_time = time(NULL);

    file = fopen(""test.txt"", ""w+"");

    fprintf(file, ""%s"", ctime(&amp;current_time));

    return 0;
}
</code></pre>

<p>Using <a href=""http://www.cplusplus.com/reference/ctime/strftime/"" rel=""nofollow"">strftime</a> function:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main ()
{
    time_t rawtime;
    struct tm* timeinfo;
    char buffer[80];
    FILE* file;

    file = fopen(""test.txt"", ""w+"");

    time(&amp;rawtime);
    timeinfo = localtime(&amp;rawtime);

    strftime(buffer, 80, ""%I:%M:%S"", timeinfo);
    fprintf(file, ""%s"", buffer);

    return 0;
}
</code></pre>
"
"<p>I'm not sure of what your code does, so here is the most basic implementation for your problem. I think this can help you.<br>
    There are more elegant ways to solve it, but I think you should start from the bottom and work your way up</p>

<pre><code>FILE *fp;

// insert the date into the char array
char text[17];
time_t now = time(NULL);
struct tm *t = localtime(&amp;now);
strftime(text, sizeof(text)-1, ""%dd %mm %YYYY %HH:%MM"", t);
text[16] = 0;

// concat the date to file name
char *filename;
if((filename = malloc(strlen(""C:\\Temp\\filename.txt"")+strlen(text)+1)) != NULL){
    filename[0] = '\0';   // ensures the memory is an empty string
    strcat(filename,""C:\\Temp\\filename"");
    strcat(filename,text);
    strcat(filename,"".txt"");
}

// use the file
fp = fopen(filename, ""w+"");
fputs(""This is testing for fputs...\n"", fp);
fclose(fp);
</code></pre>

<p>Hope it helps</p>
"
"<p>Your HEREDOC terminators are incrorect. They must be at the beginning of the line.</p>

<p>e.g.</p>

<pre><code>cat &lt;&lt; EOF
   foo bar
   EOF
^^^--these spaces matter
</code></pre>

<p>Because of those spaces, the terminator is seen as <code>[space][space][space]EOF</code>, and will never match <code>EOF</code> by itself.</p>

<p>Since your first EOF never terminates, the shell runs off the end of the script without ever seeing the <code>fi</code>, because the <code>fi</code> you have was actually treated as output, not a control sequence.</p>
"
"<p>The problem is not negative return codes, it is any return code that is != 0. DB2 exits with:</p>

<pre><code>- 0, success
- 1, no row found
- 2, warning (for example using existing index instead of creating a new one)
- 4, error (for example object not found)
- 8, system error (os related)
</code></pre>

<p>Unless you wrap db2 and return 0 for $? -lt 4 I don't see how you are going to success. Example on how to deal with db2 exit codes (-e removed)</p>

<pre><code>db2 -x ""SELECT EG_NAME FROM MS.CFG_CACHE_REF ...""
rc=$?
if [ $rc -ge 4 ]; then
    ...
</code></pre>

<p>EDIT: Alternative with sql stmts in separate file</p>

<p>Keeping all the sql in a separate file - say myfile.sql - you can do something like from your sh:</p>

<pre><code>db2 -l myfile.log +c -s -tf myfile.sql
rc=$?
if [ $rc -ge 4 ]; then
    echo ""Error""
    db2 rollback
    exit 1
elif [ $rc -ge 1 ]; then
    echo ""Warning""
fi

db2 commit
exit 0
</code></pre>

<p>-s terminates execution on error ( -ge 4 ). You can find out what caused the problem by tailing the log file, tail -10 myfile.log. Beware that certain operations such as reorg will commit the ongoing transaction.</p>
"
"<p>You are looking for a frequency formula :
amount_of_occurrence / time_elapsed</p>

<p>Create a counter to register the number or occurrence of ""Kappa"" ('counter')<br>
Register the current time when you start your program ('start_time')<br>
Each time you want to display the average amount of times your string occurred compute<br> ""counter / (current_time - start_time)""<br> then multiply the result to get a frequency by minutes (because most of System.time function give time in microseconds or nanoseconds)</p>

<p>A small pseudocode algorithm doing that :</p>

<pre><code>//Initialize
Find your input stream source (chatbox feed)
Initialize the word counter
Create a regular expression matching your word

//Run this function in a loop or trigger it when you get a new message
Match the input with your regex
If you get a positive match
    Increase the counter value
Display counter/time (with time in minutes)
</code></pre>
"
"<p>I'm not sure the best way!</p>

<p>But I think I can fix your code!</p>

<pre class=""lang-python prettyprint-override""><code> flaged_jobs = [];
    for job in job_bank:
        # first of all. get start_time from job status
        job_start_time = get_start_time(job)
        elapsed_time = current_time - job_start_time
        # Fix your logic, &lt; 5 &lt;=, &lt; 20 &lt;=...
        if job.average_time &lt; 5:
            # (current_time - start_time) == 4 * (current_time - start_time)
            # is always False except current_time == start_time, so I fixed it.
            if elapsed_time &gt;= 4 * job.average_time:
                flaged_jobs.append(job)
        elif 5 &lt;= job.average_time &lt; 20:
            if elapsed_time == 2 * job.average_time:
                flaged_jobs.append(job)
        elif 20 &lt;= job.average_time &lt; 3 * 60:
            if elapsed_time == 1.5 * job.average_time:
                flaged_jobs.append(job)
        elif 3 * 60 &lt;= job.average_time:
            if elapsed_time == .5 * job.average_time:
                flaged_jobs.append(job)
        else:
            continue

    for flaged in flaged_jobs:
         send_message(flaged)
</code></pre>
"
"<p>the data in your file is getting erased because you are opening the file in write mode (the ""w"" in your fopen() command )</p>

<pre><code>    fp=fopen(""C:\\X2.6\\X_LogFiles\\file.txt"",""w"");
</code></pre>

<p>whenever you open a file in ""w"" mode. if the file is not present it will be created. But if the file is present <strong>the file will be emptied, all its data is deleted and then opened</strong></p>

<p>If you want to append (add to the already existing file) to the file, you should use ""a"" inplace of ""w"". the append mode will create the file if it is not there. But if the file is there, then it is just opened to add (append) data to it</p>
"
"<p>use <code>printf</code> to write the time to the file.</p>

<p><code>printf(file_descriptor, ""control_String"");</code></p>

<p>here it would be</p>

<p><code>printf(fp,"" %s\n"", asctime (current_time) );</code></p>

<p>also open the file in append mode <code>a</code></p>

<pre><code>fFILE *fp;
char ch;
time_t current_time;
char* c_time_string;

/* Obtain current time as seconds elapsed since the Epoch. */
time(&amp;current_time);

if (current_time == ((time_t)-1))
{
    (void) fprintf(stderr, ""Failure to compute the current time."");
    return EXIT_FAILURE;
}

/* Convert to local time format. */
c_time_string = ctime(&amp;current_time);

if (c_time_string == NULL)
{
    (void) fprintf(stderr, ""Failure to convert the current time."");
    return EXIT_FAILURE;
}


fp=fopen(""C:\\X2.6\\X_LogFiles\\file.txt"",""a""););

/*changed here*/

fprintf(fp,""%s"",c_time_string);


fclose(fp);
</code></pre>

<p>return 0;
}</p>
"
"<p>It looks like you are expecting to process only a single request in your code. The HTTP protocol added persistent connections in version 1.1, which allow the same TCP socket to be reused for more than 1 request.</p>

<p>With persistent connections, the client (your browser) would send the ""Connection: keep-alive"" header to indicate that it supports persistent connections (which your browser does). The server can then reply with the same, or use ""Connection: close"" to indicate that it does not support persistent connections, so the client should close the current socket and open a new one for subsequent requests.</p>

<p>In your case, the browser opens a socket connection, sends a request and tells you that it support persistent connections. Your server then sends a response and closes the connection. The browser tries to send a second request over the same connection and fails, resulting in the error you see.</p>

<p>You can either modify your code to keep the socket open and handle multiple requests, or add ""Connection: close"" to tell the client that you do not support persistent connections.</p>
"
"<p>You cannot use SDL_GetTicks() if you want higher precision but there are many other alternatives. If you want to be platform independant you need to be careful though, but here is a portable C++11 example that will get you started:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;chrono&gt;
typedef std::chrono::high_resolution_clock Clock;

int main()
{
    auto t1 = Clock::now();
    auto t2 = Clock::now();
    std::cout &lt;&lt; ""Delta t2-t1: ""
              &lt;&lt; std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(t2 - t1).count()
              &lt;&lt; "" nanoseconds"" &lt;&lt; std::endl;
}
</code></pre>

<p>Running this on ideone.com gave me:</p>

<pre><code>Delta t2-t1: 282 nanoseconds
</code></pre>
"
"<p>Well, of course, you need to actually wait until >=1ms has passed before updating your last tick count</p>

<pre><code>void Application::Update()
{
    Uint32  current_time = SDL_GetTicks();
    Uint32  delta_time = current_time - last_update_time;

    SDL_Event event;
    while(SDL_PollEvent(&amp;event))
    {
        switch(event.type)
        {
            case SDL_QUIT:
            {
                should_close = true;
            }
            break;

            default:
                break;
        }
    }

    if (delta_time &gt;= 1)
    {
        // Update game objects with delta_time

        last_update_time = current_time;
    }
}
</code></pre>
"
"<p>The POSIX <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html"" rel=""nofollow""><code>read()</code></a>
function returns 0 on EOF, not -1.  Since you test for the wrong condition, you get an infinite loop.</p>

<p>Note that the description says:</p>

<blockquote>
  <p>When attempting to read from an empty pipe or FIFO:</p>

  <ul>
  <li><p>If no process has the pipe open for writing, <code>read()</code> shall return 0 to indicate end-of-file.</p></li>
  <li><p>If some process has the pipe open for writing and <code>O_NONBLOCK</code> is set, <code>read()</code> shall return -1 and set <code>errno</code> to <code>[EAGAIN]</code>.</p></li>
  <li><p>If some process has the pipe open for writing and <code>O_NONBLOCK</code> is clear, <code>read()</code> shall block the calling thread until some data is written or the pipe is closed by all processes that had the pipe open for writing.</p></li>
  </ul>
</blockquote>

<p>Reading zero bytes because there are no bytes to read is success.  That is how EOF is indicated by <code>read()</code>, whether it is on a file or any other device type.  Terminals are a special case; they may return 0 bytes after you type (on Unix) <kbd>control-D</kbd>, and then a retry may return extra data typed after that.  Once upon a long time ago, tape drives were somewhat similar.  But when <code>read()</code> returns 0, there is (for the time being) no more data to read.  For a pipe, that means all writers closed their write file descriptor.</p>
"
"<p>Opengl has a selection mode </p>

<blockquote>
  <p>glRenderMode(GL_SELECT);</p>
</blockquote>
"
"<p>I think your looking for something like this:</p>

<pre><code>#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main() {

    time_t current_time;
    char* c_time_string;

    current_time = time(NULL);

    /* Convert to local time format. */
    c_time_string = ctime(&amp;current_time);

    printf(""Current time is %s"", c_time_string);

    return 0;
}
</code></pre>
"
"<p>you need to change  clrscr(); to system(clear).Below is the working version of your code:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;time.h&gt;

void main()
 {

   time_t t;
   time(&amp;t);
   system(""clear"");
   printf(""Today's date and time : %s"",ctime(&amp;t));

  }
</code></pre>
"
"<p>Let me guess, this is in a windowed program (with a GetMessage/DispatchMessage loop), right? Here, you should never block, neither with Sleep() nor with any other long-running operation. This freezes the whole UI as no keyboard input or redraws take place in between. What you can do depends on your design, but an easy way is to trigger a timer that will call the window proc later on and where you can finish the movement.</p>

<p>Another approach is to use threads, but those have a whole different set of complications. Another alternative is I believe a sleep function that feeds the message queue, which would avoid the freeze - you'd have to check the documentation what the name of that function is.</p>
"
"<p>You should do something like this</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;windows.h&gt;
#include &lt;chrono&gt;

using namespace std;

char Map[10][20] = {""###################"",
                    ""####    #########!#"",
                    ""####  # ######### #"",
                    ""####* # ######### #"",
                    ""#     # ######### #"",
                    ""# ##### ######### #"",
                    ""# ##### ######### #"",
                    ""# ##### ######### #"",
                    ""#@#####           #"",
                    ""###################"" };

int Gamespeed = 100;
int Level = 1;
bool stopgame = false;
int Hp = 100;
int MaxHp = 100;

int main()
{
chrono::time_point&lt;chrono::system_clock&gt; current_time,last_time;
float delta_time,star_delay=0;
current_time=chrono::system_clock::now();
last_time=current_time;
    while(stopgame == false &amp;&amp; Level == 1)
    {
   current_time=chrono::system_clock::now();
   delta_time=chrono::duration_cast&lt;chrono::duration&lt;float&gt;&gt;(current_time-last_time).count();
   last_time=current_time;
        system(""cls"");
        for (int y = 0; y &lt; 10; y++)
        {
            cout &lt;&lt; Map[y] &lt;&lt; endl;
        }
        cout &lt;&lt; ""Hp: ""&lt;&lt; Hp &lt;&lt; ""/"" &lt;&lt; MaxHp &lt;&lt; endl;
        for (int y = 0; y&lt;10; y++)
        {
            for(int x = 0; x&lt;20; x++)
            {

                switch(Map[y][x])
                {
                    case '#':
                    {
                       Map[y][x] = 219;
                    }
                    break;
                    case '*':
                       if (y == 3)
                       {
                           Map[y][x] = ' ';
                           y -= 1;
                           Map[y][x] = '*';
                           star_delay=0;
                       }
                       if (y == 2)
                       {
                          if(star_delay&gt;1){
                             Map[y][x] = ' ';
                             y -= 1;
                             Map[y][x] = '*';
                          }else{
                             star_delay+=delta_time;
                          }
                       break;
                    case '@':
                    {

                        if (GetAsyncKeyState(VK_UP) != 0)
                        {
                            int y2 = (y-1);

                            switch(Map[y2][x])
                            {
                                case ' ':
                                {
                                    Map[y][x] = ' ';
                                    y -= 1;
                                    Map[y2][x] = '@';
                                }break;
                                case '!':
                                    {
                                        Level = 2;
                                    }break;
                                    case '*':
                                    {
                                        Hp -= 20;
                                        Map[y][x] = ' ';
                                        y -= 1;
                                        Map[y2][x] = '@';
                                    }break;
                            }
                        }

                        if (GetAsyncKeyState(VK_DOWN) != 0)
                        {
                            int y2 = (y + 1);

                            switch(Map[y2][x])
                            {
                            case ' ':
                                {
                                    Map[y][x] = ' ';
                                    y += 1;
                                    Map[y2][x] = '@';
                                }break;
                            case '!':
                                {
                                    Level = 2;
                                }break;
                                case '*':
                                    {
                                        Hp -= 20;
                                        Map[y][x] = ' ';
                                        y -= 1;
                                        Map[y2][x] = '@';
                                    }break;
                            }
                       }

                       if (GetAsyncKeyState(VK_RIGHT) != 0)
                       {
                           int x2 = (x + 1);

                           switch(Map[y][x2])
                           {
                           case ' ':
                            {
                                Map[y][x] = ' ';
                                x += 1;
                                Map[y][x2] = '@';
                            }break;
                           case '!':
                            {
                                Level = 2;
                            }break;
                            case '*':
                                    {
                                        Hp -= 20;
                                        Map[y][x] = ' ';
                                        x -= 1;
                                        Map[y][x2] = '@';
                                    }break;
                           }
                       }
                       if (GetAsyncKeyState(VK_LEFT) != 0)
                       {
                           int x2 = (x - 1);

                           switch(Map[y][x2])
                           {
                           case ' ':
                            {
                                Map[y][x] = ' ';
                                x -= 1;
                                Map[y][x2] = '@';
                            }break;
                           case '!':
                            {
                                Level = 2;
                            }break;
                            case '*':
                                    {
                                        Hp -= 20;
                                        Map[y][x] = ' ';
                                        x -= 1;
                                        Map[y][x2] = '@';
                                    }break;
                           }
                       }
                    }
                }
            }
        }


       }
        Sleep(Gamespeed);
    cout&lt;&lt;""dt:""&lt;&lt;delta_time&lt;&lt;endl;
    cout&lt;&lt;""sd:""&lt;&lt;star_delay&lt;&lt;endl;
    }

}
</code></pre>
"
"<pre><code>struct MyIterator
{
    Iterator i;
    DateTime t;
}

struct DataPoint
{
    DateTime t;
    int count;
}

List&lt;DataPoint&gt; CalculateIntervalCount(List&lt;List&lt;Interval&gt;&gt; series)
{
    initialise min-heap H
    foreach (List&lt;Interval&gt; S in series)
    {
        Iterator i=S.begin();
        H.push(new MyIterator(i, i.ArrivalTime));
    }
    int count=0;
    List&lt;DataPoint&gt; result=new List&lt;DataPoint&gt;();
    while(!H.emtpy())
    {
        Iterator min= H.pop();
        if(min.t==min.i.ArrivalTime)
        {
            ++count;
            result.Add(new DataPoint(min.t, count));
            H.push(new MyIterator(min.i, i.DepartureTime);
        }
        else
        {
            --count;
            result.Add(new DataPoint(min.t, count));
            if (can advance min.i)
            {
                H.push(new MyIterator(min.i, i.ArrivalTime);
            }
        }
    }
    return result;
}
</code></pre>

<p>Explanation:</p>

<p>CalculateIntervalCount is a function which takes a list of interval series and return a series which gives the count of intervals at time t.</p>

<p>Assuming you have a ""standard"" iterator construct to a list and the iterator knows how to advance itself and knows how to check if it reaches the end, MyIterator is a wrap around the ""standard"" iterator with an additional DateTime field which either takes on the value of the ArrivalTime or DepartureTime of an interval.</p>

<p>The min heap H uses the MyIterator.t for comparison between two MyIterator objects.</p>

<p>The algorithm just implements what I have described in my comment. It should run in O(n lg k) time, where k is the number of interval series, n is the number of intervals in total across all series.</p>
"
"<p>So <code>boost::chrono</code> should be fully supported in C++11's <code>std::chrono</code>.</p>

<p>Which I believe is now fully supported by Visual Studio 2013 and gcc 4.8?</p>

<p>Anyway you can print using: <a href=""http://www.cplusplus.com/reference/iomanip/put_time/"" rel=""nofollow""><code>put_time</code></a></p>

<p>There are a tremendous number of format specifiers in the link, you can use those to customize the output to your needs.</p>

<p>It's important to note that <code>put_time</code> is just a stream manipulator. If you need to get your time in a <code>string</code> you'll need to use <code>put_time</code> with a <code>stringstream</code>.</p>
"
"<p>You have to initialize the struct to 0 beforehand or also input the seconds:</p>

<pre><code>string datetime = ""2014-12-10 10:30"";
struct tm tmInfo = { 0 };
strptime(datetime.c_str(), ""%Y-%m-%d %H:%M"", &amp;tmInfo);
</code></pre>

<p>or </p>

<pre><code>string datetime = ""2014-12-10 10:30:00"";
struct tm tmInfo;
strptime(datetime.c_str(), ""%Y-%m-%d %H:%M:%S"", &amp;tmInfo);
</code></pre>
"
"<p>You need to properly zero-initialize all of the other fields of the <code>struct tm</code> instance before calling <code>strptime()</code>, since it doesn't necessarily initialize every field.  From the <a href=""http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html"" rel=""nofollow""><code>strptime()</code> POSIX specification</a>:</p>

<blockquote>
  <p>It is unspecified whether multiple calls to <em>strptime()</em> using the same <strong>tm</strong> structure will update the current contents of the structure or overwrite all contents of the structure. Conforming applications should make a single call to <em>strptime()</em> with a format and all data needed to completely specify the date and time being converted.</p>
</blockquote>

<p>For example, this should suffice:</p>

<pre><code>struct tm tmInfo = {0};
</code></pre>
"
"<p>The below code would do the work, if you want current system time in an format</p>

<pre><code> time_t current_time;
 struct tm *loctime;

 memset(buffer,0,strlen(buffer));
 current_time = time(NULL);
 loctime = localtime(&amp;current_time);
 strftime(buffer,250,""--&gt; %d/%m/%y  %H:%M:%S"",loctime);
</code></pre>
"
"<p>A <strike>materialized view</strike> is not going to help, since your query needs to be based on the latest data and you would have to refresh the MV just as often as you query.</p>

<p><strike>Trigger-based solutions</strike> would be another option: keep an auxiliary table up to date with current counts per page. But I would expect the additional cost on (your many) write operations to be <em>much</em> higher than the gain for the read operation. So I would rule this out, too.</p>

<p>While you operate with one big table I suggest a <a href=""http://www.postgresql.org/docs/current/interactive/indexes-partial.html"" rel=""nofollow noreferrer""><strong>partial index</strong></a>:</p>

<pre><code>CREATE INDEX foo ON user_is_viewing_page (page_id, timestamp)
WHERE timestamp &gt; '2014-12-29 23:30:00'::timestamp;  -- start with 'now'
</code></pre>

<p>Query (mostly what you had already):</p>

<pre><code>SELECT COUNT(DISTINCT user_id)
FROM   user_is_viewing_page
WHERE  page_id = 1
AND    timestamp &gt; LOCALTIMESTAMP - INTERVAL '10 sec';
</code></pre>

<p><code>CURRENT_TIMESTAMP</code> would work, too. But <code>LOCALTIMESTAMP</code> makes more sense for your setup. <a href=""http://www.postgresql.org/docs/current/interactive/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT"" rel=""nofollow noreferrer"">Per documentation:</a></p>

<blockquote>
  <p><code>CURRENT_TIME</code> and <code>CURRENT_TIMESTAMP</code> deliver values with time zone;
  <code>LOCALTIME</code> and <code>LOCALTIMESTAMP</code> deliver values without time zone.</p>
</blockquote>

<p>The look-up on the partial index itself has basically the same cost as using a full index. But since your table is supposedly <em>big</em>, the partial index should be <em>much</em> smaller than a full index, which will much rather fit and stay in RAM and be generally faster. If you have more than enough RAM, compare performance with a simple, big full index without <code>WHERE</code> condition.</p>

<p>The advantage of the partial index obviously deteriorates over time. Create a new index with an updated timestamp in the <code>WHERE</code> condition at intervals of your choosing and drop the old index after that. Queries will start the new (smaller) index immediately, so the old one can easily be dropped. Possible ways to automate are outlined in these related answers with more explanation:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/16168504/best-way-to-exclude-outdated-data-from-a-search-in-postgresql/16173626#16173626"">Best way to exclude outdated data from a search in PostgreSQL</a></li>
<li><a href=""https://stackoverflow.com/questions/18833832/indexed-order-by-with-limit-1/18834122#18834122"">Indexed ORDER BY with LIMIT 1</a></li>
</ul>

<p>You may need to add the exact <code>WHERE</code> condition of the index to your queries (though seemingly redundant) to convince the query planner it's safe to use the partial index. Especially with <em>prepared statements</em> (including all statements in plpgsql functions) where the actual timestamp to compare to is parametrized, else Postgres cannot use the partial index for a <a href=""https://dba.stackexchange.com/questions/86620/monitoring-the-postgres-query-parser/86626#comment156322_86626"">generic query plan</a>.</p>

<p>In the example above you would add the <code>WHERE</code> condition to the query:</p>

<pre><code>AND timestamp &gt; '2014-12-29 23:30:00'::timestamp -- matches index condition exactly
</code></pre>

<p>A more general solution for this can be found in <a href=""https://stackoverflow.com/questions/16168504/best-way-to-exclude-outdated-data-from-a-search-in-postgresql/16173626#16173626"">the linked answer above</a>.</p>

<p>Aside: I wouldn't use ""timestamp"" as identifier because it's a basic type name.</p>
"
"<p>In C, simple addition of numbers will not form a string.</p>

<p>Instead, create a buffer and print to it.</p>

<pre><code>// const char* buf = (char)(((int)0)+s_time_b_h) + "":"" +
//    (char)(((int)0)+s_time_b_min);

//create a string that merges 2 integers together and puts a colon in the middle
char   buf[100];
sprintf(buf, ""%d:%d"", s_time_b_h, s_time_b_min);
</code></pre>
"
"<p>Without seeing the linker error, it's impossible to know what the problem is. A common reason for a linker error to occur is when a symbol can't be resolved. This happens when you have a function prototype or variable declaration, but no definition. Consider:</p>

<pre><code>#include &lt;stdio.h&gt;
extern char *foo;
int main(void) { printf(""%s\n"", foo); return 0; }
</code></pre>

<p>When compiling, you'll see this sort of output:</p>

<pre><code>[dho@zendev ~]$ cc test.c -o test
/tmp/cc2ec2wu.o: In function `main':
test.c:(.text+0x7): undefined reference to `foo'
collect2: error: ld returned 1 exit status
</code></pre>

<p>This error comes up at the link phase because the compiler knows enough about the size of the type to generate all the relevant code. When linking the final binary, the location of the variable's storage is unknown. Similarly, consider:</p>

<pre><code>#include &lt;stdio.h&gt;
int foo(void);
int main(void) { foo(); return 0; }
</code></pre>

<p>And</p>

<pre><code>[dho@zendev ~]$ cc test.c -o test
/tmp/cc8tgEsT.o: In function `main':
test.c:(.text+0x5): undefined reference to `foo'
collect2: error: ld returned 1 exit status
</code></pre>

<p>Here again, we see that there's enough information for the compiler to work, but when linking, we can't find a definition of the foo symbol.</p>

<p>In your code, there are two symbols that are neither declared nor defined: <code>text_layer_set_text</code> and <code>s_time_layer</code>. It is possible that <code>pebble.h</code> declares these symbols, but you are not linking properly to resolve them. I would expect to see this in the case that you have done something like</p>

<pre><code>cc test.c -o test
</code></pre>

<p>Instead of</p>

<pre><code>cc test.c -o test -lpebble
</code></pre>

<p>The line you have highlighted couldn't possibly cause the linker error, but it is problematic. In C, the <code>+</code> operator does not concatenate strings. Thus this line does not do what you think it is doing:</p>

<pre><code>const char* buf = (char)(((int)0)+s_time_b_h) + "":"" + (char)(((int)0)+s_time_b_min);
</code></pre>

<p>Furthermore, casting an integer to a character does not make that integer representable as a character string with the same logical value. (i.e. <code>int i = 42; char c = (char)i;</code> -> <code>c</code> is <code>'*'</code>, not <code>""42""</code>). <code>s_time_b_h</code> and <code>s_time_b_min</code> are also not integers, they are pointers to character. A string in C is a contiguous byte stream of characters that is terminated by a <code>NUL</code> byte (you'll see ""NULL byte"" thrown around, but that's not really super correct). It's pretty clear from this line that you're not familiar with <a href=""http://www.eskimo.com/~scs/cclass/notes/sx11.html"" rel=""nofollow"">dynamic memory allocation or C strings</a>, which differ heavily from Java.</p>

<p>The strings you populate from <code>ctime(3)</code> have the form:</p>

<pre><code>""Wed Jun 30 21:49:08 1993\n""
</code></pre>

<p>Thus, they contain newlines. Even if your code worked as intended, the output of <code>buf</code> would look like:</p>

<pre><code>|Wed Jun 30 21:49:08 1993
:Wed Jun 30 21:49:08 1993
|
</code></pre>

<p>In this example, I have used the pipe character to show where the start and end of the string would be.</p>

<p>Your calls to <code>ctime(3)</code> are flawed. Your value <code>current_time</code> is uninitialized, and so the output of <code>ctime(3)</code> is undefined. Additionally, <code>ctime(3)</code> is not a re-entrant function, so your two calls to it overwrite eachother. Because <code>ctime(3)</code> has a second-level granularity, this probably isn't a problem given your example -- both calls will finish in the same second, and they both use the same input seed (<code>current_time</code>). To do this correctly, you would need (for example):</p>

<pre><code>time_t current_time;
char *s_time_b_h;

current_time = time(NULL);
s_time_b_h = ctime(&amp;current_time);
</code></pre>

<p>Because <code>ctime(3)</code> isn't re-entrant, and you want two values, you'll need to allocate memory for them somewhere. You could do this simply without worrying about dynamic memory allocation:</p>

<pre><code>/*
 * ctime(3) says ""The reentrant version ctime_r() does the same,
 * but stores the string in a user-supplied buffer which should have
 * room for at least 26 bytes.""
 *
 * 26 is length of string plus newline plus NUL byte.
 */
#define CTIME_MAX_LEN 26
char h_buf[CTIME_MAX_LEN], min_buf[CTIME_MAX_LEN];
time_t current_time;
char *s_time_b_h, *s_time_b_min;

current_time = time(NULL);
s_time_b_h = ctime_r(&amp;current_time, h_buf);
if (s_time_b_h == NULL) {
    return -1;
}
s_time_b_min = ctime_r(&amp;current_time, h_buf);
if (s_time_b_min == NULL) {
    return -1;
}

/* Get rid of newlines that you probably don't want */
h_buf[CTIME_MAX_LEN - 2] = '\0';
min_buf[CTIME_MAX_LEN - 2] = '\0';

/*
 * CTIME_MAX_LEN * 2 is enough space for both times, the
 * additional 2 bytes is enough for the colon and NUL-byte.
 */
char o_buf[CTIME_MAX_LEN * 2 + 2];
snprintf(o_buf, sizeof (o_buf), ""%s:%s"", h_buf, min_buf);
text_layer_set_text(s_time_layer, o_buf);
</code></pre>

<p>Of course, until you use different values for the calls to <code>ctime_r(3)</code>, both sides will be the same. And until you fix the linker error, you'll still be unable to test this code.</p>
"
"<p>I think this will help you</p>

<pre><code>print('renaming archive...')
import datetime
dt = str(datetime.datetime.now())
import os
newname = 'danish_'+dt+'.txt'
os.rename('danish.txt', newname)
print('renaming complete...')
</code></pre>
"
"<p>Try this:</p>

<pre><code>import os
import time

timestamp = time.strftime('%H%M-%Y%m%d')
os.rename('oldname.txt', 'oldname_%s.txt' % (timestamp))
</code></pre>

<p>The following will append the timestamp to the file name. You can use this example to expand on it and do whatever you feel like doing. This is a better way then using <code>datetime.datetime.now()</code> as, unformatted, that string will contain a space and that is not recommended on Linux.</p>
"
"<pre><code>import datetime
import os

current_time = datetime.datetime.now()
os.rename('mark.txt', 'mark_' + str(current_time) + '.txt')
</code></pre>
"
"<pre><code>from datetime import datetime
import os

current_time = str(datetime.utcnow())
current_time = ""_"".join(current_time.split()).replace("":"",""-"")
current_time = current_time[:-7]

os.rename('orfile.txt', 'orfile_'+current_time+'.txt')
</code></pre>

<p>This will rename the file to the exact timestamp.</p>

<pre><code>orfile2015-01-02_16-17-41.txt
</code></pre>

<p>Please use appropriate variable names it is a bad habit to give names to variables which don't make sense.</p>
"
"<p>It must be the continuously calling of <code>font = TTF_OpenFont(""DALEK.ttf"", 40);</code> that makes it fail after a time.</p>

<p>SDL allocates memory for every opened font and at some time you are going to run out. (Perhaps the file stays open and your system runs out of file handles.) You need to <em>close</em> the font handle: add</p>

<pre><code>TTF_CloseFont( font );
</code></pre>

<p>at the end of the routines that open it. Alternatively, open the fonts only <em>once</em> (in your <code>main</code>) routine and save their handles in a global variable.</p>

<p>By the way, I also notice you are as liberal with your surfaces. Use a similar function <code>SDL_FreeSurface</code> when you're done with one, again to prevent using resources only once but still having them allocated. (That is for SDL 1.0, which I'm used to. Check SDL 2 documentation.)</p>
"
"<pre><code>double search = 0.; /* or some other value */
bool found = false;
for ( auto &amp; key_value_pair : _sequence ) {
    // key_value_pair.first == map key
    // key_value_pair.second == key's associated value
    if ( key_value_pair.first.first &lt;= search || search &lt;= key_value_pair.first.second ) {
        found = true;
        break;
    }
}
if ( found ) {
    /* it's within an interval pair! */
} else {
    /* it's not within an interval pair! */
}
</code></pre>

<p>I would recommend also looking into <a href=""http://www.boost.org/doc/libs/1_57_0/libs/icl/doc/html/index.html"" rel=""nofollow""><code>boost::icl</code></a></p>
"
"<p>Firstly, don't use a <code>map</code> keyed on <code>std::pair&lt;double, double&gt;</code> if searching for inclusion is the main thing you want to do. That's just not an operation that makes sense with that data structure.</p>

<p>But if you insist, the code would look something like this (in C++11):</p>

<pre><code>bool isWithinInterval() const {
    for (const auto&amp; pr : _sequence) {
        if (_currentTime &gt;= pr.first.first &amp;&amp; _currentTime &lt;= pr.first.second) {
            return true;
        }
    }
    return false;
}
</code></pre>

<p>Pre-C++11, same idea, just slightly different loop syntax. Ideally, we'd use <code>std::find_if</code>, but it's a hassle to express the map's <code>value_type</code>. In C++14 though, no such hassle:</p>

<pre><code>auto it = std::find_if(_sequence.begin(),
                       _sequence.end(),
                       [_currentTime](const auto&amp; pr) {
                           return _currentTime &gt;= pr.first.first &amp;&amp; _currentTime &lt;= pr.first.second;
                       });
return it != _sequence.end();
</code></pre>

<p>Or just:</p>

<pre><code>return std::any_of(_sequence.begin(), _sequence.end(),
                   [_currentTime](const auto&amp; pr) {
                       return _currentTime &gt;= pr.first.first &amp;&amp; _currentTime &lt;= pr.first.second;
                   });
</code></pre>
"
"<p>One approach could be <em>not</em> to use a <code>std::map&lt;std::pair&lt;double, double&gt;, std::string&gt;</code> but rather a <code>std::map&lt;double, std::pair&lt;double, std::string&gt;&gt;</code>: you'd use <code>m.lower_bound(current_time)</code> to find the start of a range of elements where <code>current_time</code> could fit. You'd then walk the iterator until it reaches the end, falls into the relevant range, or is beyond the end time:</p>

<pre><code>auto it = _sequence.lower_bound(current_time);
for (; it != _sequence.end() &amp;&amp; current_time &lt;= it-&gt;second; ++it) {
   if (it.first &lt;= current_time) {
       // found a matching element at it
   }
}
</code></pre>

<p>Using the layout with a <code>std::pair&lt;double, double&gt;</code> a key has the awkward need to come up with a second time. You could use <code>std::make_pair(current_time, current_time)</code>, though.</p>
"
"<p>If possible, don't use std::pair as the key.  It doesn't really make sense as a key because you end up with a situation where two overlapping ranges map to the same element.</p>

<p>Anyhow, here is how I would implement the solution to such a problem.  <code>lower_bound</code>/<code>upper_bound</code> are your friend here.  Also, you can avoid the reverse iterator tricks by keying the values on stop time.</p>

<pre><code>#include &lt;map&gt;
#include &lt;stdio.h&gt;

struct ImageStuff
{
  double startTime;
  double stopTime;
  char data[1000];
};

typedef std::map&lt;double, ImageStuff&gt; starttime_map_type;
starttime_map_type starttime_map;

ImageStuff &amp; MakeImage (double start, double stop) {
  ImageStuff newImage;
  newImage.startTime = start;
  newImage.stopTime = stop;
  return starttime_map[start] = newImage;
}

starttime_map_type::iterator FindByTime (double time) {
  starttime_map_type::reverse_iterator i = starttime_map_type::reverse_iterator(starttime_map.upper_bound(time));
  if (i == starttime_map.rend() || time &gt; i-&gt;second.stopTime) {
    printf (""Didn't find an image for time %f\n"", time);
    return starttime_map.end();
  }
  else {
    printf (""Found an image for time %f\n"", time);
    return i.base();
  }
  return starttime_map.end();
}


int main (void)
{
  MakeImage (4.5, 6.5);
  MakeImage (8.0, 12);
  MakeImage (1, 1.2);

  auto i = FindByTime(3);
  i = FindByTime(4.5);
  i = FindByTime(9);
  i = FindByTime(15);

  return 0;
}
</code></pre>
"
"<blockquote>
  <p>I figured it is because the socket is everytime the method is called
  in the infinite loop, the getUdp() method opens a socket, gets the
  message and closes the socket, resulting in the server not being able
  to queue the messages.</p>
</blockquote>

<p>Your intuition is correct.  When you have a UDP socket bound to a port, the networking stack will buffer up (a finite number of) incoming UDP packets for you, so that (assuming you call recv() in a relatively timely manner), no incoming packets should get lost.  But when you closesocket() the socket, that buffer is released, and of course during the times when no socket is bound to the UDP port and a UDP packet is received, the incoming UDP packet will simply be dropped (i.e. never buffered at all) because no sockets are bound to that port.</p>

<blockquote>
  <p>How am I able to tweak this code to receive 2 or more UDP messages?
  Appreciate any advice.</p>
</blockquote>

<p>Conceptually, at least, you'll need to split the getUdp() method into three separate parts:  a Setup() part, that you call once when your program starts up, a Receive() part (containing just the recv() call) that you can call as many times as you like, to receive the next packet, and the finally a Cleanup() part that closes the socket and shuts down the TCP stack (which you would call only when your program is about to exit).  That way the UDP socket remains valid and bound to the port the whole time your program is running, so that the OS will reliably buffer up the incoming UDP packets to give to your program via recv().</p>
"
"<p>As mentioned in the comments, you cannot use <code>syslog()</code> in a signal handler. It is not <a href=""http://man7.org/linux/man-pages/man7/signal.7.html"" rel=""nofollow"">async-signal safe</a>, and as a complicated function (opening and closing the connection to syslog as needed), it is no wonder if using it causes your program to fail in odd and varying ways.</p>

<p>Instead, use <a href=""http://man7.org/linux/man-pages/man2/write.2.html"" rel=""nofollow""><code>write()</code></a> and standard output and standard error streams. For example,</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;

static void wr(int fd, const void *const ptr, const size_t len)
{
    const char       *p = (const char *)ptr;
    const char *const q = (const char *)ptr + len;
    ssize_t           n;

    while (p &lt; q) {
        n = write(fd, p, (size_t)(q - p));
        if (n &gt; (ssize_t)0)
            p += n;
        else
        if (n != (ssize_t)-1 || errno != EINTR)
            return;
    }
}

static void wrerr(const char *const string)
{
    if (string != NULL)
        wr(STDERR_FILENO, string, strlen(string));
}

static void wrout(const char *const string)
{
    if (string != NULL)
        wr(STDOUT_FILENO, string, strlen(string));
}
</code></pre>

<p>Above, <code>wrout()</code> and <code>wrerr()</code> take only a single string (like <code>puts()</code>, except these do not append a newline automatically), and are not as useful as <code>printf()</code>, but they are async-signal safe, and safe to use from a signal handler.</p>

<p>Remember that when using Bash, you can use <code>&gt;out</code> to redirect standard output to file <code>out</code>, and <code>2&gt;err</code> to redirect standard error to file <code>err</code>. Outputting to a terminal is surprisingly slow, so for any timing, do redirect to files (or better yet, don't output extra debugging information at all).</p>

<p>If you do need to send some output from a signal handler to syslog, you need to use a pipe or a socket pair, and have a thread or a child process read from the other end of that, sending the data to syslog. Then you can just write to the pipe or socket pair (using <code>write()</code>) from the signal handler, using only async-signal safe functions. (Obviously, the thread or child process that reads and syslogs the data, does not need to use async-signal safe functions -- after all, it is not a signal handler.) </p>

<hr>

<p>Let's discuss the topic of timeouts in general.</p>

<p>I recommend against using a normal signal for timeouts. If you need signals, say for interrupting a blocking syscall in a specific thread, use a realtime signal (<code>SIGRTMIN+0</code> to <code>SIGRTMAX-0</code>) instead.</p>

<p>In practice, using a separate thread to handle a set of timeouts works out much better. Here is an example, using less than 400 lines of code, which allows you to use any number of concurrent timeouts, and provides both a volatile flag and a semaphore per timeout for easy use. It uses the <code>CLOCK_MONOTONIC</code> clock, which is not susceptible to jumps (UTC seconds, daylight savings time, etc.), but otherwise tries to keep the tick rate of the realtime clock (wall clock):</p>

<pre><code>#define _POSIX_C_SOURCE 200809L
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;time.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdio.h&gt;

/* Number of timeouts to test. */
#ifndef TIMEOUT_TESTS
#define TIMEOUT_TESTS 100000
#endif

/* Seconds per timeout. */
#ifndef TIMEOUT_SECONDS
#define TIMEOUT_SECONDS 0.000000001
#endif

/* Timeout thread worker stack size; uses very few local variables. */
#define TIMEOUT_STACK_SIZE    65536

typedef struct timeout  timeout;
struct timeout {
    struct timeout      *next;
    struct timespec      abstime;   /* Using CLOCK_MONOTONIC clock */
    sem_t                elapsed;   /* sem_post()ed when elapsed */
    volatile int         pending;   /* Cleared to zero when expires */
};

static volatile int      timeouts_error = -1;
static pthread_t         timeouts_thread;
static pthread_mutex_t   timeout_lock;
static pthread_cond_t    timeout_cond; /* Uses CLOCK_MONOTONIC clock */
static timeout *volatile timeout_pending = NULL;

static void *timeouts_worker(void *unused __attribute__((unused)))
{
    struct timespec now;
    timeout *curr;
    int err;

    err = pthread_mutex_lock(&amp;timeout_lock);
    if (err) {
        timeouts_error = err;
        pthread_cond_signal(&amp;timeout_cond);
        return (void *)(long)err;
    }

    timeouts_error = 0;
    pthread_cond_signal(&amp;timeout_cond);

    while (!timeouts_error) {

        /* If there are no pending timeouts,
         * all we need to do is wait for a condition. */
        if (timeout_pending == NULL) {
            pthread_cond_wait(&amp;timeout_cond, &amp;timeout_lock);
            continue;
        }

        /* CLOCK_MONOTONIC is used for the timeouts. */
        if (clock_gettime(CLOCK_MONOTONIC, &amp;now) == -1) {
            timeouts_error = errno;
            pthread_mutex_unlock(&amp;timeout_lock);
            return (void *)(long)timeouts_error;
        }

        /* Trigger and remove all timeouts that have elapsed thus far. */
        curr = timeout_pending;
        while (curr != NULL &amp;&amp;
               (curr-&gt;abstime.tv_sec &lt; now.tv_sec ||
                (curr-&gt;abstime.tv_sec == now.tv_sec &amp;&amp;
                 curr-&gt;abstime.tv_nsec &lt;= now.tv_nsec))) {
            timeout *const prev = curr;
            curr = prev-&gt;next;
            prev-&gt;next = NULL;

            /* Mark 'prev' timeout elapsed. */
            prev-&gt;pending = 0;
            sem_post(&amp;(prev-&gt;elapsed));
        }

        /* No more timeouts? */
        if (timeout_pending == NULL)
            continue;

        /* Wait for the next one to elapse.
         * TODO: Adjust 'now' according to previous over/undershoots,
         *       Say, by one tenth of previous wakeup error
         *       (i.e. dynamically estimating the _timedwait latency).
         *       This would result in much more accurate timeouts.
        */
        now = timeout_pending-&gt;abstime;
        pthread_cond_timedwait(&amp;timeout_cond, &amp;timeout_lock, &amp;now);
    }

    return (void *)0L;
}

static int timeout_free(timeout *const old_timeout)
{
    int err;

    if (old_timeout == NULL)
        return 0;

    err = pthread_mutex_lock(&amp;timeout_lock);
    if (err)
        return errno = err; /* We also leak memory here. */

    /* Remove from timeout_pending chain. */
    if (timeout_pending == old_timeout)
        timeout_pending = old_timeout-&gt;next;
    else {
        timeout *temp = timeout_pending;
        if (temp != NULL)
            while (temp-&gt;next != NULL)
                if (temp-&gt;next == old_timeout) {
                    temp-&gt;next = old_timeout-&gt;next;
                    break;
                } else
                    temp = temp-&gt;next;
    }

    /* Unlock mutex; we no longer need to access the chain. */
    pthread_mutex_unlock(&amp;timeout_lock);

    /* Poison and free the timeout structure. */
    sem_destroy(&amp;(old_timeout-&gt;elapsed));
    old_timeout-&gt;next = NULL;
    old_timeout-&gt;abstime.tv_sec = 0;
    old_timeout-&gt;abstime.tv_nsec = 0;
    old_timeout-&gt;pending = 0;

    free(old_timeout);

    return 0;
}


static timeout *timeout_after(const double seconds)
{
    const long sec = (long)seconds;
    const long nsec = (long)(1000000000.0 * (seconds - (double)sec));
    struct timespec now;
    timeout *new_timeout;
    int err;

    /* Negative time is not allowed. */
    if (seconds &lt; 0.0) {
        errno = EINVAL;
        return NULL;
    }

    /* Get current monotonic time. */
    if (clock_gettime(CLOCK_MONOTONIC, &amp;now))
        return NULL;

    new_timeout = malloc(sizeof *new_timeout);
    if (new_timeout == NULL) {
        errno = ENOMEM;
        return NULL;
    }

    if (sem_init(&amp;(new_timeout-&gt;elapsed), 0, 0) == -1) {
        err = errno;
        free(new_timeout);
        errno = err;
        return NULL;
    }

    new_timeout-&gt;next = NULL;
    new_timeout-&gt;abstime.tv_sec = now.tv_sec + sec + (now.tv_nsec + nsec) / 1000000000L;
    new_timeout-&gt;abstime.tv_nsec = (now.tv_nsec + nsec) % 1000000000L;
    new_timeout-&gt;pending = 1;

    /* Already elapsed? */
    if (new_timeout-&gt;abstime.tv_sec &lt; now.tv_sec ||
        (new_timeout-&gt;abstime.tv_sec == now.tv_sec &amp;&amp;
         new_timeout-&gt;abstime.tv_nsec &lt;= now.tv_nsec)) {
        new_timeout-&gt;next = NULL;
        new_timeout-&gt;pending = 0;
        sem_post(&amp;(new_timeout-&gt;elapsed));
        return new_timeout;
    }

    /* Get timeout lock, to add to chain. */
    err = pthread_mutex_lock(&amp;timeout_lock);
    if (err) {
        sem_destroy(&amp;(new_timeout-&gt;elapsed));
        free(new_timeout);
        errno = err;
        return NULL;
    }


    if (timeout_pending == NULL)
        timeout_pending = new_timeout;
    else
    if (timeout_pending-&gt;abstime.tv_sec &gt; new_timeout-&gt;abstime.tv_sec ||
        (timeout_pending-&gt;abstime.tv_sec == new_timeout-&gt;abstime.tv_sec &amp;&amp;
         timeout_pending-&gt;abstime.tv_nsec &gt;= new_timeout-&gt;abstime.tv_nsec)) {
        new_timeout-&gt;next = timeout_pending;
        timeout_pending = new_timeout;
    } else {
        timeout *temp = timeout_pending;

        while (temp-&gt;next != NULL &amp;&amp;
               (temp-&gt;next-&gt;abstime.tv_sec &gt; new_timeout-&gt;abstime.tv_sec ||
                (temp-&gt;next-&gt;abstime.tv_sec == new_timeout-&gt;abstime.tv_sec &amp;&amp;
                 temp-&gt;next-&gt;abstime.tv_nsec &gt;= new_timeout-&gt;abstime.tv_nsec)))
            temp = temp-&gt;next;

        new_timeout-&gt;next = temp-&gt;next;
        temp-&gt;next = new_timeout;
    }

    /* Timeout chain manipulated; notify and unlock. */
    pthread_cond_signal(&amp;timeout_cond);
    pthread_mutex_unlock(&amp;timeout_lock);

    errno = 0;
    return new_timeout;
}

static int timeouts_end(void)
{
    if (timeouts_error == 0) {
        int err;
        void *errptr;

        pthread_mutex_lock(&amp;timeout_lock);
        timeouts_error = -1;
        pthread_cond_signal(&amp;timeout_cond);
        pthread_mutex_unlock(&amp;timeout_lock);

        err = pthread_join(timeouts_thread, &amp;errptr);
        if (err == 0)
            err = (long)errptr;

        return errno = err;

    } else
    if (timeouts_error != -1) {
        int err;
        void *errptr;

        err = pthread_join(timeouts_thread, &amp;errptr);
        if (err == 0)
            err = (long)errptr;
        else
            err = timeouts_error;

        return errno = err;

    } else
        return errno = ENOENT;
}

static int timeouts_init(void)
{
    pthread_mutexattr_t lock_attrs;
    pthread_condattr_t cond_attrs;
    pthread_attr_t attrs;
    void *errptr;
    int err;

    if (timeouts_error != -1)
        return errno = EEXIST;

    /* Initialize timeout_lock as an adaptive mutex. */
    err = pthread_mutexattr_init(&amp;lock_attrs);
    if (err)
        return errno = err;

    err = pthread_mutexattr_settype(&amp;lock_attrs, PTHREAD_MUTEX_ADAPTIVE_NP);
    if (err)
        return errno = err;

    err = pthread_mutex_init(&amp;timeout_lock, &amp;lock_attrs);
    if (err)
        return errno = err;

    err = pthread_mutexattr_destroy(&amp;lock_attrs);
    if (err)
        return errno = err;

    /* Initialize timeout_cond as a process-private monotonic clock condition variable. */
    err = pthread_condattr_init(&amp;cond_attrs);
    if (err)
        return errno = err;

    err = pthread_condattr_setpshared(&amp;cond_attrs, PTHREAD_PROCESS_PRIVATE);
    if (err)
        return errno = err;

    err = pthread_condattr_setclock(&amp;cond_attrs, CLOCK_MONOTONIC);
    if (err)
        return errno = err;

    err = pthread_cond_init(&amp;timeout_cond, &amp;cond_attrs);
    if (err)
        return errno = err;

    err = pthread_condattr_destroy(&amp;cond_attrs);
    if (err)
        return errno = err;

    /* Initialize the thread attributes to a 64k stack. */
    err = pthread_attr_init(&amp;attrs);
    if (err)
        return errno = err;

    err = pthread_attr_setstacksize(&amp;attrs, TIMEOUT_STACK_SIZE);
    if (err)
        return errno = err;

    /* Grab the timeout lock; we'll wait on the cond later. */
    err = pthread_mutex_lock(&amp;timeout_lock);
    if (err)
        return errno = err;

    /* Start the timeout worker thread. */
    err = pthread_create(&amp;timeouts_thread, &amp;attrs, timeouts_worker, NULL);
    if (err)
        return errno = err;

    pthread_attr_destroy(&amp;attrs);

    /* Wait for the worker to be ready. */
    pthread_cond_wait(&amp;timeout_cond, &amp;timeout_lock);

    /* Failed? */
    if (timeouts_error != 0) {
        timeouts_error = -1;
        pthread_mutex_unlock(&amp;timeout_lock);
        err = pthread_join(timeouts_thread, &amp;errptr);
        if (err == 0)
            err = (long)errptr;
        return errno = err;
    }

    /* Unlock. */
    pthread_mutex_unlock(&amp;timeout_lock);

    /* Success. */
    return 0;
}

int main(void)
{
    long i;
    timeout *t;

    if (timeouts_init()) {
        fprintf(stderr, ""Cannot initialize timeouts: %s.\n"", strerror(errno));
        return EXIT_FAILURE;
    }

    fprintf(stderr, ""Testing:\n"");
    fflush(stderr);

    for (i = 1L; i &lt;= TIMEOUT_TESTS; i++) {

        t = timeout_after(0.000000001);
        if (t == NULL) {
            fprintf(stderr, ""Test %ld of %ld failed: Cannot obtain a timeout: %s.\n"", i, (long)TIMEOUT_TESTS, strerror(errno));
            timeouts_end();
            return EXIT_FAILURE;
        }

        printf(""Timeout %ld of %ld: "", i, (long)TIMEOUT_TESTS);
        fflush(stdout);

        /* Wait for timeout to elapse. */
        sem_wait(&amp;(t-&gt;elapsed));

        printf(""Elapsed.\n"");
        fflush(stdout);

        timeout_free(t);
    }

    if (timeouts_end()) {
        fprintf(stderr, ""Error in disarming timeouts: %s.\n"", strerror(errno));
        return EXIT_FAILURE;
    }

    fprintf(stderr, ""No errors.\n"");
    return EXIT_SUCCESS;
}
</code></pre>

<p>Since we have a dedicated timeout worker thread, the above uses <code>pthread_cond_timedwait()</code> to wait for the next timeout to occur (with the condition variable set to use the <code>CLOCK_MONOTONIC</code> clock source), or a signal (by another thread that a new timeout was inserted).</p>

<p>To interrupt blocking syscalls, add a <code>pthread_t thread</code> to the <code>timeout</code> structure, have the <code>timeout_after()</code> set it to <code>pthread_self()</code>. Install a realtime signal (<code>SIGRTMIN+0</code> for example) handler (with an empty body -- it's the delivery that counts, not what the handler does). Finally, add <code>pthread_kill(curr-&gt;thread, SIGRTMIN+0)</code> to <code>timeouts_worker()</code> to raise the signal in the target thread.</p>

<p>The above implementation uses a simple sorted linked list, <code>timeout_pending</code>, to keep the currently pending timeouts. This yields <em>O(N)</em> behaviour in adding, removing, and triggering the timeouts, which is quite suboptimal if you have hundreds or thousands of concurrent timeouts. Replace the list handling with a binary min-heap for much better performance with lots of concurrent timeouts.</p>

<p>Also, it is not necessary to <em>always</em> signal the timeout worker that a new timeout was added. Since the adder holds the mutex, it would be sufficient to only signal when the new timeout was added as the next to elapse.</p>

<p>The code compiles, but I've not checked the logic thoroughly, so there might be some bugs lurking about. If you find any, let me know, and I shall try to fix them. (I'm quite certain the algorithm and approach itself works, though.)</p>

<p>I do not consider the above code copyrightable, as it is so straightforward, but in case someone does, I consider it to be in Public Domain, and in those jurisdictions that do not have the legal concept, licensed under Creative Commons Zero license. In short: Do what you wish with it, but there are no guarantees, and you cannot blame me for any breakage. </p>

<p>Questions? Comments? Bug fixes?</p>
"
"<p>Some quick remarks:</p>

<ul>
<li><p>your loops access different number of points!<br/>
1st loop (r, x) initialize 50 points<br/>
2nd loop (h) initialize 64 points<br/>
3rd loop (q, dw) access 59 points</p></li>
<li><p>glColor3f values should be between 0 and 1 but, using your grid y values, you get 0, 1 or 2</p></li>
<li><p>beware of the <a href=""http://en.wikipedia.org/wiki/Gimbal_lock"" rel=""nofollow"">gimbal lock problem</a> when trying to rotate your view!</p></li>
</ul>
"
"<p>If you know the position of XXX in character array as x,y,z, you can update array as follows if your 3 digit number is N.</p>

<pre><code>  int N2=N%100;
  int N3=N%10;

current_time[x]=N/100;
current_time[y]=N2%10;
current_time[z]=N3;
</code></pre>
"
"<p>You can use <a href=""http://perldoc.perl.org/functions/localtime.html"" rel=""nofollow""><code>localtime</code></a>:</p>

<pre><code>print scalar localtime($current_time);
</code></pre>

<p>Or you can run <code>localtime</code>'s return values through <a href=""https://metacpan.org/pod/POSIX#strftime"" rel=""nofollow""><code>POSIX::strftime</code></a> (which is distributed with Perl as a core module):</p>

<pre><code>use POSIX qw(strftime);

print strftime('%Y-%m-%d %H:%M:%S', localtime $current_time);
</code></pre>
"
"<p>That's easy to do with <a href=""http://perldoc.perl.org/functions/localtime.html"" rel=""nofollow"">localtime</a>.  Hours, minutes, and seconds are the 2nd, 1st, and 0th values returned.  For example:</p>

<pre><code>my ($sec, $min, $hours) = localtime(time()+120); # add 120 seconds

printf ""%02d:%02d:%02d\n"", $hours, $min, $sec;
</code></pre>
"
"<p><a href=""https://metacpan.org/pod/Time::Piece"" rel=""nofollow"">Time::Piece</a> and <a href=""https://metacpan.org/pod/Time::Seconds"" rel=""nofollow"">Time::Seconds</a> have been included with all Perl installations since 2007.</p>

<pre><code>#!/usr/bin/perl

use strict;
use warnings;
use 5.010;

use Time::Piece;
use Time::Seconds;

my $time = localtime;
$time += 2 * ONE_MINUTE;

say $time-&gt;strftime('%H:%M');
</code></pre>
"
"<p>1.exec netstat &amp; get the ip address<br>
2.grep ip result.txt<br>
3.if there is no that ip, write this one,otherwise don't.  </p>

<p>You can crontab to exec your script.</p>
"
"<p>Not quite bash but perl, but it does what you want, here is the whole script:</p>

<pre><code>use warnings;
use strict;
use Socket;
use feature 'say';

sub hex_to_ip {my $i = shift; inet_ntoa( pack( ""N"", hex( $i ) ) )}
sub addresses {open(my $net,""&lt;"",""/proc/net/tcp""); my %add;while(&lt;$net&gt;) {my $r = (split "" "",$_)[2];$r =~ s/(rem.*|:.*)//; $add{hex_to_ip($r)}++}; return %add};

my %old;
while(1) {
open(my $new_file,""&gt;&gt;"",""/tmp/new_connections.txt"");
my %fresh = &amp;addresses;
for my $f(keys %fresh) {
    my $current_time = localtime;
    say $new_file ""$f $current_time\n"" unless exists $old{$f};
}
close $new_file;
say ""!!""; %old = %fresh; sleep 2;
}
</code></pre>

<p>function to convert hex to ip</p>

<pre><code>sub hex_to_ip {my $i = shift; inet_ntoa( pack( ""N"", hex( $i ) ) )}
</code></pre>

<p>returns all remote addresses found in ""/proc/net/tcp""</p>

<pre><code>sub addresses {open(my $net,""&lt;"",""/proc/net/tcp"");
   my %add;while(&lt;$net&gt;) {my $r = (split "" "",$_)[2];
   $r =~ s/(rem.*|:.*)//; $add{hex_to_ip($r)}++}; return %add
 }
</code></pre>

<p>opens a file for appending (does not clobber what is in it)</p>

<pre><code>open(my $new_file,""&gt;&gt;"",""/tmp/new_connections.txt"");
</code></pre>

<p>runs the entire life of the program</p>

<pre><code>while(1)
</code></pre>

<p>Gets a fresh copy of the current addresses, and if $old does not have them, it writes to the file with a timestamp. (Since $old is not populated on the first try, it will write all the addresses on the first loop) and sleeps for two seconds.</p>

<pre><code> my %fresh = &amp;addresses;
for my $f(keys %fresh) {
    my $current_time = localtime;
    say $new_file ""$f $current_time"" unless exists $old{$f};
}
say ""!!""; %old = %fresh; sleep 2;
</code></pre>

<p>}</p>
"
"<p>Because ""standard compiler flags"" means you're compiling without optimizations enabled.</p>

<p><code>std::unique_ptr</code> is a thin wrapper around a raw pointer. As such, when dereferencing it, it goes through a very simple forwarding function, which the compiler is able to optimize away. But it only does that if optimizations are enabled. If they are, then it can eliminate the overhead of going through the wrapper, so performance will be the same as if you'd just used a raw pointer.</p>

<p>But if you don't ask the compiler to optimize your code, then every time you access the pointer, it has to go through the small wrapper function to get to the <em>actual</em> internal pointer.</p>

<p>Always, <em>always</em> enable optimization when benchmarking code.</p>
"
"<p>I don't think there is anyway to do this as bind is not constexpr.</p>

<p>Also lambdas are not constexpr-able.</p>

<p>Edit: there is this trick to make a constexpr-like lambda <a href=""http://pfultz2.com/blog/2014/09/02/static-lambda/"" rel=""nofollow"">http://pfultz2.com/blog/2014/09/02/static-lambda/</a></p>
"
"<p>Adding another answer 'cause it takes a very different tack to what you want.</p>

<p>std::bind isn't necessary in this case, because no 'binding' is happening.</p>

<p>However I feel this could lead to some confusing problems down the line, since current_time isn't really an alias in the same way that using delcarations are.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;chrono&gt;

using namespace std;

auto constexpr current_time = std::chrono::high_resolution_clock::now;

int main() {
    auto now = current_time();
    cout &lt;&lt; std::chrono::system_clock::to_time_t(now) &lt;&lt; endl;
    return 0;
}
</code></pre>
"
"<p>Using GCC it is possible to create a ""function alias"", but only for functions which are defined in the same translation unit and for which you know the mangled name, so it's not possible to do reliably  for <code>std::chrono::high_resolution_clock::now()</code></p>

<p>See the <code>alias</code> attribute at <a href=""https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html"" rel=""nofollow"">https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html</a></p>
"
"<p>Keep it simple.</p>

<pre><code>const auto current_time = std::chrono::high_resolution_clock::now;
</code></pre>
"
"<p>Here's what I do if I want to create a simple function alias</p>

<pre><code>contexpr auto &amp;&amp;now = std::chrono::high_resolution_clock::now;
</code></pre>

<p>and if I want to create a full wrapper alias that will be inlined</p>

<pre><code>template&lt;typename ... Args&gt;
inline constexpr auto now(Args &amp;&amp;... args) -&gt; decltype(std::chrono::high_resolution_clock::now(std::forward&lt;Args&gt;(args)...)){
    return std::chrono::high_resolution_clock::now(std::forward&lt;Args&gt;(args)...);
}
</code></pre>

<p>The reason why I use a universal reference <code>auto&amp;&amp;</code> in the alias definition is because of the possibility of <code>addressof(now) == addressof(std::chrono::high_resolution_clock::now)</code>.</p>

<p>On my system with G++ 4.9.2 running this:</p>

<pre><code>constexpr auto &amp;&amp;now_ref = std::chrono::high_resolution_clock;
constexpr auto now_var = std::chrono::high_resolution_clock;

template&lt;typename ... Args&gt;
inline constexpr auto now_wrapper(Args &amp;&amp;... args)
    -&gt; decltype(std::chrono::high_resolution_clock(std::forward&lt;Args&gt;(args)...){
    return std::chrono::high_resolution_clock(std::forward&lt;Args&gt;(args)...);
}

void main(int argc, char *argv[]){
    std::cout &lt;&lt; std::hex &lt;&lt; std::showbase;
    std::cout &lt;&lt; (uintptr_t)std::addressof(std::chrono::high_resolution_clock) &lt;&lt; '\n';
    std::cout &lt;&lt; (uintptr_t)std::addressof(now_wrapper&lt;&gt;) &lt;&lt; '\n';
    std::cout &lt;&lt; (uintptr_t)std::addressof(now_var) &lt;&lt; '\n';
    std::cout &lt;&lt; (uintptr_t)std::addressof(now_ref) &lt;&lt; '\n';
}
</code></pre>

<p>I get the following results:</p>

<pre><code>0x4007c0
0x400a50
0x400ae8
0x4007c0
</code></pre>

<p>Showing that only the <code>auto&amp;&amp;</code> is actually a direct alias of the function, whereas all other methods have some level of indirection. (although, after compilation they <em>may</em> be replaced by inlined function calls. <strong>maybe</strong>.)</p>
"
"<p>It looks like you have a few issue with your code. Your date parsing also seems to be incorrect, though it's hard to say without more info. Using <code>strtotime</code> in both the function to set <code>unixstarttime</code> and your query code would be good. Your code uses <code>time()</code> which will include the seconds and leave out events for ""today"". You have no time zone so everything will be treated as GMT, which is fine as long as you keep that in mind.</p>

<p>Not really a big deal, but you are specifying two parameters for your callback in the <code>add_action</code> but the function only takes one argument.</p>

<p>The next problem is the <code>have_posts()</code> loop - you need to specify the custom query <code>$query</code> to loop over it.</p>

<pre><code>&lt;?php if ( $query-&gt;have_posts() ) : while ( $query-&gt;have_posts() ) : $query-&gt;the_post(); ?&gt;
</code></pre>

<p>I also implemented it a slightly different way using the <code>updated_{type}_meta</code> action to only fire on the proper meta key, and then check the post type. It should only run when the meta value is updated rather than every time the post is saved. I would also recommend sorting by the <code>unixstarttime</code> meta value since it is numeric.</p>

<p><strong>functions.php</strong></p>

<pre><code>// create/update unixstartdate based on event_type.event_date update
add_action( 'updated_post_meta', 'my_updated_post_meta', 20, 4 );
function my_updated_post_meta( $meta_id, $object_id, $meta_key, $_meta_value ){
    if ( $meta_key == 'event_date' &amp;&amp; 'event_type' == get_post_type( $object_id ) ){
        $unixstartdate = strtotime( $_meta_value );
        update_post_meta( $object_id, 'unixstartdate', $unixstartdate );
    }
}
</code></pre>

<p><strong>template page</strong></p>

<pre><code>$args = array(
    'post_type' =&gt; 'event_type',
    'posts_per_page' =&gt; 5,
    'meta_query' =&gt; array(
        array(
            'key' =&gt; 'unixstartdate',
            'compare' =&gt; '&gt;=',
            'value' =&gt; strtotime('m/d/Y', time()),
        )
    ),
    'meta_key' =&gt; 'unixstartdate',
    'orderby' =&gt; 'meta_value',
    'order' =&gt; 'ASC',
);

$query = new WP_Query( $args );
if ( $query-&gt;have_posts() ) : while ( $query-&gt;have_posts() ) : $query-&gt;the_post();
    the_title(); // whatever you want to use from $post
endwhile; endif;
</code></pre>
"
"<p>I found a solution here thanks to <strong>svsdnb.</strong></p>

<p><a href=""https://wordpress.org/support/topic/query-date-array-to-display-future-events-only"" rel=""nofollow"">https://wordpress.org/support/topic/query-date-array-to-display-future-events-only</a></p>

<p>Instead of having to convert the timestamp in functions.php, there is a way to do this specifically with ACF where you use</p>

<pre><code>current_time('Ymd')
</code></pre>

<p>instead of</p>

<pre><code> $today = date ('Ymd')
</code></pre>

<p>Here's what I've ended up with (and it seems to be working, and includes events that happen today):</p>

<pre><code>&lt;?php
$today = current_time('Ymd');
$args = array(
    'post_type' =&gt; 'event_type',
    'post_status' =&gt; 'publish',
    'posts_per_page' =&gt; '0',
    'meta_query' =&gt; array(
        array(
            'key' =&gt; 'event_date',
            'compare' =&gt; '&gt;=', // Upcoming Events - Greater than or equal to today
            'value' =&gt; $today,
        )
    ),
    'meta_key' =&gt; 'event_date',
    'orderby' =&gt; 'meta_value',
    'order' =&gt; 'ASC',
    );

$query = new WP_Query( $args );
if ( $query-&gt;have_posts() ) : while ( $query-&gt;have_posts() ) : $query-&gt;the_post();
?&gt;
</code></pre>
"
"<pre><code>&lt;div class=""row""&gt;

&lt;?php
$today = current_time('Ymd');
$args = array(
    'post_type' =&gt; 'your-custom-post-type',
    'post_status' =&gt; 'publish',
    'posts_per_page' =&gt; '-1',
    'meta_query' =&gt; array(
        array(
            'key' =&gt; 'event_date',//your date picker field name
            'compare' =&gt; '&gt;=', // Upcoming Events - Greater than or equal to today
            'value' =&gt; $today,
        )
    ),
    'meta_key' =&gt; 'event_date',
    'orderby' =&gt; 'meta_value',
    'order' =&gt; 'Desc',
    );

$query = new WP_Query( $args );
if ( $query-&gt;have_posts() ) : while ( $query-&gt;have_posts() ) : $query-&gt;the_post();
?&gt;
&lt;?php  $dateformatstring = ""F d, Y"";

$unixtimestamp = strtotime(get_field('event_date')); ?&gt;

&lt;div class=""post""&gt;

    &lt;a href=""&lt;?php the_permalink; ?&gt;""&gt;&lt;?php the_title(); ?&gt;&lt;/a&gt;
 &lt;?php echo date_i18n($dateformatstring, $unixtimestamp); ?&gt;

&lt;/div&gt;

 &lt;?php
  endwhile;
endif;
wp_reset_query();  // Restore global post data stomped by the_post().
?&gt;

&lt;/div&gt;
</code></pre>
"
"<p>Emplacement on map is a rather strange thing. I would recommend Scott Meyers latest book or look at the <a href=""https://www.youtube.com/watch?v=smqT9Io_bKo"" rel=""nofollow"">talk</a>. It is about cwuks(term by Scott).</p>

<p>But to fix your problem. Use the heap.
By changing your logger_instance to be a unique_ptr in the manager.
E.g:</p>

<pre><code>class logger_manager
{
    std::map &lt; std::string, unique_ptr&lt;logger_instance&gt; &gt; loggers;
public:
    void add_logger(std::string logger)
    {
        auto it = loggers.find(logger);
        if (it == loggers.end())
        {
            loggers.emplace(logger, make_unique&lt;logger_instance&gt;(logger));
        }
    }

    logger_instance&amp; operator[](std::string logger)
    {
        return *loggers[logger];
    }
};
</code></pre>
"
"<p>This worked for me:</p>

<pre><code>CLS
@ECHO OFF

set yy=%date:~-4%
set mm=%date:~-7,2%
set dd=%date:~-10,2%
set newdate=%dd%%mm%%yy% &amp; time /T

echo %newdate%
pause
</code></pre>

<p>You can run multiple commands by adding the <code>&amp;</code> symbol. If you wish to only append time, if the first command suceed, use <code>&amp;&amp;</code> instead.</p>
"
"<p>Read the time into a variable first to get a snapshot so that it doesn't keep ticking while you're extracting the fields.  Then use the <code>set</code> substring operators to extract what you want.</p>

<p>The time has the format <code>HH:MM:SS.MS</code> (at least in my en-us locale).  One gotcha is that the hour field might start with a leading space, so you need an <code>if</code> condition to change it to a leading zero or to remove the space.</p>

<pre><code>set ""current_time=%time%""

set ""hour=%current_time:~0,2%""
if ""%current_time:~0,1%""=="" "" set ""hour=0%current_time:~1,1%""
set ""min=%current_time:~3,2%""
set ""sec=%current_time:~6,2%""
set ""ms=%current_time:~-2%""

set ""newtime=%hour% %min% %sec% %ms%""

echo %newtime%
</code></pre>

<p>If you want to remove the front space in the hour instead of changing it to a leading zero, then you'd do this instead:</p>

<pre><code>set ""hour=%current_time:~0,2%""
if ""%current_time:~0,1%""=="" "" set ""hour=%current_time:~1,1%""
</code></pre>
"
"<pre><code>@ECHO OFF
CLS
set yy=%date:~-4%
set dd=%date:~-7,2%
set mm=%date:~-10,2%
set newdate=%dd%%mm%%yy%_%Time:~0,8%
set newdate=%newdate::=%
echo %newdate%
pause
</code></pre>
"
"<p>Convert the <code>time_t</code> value to <code>struct tm</code> and then format appropriately</p>

<pre><code>char dt[20]; // space enough for DD/MM/YYYY HH:MM:SS and terminator
struct tm tm;
time_t current_time;

current_time = time(NULL);
tm = *localtime(&amp;current_time); // convert time_t to struct tm
strftime(dt, sizeof dt, ""%d/%m/%Y %H:%M:%S"", &amp;tm); // format

fprintf(currfd, ""%s %d %d\n"", dt, temp, humidity);
</code></pre>

<p>See the POSIX descriptions of <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/localtime.html"" rel=""nofollow""><code>localtime()</code></a> and <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/strftime.html"" rel=""nofollow""><code>strftime()</code></a>.</p>
"
"<p><a href=""http://en.wikipedia.org/wiki/Merge_sort"" rel=""nofollow"">Mergesort</a> is O(nlogn) for linked lists. I don't know what the default sort function is for C++, but I suspect its mergesort.</p>
"
"<p>Linked lists can be sorted in <em>O(n log n)</em> using <a href=""http://en.wikipedia.org/wiki/Merge_sort"" rel=""noreferrer"">Mergesort</a>.</p>

<p>Interestingly, since linked lists already have the appropriate structure, sorting a linked list with Mergesort only requires <em>O(1)</em> extra space.</p>

<p>The fact that this requires a specialized algorithm specifically tuned for the list structure is also the reason <code>sort</code> is a member function of the list, rather than a separate function.</p>

<hr>

<p>As for how it works - all you need is the merge operation. The merge operation takes two lists. You look at the heads of both lists, and remove the smallest head and append it to your result list. You keep doing this until all heads have been merged into the big list - done.</p>

<p>Here's a sample merge operation in C++:</p>

<pre><code>struct Node {
    Node* next;
    int val;
};

Node* merge(Node* a, Node* b) {
    Node fake_head(nullptr, 0);

    Node* cur = &amp;fake_head;
    while (a &amp;&amp; b) {
        if (a-&gt;val &lt; b-&gt;val) { cur-&gt;next = a; a = a-&gt;next; }
        else                 { cur-&gt;next = b; b = b-&gt;next; }
        cur = cur-&gt;next;
    }

    cur-&gt;next = a ? a : b;
    return fake_head.next;
}
</code></pre>
"
"<p>I don't have the standard here, but <a href=""http://en.cppreference.com/w/cpp/container/forward_list/sort"" rel=""nofollow"">CPPReference</a> states that the complexity of sort is Nlog(N) <strong>comparisons</strong>. This means that even quick sort would be a standard conforming implementation as it would be Nlog(N) comparisons (but not Nlog(N) time).</p>
"
"<p>Example code of a bottom up merge sort using an array of pointers to lists where array[i] points to a list of size 2^i (except last pointer points to a list of unlimited size). This is how the HP / Microsoft standard template library implements std::list::sort. </p>

<pre><code>#define NUMLISTS 32                     /* number of lists */

typedef struct NODE_{
struct NODE_ * next;
int data;                               /* could be any comparable type */
}NODE;

NODE * MergeLists(NODE *, NODE *);

NODE * SortList(NODE *pList)
{
NODE * aList[NUMLISTS];                 /* array of lists */
NODE * pNode;
NODE * pNext;
int i;
    if(pList == NULL)                   /* check for empty list */
        return NULL;
    for(i = 0; i &lt; NUMLISTS; i++)       /* zero array */
        aList[i] = NULL;
    pNode = pList;                      /* merge nodes into aList[] */
    while(pNode != NULL){
        pNext = pNode-&gt;next;
        pNode-&gt;next = NULL;
        for(i = 0; (i &lt; NUMLISTS) &amp;&amp; (aList[i] != NULL); i++){
            pNode = MergeLists(aList[i], pNode);
            aList[i] = NULL;
        }
        if(i == NUMLISTS)
            i--;
        aList[i] = pNode;
        pNode = pNext;
    }
    pNode = NULL;                       /* merge array into one list */
    for(i = 0; i &lt; NUMLISTS; i++)
        pNode = MergeLists(aList[i], pNode);
    return pNode;
}

NODE * MergeLists(NODE *pSrc1, NODE *pSrc2)
{
NODE *pDst = NULL;                      /* destination head ptr */
NODE **ppDst = &amp;pDst;                   /* ptr to head or prev-&gt;next */
    while(1){
        if(pSrc1 == NULL){
            *ppDst = pSrc2;
            break;
        }
        if(pSrc2 == NULL){
            *ppDst = pSrc1;
            break;
        }
        if(pSrc2-&gt;data &lt; pSrc1-&gt;data){  /* if src2 &lt; src1 */
            *ppDst = pSrc2;
            pSrc2 = *(ppDst = &amp;(pSrc2-&gt;next));
            continue;
        } else {                        /* src1 &lt;= src2 */
            *ppDst = pSrc1;
            pSrc1 = *(ppDst = &amp;(pSrc1-&gt;next));
            continue;
        }
    }
    return pDst;
}
</code></pre>

<p>Another but slower way to merge sort a list is similar to a 4 tape sort (all sequential access). The initial list is split into two lists. Each list is considered to be a stream of runs, where the initial run size is 1. In this example, counters are used to keep track of run boundaries so it's a bit more complicated and slower than the array of pointers method. Runs from two input lists are merged, alternating between two output lists. After each merge pass, the run size is doubled, the direction of the merge is changed so what were output lists become input lists and vice versa. The sort is done when all runs end up on just one of the output lists. If stability is not required, then run boundaries could be defined as any node followed by an out of order node, and this would take advantage of natural ordering with the original list.</p>

<pre><code>NODE * SortList(NODE * pList)
{
NODE *pSrc0;
NODE *pSrc1;
NODE *pDst0;
NODE *pDst1;
NODE **ppDst0;
NODE **ppDst1;
int cnt;

    if(pList == NULL)                   /* check for null ptr */
        return NULL;
    if(pList-&gt;next == NULL)             /* if only one node return it */
        return pList;
    pDst0 = NULL;                       /* split list */
    pDst1 = NULL;
    ppDst0 = &amp;pDst0;
    ppDst1 = &amp;pDst1;
    while(1){
        *ppDst0 = pList;
        pList = *(ppDst0 = &amp;pList-&gt;next);
        if(pList == NULL)
            break;
        *ppDst1 = pList;
        pList = *(ppDst1 = &amp;pList-&gt;next);
        if(pList == NULL)
            break;
    }
    *ppDst0 = NULL;
    *ppDst1 = NULL;
    cnt = 1;                            /* init run size */
    while(1){
        pSrc0 = pDst0;                  /* swap merge direction */
        pSrc1 = pDst1;
        pDst0 = NULL;
        pDst1 = NULL;
        ppDst0 = &amp;pDst0;
        ppDst1 = &amp;pDst1;
        while(1){                       /* merge a set of runs */
            if(MergeRuns(&amp;ppDst0, &amp;pSrc0, &amp;pSrc1, cnt))
                break;
            if(MergeRuns(&amp;ppDst1, &amp;pSrc0, &amp;pSrc1, cnt))
                break;
        }
        cnt &lt;&lt;= 1;                      /* bump run size */
        if(pDst1 == NULL)               /* break if done */
            break;
    }
    return pDst0;
}

int MergeRuns(NODE ***pppDst, NODE **ppSrc0, NODE **ppSrc1, int cnt)
{
NODE **ppDst = *pppDst;
NODE *pSrc0  = *ppSrc0;
NODE *pSrc1  = *ppSrc1;
int cnt0, cnt1;

    cnt0 = cnt;
    cnt1 = cnt;
    if(pSrc0 == NULL){                      /* if end data src0 */
        *ppDst = NULL;
        *pppDst = ppDst;
        return(1);
    }
    if(pSrc1 == NULL){                      /* if end data src1 */
        do{                                 /*   copy rest of src0 */
            *ppDst = pSrc0;
            pSrc0 = *(ppDst = &amp;(pSrc0-&gt;next));
        }while(pSrc0);
        *ppDst = NULL;
        *pppDst = ppDst;
        return(1);
    }
    while(1){
        if(pSrc1-&gt;data &lt; pSrc0-&gt;data){      /* if src1 &lt; src0 */
            *ppDst = pSrc1;                 /*  move src1 */
            pSrc1 = *(ppDst = &amp;(pSrc1-&gt;next));
            if(pSrc1 != NULL &amp;&amp; --cnt1)     /*  if not end run1, continue */
                continue;
            do{                             /*    copy run0 */
                *ppDst = pSrc0;
                pSrc0 = *(ppDst = &amp;(pSrc0-&gt;next));
            }while(pSrc0 != NULL &amp;&amp; --cnt0);
            break;
        } else {                            /* else src0 &lt;= src1 */
            *ppDst = pSrc0;                 /*  move src0 */
            pSrc0 = *(ppDst = &amp;(pSrc0-&gt;next));
            if(pSrc0 != NULL &amp;&amp; --cnt0)     /*  if not end run0, continue */
                continue;
            do{                             /*    copy run1 */
                *ppDst = pSrc1;
                pSrc1 = *(ppDst = &amp;(pSrc1-&gt;next));
            }while(pSrc1 != NULL &amp;&amp; --cnt1);
            break;
        }
    }
    *ppSrc0 = pSrc0;                        /* update ptrs, return */
    *ppSrc1 = pSrc1;
    *ppDst  = NULL;
    *pppDst = ppDst;
    return(0);
}
</code></pre>
"
"<p>You start with an unsorted list of unknown length. Say the elements are numbered 0, 1, 2, 3...</p>

<p>In the first pass, you created two linked lists, each consisting of pairs of numbers in sorted order. List 0 starts with elements 0 and 1 in sorted order. List 1 starts with elements 2 and 3 in sorted order. Elements 4 and 5 are added to List 0 in sorted order, 6 and 7 are added to List 1 and so on. Obviously care must be taken not to overshoot the end of the original list. </p>

<p>In the second pass, you merge these two lists to created two linked lists, each consisting of sets of 4 numbers in sorted order. Each time you combine two elements from List 0 and two elements from List 1. The next smallest element is obviously every time the one at the front of the list. </p>

<p>In the second pass, you merge these lists into two linked lists, each consisting of sets of 8 sorted numbers, then 16, then 32 and so on, until the resulting list would contain n or more numbers. If n = 2^k then there are k = log2 (n) passes, so this takes O (n log n). </p>
"
"<p>To get to the bottom of this, the best idea is to find an implementation and look at what it does. I downloaded Apple's <a href=""http://www.opensource.apple.com/tarballs/Libc/Libc-1044.1.2.tar.gz"" rel=""nofollow""><code>Libc</code> tarball for OS X 10.1.1</a> (whose link can be found on <a href=""http://www.opensource.apple.com/release/os-x-10101/"" rel=""nofollow"">this page</a>), and found that <code>ctime</code> is defined in stdtime/FreeBSD/localtime.c.</p>

<p>The function goes like this:</p>

<pre><code>char *
ctime(timep)
const time_t * const    timep;
{
/*
** Section 4.12.3.2 of X3.159-1989 requires that
**  The ctime function converts the calendar time pointed to by timer
**  to local time in the form of a string.  It is equivalent to
**      asctime(localtime(timer))
*/
#ifdef __LP64__
    /*
     * In 64-bit, the timep value may produce a time value with a year
     * that exceeds 32-bits in size (won't fit in struct tm), so localtime
     * will return NULL.
     */
    struct tm *tm = localtime(timep);

    if (tm == NULL)
        return NULL;
    return asctime(tm);
#else /* !__LP64__ */
    return asctime(localtime(timep));
#endif /* __LP64__ */
}
</code></pre>

<p>From a <a href=""http://www.cplusplus.com/reference/ctime/tm/"" rel=""nofollow"">second-hand reference</a>, <code>struct tm</code> appears to be defined in terms of integers, and the <code>tm_year</code> field is an offset from 1900. Assuming conformance to that, even a non-conforming <code>ctime</code> cannot possibly accept a timestamp after year 2<sup>31</sup>+1900-1.</p>

<p>Here is a program that finds (and tests) the largest timestamp <code>ctime</code> will accept with Apple's implementation:</p>

<pre><code>#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main(int argc, char** argv) {
    struct tm t = {
        .tm_sec = 59,
        .tm_min = 59,
        .tm_hour = 23,
        .tm_mday = 31,
        .tm_mon = 11,
        .tm_year = INT_MAX,
    };
    time_t max = mktime(&amp;t);

    printf(""Maximum time: %li\n"", max);
    printf(""ctime max: %s\n"", ctime(&amp;max));
    max++;
    printf(""ctime max+1: %s\n"", ctime(&amp;max));
}
</code></pre>

<p>Output:</p>

<blockquote>
  <p>Maximum time: 67768036191694799<br>
  ctime max: Wed Dec 31 23:59:59     2147485547<br>
  ctime max+1: (null)</p>
</blockquote>

<p>This is a 56-bit number, so the maximum year a 64-bit <code>time_t</code> can hold (though <code>struct tm</code> can't) is probably between 547,608,814,485 and 549,756,300,032, or like 36 times the age of the universe. In other words, it's going to be a while.</p>

<p>For what it's worth, Apple's implementation is not conforming. The standard says that the output of <code>ctime</code> has to fit inside 26 bytes, including a newline character and a null character. For a conforming implementation, this means that the year has to be within -999 and 9999.</p>
"
"<p>BTW, <a href=""http://www.cplusplus.com/reference/ctime/ctime/"" rel=""nofollow noreferrer"">ctime</a> (&amp; <a href=""http://man7.org/linux/man-pages/man3/ctime.3.html"" rel=""nofollow noreferrer"">ctime(3)</a>) is documented as giving a string with the year represented by <em>four</em> digits (for a total of 26 bytes). So the maximal time is in the year 9999 (certainly less than maximal <code>time_t</code> on a machine with 64 bits <code>time_t</code>).</p>

<p>Also (as I commented),  pragmatically, if <code>time_t</code> has more than 40 bits (e.g. 64 bits) you don't care about the maximally representable time. You and everyone reading that forum (and all our grand grand children) would be dead, the computers running your program will all be destroyed, and at that time C won't exist anymore. The <a href=""http://en.wikipedia.org/wiki/Year_2038_problem"" rel=""nofollow noreferrer"">Y2038 problem</a> don't practically have any 64 bits equivalent. So just special case when <code>time_t</code> is 32 bits. </p>

<p><sup>It is very unlikely than any C program would matter after the year 3000; software, hardware, standards, and human technical expertise don't last that long...</sup></p>

<p>The <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/"" rel=""nofollow noreferrer"">POSIX ctime documentation</a> says <em>explicitly</em> :</p>

<blockquote>
  <p>Attempts to use <code>ctime()</code> or <code>ctime_r()</code> for times before the Epoch or for times beyond the year 9999 produce <em>undefined results</em>. Refer to <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/functions/asctime.html#"" rel=""nofollow noreferrer"">asctime</a>.</p>
</blockquote>

<p>BTW, <a href=""http://musl-libc.org/"" rel=""nofollow noreferrer"">musl-libc</a> seems to be conformant to the standard: <a href=""http://git.musl-libc.org/cgit/musl/tree/src/time/__asctime.c"" rel=""nofollow noreferrer"">its <code>time/__asctime.c</code></a> (indirectly called by <code>ctime</code>) has a nice comment:</p>

<pre><code>if (snprintf(buf, 26, ""%.3s %.3s%3d %.2d:%.2d:%.2d %d\n"",
    __nl_langinfo(ABDAY_1+tm-&gt;tm_wday),
    __nl_langinfo(ABMON_1+tm-&gt;tm_mon),
    tm-&gt;tm_mday, tm-&gt;tm_hour,
    tm-&gt;tm_min, tm-&gt;tm_sec,
    1900 + tm-&gt;tm_year) &gt;= 26)
{
    /* ISO C requires us to use the above format string,
     * even if it will not fit in the buffer. Thus asctime_r
     * is _supposed_ to crash if the fields in tm are too large.
     * We follow this behavior and crash ""gracefully"" to warn
     * application developers that they may not be so lucky
     * on other implementations (e.g. stack smashing..).
     */
    a_crash();
}
</code></pre>

<p>and GNU <code>glibc</code> has in its <a href=""https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=time/asctime.c;hb=HEAD"" rel=""nofollow noreferrer"">time/asctime.c</a> file:</p>

<pre><code>/* We limit the size of the year which can be printed.  Using the %d
   format specifier used the addition of 1900 would overflow the
   number and a negative vaue is printed.  For some architectures we
   could in theory use %ld or an evern larger integer format but
   this would mean the output needs more space.  This would not be a
   problem if the 'asctime_r' interface would be defined sanely and
   a buffer size would be passed.  */
if (__glibc_unlikely (tp-&gt;tm_year &gt; INT_MAX - 1900))
  {
  eoverflow:
    __set_errno (EOVERFLOW);
    return NULL;
  }

int n = __snprintf (buf, buflen, format,
          (tp-&gt;tm_wday &lt; 0 || tp-&gt;tm_wday &gt;= 7 ?
           ""???"" : ab_day_name (tp-&gt;tm_wday)),
          (tp-&gt;tm_mon &lt; 0 || tp-&gt;tm_mon &gt;= 12 ?
           ""???"" : ab_month_name (tp-&gt;tm_mon)),
          tp-&gt;tm_mday, tp-&gt;tm_hour, tp-&gt;tm_min,
            tp-&gt;tm_sec, 1900 + tp-&gt;tm_year);
if (n &lt; 0)
 return NULL;
if (n &gt;= buflen)
  goto eoverflow;
</code></pre>

<p>So I believe that both GNU glibc and musl-libc are better than MacOSX implementation (as cited in <a href=""https://stackoverflow.com/a/30018023/841108"">zneak's answer</a>) on that aspect. The standards requires <code>ctime</code> to give 26 bytes. Also, <strong>POSIX 2008 is marking <code>ctime</code> as <em>obsolete</em></strong>, new code should use <a href=""http://pubs.opengroup.org/onlinepubs/9699919799/"" rel=""nofollow noreferrer"">strftime</a> (see also <a href=""http://man7.org/linux/man-pages/man3/strftime.3.html"" rel=""nofollow noreferrer"">strftime(3)</a>).</p>
"
"<p>Your program exhibits undefined behavior since you are using a pointer to an object that has been deleted.</p>

<pre><code>ifstream lf(log_loc);
log_file = &amp;lf;
</code></pre>

<p><code>if</code> gets deleted when the constructor returns and you are still holding on to a pointer to the object.</p>

<p>Change <code>log_file</code> to an object instead of a pointer.</p>
"
"<p>I'm one of those who would give you a similar performance answer, but I'll try to give you something a bit more in-depth than <code>""just because""</code>. It is something I came across through actual profiling and timing, not merely distrust and paranoia.</p>

<p>One of the biggest problems with <code>bitset</code> and <code>vector&lt;bool&gt;</code> is that their interface design is ""too convenient"". Optimizers are great at obliterating all that structure you establish to provide safety, reduce maintenance cost, make changes less intrusive, etc. They do an especially fine job with selecting instructions and allocating the minimal number of registers to make such code run as fast as the not-so-safe, not-so-easy-to-maintain/change alternatives.</p>

<p>The part that makes the bitset interface ""too convenient"" at the cost of efficiency is the random-access <code>operator[]</code> as well as the iterator design for <code>vector&lt;bool&gt;</code>. When you access one of these at index <code>n</code>, the code has to first figure out which byte the nth bit belongs to, and then the sub-index to the bit within that. That first phase typically involves a division/rshifts against an lvalue which is more costly than the actual bit operation you're trying to perform.</p>

<p>The iterator design for <code>vector&lt;bool&gt;</code> faces a similar awkward dilemma where it either has to branch into different code every 8 times you iterate through it or pay that kind of indexing cost described above. If the former is done, it makes the logic asymmetrical across iterations, and iterator designs tend to take a performance hit in those rare cases.</p>

<p>Optimizers can't seem to optimize away this phase-1 byte indexing overhead to figure out which byte to access (perhaps a bit too runtime-dependent), and you tend to see significant performance gains with that more manual code processing bits sequentially with advanced knowledge of which byte it's working on. It's somewhat of an unfair comparison, but the difficulty with <code>std::bitset</code> is that there's no way to make a fair comparison in such cases where the code knows what byte it wants to access in advance, and more often than not, you tend to have this info in advance.</p>

<p>Perhaps that wouldn't be the case if the interface design involved a <code>bitset</code> where <code>operator[]</code> returned a <code>byte</code> proxy, requiring a two-index access pattern to use. For example, in such a case, you would access bit 8 by writing <code>bitset[0][7] = true;</code> A good optimizer may be able to take such a design and make it rival the manual, old school kind of way of doing the bit manipulation by hand.</p>

<p>Another design that might help is if <code>bitsets</code> provided a <code>for_each_bit</code> kind of method, passing a bit proxy to the functor you provide. That might actually be able to rival the manual method.</p>

<p><code>std::deque</code> has a similar interface problem. Its performance shouldn't be <em>that</em> much slower than <code>std::vector</code> for sequential access. Yet unfortunately we access it sequentially using <code>operator[]</code> which is designed for random access or through an iterator, and the internal rep of deques simply don't map very efficiently to an iterator-based design. If deque provided a <code>for_each</code> kind of method of its own, then there it could potentially start to get a lot closer to <code>std::vector's</code> sequential access performance. These are some of the rare cases where that Sequence interface design comes with some efficiency overhead that optimizers often can't obliterate. Often good optimizers can make convenience come free of runtime cost in a production build, but unfortunately not in all cases.</p>
"
"<p>Did a short test profiling std::bitset vs bool arrays for sequential and random access - you can too:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;bitset&gt;
#include &lt;cstdlib&gt; // rand
#include &lt;ctime&gt; // timer

inline unsigned long get_time_in_ms()
{
    return (unsigned long)((double(clock()) / CLOCKS_PER_SEC) * 1000);
}


void one_sec_delay()
{
    unsigned long end_time = get_time_in_ms() + 1000;

    while(get_time_in_ms() &lt; end_time)
    {
    }
}



int main(int argc, char **argv)
{
    srand(get_time_in_ms());

    using namespace std;

    bitset&lt;5000000&gt; bits;
    bool *bools = new bool[5000000];

    unsigned long current_time, difference1, difference2;
    double total;

    one_sec_delay();

    total = 0;
    current_time = get_time_in_ms();

    for (unsigned int num = 0; num != 200000000; ++num)
    {
        bools[rand() % 5000000] = rand() % 2;
    }

    difference1 = get_time_in_ms() - current_time;
    current_time = get_time_in_ms();

    for (unsigned int num2 = 0; num2 != 100; ++num2)
    {
        for (unsigned int num = 0; num != 5000000; ++num)
        {
            total += bools[num];
        }
    }

    difference2 = get_time_in_ms() - current_time;

    cout &lt;&lt; ""Bool:"" &lt;&lt; endl &lt;&lt; ""sum total = "" &lt;&lt; total &lt;&lt; "", random access time = "" &lt;&lt; difference1 &lt;&lt; "", sequential access time = "" &lt;&lt; difference2 &lt;&lt; endl &lt;&lt; endl;


    one_sec_delay();

    total = 0;
    current_time = get_time_in_ms();

    for (unsigned int num = 0; num != 200000000; ++num)
    {
        bits[rand() % 5000000] = rand() % 2;
    }

    difference1 = get_time_in_ms() - current_time;
    current_time = get_time_in_ms();

    for (unsigned int num2 = 0; num2 != 100; ++num2)
    {
        for (unsigned int num = 0; num != 5000000; ++num)
        {
            total += bits[num];
        }
    }

    difference2 = get_time_in_ms() - current_time;

    cout &lt;&lt; ""Bitset:"" &lt;&lt; endl &lt;&lt; ""sum total = "" &lt;&lt; total &lt;&lt; "", random access time = "" &lt;&lt; difference1 &lt;&lt; "", sequential access time = "" &lt;&lt; difference2 &lt;&lt; endl &lt;&lt; endl;

    delete [] bools;

    cin.get();

    return 0;
}
</code></pre>

<p>Please note: the outputting of the sum total is necessary so the compiler doesn't optimise out the for loop - which some do if the result of the loop isn't used.</p>

<p>Under GCC x64 with the following flags: -O2;-Wall;-march=native;-fomit-frame-pointer;-std=c++11;
I get the following results:</p>

<p>Bool array:
random access time = 4695, sequential access time = 390</p>

<p>Bitset:
random access time = 5382, sequential access time = 749</p>
"
"<p>Count finished requests and divide it by the time the program took to execute already?</p>

<p>time.time will be useful for getting the time. The rest is just dividing of current_requestnumber by the differnce in seconds since start...
That way you get the long term average. If you need to quickly show when the speed changes it gets a bit more complicated because you need to count the number of requests for say the last 10 seconds. (one way is just reset the counter when more than 10 seconds have passed since the last reset)</p>
"
"<pre><code>import time
start = time.clock()

...

current_time = time.clock()
elapsed = current_time - start
print(""speed: "", round(current_requestnumber/elapsed, 1), "" requests/second"")
</code></pre>
"
"<p>You can get a total average number of events per second like this:</p>

<pre><code>#!/usr/bin/env python3

import time
import datetime as dt

start_time = dt.datetime.today().timestamp()
i = 0
while(True):
    time.sleep(0.1)
    time_diff = dt.datetime.today().timestamp() - start_time
    i += 1
    print(i / time_diff)
</code></pre>

<p>Which in this example would print approximately 10. Please note that I used a <code>timestamp</code> method of <code>datetime</code> which is only availble in Python 3.</p>

<p>Now, if you would like to calculate the ""current"" number of events per second, say over the last 10 events, you can do it like this:</p>

<pre><code>#!/usr/bin/env python3

import time
import datetime as dt

last_time = dt.datetime.today().timestamp()
diffs = []
while(True):
    time.sleep(0.1)

    # Add new time diff to list
    new_time = dt.datetime.today().timestamp()
    diffs.append(new_time - last_time)
    last_time = new_time

    # Clip the list
    if len(diffs) &gt; 10:
        diffs = diffs[-10:]

    print(len(diffs) / sum(diffs))
</code></pre>

<p>Here, I'm keeping a list of durations of last 10 iterations over which I can then use to get the average number of events per second.</p>
"
"<blockquote>
  <p>The c value is coming from the vertex shader so i assume it goes for -1 to 1 on both x and y axis and being interpolated in between.</p>
</blockquote>

<p>That's correct.</p>

<blockquote>
  <p>1) How can I center the image on the quad? I am not really sure of that.</p>
</blockquote>

<p>You just need to zoom out by a factor of 1.5 and center it on -0.5. The interesting parts of the Mandelbrot set extend from roughly -2 to 1 on the real axis and -i to i on the imaginary axis:</p>

<p><a href=""https://i.stack.imgur.com/V9sd1.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/V9sd1.png"" alt=""enter image description here""></a></p>

<blockquote>
  <p>2) How can I say zoom in on some in on the mandelbrot set and a follow up, lets say I want to zoom in on a specific part of the set?
  2B) Let's say I click the screen and get the position in NDC?</p>
</blockquote>

<p>Put back the 2 uniforms that you had in your previous version:</p>

<pre><code>uniform vec2 center;
uniform float scale;
</code></pre>

<p>Declare variables to hold these values in your C code and set them with <code>glUniform2f</code> and <code>glUniform1f</code>. To center the set the initial values should be -0.5, 0.0 for the center, and 1.5 for the scale (larger values zoom out). Then in your fragment shader, just apply them like this:</p>

<pre><code>c = (fCoord * scale) + center;
</code></pre>

<p>To click the screen and zoom in on a particular location, turn the mouse location into a value between -1,-1 and 1,1 based on its position on the screen then apply the above equation to it to find the location you clicked on. Set that as the new center and multiply scale by a value less than 1 to zoom in a given amount.</p>

<blockquote>
  <p>3) If I set my max iterations higher the set seems to get really jaggy, is that normal behavior?</p>
</blockquote>

<p>The screenshot you posted looks ok. It would probably look better if you implemented some kind of multi-sampling in your fragment shader (e.g. calculate several values in a loop and add them together so that each pixel is actually the average of a 2x2 or 4x4 block of pixels etc).</p>

<p>If you zoom in far enough eventually you will run into the limits of the precision of the floating point numbers used by the GPU.</p>
"
"<p>I can think of a pretty simple solution:</p>

<pre><code>uint64_t last_time = 0;
uint64_t current_time = time();
uint64_t frame_limit_ms = 17; // 60fps = 16.666... ms/f
uint64_t frame_diff = frame_limit_ms;

sleep(frame_limit_ms);

while(running){
    last_time = current_time;
    current_time = time(); // get frame start time in milliseconds
    frame_diff = current_time - last_time; // get time since last frame in ms

    if(frame_diff &lt; frame_ms_limit){
        sleep(frame_ms_limit - frame_diff);

        // need to do a re-calculation for accuracy
        current_time = time();
        frame_diff = current_time - last_time;
    }

    do_physics(frame_diff);
    draw_scene();
    swap_buffers();
}
</code></pre>

<p>Which looks a lot like what you have, but doesn't use <code>float</code> so should be faster and is accurate up to one unit of time (milliseconds in this case).</p>

<p>If you want it to be more accurate, use a more accurate unit (nanoseconds) and convert it back to milliseconds if you need to.</p>
"
"<p>One issue with the example code, is that last_time get updated to current_time which gets updated to time(), which can lead to drift over time. To avoid this, last_time should be based on an original reading of time(), and advanced by the desired delay for each frame. The following windows based code is similar what is used in games to keep a thread running at a fixed frequency with no drift. uRem is used to deal with frequencies that aren't exact multiples of the clock frequency. dwLateStep is a debugging aid that gets incremented each instance where the step time is exceeded. The code is Windows XP compatible, where a Sleep(1) can take up to 2 ms, so it checks for >= 2 ms delay pending before using Sleep(1).</p>

<pre><code>/* code for a thread to run at fixed frequency */
typedef unsigned long long UI64;        /* unsigned 64 bit int */
#define FREQ    400                     /* frequency */
DWORD    dwLateStep;                    /* late step count */
LARGE_INTEGER liPerfFreq;               /* 64 bit frequency */
LARGE_INTEGER liPerfTemp;               /* used for query */
UI64 uFreq = FREQ;                      /* process frequency */
UI64 uOrig;                             /* original tick */
UI64 uWait;                             /* tick rate / freq */
UI64 uRem = 0;                          /* tick rate % freq */
UI64 uPrev;                             /* previous tick based on original tick */
UI64 uDelta;                            /* current tick - previous */
UI64 u2ms;                              /* 2ms of ticks */
UI64 i;

    /* ... */ /* wait for some event to start thread */
    QueryPerformanceFrequency(&amp;liPerfFreq);
    u2ms = ((UI64)(liPerfFreq.QuadPart)+499) / ((UI64)500);

    timeBeginPeriod(1);                 /* set period to 1ms */
    Sleep(128);                         /* wait for it to stabilize */

    QueryPerformanceCounter((PLARGE_INTEGER)&amp;liPerfTemp);
    uOrig = uPrev = liPerfTemp.QuadPart;

    for(i = 0; i &lt; (uFreq*30); i++){
        /* update uWait and uRem based on uRem */
        uWait = ((UI64)(liPerfFreq.QuadPart) + uRem) / uFreq;
        uRem  = ((UI64)(liPerfFreq.QuadPart) + uRem) % uFreq;
        /* wait for uWait ticks */
        while(1){
            QueryPerformanceCounter((PLARGE_INTEGER)&amp;liPerfTemp);
            uDelta = (UI64)(liPerfTemp.QuadPart - uPrev);
            if(uDelta &gt;= uWait)
                break;
            if((uWait - uDelta) &gt; u2ms)
                Sleep(1);
        }
        if(uDelta &gt;= (uWait*2))
            dwLateStep += 1;
        uPrev += uWait;
        /* fixed frequency code goes here */
        /*  along with some type of break when done */
    }

    timeEndPeriod(1);                   /* restore period */
</code></pre>
"
"<p>Probably <code>lcd_putint</code> takes a lot of time to refresh the display. It probably convert each number to string and then put it to the screen.
<code>format_int()</code> In binary case it loops 4 times, then 4 times more than Hex and Dec cases.</p>

<p>If you change the code as below, It will, I guess, be faster:</p>

<pre><code>char bin[5];
sprintf(bin, ""%d%d%d%d"", ((n&amp;0x08)&gt;&gt;3), ((n&amp;0x04)&gt;&gt;2), ((n&amp;0x02)&gt;&gt;1), (n&amp;0x01));
lcd_putstring(bin);
</code></pre>

<p>I know there are a lot of solutions to convert number to binary string, but the key point is to use <code>lcd_putstring</code> that is surely faster then call 4 times <code>lcd_putint</code></p>
"
"<p>First of all, you must ensure that the input pin connected to the button has pull resistors, either on the PCB or enabled internally in the microcontroller i/o port. If you haven't, the input will be in no defined state when the button is inactive, and you'll get garbage interrupts. Resistors should pull towards the inactive state.</p>

<p>As indicated in comments, you should never have any delays inside interrupt service routines. ISRs should be as small and fast as possible.</p>

<p>It is important to note that if you have an interrupt-triggering pin connected to a button, it means you will get interrupts for every bounce or other EMI noise that appears on the pin. These false, spurious interrupts will stall the main program and overall realtime performance will be suffering. This is a classic beginner mistake and it is present in your program.</p>

<p>You <em>can</em> use an interrupt-triggering pin for buttons, but then you must know what you are doing. You must disable the interrupt itself from inside the ISR as soon as you get the first edge trigger, in this way:</p>

<ul>
<li>Make sure the button interrupt is set to trigger both on raising and falling edge.</li>
<li><p>Upon receiving interrupt, disable the interrupt from inside the ISR. From inside the ISR, start one of the on-chip hardware timers and have it trigger through a timer interrupt after x milliseconds. </p>

<p>Pseudo code for such an ISR for a generic, fictive MCU, with fictive register names: </p>

<pre><code>void button_isr (void)
{
  BUTTON_ISR_ENABLE = CLEAR; // some hw register that disables the ISR
  BUTTON_ISR_FLAG = CLEAR; // some hw register that clears the interrupt flag
  TIMER_COUNTER = CURRENT_TIME + DEBOUNCE_TIME; // some hw timer register
  TIMER_ISR_ENABLE = SET; // some hw timer register
}
</code></pre></li>
<li><p>Typical debounce times are between 5ms to 20ms. You can measure the bounce on the particular switch with an oscilloscope.</p></li>
<li><p>When the timer runs out, the timer ISR is triggered and you read the input again. If they read equal, (both high), set a flag ""button pressed"". If not, you had some noise on the line, which should be ignored. Disable the timer but enable the button I/O interrupt again.</p>

<p>Pseudo code for the timer ISR, for a generic, fictive MCU:</p>

<pre><code>static bool button_pressed = false;

void timer_isr (void)
{
  TIMER_ISR_FLAG = CLEAR;
  TIMER_ISR_ENABLE = CLEAR;

  if(BUTTON_PIN == ACTIVE) // whatever you have here, active high/active low
  {
    button_pressed = true;
  }
  else
  {
    button_pressed = false;
  }

  BUTTON_ISR_ENABLE = SET;
}
</code></pre></li>
</ul>

<p>In the real code, the register names will be something more cryptic, and how to set/clear flags will vary from MCU to MCU. Sometimes you clear by writing 1, sometimes by 0. </p>

<p>The above code should work well for standard applications. For applications with tighter realtime demands, you would have a timer/task running continuously, polling the button(s) at even time intervals. Demand that two following reads give the same value pressed/not pressed, in order to accept it as a change in the button state.</p>

<p>More advanced algorithms involve median filters that make multiple reads. A median filter with 3 reads is quite easy to implement and is sufficient even for many safety-critical applications.</p>
"
"<p>Add a <code>time.sleep(.1)</code> in the loop. Your loop is currently busy in that it is constantly updating current_time as fast as it can. Adding the <code>sleep()</code> call allows the CPU some breathing room to do other stuff.</p>

<p>Also, the <code>time.time()</code> logic could be improved so you only do the function call once (function calls are relatively slow in Python):</p>

<pre><code>current_time = time.time()
counter += current_time - prev_time
prev_time = current_time
</code></pre>

<p>Or better yet, just maintain the start time and compare the difference (this assumes you properly initialize everything):</p>

<pre><code>current_time = time.time()
if current_time - start_time &gt; random_interval:
    play_sound()
    start_time = current_time
    random_interval = randint(300, 900)
</code></pre>
"
"<p>The approach depends on whether or not you need the script to do anything else whilst waiting. If it only has to play the file, then the follow approach should suffice:</p>

<pre><code>import pyglet
import time
import random

music = pyglet.resource.media('input.wav', streaming=False)

def playSound():
    music.play()

while True:
    time.sleep(random.randint(300, 900))
    playSound()
</code></pre>

<p><a href=""https://docs.python.org/2/library/time.html?highlight=time.sleep#time.sleep"" rel=""nofollow"">time.sleep</a> will suspend the execution of your script for the given number of seconds. As such it will not use any CPU.</p>
"
"<p>I already answered this before but you ignored my comments. You should not call <code>InvalidateRect</code> from <code>WM_PAINT</code>. You must remove <code>InvalidateRect</code> from <code>OnPaint</code>. </p>

<p>Your <code>OnPaint</code> function is not even called. You must add this line:</p>

<pre><code>case WM_PAINT:
    OnPaint();
    return 0;
</code></pre>

<p>You are doing weird things inside the main message loop. This is very dangerous. Just remove <code>HandleMessages</code> altogether. Replace it with a simple message loop:</p>

<pre><code>int APIENTRY WinMain(HINSTANCE h_instance, HINSTANCE, LPSTR, int)
{
    ChildWindow child_window(h_instance, TEXT(""Child Window""));
    BaseWindow base_window(TEXT(""Base Window""), child_window.ClassName());

    //main message loop
    MSG msg;
    while (GetMessage(&amp;msg, NULL, 0, 0))
    {
        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);
    }

    return 0;
}
</code></pre>

<p>Leave the main message loop alone. You can later handle accelerators inside the message loop, but that's about it. </p>

<p>Now lets say you want to add animation. First, lets start with some simple animation. Declare a global variable <code>int g_counter = 0;</code> Then change <code>PaintManager</code> like so:</p>

<pre><code>bool BaseWindow::PaintManager()
{
    HBRUSH brush = (HBRUSH)(GetStockObject(WHITE_BRUSH));
    SelectObject(back_buffer_, brush);      // Select Brush
    Rectangle(back_buffer_, 200, 200, 500, 500);
    DeleteObject(brush);

    TCHAR buf[100];
    wsprintf(buf, TEXT(""%d""), g_counter);
    TextOut(back_buffer_, 0, 0, buf, strlen(buf));

    return true;
}
</code></pre>

<p>Add something to signal animation:</p>

<pre><code>case WM_LBUTTONDOWN:
    animate();
    return 0;
</code></pre>

<p>Make animation function:</p>

<pre><code>void BaseWindow::animate()
{
    for (int i = 0; i &lt; 10000; i++)
    {
        g_counter++;
        InvalidateRect(hwnd_, 0, FALSE);

        //this code allows window to refresh itself, use it as is
        //don't mess around with it
        MSG msg;
        while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE))
        {
            if (msg.message == WM_QUIT)
            {
                PostQuitMessage(0);
                return;
            }
            TranslateMessage(&amp;msg);
            DispatchMessage(&amp;msg);
        }
    }
}
</code></pre>

<p>You can put a timer inside that <code>for</code> loop to slow it down... You can also look at <code>WM_TIMER</code> if you don't need high precision timers.</p>
"
"<p>By modern C rules, unsigned shorts will promote to signed ints, and the difference will be correctly signed according to their original values.</p>
"
"<p>If <code>current_time</code> is greater than or equal to <code>last_time</code>, there won't be potential for a negative value.</p>

<p>To quote section 6.2.1.2 ""Signed and unsigned integers"" of the C90 spec:</p>

<blockquote>
  <p>When a value with integral type is converted to another integral type, if the value can be represented by the new type, its value is unchanged.</p>
</blockquote>

<p>With <code>unsigned short</code> being shorter than <code>int</code>, all values of type <code>unsigned short</code> can be represented by <code>int</code>, so the converted-to-<code>int</code> values of <code>current_time</code> and <code>last_time</code> will be the same as their un-converted <code>unsigned short</code> value, and the result of the subtraction will be what you expect it to be.</p>

<p>If, however, <code>current_time</code> is <em>less than</em> <code>last_time</code>, there is potential for a negative value; that, however, is not a bug, it's a feature, because, in that case, time really <em>did</em> go backwards.</p>

<p>If <code>current_time</code> and <code>last_time</code> were <code>unsigned int</code>s, and <code>current_time</code> were less than <code>last_time</code>, the result of the subtraction would be an <code>unsigned int</code>, and thus not negative; it would be the difference between the times, modulo the maximum value of an <code>unsigned int</code>.</p>

<p>You probably want to handle time going backwards specially, anyway, if it can happen.</p>
"
"<p>when we execute <strong><code>hadoop fs -ls .</code></strong>, <strong><code>Hadoop</code></strong>, by default, looks for <strong><code>/user/&lt;current login user&gt;</code></strong></p>

<p>Since you are facing error <strong><code>No such file or directory</code></strong>, it seems that <strong><code>/user/&lt;current login user&gt;</code></strong> doesn't exist in <strong><code>hdfs</code></strong>.</p>

<p>To fix this issue, execute following command</p>

<pre><code>hadoop fs -mkdir -p /user/&lt;current login user&gt;
</code></pre>

<p>where ""current login user"" is linux username.</p>

<blockquote>
  <p>recmach@chetan-HP-ENVY-15-Notebook-PC:~/hadoop/hadoop-2.6.1/sbin$ hadoop fs -ls /home/recmach
  ls: `/home/recmach': No such file or directory</p>
</blockquote>

<p>/home/recmarch doesn't exist on HDFS and hence error. Try following command</p>

<pre><code>hadoop fs -mkdir -p /home/recmarch
</code></pre>
"
"<p>No output for <code>hadoop fs -ls /</code> shows that your hdfs is empty.<br>
The reason you are getting FileNotFound is because you are trying absolute path from your local filesystem.</p>

<p>Try creating a drirectory iun HDFS and list directory.</p>

<pre><code>hadoop fs -mkdir /abcd
hadoop fs -ls /
</code></pre>

<p>You should get an output like</p>

<blockquote>
  <p>drwxr-xr-x   - user supergroup          0 2015-10-21 17:33 /abcd</p>
</blockquote>

<p>You should understand that HDFS is different from your local file system.</p>

<p>Now you want to copy a file from your local file system to HDFS, for this use <code>haddop fs -put &lt;file on local filesystem&gt; &lt;destination path on HDFS&gt;</code>.  </p>

<pre><code>date &gt; current_time.txt #creates a new file
hadoop fs -put current_time.txt /abcd/
hadoop fs -ls /abcd
</code></pre>

<p>Should give you the output like </p>

<blockquote>
  <p>-rw-r--r--   3 user supergroup         26 2015-10-21 17:35 /abcd/current_time.txt</p>
</blockquote>
"
"<p>Currently, this is not easily possible with odeint. If you can use the range library <a href=""https://github.com/ericniebler/range-v3"" rel=""nofollow"">here</a> you can combine a <code>for_each</code> and a <code>find_if</code> algorithm.</p>

<p>Otherwise you need to write the loop yourself, which is also not that difficult and should be similar to this:</p>

<pre><code>auto stepper = make_dense_output&lt; rosenbrock4&lt; double &gt; &gt;( 1.0e-12 , 1.0e-12 );
auto ode = make_pair( stiff_system() , stiff_system_jacobi() );

double t = 0.0;
double const end_time = 50.0;
double const dt = 0.01;
vector_type x( 2 , 1.0 );
const double y_min = 1.0;

stepper.initialize( x , t , dt );
cout &lt;&lt; t &lt;&lt; "" "" &lt;&lt; x[0] &lt;&lt; "" "" &lt;&lt; x[1] &lt;&lt; endl; // or some other output
t += dt;
while( t &lt; end_time )
{
    if( t &gt; stepper.current_time() )
    {
        // perform a real step
        stepper.do_step( ode );
    }
    else
    {
        // perform a dense output step
        stepper.calc_state( t , x );
        cout &lt;&lt; t &lt;&lt; "" "" &lt;&lt; x[0] &lt;&lt; "" "" &lt;&lt; x[1] &lt;&lt; endl; // or some other output
        t += dt;
    }
    if( x[1] &lt; y_min ) // or some other condition
    {
        cout &lt;&lt; ""Bound reached."" &lt;&lt; endl;
        break;
    }
}
</code></pre>
"
"<p>You cannot access local variable declared in another function regardless it is a pointer or not in c. However, you can (but maybe you shall not) access memory allocated in another function as long as you have the address of this block of memory. </p>

<p>For instance, if you allocate memory for local variable 'current_time' (which you didn't, but this is another issue) by using: </p>

<pre><code>double* current_time = (double*) malloc(sizeof(double));
</code></pre>

<p>and you keep the address of allocated memory (the value hold in 'current_time'). Then, you can access the allocated memory in another function as long as you can somehow let that function know this address. </p>

<p>Having said that, why don't you just simply keep this value in a higher level place and then pass it into all functions that require this value?</p>
"
"<p>You can get the unixtimstamp using strtotime:</p>

<pre><code>&lt;?php
$date = date(""d M Y"");
$time = ""15:00"";
$unixTime = strtotime($date . "" "" . $time);
?&gt;
</code></pre>
"
"<p>Something like:</p>

<pre><code>$return .= '&lt;td data-reservation_time=""' . strtotime($dt-&gt;format(""Y-m-d"") . "" "" . $hour . "":00:00"") . '""&gt;&lt;/td&gt;';
</code></pre>

<p>In order to get the timestamp, get the day from your <code>$dt</code> object, and time from the loop.</p>
"
"<p>Ok, so the answer was simpler than I thought. Well I am still not 100% sure that the first part is absolutely correct, but it should be (by my logic).</p>

<p>First, create an array of dates for this week (curtesy of <a href=""https://stackoverflow.com/a/2536802/629127"">this answer</a>)</p>

<pre><code>$today = time();

if (date('D', $today) === 'Mon') {
    $timestamp = strtotime('this Monday');
} else{
    $timestamp = strtotime('last Monday');
}
$days = array();
$dates = array();
for ($i = 0; $i &lt; 7; $i++) {
    $days[] = strftime('%A &lt;br /&gt; %d %b %Y', $timestamp);
    $dates[] = strftime('%d %b %Y', $timestamp);
    $timestamp = strtotime('+1 day', $timestamp);
}
</code></pre>

<p>The first <code>if else</code> loop was to check if today is Monday, so that you fill the array towards the next Sunday (in the same week). If it's Tuesday, then the timestamp reference is the last Monday.</p>

<p>And then just do a <code>foreach</code></p>

<pre><code>$return .= '&lt;table class=""reservation_time_table""&gt;
                &lt;tr&gt;&lt;th&gt;'.esc_html__('Hours', 'time_reservation').'&lt;/th&gt;';
    foreach ($days as $day =&gt; $day_value) {
        $return .= '&lt;th&gt;'.$day_value.'&lt;/th&gt;';
    }
    $return .= '&lt;/tr&gt;';
    for ($hour=8; $hour &lt; 23 ; $hour++) {
    $return .= '&lt;tr&gt;';
        $return .= '&lt;th&gt;'.$hour.':00&lt;/th&gt;';
    foreach ($dates as $date =&gt; $date_value) {
        $full_hour = $hour. ':00';
        $return .= '&lt;td data-time=""'.strtotime($date_value. ' ' .$full_hour).'""&gt;&lt;/td&gt;';
    }
    $return .= '&lt;/tr&gt;';
    }
$return .= '&lt;/table&gt;';
</code></pre>

<p>And my dates with times are in <code>data-time</code>, ripe for jquery grabbing :D</p>
"
"<p>Of course you must get an error... You have changed some print parameter that will be used in <code>cmu-trace.cc</code>.</p>

<p>I don't know what you wanted to do, but it's so clear that you shouldn't change those parameter from <code>fprintf</code>.</p>

<p>like here :</p>

<pre><code> fprintf(stderr,
             ""%s%d\t%s%d\t%s%d\t%s%d\t%s%d\t%s%d\t%s%d\t%s%d\t%s%f\t%s%f\n"",
             ""src="",         index,
             ""dst="",         rp-&gt;rp_dst,
             ""nhops="",       rp-&gt;rp_hop_count+1,
             ""opthops="",     opthops,
             ""sumHops="",     sumHops,
             ""sumGodHops="",  sumGodHops,
             ""numRtsFound="", numRtsFound,
             ""prevHop="",     ch-&gt;prev_hop_,
             ""t:"",           CURRENT_TIME,
             ""RTT="",         CURRENT_TIME - rp-&gt;rp_timestamp);

         fprintf(gspTraceFile,
             ""%s%d\t%s%d\t%s%d\t%s%d\t%s%d\t%s%d\t%s%d\t%s%d\t%s%f\t%s%f\n"",
             ""src="",         index,
             ""dst="",         rp-&gt;rp_dst,
             ""nhops="",       rp-&gt;rp_hop_count+1,
             ""opthops="",     opthops,
             ""sumHops="",     sumHops,
             ""sumGodHops="",  sumGodHops,
             ""numRtsFound="", numRtsFound,
             ""prevHop="",     ch-&gt;prev_hop_,
             ""t:"",           CURRENT_TIME,
             ""RTT="",         CURRENT_TIME - rp-&gt;rp_timestamp);
</code></pre>

<p>Say exactly what do you want to do so maybe i could help you or maybe others help you.</p>
"
"<p>You must test for errors from <code>recvfrom()</code> -- you're setting SO_RCVTIMEO, so you can expect the receives to timeout.</p>

<p>Do you <strong><em>really</em></strong> want to enable read timeouts? If so, when you set SO_RCVTIMEO, set <code>tv.tv_usec = 0</code>. You're leaving it uninitialized. If tv_usec happens to be an invalid value (less than 0 or greater than 999,999) then the <code>setsockopt()</code> call should fail.</p>
"
"<p>First, you should add ""return os;"" in our operator overloading (&lt;&lt;).
Second, add Preprocessor directives to one of two &lt;&lt; overloading like this:</p>

<pre><code>#ifdef Oper
ostream &amp;operator&lt;&lt;(ostream &amp;os, const ACE_Time_Value &amp;)
{
  os &lt;&lt; ""Banana""    ; return os;
}
#endif
</code></pre>
"
"<p>You can do something like below and make use of inheritance:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

struct ACE_Time_Value { };
ostream &amp;operator&lt;&lt;(ostream &amp;os, const ACE_Time_Value &amp;) { os &lt;&lt; ""Apple"" ; return os; }
void foo(const ACE_Time_Value &amp;) { cout &lt;&lt; ""Cherry"" &lt;&lt; endl; }

namespace mine {
        struct New_ACE_Time_Value: ACE_Time_Value {};

        ostream &amp;operator&lt;&lt;(ostream &amp;os, const New_ACE_Time_Value &amp;) { os &lt;&lt; ""Banana"" ;
            return os;
        }
        void foo(const ACE_Time_Value &amp;) { cout &lt;&lt; ""Durian"" &lt;&lt; endl; }

        void bar() {
                New_ACE_Time_Value t;
                ::mine::foo(t); // OK
                cout &lt;&lt; ""The current time is "" &lt;&lt;
                   t &lt;&lt; endl; // error: ambiguous overload for 'operator&lt;&lt;'
        }
}
</code></pre>

<p>Probably you should also make 'NewACE_Time_Value' non copyable to shrug off object slicing issues.</p>
"
"<p>This is how I would solve your conceptual example:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

struct ACE_Time_Value { };

namespace ACE
{
    ostream &amp;operator&lt;&lt;(ostream &amp;os, const ACE_Time_Value &amp;) { os &lt;&lt; ""Apple"" ; return os; }
}

void foo(const ACE_Time_Value &amp;) { cout &lt;&lt; ""Cherry"" &lt;&lt; endl; }

namespace mine {
    ostream &amp;operator&lt;&lt;(ostream &amp;os, const ACE_Time_Value &amp;) { os &lt;&lt; ""Banana"" ; return os; }
    void foo(const ACE_Time_Value &amp;) { cout &lt;&lt; ""Durian"" &lt;&lt; endl; }

    void bar() {
        ACE_Time_Value t;
        ::mine::foo(t); // OK
        cout &lt;&lt; ""The current time is "" &lt;&lt; t &lt;&lt; endl;
    }
}

int main() {
    mine::bar();
}
</code></pre>

<p>Since ACE is open-source, it shouldn't be too hard to apply the same modifications so that their <code>&lt;&lt;operator</code> overload is wrapped inside a namespace.</p>
"
"<p>I ended up in defining a wrapper object with <code>operator&lt;&lt;</code>.</p>

<pre><code>namespace mine {
    void foo(const ACE_Time_Value &amp;) { cout &lt;&lt; ""Durian"" &lt;&lt; endl; }
    struct AceTimePrinter {
        const ACE_Time_Value &amp;tv;
        AceTimePrinter(const ACE_Time_Value &amp;tv) : tv(tv) { }
        inline friend std::ostream &amp;operator&lt;&lt;(
                std::ostream &amp;os, const AceTimePrinter &amp;o) {
            const ACE_Time_Value &amp;tv = o.tv;
            return os &lt;&lt; ""Durian"" ;
        }
    };

    void bar() {
        ACE_Time_Value t;
        ::mine::foo(t); // OK
        cout &lt;&lt; ""The current time is "" &lt;&lt;
            AceTimePrinter(t) &lt;&lt; endl;
    }
}
</code></pre>

<p>We chose not to use inheritance because we cannot change existing method signatures in the ACE reactor framework, such as <a href=""http://www.dre.vanderbilt.edu/Doxygen/6.3.1/html/libace-doc/a00208.html#a127251f675c0b6ce394f0e1c9cfd28b6"" rel=""nofollow""><code>virtual int handle_timeout (const ACE_Time_Value &amp;current_time, const void *act=0)</code></a></p>
"
"<p>Have you installed kernel-headers/kernel-devel/linux-headers(exact name depends on used distro) package? Looks like this program require kernel header file with definitions.</p>

<p>If installing this package won't help please copy-paste full make output, there should be errors about missing file there.</p>
"
"<p>I have to answer my own question here but it seems that there was two issues at hand.</p>

<p>One was that I got this slowdown because of vsync, turning off vsync totally got rid of the slowdown which wasn't actually a slowdown in my logic update but was a slowdown in the rendering. Since I am using a fixed step this shouldn't be a big issue.</p>

<p>The other issue is the fact that SDL_GetTicks() isn't very accurate. I rewrote the timing functions with clock_gettime(realtimeclock...) and it had a lot more consistent numbers.</p>

<p>For example SDL_GetTicks would return anywhere from 240ms to 267ms per update while clock_gettime was consistent on a 250ms update.</p>

<p>I was using SDL_SetDelay(0.25 * 1000) and clock_gettime was on point, SDL was lacking a bit there.</p>

<p>It's not as cross platform as SDL but there's a high performance counter for windows and mac that can easily be implemented.</p>

<p>here is the code that I am using for timing btw.</p>

<pre><code>#define _POSIX_C_SOURCE 199309L
#include ""headers/timer_utils.h""

void tu_set_current_time(timer* time) { clock_gettime(CLOCK_REALTIME, time); }

void tu_copy_current_time(timer* to, timer* from) {
    to-&gt;tv_sec = from-&gt;tv_sec;
    to-&gt;tv_nsec = from-&gt;tv_nsec;
}

double tu_get_time_diff(timer* start, timer* finish) {
    return (finish-&gt;tv_sec - start-&gt;tv_sec) +
           (finish-&gt;tv_nsec - start-&gt;tv_nsec) * 0.000000001;// / 1E9;
}
</code></pre>
"
"<p>You have this line of code:</p>

<pre><code>setsockopt(sd, SOL_SOCKET, SO_RCVTIMEO, (char *)&amp;tv, sizeof(struct timeval));
</code></pre>

<p>If the 10 second timeout elapses because no data was received, <code>recvfrom()</code> will return -1 and <code>WSAGetLastError()</code> will return 10060.  Your code is exiting in that situation:</p>

<pre><code>bytes_received = recvfrom(sd, sendBuffer, NTP_PACKET_MAX, 0, (struct sockaddr *)&amp;client, &amp;len);

if (bytes_received == SOCKET_ERROR)
{
    std::cerr &lt;&lt; ""Could not receive datagram."" &lt;&lt; std::endl;
    closesocket(sd);
    WSACleanup();
    exit(0); // &lt;-- here
}
</code></pre>

<p>Even if <code>select()</code> times out, you are exiting as well:</p>

<pre><code>n = select(sd, &amp;fds, NULL, NULL, &amp;tv);
if (n == 0)
{
    exit(0); // &lt;-- here
}
</code></pre>

<p>Make sure there is another application actually sending data to your UDP app.</p>
"
"<pre><code>bytes_received = recvfrom(sd, sendBuffer, NTP_PACKET_MAX, 0, (struct sockaddr *)&amp;client, &amp;client_length);

if (bytes_received &lt; NTP_PACKET_MIN)
{
    std::cerr &lt;&lt; ""Could not receive datagram."" &lt;&lt; std::endl;
    closesocket(sd);
    WSACleanup();
    exit(0);
}
</code></pre>

<p>Should be:</p>

<pre><code>bytes_received = recvfrom(sd, sendBuffer, NTP_PACKET_MAX, 0, (struct sockaddr *)&amp;client, &amp;client_length);

if (bytes_received == SOCKET_ERROR)
{
    int err = WSAGetLastError();

    // Handle WSAETIMEDOUT here if necessary

    std::cerr &lt;&lt; ""Could not receive datagram, error: "" &lt;&lt; err &lt;&lt; std::endl;
    closesocket(sd);
    WSACleanup();
    exit(0);
}

if (bytes_received &lt; NTP_PACKET_MIN)
{
    // print/log a warning here
    continue;
}
</code></pre>

<p>This aborts the receive loop if a call to <code>recvfrom()</code> fails, but simply ignores invalid packets (those less than the minimum length).</p>

<p>Another issue:</p>

<pre><code>unpack_ntp(&amp;ntpData, (unsigned char *)readBuffer, bytes_received);
make_packet(&amp;ntpData, NTP_CLIENT, current_value);
pack_ntp((unsigned char *)sendBuffer, NTP_PACKET_MIN, &amp;ntpData);

/* Send data back */
if (sendto(sd, sendBuffer,
    (int)sizeof(sendBuffer), 0,
    (struct sockaddr *)&amp;client, client_length) != (int)sizeof(current_time))
{
    std::cerr &lt;&lt; ""Error sending datagram."" &lt;&lt; std::endl;
    closesocket(sd);
    WSACleanup();
    exit(0);
}
</code></pre>

<p>You're sending the entire <code>sendBuffer</code>; you should probably send only the size of the NTP packet. (Hopefully <code>pack_ntp</code> returns the packet size and you can use that). Also, you're comparing the sent size with <code>sizeof(current_time)</code> which makes zero sense. You should compare against the size of the buffer sent.</p>

<p>There are other minor issues, but these are the big ones that jump out.</p>
"
"<p>Take a look at the <a href=""http://man7.org/linux/man-pages/man3/inet_pton.3.html"" rel=""nofollow"">inet_pton documentation</a>. The <code>inet_pton</code> convert a string representing an IP address to a binary IP address. It doesn't resolve names, thus it won't work with an host name, like <code>localhost</code>, which would have to be resolved.</p>

<p>You should use a specific function to resolve a name, like <code>getaddrinfo</code> (recommended), or <code>gethostbyname</code> (obsoleted).</p>
"
"<p>I'm not really proficient with <code>cv2</code> but I do see something <em>rather iffy</em> with your timing technique here.</p>

<p>Look at what part of the code you are measuring with <code>cv2.getTickCount()</code>:</p>

<pre><code>e1 = cv2.getTickCount()  # start
ret, frame = cap.read()
cv2.imshow(""cam"",frame)
e2 = cv2.getTickCount()  # stop
</code></pre>

<p>Now, look at what you are measuring using <code>time.time()</code>:</p>

<pre><code>t_start=time.time()  # start
time1=0

while True:
    e1 = cv2.getTickCount()
    ret, frame = cap.read()
    cv2.imshow(""cam"",frame)
    e2 = cv2.getTickCount()
    time1 = (e2 - e1)/ cv2.getTickFrequency() + time1
    elapsedTime= time.time()-t_start  # stop
</code></pre>

<p>You are obviously mistreating poor ol' <code>time</code> over here by counting different things. Unfortunately, I cannot verify the actual runtimes because I do not have OpenCV, but, you might want to put your <code>time</code> calls on par with <code>getTickCount()</code>. In short, use something similar to this:</p>

<pre><code>time1=0

while True:
    t_start = time.time()  # start
    ret, frame = cap.read()
    cv2.imshow(""cam"",frame)
    elapsedTime= time.time()-t_start  # stop
</code></pre>

<p>And re-evaluate your results, it's quite possible <code>getTickCount()</code> will get more accurate results than <code>time</code> because of the way it is implemented, I really can't know that.</p>

<hr>

<p>As for <em>which one should you use?</em> <code>cv2</code>'s internal timing module. </p>

<p><em>Why?</em> Because, without making outlandish claims, it is <em>a tested module</em> that has <em>probably</em> been developed by people that are most likely more proficient than us with <code>Python</code>. Timing on your own can be <em>a tricky thing</em> and leaves a lot of room for little mistakes, especially when you're first starting out.</p>

<p>So, in short, go with <code>getTickCount()</code>, it is there for a reason.</p>
"
"<p>This should produce consistent results:</p>

<pre><code>t_start = time.time()
e1 = cv2.getTickCount()

while True:
    ret, frame = cap.read()
    cv2.imshow(""cam"",frame)
    e2 = cv2.getTickCount()
    current_time = time.time()
    time1 = (e2 - e1)/ cv2.getTickFrequency()
    elapsedTime= current_time - t_start
    print [time1 , elapsedTime]
</code></pre>

<p>Actually, I cannot reproduce your problem:</p>

<pre><code>import time
import cv2

t_start = time.time()
e1 = cv2.getTickCount()

for x in range(10):
    time.sleep(0.1)
    e2 = cv2.getTickCount()
    time1 = (e2 - e1)/ cv2.getTickFrequency()
    elapsedTime= time.time() - t_start
    print 'new:', [time1 , elapsedTime]

t_start=time.time()
time1=0

for x in range(10):

    e1 = cv2.getTickCount()
    time.sleep(0.1)
    e2 = cv2.getTickCount()
    time1 = (e2 - e1)/ cv2.getTickFrequency() + time1
    elapsedTime= time.time()-t_start
    print 'old:', [time1 , elapsedTime]
</code></pre>

<p>Pints rather consistent values:</p>

<pre><code>new: [0.101121973, 0.10170483589172363]
new: [0.202431593, 0.20299196243286133]
new: [0.303379863, 0.3039419651031494]
new: [0.404390379, 0.40494799613952637]
new: [0.505434471, 0.5059988498687744]
new: [0.606657266, 0.6072208881378174]
new: [0.70785313, 0.7083899974822998]
new: [0.808160676, 0.808696985244751]
new: [0.90930442, 0.9098358154296875]
new: [1.010264773, 1.0107979774475098]
old: [0.101093147, 0.10112500190734863]
old: [0.201946665, 0.20209193229675293]
old: [0.302889158, 0.3032569885253906]
old: [0.40368225999999996, 0.40418291091918945]
old: [0.504733644, 0.5053050518035889]
old: [0.605701044, 0.6063768863677979]
old: [0.7066711290000001, 0.707442045211792]
old: [0.807242644, 0.8081610202789307]
old: [0.908066402, 0.9092309474945068]
old: [1.008913762, 1.0102128982543945]
</code></pre>

<p>Are you sure the printed numbers correspond to code you show in your question?</p>
"
"<p>Your code is right. The problem is with the path you are giving to search for the display driver files <code>""C:\\TC\\BGI""</code>. This generally happen because the <code>tc</code> is not root of the mounted drive or the <code>.exe</code> file path you are using is not <code>c:\\TC</code>. Replace the path with <code>""..//bgi""</code>. This will redirect from <code>bin</code>(<strong>the current working directory</strong>) to bgi.</p>
"
"<p><code>sleep_for</code> really means something like <code>sleep_for_at_least</code>. On a realtime OS you might be able to depend on its waking up exactly when asked, but on a conventional OS, it can sleep for some arbitrary amount of time longer than specified.</p>

<p>If you need long-term synchronization with a wall clock, you usually want to compute when the next wake-up should take place mathematically (i.e., multiply the intended duration by the number of sleeps so far to get the ideal wakeup time), and <code>sleep_until</code> that time. This way each single wakeup can be somewhat late, but the error doesn't accumulate from one to the next. You can do this by computing the difference between the wakeup time and the current time, then us <code>sleep_for</code> that difference, but this usually sacrifices a little accuracy (the time taken by everything subsequent to obtaining the current time) and extra work, since you still have the compute the next wakeup time.</p>
"
"<p>This is expected. A sleep is a sleep for <em>at least</em> that amount of time, not a precise scheduler to ""do a thing at a specific time"".</p>

<p>You're not considering the amount of time it takes to actually run your code each second, or to wake from sleep, or to start sleeping again .. not to mention all the other things your computer is doing in the meantime. Some drift is normal.</p>

<p>Instead of sleeping for 1 second, sleep for a certain number of microseconds (990,000 maybe?) based upon how much real time has elapsed since your last ""iteration"". The next wakeup may again be slightly late, but at least that lateness won't be cumulative, because your subsequent ""sleep"" argument will be slightly shorter to compensate.</p>

<p>That's the best naive scheduler you'll get.</p>
"
"<p>the <code>clock_gettime()</code> function is available for the timing your interested in.</p>

<p>It can get elapsed time since the process started</p>

<p>It can get the actual time spent running the process (does not include elapsed time not running the process.)</p>

<p>Per the man page (trimmed to only discuss clock_gettime())</p>

<pre><code>#include &lt;time.h&gt;
int clock_gettime(clockid_t clk_id, struct timespec *tp);
</code></pre>

<p>The  tp  argument is a timespec structure, as specified in :</p>

<pre><code>       struct timespec {
           time_t   tv_sec;        /* seconds */
           long     tv_nsec;       /* nanoseconds */
       };
</code></pre>

<p>The clk_id argument is the identifier of the particular clock on  which to  act.   </p>

<p>A  clock  may  be system-wide and hence visible for all processes, or per-process  if  it  measures  time  only  within  a  single process.</p>

<pre><code>  CLOCK_REALTIME
          System-wide  clock  that  measures real (i.e., wall-clock) time.
          Setting this clock requires appropriate privileges.  This  clock
          is  affected by discontinuous jumps in the system time (e.g., if
          the system administrator manually changes the clock), and by the
          incremental adjustments performed by adjtime(3) and NTP.

   CLOCK_REALTIME_COARSE (since Linux 2.6.32; Linux-specific)
          A  faster  but less precise version of CLOCK_REALTIME.  Use when
          you need very fast, but not fine-grained timestamps.

   CLOCK_MONOTONIC
          Clock that cannot be set and  represents  monotonic  time
          since some unspecified starting point.  This clock is not
          affected by discontinuous jumps in the system time (e.g.,
          if  the system administrator manually changes the clock),
          but is affected by the incremental adjustments  performed
          by adjtime(3) and NTP.

   CLOCK_MONOTONIC_COARSE (since Linux 2.6.32; Linux-specific)
          A  faster  but  less  precise version of CLOCK_MONOTONIC.
          Use when you need very fast, but not  fine-grained  time-
          stamps.

   CLOCK_MONOTONIC_RAW (since Linux 2.6.28; Linux-specific)
          Similar  to CLOCK_MONOTONIC, but provides access to a raw
          hardware-based time that is not subject  to  NTP  adjust-
          ments  or  the  incremental adjustments performed by adj-
          time(3).

   CLOCK_BOOTTIME (since Linux 2.6.39; Linux-specific)
          Identical to CLOCK_MONOTONIC, except it also includes any
          time  that the system is suspended.  This allows applica-
          tions to get a suspend-aware monotonic clock without hav-
          ing  to  deal  with  the complications of CLOCK_REALTIME,
          which may have discontinuities if  the  time  is  changed
          using settimeofday(2).

   CLOCK_PROCESS_CPUTIME_ID (since Linux 2.6.12)
          High-resolution per-process timer from the CPU.

   CLOCK_THREAD_CPUTIME_ID (since Linux 2.6.12)
          Thread-specific CPU-time clock.

RETURN VALUE
   clock_gettime()  returns
       0 for success,
       or
       -1 for failure (in which case errno is set appropriately).

ERRORS
   EFAULT tp points outside the accessible address space.

   EINVAL The clk_id specified is not supported on this system.
</code></pre>
"
"<p>You can use a <code>deque</code> from <code>collections</code>. It gives you <code>O(1)</code> complexity to remove element from the head of the list. Since you elements are sorted by time and the oldest is in the head of the list you can easily remove the elements one by one.</p>
"
"<p>Since they're time-ordered, you could use a binary search to find the index of the cut-off point, then re-slice the list. Binary search should be (roughly) O(log n) in finding the cut-off point, then O(n) for the slicing.</p>

<p>However, if you do this frequently, it might be better to use a deque and simply pop elements until the head is ""within the period to keep"".</p>

<p>So whatever is best would require benchmarking. However, the deque solution is (probably) easier to write, so it might be best to start there, then consider other methods if you are seeing performance problems.</p>
"
"<pre><code>import random

class Element():

    def __init__(self, time):
        self.time = time

l = [ Element(z*5 - random.randrange(6) + 3) for z in range( 21)]
print('list:', [z.time for z in l])
target_time = 72
print('cutoff time:', target_time)


match = False
working_list_from = 0
working_list_to = len(l)
while not match:
    mid = (working_list_to - working_list_from) // 2
    if l[working_list_from + mid].time &lt; target_time:
        working_list_from += mid
    else:
        working_list_to -= mid


    match = (working_list_to - working_list_from) == 1

print(' resulting list', [z.time for z in l[working_list_from+mid:]])
</code></pre>

<p>results:</p>

<pre><code>list: [3, 5, 9, 18, 21, 25, 32, 33, 40, 48, 49, 57, 62, 67, 73, 73, 79, 85, 93, 94, 99]
cutoff time: 72
 resulting list [73, 73, 79, 85, 93, 94, 99]
</code></pre>
"
"<p>timestamp like this;</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;

int main() {

    std::chrono::time_point&lt;std::chrono::system_clock&gt; now = std::chrono::system_clock::now();
    std::time_t start_time = std::chrono::system_clock::to_time_t(now);
    char timedisplay[100];
    struct tm buf;
    errno_t err = localtime_s(&amp;buf, &amp;start_time);
    if (std::strftime(timedisplay, sizeof(timedisplay), ""%H:%M:%S"", &amp;buf)) {
        std::cout &lt;&lt; timedisplay &lt;&lt; '\n';
    }
}
</code></pre>

<p>Date in a similar manner.</p>
"
"<p>You can use the code snippet given below as it will serve your purpose. Here use <strong>time.h</strong> header file for required <strong>localtime()</strong> function and then using the <strong>strftime()</strong> function with required parameters will give the output and it returns it as a string.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;time.h&gt;
std::string current_date();
std::string current_time();
int main(){
    std::cout&lt;&lt;""Current date =&gt; ""&lt;&lt;current_date()&lt;&lt;""\n"";
    std::cout&lt;&lt;""Current time =&gt; ""&lt;&lt;current_time()&lt;&lt;""\n"";
}
std::string current_date(){
    time_t now = time(NULL);
    struct tm tstruct;
    char buf[40];
    tstruct = *localtime(&amp;now);
    //format: day DD-MM-YYYY
    strftime(buf, sizeof(buf), ""%A %d/%m/%Y"", &amp;tstruct);
    return buf;
}
std::string current_time(){
    time_t now = time(NULL);
    struct tm tstruct;
    char buf[40];
    tstruct = *localtime(&amp;now);
    //format: HH:mm:ss
    strftime(buf, sizeof(buf), ""%X"", &amp;tstruct);
    return buf;
}
</code></pre>
"
"<p>Firstly, <code>std::time_t</code> indeed captures both date and time, since it generally represents seconds from January 1st, 1970.</p>

<p>There is no <em>great</em> support for handling dates in C++11. You still have to depend on boost if you don't wish to do it, mostly, manually. Here's how to do it manually.</p>

<p>You can use it&mdash;in a thread-safe way&mdash;together with any <code>std::chrono::*clock</code>, such as <code>std::system_clock</code>, like this:</p>

<pre><code>std::string get_date_string(std::chrono::time_point t) {
  auto as_time_t = std::chrono::system_clock::to_time_t(t);
  struct tm tm;
  if (::gmtime_r(&amp;as_time_t, &amp;tm))
    if (std::strftime(some_buffer, sizeof(some_buffer), ""%F"", &amp;tm))
      return std::string{some_buffer};
  throw std::runtime_error(""Failed to get current date as string"");
}
</code></pre>

<p>Somewhere else, you can issue:</p>

<pre><code>get_date_string(std::system_clock::now());
</code></pre>

<p>The <em>relatively good</em> thing about this solution is that, at the API level, you're still using modern, portable C++ concepts such as <code>std::chrono::time_point</code>, and of course, <code>std::string</code>.</p>
"
"<p>Simpler:</p>

<pre><code>string CurrentDate()
{
    std::time_t now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());

    char buf[100] = {0};
    std::strftime(buf, sizeof(buf), ""%Y-%m-%d"", std::localtime(&amp;now));
    return buf;
}
</code></pre>

<p>Adjust the format as appropriate for the time too.</p>

<p>Note that I suspect this will not work well for multithreaded code since <code>std::localtime()</code> returns a pointer to an internal struct.</p>
"
"<p>Using <a href=""https://howardhinnant.github.io/date/date.html"" rel=""nofollow noreferrer"">Howard Hinnant's free, open-source header-only datetime library</a>, you can get the current UTC time as a <code>std::string</code> in a single line of code:</p>

<pre><code>std::string s = date::format(""%F %T"", std::chrono::system_clock::now());
</code></pre>

<p>I just ran this, and the string contains:</p>

<pre><code>2017-03-30 17:05:13.400455
</code></pre>

<p>That's right, it even gives you the full precision.  If you don't like that format, all of the <code>strftime</code> formatting flags are available.  If you want your local time, there is a <a href=""https://howardhinnant.github.io/date/tz.html"" rel=""nofollow noreferrer"">timezone library</a> also available, though it is not header only.</p>

<pre><code>std::string s = date::format(""%F %T %Z"", date::make_zoned(date::current_zone(),
                                         std::chrono::system_clock::now()));
</code></pre>

<p>Output:</p>

<pre><code>2017-03-30 13:05:13.400455 EDT
</code></pre>
"
"<p>The basic cause for the failure is in the server's line</p>

<pre><code>int xx = sendus(sockfd,(char*)msg);
</code></pre>

<p>- <code>sockfd</code> is the <code>listen()</code> socket, but we have to use the <code>newsockfd</code> returned from <code>accept()</code>, i. e.</p>

<pre><code>    sendus(newsockfd, msg);
</code></pre>
"
"<pre><code>'int xx = sendall(sockfd,(char*)msg,&amp;len);'
</code></pre>

<p>'sockfd' is the server listening socket.  You should be calling sendall() with 'newsockfd', as returned by the accept() call.</p>
"
"<p>You are rotating your object using a constant value, with no respect to the amount of time that has passed since the previous rotation. When you run your code on different machines, you will end up with different rotation speeds, based on how fast the machine can process your drawing and update loop.</p>

<p>You need to keep track of time - keep the time of the last update, and the current update, and call the difference 'time delta'. Your rotation needs to be multiplied by 'time delta', so that even if the two machines process the code at different speeds, the object still rotates at the same speed.</p>
"
"<p>Given that there are no details on hardware or the systems used at all, I assume your significant difference in performance comes from either</p>

<ul>
<li>Different graphics hardware or</li>
<li>Different drivers for said graphics hardware (or both)</li>
</ul>

<p>When the same code runs with different performances on the two systems and your code doesn't seem to be the reason, this is the next best thing.</p>

<p>I assume that your input and draw functions are executed iteratively; so that the next input is only processed when the drawing function returned already. The drawing can take significantly longer on slower graphics hardware/machines. That's where the different you observe can result from.</p>

<p>Try out <code>glxgears</code> on both and see what FPS you get. If your PC is much slower than your laptop (in scales of <code>10^1</code> or more), then that's your issue.</p>
"
"<p>You must make use of a timestamp between frames. GLFW has a portable <a href=""http://www.glfw.org/docs/latest/group__input.html#gaa6cf4e7a77158a3b8fd00328b1720a4a"" rel=""nofollow""><code>glfwGetTime</code></a> for this purpose. Your frame <code>delta</code> is <code>current_time - previous_time</code>, which you use to update your (animation) state with. You then set <code>previous_time = current_time</code> prior to your next frame, and repeat the process.</p>

<p>I'd also consider using <a href=""http://www.glfw.org/docs/latest/group__context.html#ga6d4e0cdf151b5e579bd67f13202994ed"" rel=""nofollow""><code>glfwSwapInterval(1)</code></a> to wait for vsync - provided your GPU driver honours it. Otherwise, you're just burning cycles doing unnecessary updates.</p>
"
"<p>The format specifier <code>%ld</code> is for implicitly typecasting the <strong>numeric value</strong> to <code>long int</code>, whereas, <code>%d</code> is for <code>int</code> alone.</p>

<p><strong>Edit:</strong></p>

<p>I ran your code now, using the following data types of the variables mentioned therein:</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
 char tempStr[100];
 char year_str[5];
 char month_str[3];
 char day_str[3];
 long int tempout;
 char other[100];
 int count;

 strcpy(year_str, ""2016"");
 strcpy(month_str ,""02"");
 strcpy(day_str ,""08"");

 sprintf(tempStr,""%s%2s%s"",year_str,month_str,day_str);
 count=sscanf(tempStr,""%ld%s"",&amp;tempout,other);

 printf(""tempStr: %s\ntempout: %ld\n"", tempStr,tempout);
}
</code></pre>

<p>Then only did I understand what your concern is, the output is showing:</p>

<blockquote>
  <p>tempStr: 20160208<br>
  tempout: 20160208</p>
</blockquote>

<p>Clearly, we can see that the problem here is in <code>sprintf</code> and not in <code>sscanf</code>.</p>

<p>The format specifier <code>%s%2s%s</code> that you have given to <code>sprintf</code> means that you want to <strong>concatenate</strong> the three strings, <code>year_str</code>, <code>month_str</code> and <code>day_str</code> namely, without any character (<strong>'/'</strong>, <strong>space</strong> or a <strong>'-'</strong>) in between them. The <code>2</code> in <code>%2s</code> only means a padding of two spaces only where it is possible.</p>

<p>This means that when <code>sscanf</code> will try to read a <code>long int</code> into <code>tempout</code> it will read <code>20160208</code> as one number doing rightly what it is meant to do.</p>

<p>You therefore have to add a character such as <code>space</code> <code>-</code> or <code>/</code> between <strong>year</strong>, <strong>month</strong> and <strong>day</strong> and everything will work fine:</p>

<pre><code>sprintf(tempStr,""%s %2s %s"", year_str,month_str,day_str);
</code></pre>

<p>New output now is:</p>

<blockquote>
  <p>tempStr: 2016 02 08<br>
  tempout: 2016</p>
</blockquote>

<p><strong>Edit2:</strong></p>

<p>If you look at the <a href=""http://linux.die.net/man/3/localtime"" rel=""nofollow"">Man Page of localtime()</a> you will see that the ranges of the members of the <code>struct tm</code> are:</p>

<blockquote>
  <p>tm_mday</p>

  <p>The day of the month, in the range 1 to 31.</p>

  <p>tm_mon</p>

  <p>The number of months since January, in the range 0 to 11.</p>

  <p>tm_year</p>

  <p>The number of years since 1900. </p>
</blockquote>

<p>Which explains the addition of <code>1</code> in <code>sprintf(month_str,""%02d"",current_time-&gt;tm_mon + 1);</code> so similarly, <code>1900</code> should be added to <code>current_time-&gt;tm_year</code> for correct output:</p>

<pre><code>sprintf(year_str,""%d"",current_time-&gt;tm_year+1900);
</code></pre>
"
"<p>This happens because initializers for static variables are only called once when the variable is initialized. Also the const is a good hint that this variable will never change.</p>

<p>So if you want a different color in every frame, remove the <code>static const</code> and stick with </p>

<pre><code>GLfloat color[] = {
        (float)sin(current_time) * 0.5f + 0.5f,
        (float)cos(current_time) * 0.5f + 0.5f,
        0.0f,
        1.0f };
</code></pre>
"
"<p>You are trying to write an integer to a file; the <code>file.write()</code> method only accepts strings.</p>

<p>Convert to a string first:</p>

<pre><code>filess.write(str(msg))
</code></pre>

<p>You really should not use a blanket <code>except</code> handler in your code; you really do't want to play Pokemon and catch them all. By doing so you are missing valuable error information. See <a href=""https://stackoverflow.com/questions/21553327/why-is-except-pass-a-bad-programming-practice"">Why is &quot;except: pass&quot; a bad programming practice?</a></p>

<p>Rather than roll your own, you could just use the <a href=""https://docs.python.org/2/library/logging.html"" rel=""nofollow""><code>logging</code> module</a>.</p>
"
"<ol>
<li><p>Rename the variable <code>time</code> to something like <code>current_time</code> to avoid conflicts with the module <code>time</code>.</p></li>
<li><p>You passed <code>msg</code>, which is an integer, into the method <code>write</code>. You should convert it to a string first: <code>msg = str(operazione)</code></p></li>
</ol>
"
"<p>You open a file, and then you close it. You don't write anything in it though, because the function <code>write()</code> fails should anything but a variable of type <code>str()</code> be passed to it! Here is an alternative to <code>write()</code> with fewer restrictions:</p>

<pre><code>with open('file_name.txt', 'w') as file:

    print(variable_you_want_written, file=file, end='\n')
</code></pre>

<p><code>print()</code> function has fewer restrictions and is a better option here as it automatically formats the inputs it receives as a <code>str()</code>, regardless of the initial <code>type()</code>, and excluding functions, instances and generator objects, which would be displayed as, for instance, something like this: <code>&lt;function &lt;lambda&gt; at 0x1089b70d0&gt;</code>. </p>

<p>Additionally, be aware that the visual format to which they are converted (and subsequently displayed or written in a file) may not necessarily be to your liking, so I suggest you do experiment with the results and see what works best in a particular situation. </p>

<p><a href=""https://docs.python.org/3/library/functions.html#print"" rel=""nofollow"">Click here</a> for Python 3 docs on <code>print()</code>.</p>
"
"<p>You are on right track, but you need to compile your code and fix compilation errors.</p>

<p>Here is corrected version of function <code>ce_interpolate</code>:</p>

<pre><code>// Interpolation / Tweening between old (x,y) and current (x, y)
ce_interpolate(double delta)
{
     // TODO: Check if delta is &gt; 0 and &lt;= 1.0

     float interpolated_x, interpolated_y;
     interpolated_x = (x * delta) + (previous_x * (1.0 - delta));
     interpolated_y = (y * delta) + (previous_y * (1.0 - delta));
     previous_x = interpolated_x; // Update global var
     previous_y = interpolated_y; // Update global var
}
</code></pre>

<p>If you are facing specific issue, please edit the question. </p>

<p>For more theory behind tweening, see: <a href=""https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Linear_B.C3.A9zier_curves"" rel=""nofollow"">https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Linear_B.C3.A9zier_curves</a></p>
"
"<p>Threads do not run in any particular order - the operating system can schedule them whenever it feels like it. Your code starts ten threads - five that print ""Hello"", and five that count down. So the most likely outcome is that your program will try to print ""Hello"" <em>five times at the same time</em>, and also count down <em>five times at the same time</em>.</p>

<p>If you want to do things in a particular order, don't do them all in separate threads. Just have one thread that does the things in the right order.</p>
"
"<p>Except for ""unnatural"" juggling with chrono (timepoint or duration, pick one!) the code looks ok. I can't reproduce any failure (GCC, linux):</p>

<p><strong><kbd><a href=""http://coliru.stacked-crooked.com/a/33f400874358b133"" rel=""nofollow"">Live On Coliru</a></kbd></strong></p>

<p>If adding random variables make problems appear/disappear, you should think of Undefined Behaviour, use static analysis, valgrind/purify/... and code scrutiny to find your culprit. Valgrind, ASAN and UBSAN ran clean on my PC</p>

<blockquote>
  <p>@sehe thanks for your effort. The diference is If I put every code into a single file, main.cpp, it runs, but if I separate into several files, the problem still there. In other hand, If I instanciate a high_resolution_timer object in the main.cpp, no matter the place (inside main(), in separate function that never is called, ...) it runs, but without it, a segmentation fault is raised. </p>
</blockquote>

<p>That's great: you have found a <em>potential</em> source of the UB: look at the use of static variables or inline functions that are not ODR-safe. (Double check all translation units are using the same compiler flags).</p>

<p>Also, keep in mind <strong><a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">UB</a></strong> is <em>UNDEFINED</em>, so like adding an unrelated <code>_timer1</code> changes the apparent behaviour (without changing the <em>source</em> of UB) the same thing could make it <em>appear</em> to work. </p>

<p>The fact that it runs clean on my machine tells you that this would have to be a platform-specific source of UB</p>
"
"<p>The problem was that I had been using the version 1.10.2 of the library and it seems there was a bug.</p>

<p>I have updated to the last version 1.10.6 and now it runs ok.</p>
"
"<p><code>localtime(&amp;current_time)-&gt;tm_hour</code> has type <code>int</code> . You then cast this to <code>struct tm *</code>, producing the warning.  In general, conversion between pointers and <code>int</code> is not meaningful and may cause undefined behaviour.</p>

<p>To avoid this error, remove the casts:</p>

<pre><code>hour = localtime(&amp;current_time)-&gt;tm_hour;
</code></pre>
"
"<p><code>char *current_time = (char *) malloc(17)</code> allocates sufficient memory for a maximum sized <code>current_time</code> as well as the null terminator.</p>
"
"<p>Since C99, <em>compound literals</em> offer a nifty solution for memory allocation.  The return value from <code>get_time()</code> is valid until the end of the block</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#define GET_TIME_N 17
#define GET_TIME()  get_time((char[GET_TIME_N]) { """"}, GET_TIME_N)

char *get_time(char *current_time, size_t n) {
  time_t rawtime;
  struct tm *timeinfo;
  time(&amp;rawtime);
  timeinfo = localtime(&amp;rawtime);
  snprintf(current_time, n, ""[%d/%d %d:%d] # "", timeinfo-&gt;tm_mday,
          timeinfo-&gt;tm_mon + 1, timeinfo-&gt;tm_hour, timeinfo-&gt;tm_min);
  return current_time;
}

int main(void) {
  printf(""%s\n%s\n%s\n"", GET_TIME(), GET_TIME(), GET_TIME());
}
</code></pre>

<p>Output</p>

<pre><code>[27/3 12:33] #
[27/3 12:33] #
[27/3 12:33] #
</code></pre>
"
"<p>In case the amount of characters which would go into the target string cannot be determined <code>snprintf()</code> allows to calculate the necessary size by an addtional ""fake"" call.</p>

<p>From the C11 draft:</p>

<blockquote>
<pre><code>int snprintf(char * restrict s, size_t n, const char * restrict format, ...);
</code></pre>

  <p>The <code>snprintf</code> function returns the number of characters that would have been written
  had n been sufficiently large, not counting the terminating null character, or a negative
  value if an encoding error occurred.</p>
</blockquote>

<p>Example:</p>

<pre><code>char * unknown_sized_string(const char * str)
{
  char * buffer = NULL;

  int size = snprintf(buffer, 0,
    ""I do not known how long this will be: %s"", str);

  if (0 &lt;= size)
  {
    buffer = malloc(size + 1);

    if (NULL != buffer)
    {
      snprintf(buffer, size,
        ""I do not known how long this will be: %s"", str);
    }
  }

  return buffer;
}
</code></pre>
"
"<p>Among other valid questions/points in the comments, memory allocation in your code may be contributing to your segmentation fault... </p>

<p><code>char *file_location</code> (and others) are being used as if memory has been allocated.</p>

<p>Your use of the variable in <code>scanf(""%s"", &amp;file_location);</code> before allocating memory invokes undefined behavior, and most likely will be (at least partially) responsible for your run-time errors. </p>

<p>add memory <em>before</em> the scanf statement.  Here are two examples of how to do that: </p>

<p>1) Create heap memory (using [m][c]alloc):    </p>

<pre><code>char *file_location;

file_location = malloc(MAX_FILENAME_LEN);//or your systems value for max directory length
if(file_location)
{
    scanf(""%s"", &amp;file_location);
    ...
</code></pre>

<p>2) Use stack memory: (point your pointer to a place with memory)</p>

<pre><code> char file_name[256];
 char *file_location = file_name;

 file_location = file_name;
 scanf(""%s"", &amp;file_location);
</code></pre>

<p>But the simplest way (if there is nothing constraining you to use a pointer) would be to just create the variable on the stack and use it in <code>scanf(...)</code>:</p>

<pre><code>char file_location[256];

scanf(""%s"", &amp;file_location);
</code></pre>

<p>There are other variables (besides <code>file_location</code>) in your example code that need memory before use.  Remember to free any variable with memory created <em><a href=""https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap"">on the heap</a></em> when finished using.</p>
"
"<blockquote>
  <p>bind error</p>
</blockquote>

<p>There is no bind error here. The client doesn't do a bind at all. It gets an error <em>connecting</em> the socket, and then misleadingly prints 'bind error'.</p>

<p>The connect error is because you aren't initializing the address field of the target you're trying to connect to.</p>

<p>NB you don't need \EOF. recv() will return zero when the peer disconnects, which you aren't checking for. You aren't checking it for errors either. This is very strange code. ? EJP 19 mins ago   </p>
"
"<p>As far as I understand, if opened as O_APPEND, file_write always writes to the end of the file (so at offset i_size) and updates i_size. And if not opened as O_APPEND, file_write writes to wherever f_pos is, and updates f_pos.</p>

<p>I think you expect file_write when not opened as O_APPEND to keep f_pos constant, which is not how it works I think.</p>
"
"<p>There's no elegant way to increate the value of data members from many objects at once, so your options seem to be to either have a single static <code>age</code> (which I assume is not valid for your use case), to increase the <code>age</code> of all objects one at a time (by iterating through whatever container they're in to find each), or adopting a different solution completely.</p>

<p>One possible alternative solution is to not store <code>age</code> as a data member at all, but rather store a <code>time_of_birth</code> as a data member, and also keep track of a <code>current_time</code> as a static data member. Your class would then look something like:</p>

<pre><code>class ANIMAL
{
private:
    int time_of_birth;
    static int current_time;

public:

    ANIMAL()
    {
     time_of_birth=current_time;
    }

    static void grow_older(){ current_time++; }

    int age() { return current_time - time_of_birth; }
};
int ANIMAL::current_time = 0; /* defined in a source, not header file */
</code></pre>

<p>If each time you must increase the age you also need to examine the age (for example, to see if the animal must now be dead), there probably is no savings since you need to iterate through your menagerie anyway. On the other hand, if you do not need to examine the age as (or more) often than you need to increase it, this approach should perform better due to resulting in less work.</p>
"
"<p>Print a new line to flush stdout : </p>

<pre><code> printf(""Hello\n"");
</code></pre>

<p>Currently no characters in the standard output will be displayed because it is line buffered. You can also call the <code>fflush</code> function for the same outcome.</p>
"
"<p>I would suggest to have a Customer class which holds vector of products. Also a Cashier class to hold your customer. Say you have a vector of customers.</p>

<pre><code>std::vector&lt;Customer&gt; customers;
</code></pre>

<p>There are two ways in which to use a for loop to access elements iteratively</p>

<pre><code>for (int i = 0; i &lt; customers.size; i++)
{
    customers[i]; //access element
}
</code></pre>

<p>OR</p>

<pre><code>for (Customer customer: customers)
{
    customer;//access element
}
</code></pre>

<p>If you want to use it in vector of vectors</p>

<pre><code>for (int i = 0; i &lt; customers.size; i++)
{
    for (int j = 0; j &lt; customers[i].size; j++)
    {
        customers[i][j]; //access element
     }
}
</code></pre>
"
"<p><code>categories</code> is a list, not a vector. Therefore you get the error message. </p>
"
"<p>""I understand that the author has redeclared *time_ptr as a pointer to unsigned char, but how did it manage to become an array (character array, I think)?""</p>

<p>Pointers point to memory.  Memory is an array of bytes.  How many bytes a pointer points to depends on the interpretation (type) of the thing pointed at.  Beyond that simple fact the compiler doesn't do bounds checking in C/C++.  So in essence EVERY pointer is a pointer to an array of elements of the type the pointer points at.  So pointer to unsigned char is a pointer to an array of single byte chars.  A pointer to a structure is a pointer to an array of elements that are each as long as one structure's size.  </p>

<p>So a pointer to a single structure <em>IS</em> a pointer to an array of size 1.  Nothing in the language prevents the code from being bad and trying to access an element at the next location.  </p>

<p>This is both the power and curse of pointers.  And the source of many bugs and security problems in C/C++.  It's also why you can do a lot of cool things in the language efficiently.  </p>

<p>""With great power comes great responsibility.""</p>

<p>So this code interprets the struct pointer first as an array of bytes and prints the hex dump, then as an array of integers.  When processing the pointer as a int*, the single increment operation moves by 4 bytes.  </p>

<p>Hence the first element is 0x00000018 (little endian for the 4 bytes: 18 00 00 00).  0x18 hex is 24.  </p>

<p>The second integer is 0x00000016 (little endian for 16 00 00 00) = 22.</p>

<p>Etc.</p>

<p>Note that the int* moves by 4 bytes because in your particular compiler, <code>sizeof(int) == 4</code>.  ""int"" is a special type and can change size based on your compiler.  If you had a different compiler (say for an embedded micro controller), then sizeof(int) might be 2 and the integers would print out as 24, 0, 22 (assuming the exact same memory block).</p>

<p><a href=""https://stackoverflow.com/questions/11438794/is-the-size-of-c-int-2-bytes-or-4-bytes"">Is the size of C &quot;int&quot; 2 bytes or 4 bytes?</a></p>

<p>=== in response to comment ===</p>

<p>""(Accidentally commented somewhere else) Thank you for your answer. However, there is one thing which seems a bit unclear. Let's say I have a pointer to a char 'c'. Is the pointer now a pointer to a char array of size 1?</p>

<p>YES.  A byte array of one byte.</p>

<p>Also, just to verify, you've mentioned that a pointer to a single structure is a pointer to an array of size one. </p>

<p>YES, but in this case the size of a single element in the array is <code>sizeof(mystruct)</code>, which is likely more than a single byte.</p>

<p>Typecasting that pointer to a pointer to char will therefore result in the array size now being larger than 1 and being an array of bytes, responsible for the hex dump. </p>

<p>YES.  </p>

<p>Hence should any pointer when typecasted in such a manner result in this nice byte breakup?</p>

<p>YES.  This is how byte/memory dumps work.</p>

<p>One more thing about the <code>sizeof(type)</code> keyword.  <code>sizeof(type)</code> reports the size (in bytes) of an instance of <code>type</code>.  <code>sizeof(variable)</code> is equivalent to the sizeof(type-of-variable).  This has a subtle behavior when variable is a pointer or array.  For example:</p>

<pre><code>char c = '0'   // in memory this is the single byte 0x30
char str[] = { 0x31, 0x32, 0x00 }; // an array of bytes 0x31, 0x32, 0x00

sizeof(char) == sizeof(c) == 1
sizeof(str) == 3 // compiler knows the array was initialized to 3 bytes
sizeof(p) == 4 // assuming your compiler is using 32-bit pointers.  On a 64-bit machine this would be 8.

char* p = &amp;c;  //  note that assigning a pointer to the address of a variable requires the address-of operator (&amp;)

sizeof(*p) == 1 // this is the size of the thing pointed to.

p = str; // note that assigning an ARRAY variable name to a pointer does not require address-of (because the name of an array IS a pointer - they *are* the same type in all ways except with respect to sizeof() where sizeof() knows the size of an initialized array.)

sizeof (*p) == 1; // even though p was assigned to str - an array - sizeof still returns the answer based on the type of the thing p is pointing to - in this case a single char.  This is subtle but important.  p points to a single character in the array.

// Thus at this point, p points to 0x31.
p++; // p advances in memory by sizeof(*p), now points at 0x32.
p++; // p advances in memory by sizeof(*p), now points at 0x00.
p++; // p advances in memory by sizeof(*p), now points BEYOND THE ARRAY.
</code></pre>

<p>IMPORTANT - Because the pointer was advanced past the end of the array, at this point p points to possibly invalid memory OR it might point to some other random variable in memory.  This can result in a crash (in the case of invalid memory), or a bug and memory corruption (and a likely security bug) if it points to ""valid"" memory that isn't being used as expected.  In this specific case where the variables are assumed to live on the stack it points to a variable or perhaps the return address of the function.  Either way, going beyond the array is BAD. VERY VERY BAD. and the COMPILER WON'T STOP YOU!!!</p>

<p>Also, by the way - <code>sizeof</code> is NOT a function.  It is evaluated by the compiler at compile time based on the compiler's symbol table.  Therefore there is no way to get the size of an array allocated like this:</p>

<pre><code>char* p = malloc(sizeof(char)*100);
</code></pre>

<p>The compiler doesn't realize that you're allocating 100 bytes because malloc is a run-time function.  (indeed, 100 is usually a variable with a changing value).  Therefore <code>sizeof(p)</code> will return the sizeof a pointer (either 4 or 8 as mentioned earlier), and <code>sizeof(*p)</code> will return <code>sizeof(char)</code>, which is 1.  In a case like this the code has to remember how much memory was allocated in a separate variable (or in some other way - dynamic allocation is a separate topic altogether). </p>

<p>In other words, sizeof() only works for types and for statically initialized arrays (those that are initialized in code), such as these:</p>

<pre><code>char one[] = { 'a' };
char two[] = ""b"";  // using the string quotes results in a final zero-byte being automatically added.  So this is an array of 2 bytes.
char three[3] = ""c""; // the specified size overrides the string size, so this produces an array of 'c', 0, &lt;uninitialized&gt;
char bad[1] = ""d""; // trying to put 2 bytes in a 1 byte-bag. This should generate a compiler error.
</code></pre>
"
"<p>The pointer <code>struct tm *time_ptr</code> is typecasted to <code>char *</code>, this simply means that the memory to which it is pointing to will now be treated as sequence of 1 byte data. This is the main concept used for the pointer airthmetic, the type of the pointer governs how many bytes will the pointer move when it is incremented. Since this is a <code>char</code>  pointer, incrementing it will move it ahead by just a single byte and you can see the memory dump being printed byte by byte.</p>

<p>In the second case, the type of the pointer is <code>(int*)</code>, pointing to the same memory location which will now treat the memory as sequence of <code>sizeof(int)</code> (depend on the platform, the size could vary). In this case it is 4 bytes. Now you can see that 4 bytes group 0x00 00 00 18 is equal to 24 decimal. Similarly 0x00 00 00 16 is equal  to 22 in decimal and 0x00 00 00 04 is equal to 4 in decimal. (Take the endianness into account here).</p>
"
"<pre><code>unsigned char *raw_ptr;
raw_ptr = (unsigned char *)time_ptr;
</code></pre>

<p>This creates a pointer of type <code>unsigned char</code> and it's initialized with a pointer to a <code>struct tm</code> pointer (accomplished via casting).</p>

<blockquote>
  <p>but how did it manage to become an array (character array, I think)</p>
</blockquote>

<p>The <code>time_ptr</code> has not changed. The program is being told to look at the same memory location as <code>time_ptr</code> but consider it as an array of <code>unsigned char</code> types.</p>

<blockquote>
  <p>I think that this might be to do with the fact that arrays are interpreted as pointers which point to their 0th elements, but I am not sure.</p>
</blockquote>

<p>Array types decay to pointers. So yes, arrays are represented by pointers. However, the pointer doesn't have to be associated with the 0th index, but it will be that way when the array is first created.</p>

<blockquote>
  <p>Secondly, what is the output from the dump_time_struct_bytes function (the dumped bytes)?</p>
</blockquote>

<p>Yes. There is no <code>byte</code> type so <code>char</code> or <code>unsigned char</code> is often used.</p>

<blockquote>
  <p>Also, what does the address of *time_ptr correspond to? Is it the start of the structure?</p>
</blockquote>

<p>Yes.</p>

<blockquote>
  <p>If the latter is true, do the corresponding dumped bytes in the output belong only to its first element (tm_sec) or to the whole structure ?</p>
</blockquote>

<p>The whole structure because the second parameter <code>size</code> was initialized using <code>sizeof(struct tm)</code> (i.e., all the bytes comprising that type).</p>

<blockquote>
  <p>The explanation for the ""hacky pointer"" was a bit weird- why does dereferencing a converted integer pointer solely reveal the contents of the first element in the structure- tm_sec?</p>
</blockquote>

<p><a href=""http://en.cppreference.com/w/c/chrono/tm"" rel=""nofollow"">It seems that the first data member is <code>tm_sec</code> and it is of type <code>int</code></a>. Therefore a pointer to <code>struct tm</code> is pointing to the same memory used to store <code>tm_sec</code>. So, the memory location is cast to <code>int*</code> since <code>tm_sec</code> is of type <code>int</code> and and we're dealing with a pointer to it. Then it's dereferenced to see the value of that address (when it's treated/viewed as an <code>int</code> as opposed to <code>struct tm</code>).</p>

<hr>

<p>Note: Given an arbitrary 4 bytes. What do the mean? If they are viewed as an unsigned 32-bit integer type a certain value is produced. If they are viewed as a 32-bit floating point type a different value may be produced. Casting is way to force a particular ""view"" of the bytes regardless of what the bytes really represent.</p>
"
"<p>I'm posting an answer I gave in the comments, in case it should help someone experiencing a similar issue.</p>

<p>The message header type in the code looks like this:</p>

<pre><code>typedef struct {
    // Message ID
    unsigned mID;
    // IP of sender
    struct in_addr sender;
    // Message size
    size_t datasize;
} header_type;
</code></pre>

<p>This message header type is non-portable and architecture dependent.</p>

<p>On some architectures unsigned and size_t might have 32 bit, on others they might have 64bits or 16bits...</p>

<p>Also, struct <code>in_addr</code> is implementation specific, so the message header might look different on different operating systems (which OS does the server run on? which version?).</p>

<p>Unless all the network nodes (servers and clients) run on the same OS and architecture, there's a need for byte streams and bit specific types (i.e. <code>uint64_t datasize</code> and <code>uint8_t client_addr[16]</code>.</p>

<p>Another related issue would be the architecture (vs. network) byte order for the message size.</p>

<p>Different architectures exhibit different <a href=""https://en.wikipedia.org/wiki/Endianness"" rel=""nofollow"">Endianness</a>, so it's important to make sure the message length is stored and read correctly.</p>

<p>I would consider a <code>union</code> for the message size, or limiting the message size length to 32 bits (<code>uint32_t</code>), so I could use the POSIX <a href=""http://linux.die.net/man/3/byteorder"" rel=""nofollow"">network byte order API</a>.</p>

<pre><code>typedef struct {
    // Network byte ordered Message ID
    uint32_t nb_mID;
    // IP of sender as either a IPv4 string or a IPv6 string 39
    uint8_t sender[39];
    // IPv4 vs. IPv6 data identifier
    uint8_t sender_type;
    // Network byte ordered Message size
    uint32_t nb_datasize;
} header_type;
</code></pre>

<p><strong>Side Note</strong></p>

<p>As a side note, it should be mentioned that using a thread per connection design causes slowdowns due to excessive context switches and could make the server more susceptible toDoS attacks.</p>

<p>Normally, running more threads (or processes) then the number of CPU cores would lead to excessive context switches.</p>

<p>This is usually acceptable to some extent due to other considerations, but a thread per connection would run down system resources very fast and the system could easily reach a point where it is spending more time on context switches then task performance.</p>
"
"<p>If you are piping data to <code>aplay</code>, you will not experience any problems with the sample rate (8 kHz, for example) because the kernel will block your program when you <code>write()</code> when the buffer is full.  This will effectively limit your audio generation to 8 kHz with no work on your part.</p>

<p>However, this is far from ideal.  Your application will only be throttled once the kernel buffer for the pipe is full, and the default size for pipe buffers on Linux is 64 kB.  For stereo 16-bit data at 8 kHz, this is two full seconds of audio data, so you would expect your audio to lag at least two seconds from the user input.  This is unacceptable for synthesizer applications.</p>

<p>The only real solution is to use the ALSA library directly (or some alternative sound API).  Using this API, you can send buffered audio data to your audio output device without accumulating excessive queued data in kernel buffers.</p>

<p>See <a href=""http://0pointer.de/blog/projects/guide-to-sound-apis"" rel=""nofollow"">A Guide Through The Linux Sound API Jungle</a> for some tips.</p>
"
"<p>To generate audio samples at 8000 Hz (or any fixed rate) you don't want your loop to ""run at"" that rate. That would involve huge amounts of overhead (99.99% or more) spinning doing nothing until time to generate the next sample, and (especially if you sleep rather than spinning) would be unreliable in that your process might not wake-up/get-scheduled in time for some of the samples.</p>

<p>Instead, you just want to be producing samples at an overall rate matching what the consumer (<code>aplay</code>/the audio device) expects. You can compute the overall current sample number you should be generating up to as something like:</p>

<pre><code>current_time + buffer_depth - start_time
</code></pre>

<p>then, after generating up to that sample, sleep for some period proportional to the buffer depth, but sufficiently less that you won't be in trouble if your process doesn't get scheduled again right away. The buffer depth you can use depends on what kind of latency you need. If you're making sounds for live/realtime events, you probably want a buffer depth of 1/50 sec (20 ms) or less. If not, you can happily use huge buffers like 5-10 seconds.</p>
"
"<p>You can use:</p>

<pre><code>    #include &lt;time.h&gt;
</code></pre>

<p>for time. To get the current time : </p>

<pre><code>    time_t current_time = clock();
</code></pre>

<p>To get the current date, you can use :</p>

<pre><code>    struct tm *localtime(const time_t *time);
</code></pre>

<p>Which returns a struct for the local time that looks like this :</p>

<pre><code>    struct tm {
      int tm_sec;   // seconds of minutes from 0 to 61
      int tm_min;   // minutes of hour from 0 to 59
      int tm_hour;  // hours of day from 0 to 24
      int tm_mday;  // day of month from 1 to 31
      int tm_mon;   // month of year from 0 to 11
      int tm_year;  // year since 1900
      int tm_wday;  // days since sunday
      int tm_yday;  // days since January 1st
      int tm_isdst; // hours of daylight savings time
    }
</code></pre>
"
"<p>As currently written, your code does not compile: <code>current_time</code> is a <code>time_t</code>, not a <code>struct tm</code>.  How do you compute the <code>tm</code> structure and how do you use it? If this structure is not properly initialized, the <code>sprintf()</code> may invoke undefined behavior, which means anything can happen, but this would require some of the fields to be out of range.</p>

<p>It is vain to try and elaborate on side effects from such a small and inaccurate code fragment.</p>

<p>Fix the code by making the buffer larger, and use <code>snprintf</code> instead of <code>sprintf</code> and ensure the <code>tm</code> structure is correctly computed. An invalid <code>date_time</code> string, even without a buffer overflow, may cause other problems elsewhere in the code or in the database itself...  Posting more code would help investigate.</p>

<p>Do you know more about the actual crash? Do you have a register dump?</p>
"
"<p>It is still not 100% clear what your heart's desire might be, but the topic is pretty interesting.</p>

<p>First: The github project you are referring to is not documented well enough to say what exactly it expects as input and I don't have enough knowledge about Markov processes to say that the continuous part is wrong, but to me it does not make much sense.</p>

<p>Secondly:  The sum of a row of a transition rate matrix is 0 for all Markov processes, not only for birth-death processes.</p>

<p>That is how I would simulate a run:</p>

<ol>
<li><p>Given: the start state (probably <code>0</code>) <code>S</code>, transition rate matrix <code>Q</code> (defined via<code>P'=PQ</code>), number of transitions <code>n</code> of interest.</p></li>
<li><p>Output: <code>times</code> - times to which the transitions occurred, <code>states</code> - the series of visited states.</p></li>
</ol>

<p>Here we go with a wild mix of C++ and pseudo-code:</p>

<pre><code>std::default_random_engine rnd;//ini

double current_time=0.0;
int current_state=S;
vector&lt;doubles&gt; times={current_time};
vector&lt;int&gt; states={current_state};

for (int i=0;i&lt;n;i++){
//Part 1: simulate the time staying in current state:
  double decay_rate=-Q[current_state][current_state];
  if(decay_rate==0.0){
  //that means we are not going anywhere anymore and staying for ever in this state:
      return;
  }
  //we don't do error checking and expect rate to be positive, because diagonal elements of Q must be 0.0 or negative
  //The current state will decay with the decay_rate, so the life time in this state until the decay is exponentially distributed with parameter decay_rate
 //simulate the life time:
 std::exponential_distribution&lt;&gt; life_time_generator(decay_rate);
 double life_time=life_time_generator(rnd);
 times.push_back(times.back()+life_time);

//Part2: to which state have we actually decayed?
// The probability to decay to the state new_state is proportional to transition rate Q[current_state][new_state]
//thus generate an uniformly distributed random variable [0, decay_rate] (decay_rate - sum of transition rates of all possible new states) and map it on the states:
 double target_value=std::generate_canonical&lt;double,10&gt;(rnd)*decay_rate;
 double sum=0.0;
 for (int new_state=0;new_state&lt;Q.size();new_state++){
     if (new_state==current_state)//don't forget to skip the state itself
         continue;
     sum+=Q[current_state][new_state];
     if (sum&gt;target_value){//we found our next state!
         current_state=new_state;
         states.push_back(current_state);
         break;
     }
     //there are still a some precision issues, if the sum of all transition rates is slightly under 1.0
     //the issues should be handled somehow but not in this pseudo-code.
 }

}
// do whatever you want with times/states
</code></pre>

<p>I hope it is something you had in mind.</p>

<p><strong>Edit:</strong></p>

<p>As short explanation: </p>

<ol>
<li><p>For the first part - the time until the transition. The code is based on the well known fact, that if the arrivals are Poisson distributed with rate lambda, than the waiting times are exponential distributed with parameter lambda. See for example <a href=""https://en.wikipedia.org/wiki/Poisson_point_process#Memoryless_property"" rel=""nofollow"">here</a> </p></li>
<li><p>For the second part - it is just the <a href=""https://en.wikipedia.org/wiki/Conditional_probability"" rel=""nofollow"">conditional probability</a>: The transition probability for a very short period of time <code>dt</code> is <code>-Q[current_state][current_state]dt</code>. This condition is fulfilled as we know the transition happened. The probability to go to the state <code>new_state</code>is <code>Q[current_state][new_state]*dt</code> but under the condition that the transition happened it is <code>Q[current_state][new_state]/-Q[current_state][current_state]</code> - and that is what is calculated in the second part.</p></li>
</ol>
"
"<p>You should change your index by adding proper operator class, according to <a href=""https://www.postgresql.org/docs/9.5/static/indexes-opclass.html"" rel=""nofollow"">documentation</a>:</p>

<blockquote>
  <p>The operator classes text_pattern_ops, varchar_pattern_ops, and
  bpchar_pattern_ops support B-tree indexes on the types text, varchar,
  and char respectively. The difference from the default operator
  classes is that the values are compared strictly character by
  character rather than according to the locale-specific collation
  rules. This makes these operator classes suitable for use by queries
  involving pattern matching expressions (LIKE or POSIX regular
  expressions) when the database does not use the standard ""C"" locale.
  As an example, you might index a varchar column like this:</p>

  <p><code>CREATE INDEX test_index ON test_table (col varchar_pattern_ops);</code></p>
</blockquote>
"
"<p>It's too hard to make an index for queries like <code>strin LIKE pattern</code> because wildcards (% and _) can stand everywhere.</p>

<p>I can suggest one risky solution:</p>

<ol>
<li><p>Slightly redesign the table - make it indexable. Add two more column <code>prefix_low</code> and <code>prefix_high</code> of fixed width - for example <code>char(32)</code>, or any arbitrary length enough for the task. Also add one <code>smallint</code> column for prefix length. Fill them with lowest and highest values matching prefix and prefix length.  For example:</p>

<pre><code>select rpad(rtrim('00436641997142%','%'), 32, '0') AS prefix_low, rpad(rtrim('00436641997142%','%'), 32, '9') AS prefix_high, length(rtrim('00436641997142%','%')) AS prefix_length;

       prefix_low                 |               prefix_high             |   prefix_length
----------------------------------+---------------------------------------+-----
 00436641997142000000000000000000 | 00436641997142999999999999999999      |   14
</code></pre></li>
<li><p>Make index with these values</p>

<pre><code>CREATE INDEX table_prefix_low_high_idx ON table (prefix_low, prefix_high);
</code></pre></li>
<li><p>Check modified requests against table:</p>

<pre><code>SELECT prefix, changeprefix, deletelast, outgroup, tariff
FROM table
WHERE '00436641997142%' BETWEEN prefix_low AND prefix_high
  AND company = 0
  AND ((current_time between timefrom and timeto) or (timefrom is null and timeto is null)) and (strpos(""Day"", cast(to_char(now(), 'ID') as varchar)) &gt; 0  or ""Day"" is null )
ORDER BY prefix_length DESC
LIMIT 1
</code></pre>

<p>Check how well it works with indexes, try to tune it - add/remove index for prefix_length add it to between index and so on.</p></li>
<li><p>Now you need to rewrite queries to database. Install PgBouncer and <a href=""https://github.com/awslabs/pgbouncer-rr-patch"" rel=""nofollow"">PgBouncer-RR patch</a>. It allows you rewrite queries on-fly with easy python code like in example:</p>

<pre><code>import re

def rewrite_query(username, query):
   q1=r""""""^SELECT [^']*'(?P&lt;id&gt;\d+)%'[^'] ORDER BY (?P&lt;position&gt;\('%' in prefix\) ASC, char_length\(prefix\) LIMIT """"""
   if not re.match(q1, query):
      return query  # nothing to do with other queries
   else:
      new_query = # ... rewrite query here
   return new_query
</code></pre></li>
<li><p>Run pgBouncer and connect it to DB. Try to issue different queries like your application does and check how they are getting rewrited. Because you deal with text you have to tweak regexps to match all required queries and rewrite them properly.</p></li>
<li><p>When proxy is ready and debugged reconnect your application to pgBouncer.</p></li>
</ol>

<p>Pro:</p>

<ul>
<li>no changes to application</li>
<li>no changes to basic structure of DB</li>
</ul>

<p>Contra:</p>

<ul>
<li>extra maintenance - you need triggers to keep all new columns with actual data</li>
<li>extra tools to support</li>
<li>rewrite uses regexp so it's closely tied to particular queries issued by your app. You need to run it for some time and make robust rewrite rules.</li>
</ul>

<p>Further development:
 highjack parsed query tree in pgsql itself <a href=""https://wiki.postgresql.org/wiki/Query_Parsing"" rel=""nofollow"">https://wiki.postgresql.org/wiki/Query_Parsing</a></p>
"
"<p>If I understand your problem correctly, creating proxy server which rewrites queries could be solution here.</p>

<p>Here is an <a href=""https://stackoverflow.com/a/7550381/5932498"">example from another question</a>.</p>

<p>Then you could change ""LIKE"" to ""="" in your query, and it would run a lot faster.</p>
"
"<p>This is a no brainer.</p>

<p><strong>Yes</strong> - store the function call result of <code>time_elapsed_string($ptime)</code> in an array, then use that to access your results. You're wasting CPU cycles otherwise!</p>

<pre><code>// call it once
$result = time_elapsed_string($ptime);

// then use:
$result['date'];
$result['time'];
$result['difference'];
</code></pre>
"
"<p>Counting time elapsed since some date/time like this is <em>mauvais ton</em>.</p>

<p><a href=""http://php.net/manual/en/class.datetime.php"" rel=""nofollow""><code>DateTime</code></a> has been available since PHP 5.2.0 and tonns of people underestimate it. Why don't you use this instead of <code>loop</code>s and <code>if</code>s?</p>

<pre><code>$create_time = ""2016-08-02 12:35:04"";
$current_time=""2016-08-02 16:16:02"";

$dtCurrent = DateTime::createFromFormat('Y-m-d H:i:s', $current_time);
// to use current timestamp, use the following:
//$dtCurrent = new DateTime();
$dtCreate = DateTime::createFromFormat('Y-m-d H:i:s', $create_time);
$diff = $dtCurrent-&gt;diff($dtCreate);
</code></pre>

<p>Now, you can <a href=""http://php.net/manual/en/datetime.format.php"" rel=""nofollow"">format</a> the result however you want:</p>

<pre><code>$interval = $diff-&gt;format(""%h hours %i minutes %s seconds"");
</code></pre>

<p>This will give a clean <code>3 hours 40 minutes 58 seconds</code> without any arrays, which is better.</p>

<p><strong>UPDATE</strong></p>

<p>There is a general solution to get hours / minutes / seconds via regex:</p>

<pre><code>$interval = $diff-&gt;format(""%y years %m months %d days %h hours %i minutes %s seconds"");

// now remove zero values
$interval = preg_replace('/(^0| 0) (years|months|days|hours|minutes|seconds)/', '', $interval);
</code></pre>

<p><strong>UPDATE 2</strong></p>

<p>As of your comment:</p>

<blockquote>
  <p>Look, I want to use your approach .. but I really cannot implement it .. Actually I need three things: <code>time</code>, <code>date</code>, <code>difference</code> ..! But your approach doesn't give me them..</p>
</blockquote>

<p>Well, we already know how to get the difference, it's the <code>$interval</code> variable described above.</p>

<p>To get time and date, you can get it from the <code>$dtCreate</code> variable by, again, using format:</p>

<pre><code>$time = $dtCreate-&gt;format('H:i:s');
$date = $dtCreate-&gt;format('d-m-Y');
</code></pre>
"
"<p>The reason appears to be how difficult it is to do free-form date parsing:</p>

<p>A baseline date: (I'm in the America/Toronto time zone)</p>

<pre><code>$ date -d ""2016-11-06 01:00:00"" ""+%F %T%z""
2016-11-06 01:00:00-0400
</code></pre>

<p>Try adding a day</p>

<pre><code>$ date -d ""2016-11-06 01:00:00 + 1 day"" ""+%F %T%z""
2016-11-06 19:00:00-0500
</code></pre>

<p>Hmm, that's strange, looks like it's adding a day but then expressing it as midnight, then subtracting 5 hours.</p>

<p>Let's try adding a day to just the date part</p>

<pre><code>$ date -d ""2016-11-06 + 1 day 01:00:00"" ""+%F %T%z""
2016-11-07 01:00:00-0500
</code></pre>

<p>That looks better.</p>

<p>In your script try this:</p>

<pre class=""lang-bsh prettyprint-override""><code>read current_date current_time &lt; &lt;(date -d ""$1"" +""%F %T%z"")
echo ""$current_date $current_time""
next_day=$(date -d ""$current_date + 1 day $current_time"" +""%F %T%z"")
echo ""$next_day""
three_days=$(date -d ""$current_date + 3 day $current_time"" +""%F %T%z"")
echo ""$three_days""
</code></pre>
"
"<p>You're getting this warning perhaps because <code>localtime()</code> is not thread-safe. Two instances calling this function might result in some discrepancy.</p>

<blockquote>
  <p>[...] localtime returns a pointer to a static buffer (std::tm*).
  Another thread can call the function and the static buffer could be
  overwritten before the first thread has finished reading the content
  of the struct std::tm*.</p>
</blockquote>
"
"<p>The standard and cross-platform way is to use <code>chrono</code>.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;chrono&gt;

int main(){
    std::time_t now_time = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    std::cout &lt;&lt; ""Now:"" &lt;&lt; std::ctime(&amp;now_time);
}
</code></pre>
"
"<p>This is another way that could work: </p>

<pre><code>time_t current_time;
struct tm *timeinfo;
time(&amp;current_time);
timeinfo = localtime(&amp;current_time);
string date = asctime(timeinfo);
</code></pre>
"
"<p>You can try below code and description beneath it.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;ctime&gt;

int main ()
{
  time_t rawtime;
  struct tm * timeinfo;
  char buffer[80];

  time (&amp;rawtime);
  timeinfo = localtime(&amp;rawtime);

  strftime(buffer,80,""%d-%m-%Y %I:%M:%S"",timeinfo);
  std::string str(buffer);

  std::cout &lt;&lt; str;

  return 0;
}
</code></pre>

<p><strong>Function</strong></p>

<p>time_t time (time_t* timer);</p>

<p>function returns this value, and if the argument is not a null pointer, it also sets this value to the object pointed by timer.</p>

<p><strong>Parameters</strong></p>

<ul>
<li>timer
Pointer to an object of type time_t, where the time value is stored.you can also pass it null pointer in case not required</li>
</ul>

<p><strong>Return Value</strong></p>

<p>The current calendar time as a time_t object.If the function could not retrieve the calendar time, it returns a value of -1.</p>
"
"<p>Here is how I do it:</p>

<pre><code>#include ""tz.h""
#include &lt;iostream&gt;

int
main()
{
    using namespace std::chrono;
    std::cout &lt;&lt; date::make_zoned(date::current_zone(), system_clock::now()) &lt;&lt; '\n';
}
</code></pre>

<p>which just output for me:</p>

<pre><code>2016-10-18 10:39:10.526768 EDT
</code></pre>

<p>I use this C++11/14 <a href=""https://howardhinnant.github.io/date/tz.html"" rel=""nofollow"">portable, free, open-source library</a>.  It is thread-safe.  It is based on <code>&lt;chrono&gt;</code>.  It is type safe and easy to use.  If you need more functionality, this library will do it.</p>

<ul>
<li>Get the local time in another timezone</li>
<li>Convert local time directly from one timezone to another.</li>
<li>Take leap seconds into account in time computations.</li>
<li>Stream out / stream in time stamps round trip with any precision, and no loss of information.</li>
<li>Search all timezones for a property (such as abbreviation or offset).</li>
</ul>

<p>This library is being proposed to the C++ standards committee, <a href=""https://howardhinnant.github.io/date/d0355r1.html"" rel=""nofollow"">draft here</a>.</p>
"
"<p>I greatly appreciate all of your timely the responses. Ultimately I was able to use a variation of Heemanshu Bhalla?s response. I added ?_CRT_SECURE_NO_WARNINGS? to the preprocessor definitions by going <strong><a href=""https://stackoverflow.com/questions/33385730/where-is-the-place-to-add-c-preprocessor-directives-in-visual-studio-2015-ente"">here</a></strong> then I altered Heemanshu?s code to the following code. This suited my needs.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;string&gt;

using namespace std;

int main()
{
    time_t rawtime;
    struct tm * timeinfo;
    char buffer[80];

    time(&amp;rawtime);
    timeinfo = localtime(&amp;rawtime);

    strftime(buffer, 80, ""%m/%d/%Y "", timeinfo);
    string str(buffer);

    cout &lt;&lt; str &lt;&lt; endl;

    system(""PAUSE"");

    return 0;
}
</code></pre>
"
"<p>I'm sorry, I discovered that 'timespan' here is not a php command but a function in a script. Right now, I'm starting to play whit that to see the results.</p>

<p>Thank you for your patience.</p>
"
"<p>Here is a sample timespan function:</p>

<pre><code>function timespan ($current_time, $list_expires) {
    /** The formatted time span */
    $formatted_timespan = """";
    /** The difference between the current time and list expires */
    $time_difference = ($current_time - $list_expires);
    /** If the time difference is greater than 1 day */
    if ($time_difference &gt; (3600*24)) {
        /** The number of days */
        $day_count          = floor($time_difference / (3600*24));
        $formatted_timespan = ""Expires in "" . $day_count . "" days"";
    }
    /** If the time difference is less than 1 day but larger than 1 hour */
    else ($time_difference &lt; (3600*24) &amp;&amp; $time_difference &gt; (3600)) {
        /** The number of hours */
        $hour_count         = floor($time_difference / (3600));
        $formatted_timespan = ""Expires in "" . $hour_count . "" hours"";
    }
    /** If the time difference is less than 1 hour */
    else ($time_difference &lt; (3600)) {
        /** The number of minutes */
        $minute_count       = floor($time_difference / (60));
        $formatted_timespan = ""Expires in "" . $minute_count . "" minutes"";
    }
    return $formatted_timespan;
}
</code></pre>
"
"<p>Well, walking deeper throught docomentation to <code>soapcpp2</code> I found option <code>-Ed</code> witch generates <code>soap_del_T</code> macros for each type used by gsoap.</p>
"
"<p>Use <a href=""http://en.cppreference.com/w/c/string/byte/strncmp"" rel=""nofollow noreferrer"">strncmp()</a> instead of comparing the string with <code>==</code>:</p>

<pre><code>if (strncmp(timeString,""Friday"",7) == 0)
    {printf(""Weekday"");

}
</code></pre>

<p>See this in action at tutorialspoint.com:
<a href=""http://www.tutorialspoint.com/compile_c_online.php?PID=0Bw_CjBb95KQMMW80dl9XN1cySFU"" rel=""nofollow noreferrer"">Friday</a></p>

<p>Currently, it is Thursday (for ~50% of the world) - so try this one:
<a href=""http://www.tutorialspoint.com/compile_c_online.php?PID=0Bw_CjBb95KQMZzBQRVpNWDVoTUE"" rel=""nofollow noreferrer"">Thursday</a></p>
"
"<p>You can use <a href=""https://www.opengl.org/resources/libraries/glut/spec3/node64.html"" rel=""nofollow noreferrer""><code>glutTimerFunc</code></a> to execute a function at a regular time period. This has the signature</p>

<pre><code>void glutTimerFunc(unsigned int msecs,
                   void (*func)(int value),
                   value);
</code></pre>

<p>For example if your drawing function was</p>

<pre><code>void UpdateTokens(int time);
</code></pre>

<p>Then you could call an update every 0.5 seconds with the following call (where <code>current_time</code> was the current simulation time)</p>

<pre><code>glutTimerFunc(500, UpdateTokens, current_time);
</code></pre>

<p>For more precise timing, I would recommend using <a href=""http://en.cppreference.com/w/cpp/chrono"" rel=""nofollow noreferrer""><code>&lt;chrono&gt;</code></a> instead, and performing your timing using things like <a href=""http://en.cppreference.com/w/cpp/chrono/duration"" rel=""nofollow noreferrer""><code>std::chrono::duration</code></a> with a <a href=""http://en.cppreference.com/w/cpp/chrono/steady_clock"" rel=""nofollow noreferrer""><code>std::chrono::stead_clock</code></a>.</p>
"
"<p>The actual problem here is how glut works. Basically, the user only gets a image presented at the end of the main loop. As long as you do not return from the mouse function, nothing is presented on screen. You can solve the problem by transferring the work to the display function and distribute the translation across multiple frames:</p>

<p>global variables:</p>

<pre><code>double circlex = 0, circley = 0, bottomy = 0;
bool isfalling = false;
int topy = 0;
</code></pre>

<p>mouse_func:</p>

<pre><code>if (isfalling == false) //Prevents the user from clicking during an animation
{
    circlex = (double)x / width ;
    circley = (double)y / height ;

    int row = board.getRow(col) + 1;
    bottomy = 500 - (25*row);
    topy = y;

    isfalling = true;
}
</code></pre>

<p>display_func:</p>

<pre><code>if (isfalling)
{
    circley += .0000000000000000001;
    topy += 2;

    if (topy &gt;= bottomy)
        isfalling = false;
}

glTranslatef(circlex, circley, 0.0f);
display();
</code></pre>
"
"<p>Here is the possible solution.</p>

<pre><code> #include &lt;iostream&gt;
 #include &lt;ctime&gt;
 #include &lt;unistd.h&gt;

 class VideoTimer {
 public:
     // Initializing offset time in ctor.
     VideoTimer(const std::string&amp; t) {
         struct tm tm;
         strptime(t.c_str(), ""%H:%M:%S"", &amp;tm);
         tm.tm_isdst = -1;
         offset = mktime(&amp;tm);
     }
     // Start timer when video starts.
     void start() {
         begin = time(nullptr);
     }
     // Get video time syncronized with shot time.
     struct tm *getTime() {
         time_t current_time = offset + (time(nullptr) - begin);
         return localtime(&amp;current_time);
     }
 private:
     time_t offset;
     time_t begin;
 };

 int main() {
     auto offset_time = ""13:43:59"";
     auto timer = VideoTimer(offset_time);
     timer.start();

     // Do some work.

     auto video_tm = timer.getTime();
     // You can play around with time now.
     std::cout &lt;&lt; video_tm-&gt;tm_hour &lt;&lt; "":"" &lt;&lt; video_tm-&gt;tm_min &lt;&lt; "":"" &lt;&lt; video_tm-&gt;tm_sec &lt;&lt; ""\n"";

     return 0;
 }
</code></pre>
"
"<p>Do you need RTC timer or just to keep video and text in sync?</p>

<p>I would suggest getting frame rate and converting all text timestamps into number of frames from beginning of video file.</p>

<p>Pseudocode:</p>

<pre><code>static uint64_t startTime = (startHours * 60 + startMinutes) * 60 + startSeconds;
static float fps = 60.00;

uint64_t curFrameFromTimestamp(int hours, int minutes, int seconds)
{
    return ((hours * 60 + minutes) * 60 + seconds - startTime) * fps;
}
</code></pre>
"
"<pre><code>if %current_time% lss ""12:00"" if %current_time% gtr ""23:00"" goto :STOP
</code></pre>

<p><code>current_time</code> may be eg. <code>12:57</code>. <code>12:57</code> and <code>""12:57""</code> are totally different strings. You need to quote the variable wherever you are comparing it against a quoted value,</p>

<pre><code>if ""%current_time%"" lss ""12:00"" if ""%current_time%"" gtr ""23:00"" goto :STOP
</code></pre>

<p><strong>BUT</strong> whereas this will correct the comparison, this code performs an ""and"" function, so you are asking ""time &lt;12:00"" AND ""time > 23:00"" which is never going to be true. Your next statement <em>may</em> become true, but since <em>this</em> statement never becomes true, batch will simply skip to the next statement. It ignores labels - they are just position-markers.</p>
"
"<p>As I mentioned you can use Timeout for a delay, but there is also<br>
<a href=""http://ss64.com/nt/choice.html"" rel=""nofollow noreferrer"">Choice</a> - a one key input which responds with an errorlevel
which allows you to abort while delaying.</p>

<p>As aacini elaborates in his comment, variables store only strings
Set /A and If try to convert to an integer if possible.  </p>

<p>One thing to always remember is that numbers with a leading zero
are treated as coded in octal (0x as hex.) This is important when
dealing with date/time parts month days hours mins secs.</p>

<p>Here is an example of a stacked if else construct </p>

<pre><code>@echo off
:loop

Set Now=%time:~0,2%%time:~3,2%
If ""%Now:~0,1%"" equ ""0""  Set Now=%Now:~1%""
cls&amp;Echo %Time:~0,8%  Now=%Now%

if %Now% geq 1200 (
    if %Now% leq 2300 (
        goto :START
    ) Else (
        goto :Stop
    )
) Else (
    Goto :Stop
)
Rem Could never reach here

:START
echo The program has successfully ran.
echo Press anything to exit now.
pause &gt;nul
exit

:STOP
echo Sorry, but this program is closed. Come back at 12:00 P.M.
echo To abort, hit A
Choice /T 2 /C AN /M ""Abort [A/N] "" /D N &gt;NUL
If %ErrorLevel% == 1 exit /B
Goto :loop
</code></pre>
"
"<p>I think this is probably memory-bandwidth limited. The few extra adds implied by inlining f1 or f2 into res don't really matter. Indeed, I get the best performance with the following schedule:</p>

<pre><code>in1.compute_at(res, yi).vectorize(in1.args()[0], 8);
in2.compute_at(res, yi).vectorize(in2.args()[0], 8);
res.split(y, y, yi, 8).vectorize(x, 8).parallel(y);
</code></pre>

<p>I.e. just pulling in a padded scanline of each inputs and then doing all the math inlined.</p>

<p>But it's barely any faster than yours. The difference might be noise. My full experiment: </p>

<p><a href=""https://gist.github.com/abadams/c2e6f67d79e1768af6db5afcabb1caab"" rel=""nofollow noreferrer"">https://gist.github.com/abadams/c2e6f67d79e1768af6db5afcabb1caab</a></p>

<p>The produce of f2 is nested inside the <em>consume</em> of f1. That's normal - it doesn't use f1, but it's used by something that does use f1, so that's a reasonable place for it to end up.</p>
"
"<p><code>""%H:%I""</code> is wrong format, you need <code>""%H:%M""</code> instead - with <code>%M</code> specifier for minute.</p>

<p>Refer to C11 standard</p>

<blockquote>
  <p>7.27.3.5 The strftime function</p>
</blockquote>

<pre><code>    #include &lt;time.h&gt;
    size_t strftime(char * restrict s,
         size_t maxsize,
         const char * restrict format,
         const struct tm * restrict timeptr);
</code></pre>

<blockquote>
  <ol start=""3"">
  <li>Each conversion specifier is replaced by appropriate characters as described in the following list.</li>
  </ol>

  <blockquote>
    <p>%M
    is replaced by the minute as a decimal number (00-59). [tm_min]</p>
  </blockquote>
</blockquote>
"
"<p>You're using the wrong format string for the time.</p>

<p>The <code>%I</code> format specifier gives you the hour in the range 01-12.  So <code>%H:%I</code> gives you the hour twice: first in 24 hour format then 12 hour format.</p>

<p>If you want minutes and seconds, you need to use <code>%M</code> and <code>%S</code> respectively.</p>

<pre><code>strftime(current_time, sizeof(current_time), ""%H:%M:%S"", time_ptr);
</code></pre>
"
"<p>The Bash man page says this of here documents (emphasis added):</p>

<blockquote>
  <p>This type of redirection instructs the shell to read input from the current source until a line  containing <strong><em>only</em></strong> [the delimiter] (<strong><em>with no trailing blanks</em></strong>) is seen.  All of the lines read up to that point are then used as the standard input for a command.</p>

  <p>[...]</p>

  <p>If the redirection operator is <code>&lt;&lt;-</code>, then all leading tab characters are stripped from input lines and the line containing [the delimiter].</p>
</blockquote>

<p>I reviewed the literal whitespace in your code by opening the question for editing.  Supposing that the code presented accurately reflects your actual script, including whitespace, your problem is trailing spaces on the lines containing your here documents' closing delimiters.</p>
"
"<p>You are re-using the vertex colors as the normals, and never use the actual normals in your array:</p>

<pre><code>glVertexAttribPointer(1, 3, GL_FLOAT, false, 9 * sizeof(GLfloat), (void*)(3 * sizeof(GLfloat)));
glVertexAttribPointer(2, 3, GL_FLOAT, false, 9 * sizeof(GLfloat), (void*)(3 * sizeof(GLfloat)));
</code></pre>
"
"<p>Try something like this</p>

<pre><code>static void get_temperature_sample(int *previous_temp)
{
    *previous_temp -= 2; // This decrements the value and
                         // don't need a return value, because
                         // you are passing a pointer to
                         // the variable and hence modifying
                         // it's value directly
}
</code></pre>

<p>And when you call the function</p>

<pre><code>int32_t temperature = 50;      // Initial temperature
get_temperature_sample(&amp;temperature);
</code></pre>

<p>You'll need to add a while somewhere in there depending on how you're tracking the temperature. But this will decrement the temp value whenever you call the function.</p>
"
"<p>To decrement <code>a</code>, try using</p>

<pre><code> a -=2;
</code></pre>

<p>it will help you..</p>
"
"<p>Printing a <code>long long int</code> value through <code>printf</code> requires a <code>%lld</code> (or <code>%lli</code>) format. You are using <code>%i</code>, which is wrong. The behavior is undefined.</p>
"
"<p>To get the seconds since midnight you need to find the seconds since epoch and mod it by the seconds in a day and then subtract the number of seconds to convert to your local time zone: </p>

<pre><code>#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    time_t current_time;
    char* c_time_string;

    /* Obtain current time. */
    current_time = time(NULL);

    if (current_time == ((time_t)-1))
    {
        (void) fprintf(stderr, ""Failure to obtain the current time.\n"");
        exit(EXIT_FAILURE);
    }

    /* Convert to local time format. */
    c_time_string = ctime(&amp;current_time);

    if (c_time_string == NULL)
    {
        (void) fprintf(stderr, ""Failure to convert the current time.\n"");
        exit(EXIT_FAILURE);
    }

    /* Print to stdout. ctime() has already added a terminating newline character. */
    (void) printf(""Current time is %s"", c_time_string);
    (void) printf(""Seconds since midnight is %li"", current_time%86400 - 18000);
    exit(EXIT_SUCCESS);
}
</code></pre>

<p>I subtracted 18000 to make it show seconds since midnight for eastern time zone :)</p>
"
"<p>Please Use <code>%lld</code> or <code>%lli</code> for printing <code>long long int</code> , you are using <code>%i</code> which can only be used with <code>int</code>.It causes Undefined Behaviour.</p>

<p>Your Compiler Should Have Warned You</p>

<blockquote>
  <p>format <code>%i</code> expects argument of type <code>int</code>, but argument 2 has type <code>long long int</code></p>
</blockquote>

<p>If not then please enable <code>[-Wformat=]</code> Warning.</p>

<p>Also Look At This Question <a href=""https://stackoverflow.com/questions/6299083/cross-platform-printing-of-64-bit-integers-with-printf?noredirect=1&amp;lq=1"">cross-platform printing of 64-bit integers with printf</a></p>

<p>You were unlucky with first <code>printf</code> for that to be working correctly , often things like these get unchecked and cause harm later , it is often much better to enable extra warning and correct your code.</p>
"
"<p>You are using:</p>

<pre><code>fopen($filename, ""w+"")
</code></pre>

<p>According to the manual <code>w+</code> means:</p>

<blockquote>
  <p>Open for reading and writing; place the file pointer at the beginning of the file and truncate the file to zero length. If the file does not exist, attempt to create it.</p>
</blockquote>

<p>So the file size being 0 is correct.</p>

<p>You probably need <code>r+</code></p>
"
"<p>Save the current time at the point when the thread is started. The total time spent by the thread, counting both running and blocked time, is then just:</p>

<pre><code>current_time - start_time
</code></pre>

<p>Of course this is almost always useless/meaningless, which is why there's no dedicated API for it.</p>
"
"<p>Depending on what you want to use this for, one possibility to think about is to sum the number of clock ticks consumed during blocking, which typically is slow enough hide a little overhead like that.  So from that sum and the surrounding thread interval you also measure, you can compute the real time load on your thread over that interval.  Of course, time-slicing with other processes will throw this off some amount, and capturing all blocking may be very easy or very hard, depending on your situation.</p>
"
"<p>I would recommend looking at Howard Hinnant's <a href=""https://github.com/HowardHinnant/date"" rel=""nofollow noreferrer"">date library</a>. One of the <a href=""https://github.com/HowardHinnant/date/wiki/Examples-and-Recipes#localtime"" rel=""nofollow noreferrer"">examples given in the wiki</a> shows how to get the current local time, up to the given precision of your <code>std::chrono::system_clock</code> implementation (nanoseconds on Linux, from memory?):</p>

<p>EDIT: As Howard points out in the comments, you can use <code>date::floor()</code> to obtain the desired precision. So to generate a string as requested in the question, you could do something like this:</p>

<pre><code>#include ""tz.h""
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

std::string current_time()
{
    const auto now_ms = date::floor&lt;std::chrono::milliseconds&gt;(std::chrono::system_clock::now());
    std::stringstream ss;
    ss &lt;&lt; date::make_zoned(date::current_zone(), now_ms);
    return ss.str();
}

int main()
{
    std::cout &lt;&lt; current_time() &lt;&lt; '\n';
}
</code></pre>
"
"<p>IMHO, the best way would be to store the date of last occurence of the other event and compare each in your dayly function. Or alternatively store directly the new date (old date + X days) and also test it directly. That way you would be immune to reboots, provided you test it also at boot time.</p>

<p>As an alternative if you must keep on processing a remaining number of days, you could check the last modification time of the file. A good hint for the number of days to remove would be the value of (last_time - current_time + 12 hours) / 24 hours. It should accept several days without activation and even several activations in few hours. But you should be very cautious on manual actions of that file, including for example a restore after a major incident, and ensure that the content of the file is coherent with its modification time. DRAGONS LIE THERE...</p>
"
"<p>You could create your own decorator like the following:</p>

<pre><code>#include&lt;functional&gt;
#include &lt;iostream&gt;

void count_time() {};
void count_X_metrics() {};

void decorator(std::function&lt;void()&gt; work)
{
    count_time();
    count_X_metrics();

    work();

    count_time();
    count_X_metrics();
}


void do_work_1() {
    std::cout &lt;&lt; ""Hello, World 1!"" &lt;&lt; std::endl;
}

void do_work_2() {
    std::cout &lt;&lt; ""Hello, World 2!"" &lt;&lt; std::endl;
}

int main() {
    decorator(do_work_1);
    decorator(do_work_2);
}
</code></pre>

<p>Edit: I'm not sure how your <code>count_time</code> and <code>count_X_metrics</code> functions work, but if you need something more complicated, or a way to keep track of state, you can create an object that will do that work for you. This is certainly different than you need, but hopefully it conveys the point I am trying to make:</p>

<pre><code>#include&lt;functional&gt;
#include &lt;iostream&gt;

int current_time() { return 0; }
int x_metric() { return 0; }

class Timer {
    public:
    void time(std::function&lt;void()&gt; work) {
        // Capture state before
        int starttime = current_time();
        int startmetric = x_metric();

        work();

        // Capture state after
        int endtime = current_time();
        int endmetric = x_metric();

        // Update results
        ellapsed = endtime - starttime;
        metric = endmetric - startmetric;

        // Possibly do something with the metrics here.
        // ...
    }

    int get_ellapsed() { return ellapsed; }
    int get_metric() { return metric; }

    private:
    int ellapsed;
    int metric;
};

void do_work_1() {
    std::cout &lt;&lt; ""Hello, World 1!"" &lt;&lt; std::endl;
}

void do_work_2() {
    std::cout &lt;&lt; ""Hello, World 2!"" &lt;&lt; std::endl;
}

int main() {
    Timer t;
    t.time(do_work_1);

    // Possibly do something with the metrics here.
    // cout &lt;&lt; t.get_ellapsed();

    t.time(do_work_2);
}
</code></pre>
"
"<p>I'm not an Arduino expert, but it seems to me that it would be possible (in fact, likely) for <code>rpmcount</code> to be sometimes greater than 1 when <code>loop()</code> is executed. The variable <code>rpmcount</code> is being incremented by means of an interrupt, and there doesn't appear to be any way of ensuring that loop is called once for each interrupt. In other words, what happens if there are multiple revolutions of the wheel in between calls to <code>loop()</code>?</p>

<p>This would be especially likely to cause the problem you are seeing if <code>loop()</code> in your full project has a lot of other tasks to perform and may explain why it sometimes works right at the start. </p>

<p>You should be able to fix the issue by just testing for <code>rpmcount &gt;= 1</code></p>
"
"<p>Other people have recommended that the if statement rpmcount == 1 be updated to rpmcount >= 1. I agree with them and here is why:</p>

<p>When the LCD code is added to your project it makes the loop() call take far longer than when it is not there. Since the loop call is taking so long the wheel is going to get around several times before the rpmcount = 0 code even gets a chance to run. Try removing the rpm code and putting millis() calls around the LCD code to see how long it takes to update the LCD. Then as a test replace the LCD update code with a delay of the measured interval.</p>

<pre><code>  unsigned long temp = millis();

  lcd.clear();
  lcd.begin(16,2);
  lcd.setCursor(0,0);
  lcd.print(""GS="");
  lcd.setCursor(3,0);
  lcd.print(groundspeed,1);
  lcd.print(""m/s"");
  lcd.setCursor(10,0);
  lcd.print(""D="");
  lcd.print(distance,0);
  lcd.print(""m"");

  Serial.println(millis()-temp); // println can take a while too,
                                 // so don't add to many in parts
                                 // of the code that are timing critical.
</code></pre>

<p>A couple of other points to note:</p>

<p>rpmcount is read before a value has been assigned to it. So it should be initialized to 0 in the setup function. </p>

<p>The same is true for fin_time, as good practice the code should initialize all of the global variables. </p>

<p>Uninitialized variables might cause of some of the undesired behavior... Sometimes.</p>
"
"<p><code>docker inspect</code> command output is not assigned to <code>time</code> variable. Try command substitution:</p>

<pre><code>#!/bin/bash

name=$1
matching=$(docker ps -a --filter=""name=$name"" -q | xargs)
current_time=$(date -u +""%Y-%m-%dT%T"")
echo Current time: ${current_time}

for i in $matching
do
    time=$(sudo docker inspect $i | grep -w ""StartedAt"" | awk '{gsub(/""/, """", $2); print $2 }' | head -n 1 | cut -c -19)
    echo ${time}
    echo $(date -d +""%Y-%m-%dT%H:%M:%S"" --date=""$time"")
done
</code></pre>
"
"<p>The function returns a pointer <code>text</code> which is freed once the function returns, hence it is undefined behavior. You can use malloc to allocate memory for it on the heap but you also need to free it.</p>

<pre><code>char* text;
text = (char*)malloc(text_size * sizeof(char));
</code></pre>

<p>or for C++,</p>

<pre><code>char* text = new char[text_size];
</code></pre>

<p>where <code>text_size</code> is the size of your string.</p>
"
"<p>I solved my issue. I ditched the CI Date Helper and opted for the default PHP one. It is much better than going through trial and error and always getting an offset that is way off the actual time.</p>

<p>@astound's answer also helped in this.</p>
"
"<p>Yes, implement a <a href=""http://en.cppreference.com/w/cpp/language/cast_operator"" rel=""nofollow noreferrer"">user-defined conversion operator</a>:</p>

<pre><code>class MyTime {
    // ...

    operator double() const;
};

MyTime::operator double() const {
    // compute and return a double
}
</code></pre>
"
"<p>One solution to be able to get the traffic light state from the Supervisor would be to set the state in the 'data' field of the Robot from the controller.</p>

<p>Then you will be able to read it from the Supervisor. Here is for example the modified version of 'generic_traffic_light.c' (I just added a few call to 'wb_robot_set_data'):</p>

<pre><code>#include &lt;webots/robot.h&gt;
#include &lt;webots/led.h&gt;

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define TIME_STEP 512
enum {GREEN_STATE, RED_STATE, ORANGE_STATE_TO_RED, ORANGE_STATE_TO_GREEN};

int main(int argc, char **argv) {
  wb_robot_init();
  double red_time = 20.0;
  double green_time = 20.0;
  double orange_time = 1.5;
  int current_state = GREEN_STATE;

  if (argc &gt; 1) {
    sscanf(argv[1],""%lf"",&amp;red_time);
    if (argc &gt; 2) {
      sscanf(argv[2],""%lf"",&amp;green_time);
      if (argc &gt; 3) {
        if (strcmp(argv[3], ""r"") == 0)
          current_state = RED_STATE;
        else if (strcmp(argv[3], ""g"") == 0)
          current_state = GREEN_STATE;
        else if (strcmp(argv[3], ""og"") == 0)
          current_state = ORANGE_STATE_TO_GREEN;
        else if (strcmp(argv[3], ""or"") == 0)
          current_state = ORANGE_STATE_TO_RED;
      }
    }
    else
      green_time = red_time;
  }

  WbDeviceTag red_light, orange_light, green_light;
  red_light = wb_robot_get_device(""red light"");
  orange_light = wb_robot_get_device(""orange light"");
  green_light = wb_robot_get_device(""green light"");
  double last_phase_change_time = 0.0;

  if (current_state == GREEN_STATE) {
    wb_led_set(green_light, 1);
    wb_robot_set_data(""green"");
  } else if (current_state == RED_STATE) {
    wb_led_set(red_light, 1);
    wb_robot_set_data(""red"");
  } else {
    wb_led_set(orange_light, 1);
    wb_robot_set_data(""orange"");
  }

  while (wb_robot_step(TIME_STEP) != -1) {
    double current_time =  wb_robot_get_time();

    if (current_state == GREEN_STATE) {
      if ((current_time - last_phase_change_time) &gt;=  green_time) {
        current_state = ORANGE_STATE_TO_RED;
        last_phase_change_time = current_time;
        wb_led_set(green_light, 0);
        wb_led_set(orange_light, 1);
        wb_robot_set_data(""orange"");
      }
    } else if (current_state == RED_STATE) {
      if ((current_time - last_phase_change_time) &gt;=  red_time) {
        current_state = ORANGE_STATE_TO_GREEN;
        last_phase_change_time = current_time;
        wb_led_set(red_light, 0);
        wb_led_set(orange_light, 1);
        wb_robot_set_data(""orange"");
      }
    } else if (current_state == ORANGE_STATE_TO_RED) {
      if ((current_time - last_phase_change_time) &gt;=  orange_time) {
        current_state = RED_STATE;
        last_phase_change_time = current_time;
        wb_led_set(orange_light, 0);
        wb_led_set(red_light, 1);
        wb_robot_set_data(""red"");
      }
    } else { //current_state == ORANGE_STATE_TO_GREEN
      if ((current_time - last_phase_change_time) &gt;=  orange_time) {
        current_state = GREEN_STATE;
        last_phase_change_time = current_time;
        wb_led_set(orange_light, 0);
        wb_led_set(green_light, 1);
        wb_robot_set_data(""green"");
      }
    }
  };

  wb_robot_cleanup();

  return 0;
}
</code></pre>

<p>Then you need to change the 'GenericTrafficLight' PROTO in order to render the 'data' field visible, here is a modified version:</p>

<pre><code>PROTO GenericTrafficLight [
  field SFVec3f    translation 0 0 0
  field SFRotation rotation    0 1 0 0
  field SFBool     startGreen  TRUE
  field SFFloat    greenTime   60
  field SFFloat    redTime     15
  field SFString   state       ""off""
]
{
%{
  local greenTime = fields.greenTime.value
  if greenTime &lt;= 0.0 then
    greenTime = fields.greenTime.defaultValue
    io.stderr:write(""'greenTime' should be strictly positive.\n"")
    io.stderr:write(""'greenTime' was reset to '"" .. greenTime .. ""'.\n"")
  end
  local redTime = fields.redTime.value
  if redTime &lt;= 0.0 then
    redTime = fields.redTime.defaultValue
    io.stderr:write(""'redTime' should be strictly positive.\n"")
    io.stderr:write(""'redTime' was reset to '"" .. redTime .. ""'.\n"")
  end
  local controllerArgs = '""' .. redTime .. ' ' .. greenTime .. ' '
  if fields.startGreen.value then
    controllerArgs = controllerArgs .. 'g'
  else
    controllerArgs = controllerArgs .. 'r'
  end
  controllerArgs = controllerArgs .. '""'
}%
  Robot {
    translation IS translation
    rotation IS rotation
    children [
      Pole {
        slot [
          TrafficLight {
            lamp_geometry TrafficLightStandardLampGeometry {
            }
          }
        ]
      }
    ]
    controller ""generic_traffic_light""
    controllerArgs %{= controllerArgs }%
    data IS state
  }
}
</code></pre>

<p>Sincerely,</p>

<p>David</p>
"
"<blockquote>
  <p>why gdb is not using the generated mycountertest.cc file</p>
</blockquote>

<p>Because it was told not to. In particular, this line:</p>

<pre><code>#line 17 ""mycountertest.cc.aal""
bool action1_guard(const std::string&amp; name) {
</code></pre>

<p>tells GCC to tell GDB that whatever code follows was generated from line 17 of <code>mycountertest.cc.aal</code>, so that's what GDB will show.</p>

<p>Usually that's exactly what one wants for generated code.</p>

<p>You can safely strip the <code>#line</code> directives from <code>mycountertest.cc</code> before compiling it, and then GDB will show you the generated source:</p>

<pre><code>fmbt-aalc mycountertest.cc.aal | sed -e '/^#line/d' &gt; mycountertest.cc
</code></pre>
"
"<p>The <code>AVCodecContext.pkt_timebase</code> and <code>AVCodecContext.time_base</code> is what you will need to keep the stream running smoothly. Each stream has its own <code>pkt_timebase</code>. When broadcasting, use one stream to sync to the system clock. Use the <code>AVPacket.pts</code> and FFMpegs function <code>av_q2d()</code> to convert the pts value to seconds as a double value.</p>

<pre><code>double time_base = av_q2d(ctx-&gt;pkt_timebase);
int64_t time_stamp = packet-&gt;pts;
double packet_time = time_base * time_stamp; // time stamp in seconds
</code></pre>

<p>From there sync the first streams packet to the system clock. The pauses between sending the following packets will be easier to handle.</p>

<p>The following function is nothing to do with streaming but does illustrate syncing with a system clock.</p>

<pre><code>FFVideoFrame *FFMpeg::getVideoFrame(double r_time) { // r_time is current system time
    FFVideoFrame *vframe = nullptr;

    double timestamp;
    double clock_current_time = r_time - sys_clock_start;
    double clock_current_frame = 0.0;

    mutex_vid_queues.lock();

    int vid_queue_size = vid_queue.size();

    if (playback_started) {
        if (vid_queue_size &gt; MAX_VID_OVERRUN) { // keep the buffer queues low
            playback_clock_start += 0.75;
            LOGD(""TIMESHIFT buffers over MAX_VID_OVERRUN"");
        } else if (vid_queue_size &lt; 20) {
            playback_clock_start -= 0.4; // resync
            LOGD(""TIMESHIFT buffers below 20"");
        }
    }

    if (!playback_started) {
        // queued video buffers need to be at least 1 second for network stream

        if (((vid_queue_size &gt; MIN_VID_FRAMES_START_NON_NETWORK &amp;&amp; !isNetworkStream)
                || (vid_queue_size &gt; MIN_VID_FRAMES_START &amp;&amp; isNetworkStream))
                ) {

            playback_started = true;

            vframe = vid_queue.front();
            vid_queue.pop_front();

            playback_clock_start = vframe-&gt;timestamp_f; // set stream start time from time stamp

            sys_clock_start = r_time; // set system start time from current time
        }
    } else {
        bool in_bounds = true;
        FFVideoFrame *frame_temp;
        int drop_count = 0;

        while (in_bounds) {
            if (vid_queue_size == 0) {
                in_bounds = false;
            } else {
                frame_temp = vid_queue.front();

                timestamp = frame_temp-&gt;timestamp_f;
                clock_current_frame = timestamp - playback_clock_start;

                if (clock_current_frame &gt; clock_current_time) {
                    in_bounds = false;
                } else {

                    // adds 0.xx of a second tolerance for video playback REMOVED FROM HERE
                    // this may get increased at some point

                    vid_queue.pop_front();
                    vid_queue_size--;

                    if (isNetworkStream
                        &amp;&amp; fabs(clock_current_time - clock_current_frame) &lt; 0.05) {
                        in_bounds = false;
                    }

                    if (vframe) {
                        vid_unused.push_back(vframe);
                        drop_count++;
                    }

                    vframe = frame_temp;
                }
            }
        }

        // if rendering takes too long then dropped frames will occur

        if (drop_count &gt; 0) LOGD(""Dumped %d video frames"", drop_count);
    }

    mutex_vid_queues.unlock();

    if (vframe) clock_last_frame = (int64_t)timestamp;

    return vframe;
}
</code></pre>
"
"<pre><code>while true; do
    sleep $(((RANDOM%25+5)*60))
    curl http://localhost:8080
done
</code></pre>
"
"<p>If you run above script, you must run as background process and make sure it will not be killed by something (OS, other users,...)</p>

<p>Another way is use cronjob to trigger automatically but the script is more complex.</p>

<p>Cronjob setting:</p>

<pre><code>* * * * * bash test_curl.sh &gt;&gt; log_file.log
</code></pre>

<p>Shell script test_curl.sh:</p>

<pre><code>#!/bin/bash

# Declare some variable
EXECUTE_TIME_FILE_PATH=""./execute_time""

# load expected execute time
EXPECTED_EXECUTE_TIME=$(cat $EXECUTE_TIME_FILE_PATH)

echo ""Start at $(date)""

# calculate current time and compare with expected execute time
CURRENT_MINUTE_OF_TIME=$(date +'%M')

if [[ ""$EXPECTED_EXECUTE_TIME"" == ""$CURRENT_MINUTE_OF_TIME""  ]];
then
  curl http://localhost:8080
  # Random new time from 5 -&gt; 30
  NEXT_RANDOM=$((RANDOM%25+5))
  # Get current time
  CURRENT_TIME=$(date +'%H:%M')
  # Calculate next expected execute time = Current Time + Next Random
  NEXT_EXPECTED_EXECUTE_TIME=$(date -d ""$CURRENT_TIME $NEXT_RANDOM minutes"" +'%M')
  # Save to file
  echo -n $NEXT_EXPECTED_EXECUTE_TIME &gt; $EXECUTE_TIME_FILE_PATH
  echo ""Next Executed time is $(date -d ""$CURRENT_TIME $NEXT_RANDOM minutes"" +'%H:%M')""
else
  echo ""This $(date +'%H:%M') is not expected time to run test""
fi

echo ""End at $(date)""
</code></pre>

<p>I commented out in line so you can read it easily.
**</p>

<blockquote>
  <p>Update: Importance: file execute_time must has initial value. For
  example, the current minute of first time you execute.</p>
</blockquote>

<p>**</p>
"
"<p>For data_collection you have to set <code>-DWITH_EXTENSION_LOGGING=ON</code> . </p>

<p>For esp8266 you have a different ""time.h"" library <code>/kaa/src/kaa/platform-impl/esp8266/platform</code> that doesn't support the function <code>time(NULL)</code>, but support </p>

<p><code>kaa_time_t kaa_esp8266_get_time(void);</code></p>
"
"<p>Calculate midnight on the system clock.</p>

<p>Get a time point for both the system clock, and the clock you want midnight on, at ""the same time"" (approx).  Call this time point X.</p>

<p>Convert the interval from midnight to X on system clock.  Convert to a duration in picoseconds (or whatever resolution).</p>

<p>You now have the time since midnight in picoseconds for time point X on the clock you want midnight on.</p>

<p>Note that this is going to be fundamentally approximate, because the ""time X"" is going to be a line apart for system clock and the clock you care about.  But it will only differ by about the time it takes to calculate a time stamp.  If you really care, you can do two system clock samples braketing the target clock and average the time since midnight.</p>
"
"<p>Your <code>processRequestsSecondArray()</code> function looks like it would do this once a second:</p>

<ol>
<li><p>Wake up from the <code>sleep_for()</code> call.</p></li>
<li><p>Set <code>currentRequestsASecond</code> to zero.</p></li>
<li><p>Return to the top of the <code>while</code> loop.</p></li>
<li><p>Possibly compute and print out an average from the array.</p></li>
<li><p>Store <code>currentRequestsASecond</code> in an element of <code>requestsASecondForAMinute</code>.</p></li>
<li><p>Call <code>sleep_for()</code> again.</p></li>
</ol>

<p>See the problem yet?</p>

<p>Any changes made to <code>currentRequestsASecond</code> during the <code>sleep_for()</code> time get wiped out and are never put in the array.  You would only get a value there if the increment was just lucky enough to happen to get a request and grab the mutex in the probably very short time <code>processRequestsSecondArray()</code> unlocks the mutex, checks the <code>getApplicationStatus()</code>, and immediately locks the mutex again.  It looks like you will need to rearrange some of that logic.</p>
"
"<p>Some pseudo-code to give you an idea of how it could be done:</p>

<pre><code>time_type last_time = now();  // Initialize to the current time

// Main game loop
forever
{
    // Do other game-related things...

    // Now handle things that should be done on regular intervals
    time_type current_time = now();
    time_diff_type difference = current_time - last_time;

    if (difference &gt; 2 second)
    {
        // Do things that should be done every two seconds
    }

    if (difference &gt; 1 second)
    {
        // Do things that should be done every second
    }

    last_time = current_time;
}
</code></pre>

<p>For the <code>time_type</code> and <code>now</code> functions, use the functionality in <a href=""http://en.cppreference.com/w/cpp/header/chrono"" rel=""nofollow noreferrer""><code>std::chrono</code></a>.</p>

<p>For example, to get the current time do e.g.</p>

<pre><code>auto current_time = std::chrono::system_clock::now();
</code></pre>

<p>And with a newer compiler and a <code>using namespace std::literals::chrono_literals;</code> you could actually use e.g. <code>1s</code> as a second:</p>

<pre><code>auto difference = current_time - last_time;
if (difference &gt; 1s) { /* Code here... */ }
</code></pre>

<p>The above is valid C++ code.</p>
"
"<p>thanks for your help. I just forgot to get mem for the blob-struct, so setting the data and size pointer inevitably killed it.</p>

<p>Here's the correct version, pumping 32K' worth of u32's from kernel to userspace. It builds with a 2.6.32.38 Kernel:</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/moduleparam.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/debugfs.h&gt;

#define SIZE 8192

MODULE_AUTHOR(""CREED0R"");
MODULE_LICENSE(""GPL"");

struct dentry *dfs;
struct debugfs_blob_wrapper *myblob;

u32 *stats; /* our blob of data */

int my_init(void)
{
    int i;
    int stats_size;   /* size of our data */
    int struct_size;  /* size of the blob struct */

    struct_size = sizeof(struct debugfs_blob_wrapper);
    stats_size  = SIZE * sizeof(u32);


    /* get mem for data */
    stats = kmalloc(stats_size, GFP_KERNEL);

    if (stats == NULL) {
        printk(""Could not allocate mem for data\n"");
        return -ENOMEM;
    }


    /* fill datablob with dummy data */
    for (i = 0; i &lt; SIZE; i++)
        stats[i] = i;


    /* get mem for blob struct and init */
    myblob = (struct debugfs_blob_wrapper *) kmalloc(struct_size, GFP_KERNEL);

    if (myblob == NULL) {
        printk(""Could not allocate mem for blob\n"");
        kfree(stats);
        return -ENOMEM;
    }


    /* only set data pointer and data size */
    myblob-&gt;data = (void *) stats;
    myblob-&gt;size = (unsigned long) stats_size;


    /* create pseudo file under /sys/kernel/debug/ with name 'test' */
    dfs = debugfs_create_blob(""test"", 0644, NULL, myblob);

    if (dfs == NULL) {
        printk(""Could not create debugfs blob\n"");
        kfree(stats);
        kfree(myblob);
        return -EINVAL;
    }

    printk(""DebugFS file created\n"");

    return 0;
}


void my_exit(void)
{
    printk(""DebugFS file deleted\n\n"");

    kfree(myblob);
    kfree(stats);

    debugfs_remove(dfs);
}


module_init(my_init);
module_exit(my_exit);
</code></pre>
"
"<p>You are missing a <code>.open</code> function pointer in your <code>file_operations</code> structure to specify the function to be called when a process attempts to open the device file.  You will need to specify a <code>.ioctl</code> function pointer for your ioctl function as well.</p>

<p>Try reading through <a href=""http://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html"" rel=""noreferrer"">The Linux Kernel Module Programming Guide</a>, specifically chapters 4 (Character Device Files) and 7 (Talking to Device Files).</p>

<p><a href=""http://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN567"" rel=""noreferrer"">Chapter 4</a> introduces the <code>file_operations</code> structure, which holds pointers to functions defined by the module/driver that perform various operations such as <code>open</code> or <code>ioctl</code>.</p>

<p><a href=""http://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN890"" rel=""noreferrer"">Chapter 7</a> provides information on communicating with a module/drive via ioctls.</p>

<p><a href=""http://lwn.net/Kernel/LDD3/"" rel=""noreferrer"">Linux Device Drivers, Third Edition</a> is another good resource.  </p>
"
"<p>The example code you need can be found in <code>drivers/watchdog/softdog.c</code> (from Linux 2.6.33 at the time this was written), which illustrates proper file operations as well as how to permit userland to fill a structure with ioctl().</p>

<p>It's actually a great, working tutorial for anyone who needs to write trivial character device drivers.</p>

<p>I dissected softdog's ioctl interface when <a href=""https://stackoverflow.com/questions/559808/linux-software-watchdog/559986#559986"">answering my own question</a>, which may be helpful to you.</p>

<p>Here's the gist of it (though far from exhaustive) ...</p>

<p>In <code>softdog_ioctl()</code> you see a simple initialization of struct watchdog_info that advertises functionality, version and device information:</p>

<pre><code>    static const struct watchdog_info ident = {
            .options =              WDIOF_SETTIMEOUT |
                                    WDIOF_KEEPALIVEPING |
                                    WDIOF_MAGICCLOSE,
            .firmware_version =     0,
            .identity =             ""Software Watchdog"",
    };
</code></pre>

<p>We then look at a simple case where the user just wants to obtain these capabilities:</p>

<pre><code>    switch (cmd) {
    case WDIOC_GETSUPPORT:
            return copy_to_user(argp, &amp;ident, sizeof(ident)) ? -EFAULT : 0;
</code></pre>

<p>... which of course, will fill the corresponding userspace watchdog_info with the initialized values above. If copy_to_user() fails, -EFAULT is returned which causes the corresponding userspace ioctl() call to return -1 with a meaningful errno being set.</p>

<p>Note, the magic requests are actually defined in linux/watchdog.h , so that the kernel and userspace share them:</p>

<pre><code>#define WDIOC_GETSUPPORT        _IOR(WATCHDOG_IOCTL_BASE, 0, struct watchdog_info)
#define WDIOC_GETSTATUS         _IOR(WATCHDOG_IOCTL_BASE, 1, int)
#define WDIOC_GETBOOTSTATUS     _IOR(WATCHDOG_IOCTL_BASE, 2, int)
#define WDIOC_GETTEMP           _IOR(WATCHDOG_IOCTL_BASE, 3, int)
#define WDIOC_SETOPTIONS        _IOR(WATCHDOG_IOCTL_BASE, 4, int)
#define WDIOC_KEEPALIVE         _IOR(WATCHDOG_IOCTL_BASE, 5, int)
#define WDIOC_SETTIMEOUT        _IOWR(WATCHDOG_IOCTL_BASE, 6, int)
#define WDIOC_GETTIMEOUT        _IOR(WATCHDOG_IOCTL_BASE, 7, int)
#define WDIOC_SETPRETIMEOUT     _IOWR(WATCHDOG_IOCTL_BASE, 8, int)
#define WDIOC_GETPRETIMEOUT     _IOR(WATCHDOG_IOCTL_BASE, 9, int)
#define WDIOC_GETTIMELEFT       _IOR(WATCHDOG_IOCTL_BASE, 10, int)
</code></pre>

<p>WDIOC obviously signifying ""Watchdog ioctl""</p>

<p>You can easily take that a step further, having your driver do something and place the result of that something in the structure and copy it to userspace. For instance, if struct watchdog_info also had a member <code>__u32 result_code</code>. Note, <code>__u32</code> is just the kernel's version of <code>uint32_t</code>.</p>

<p>With ioctl(), the user passes the address of an object, be it a structure, integer, whatever to the kernel expecting the kernel to write its reply in an identical object and copy the results to the address that was provided.</p>

<p>The second thing you are going to need to do is make sure your device knows what to do when someone opens, reads from it, writes to it, or uses a hook like ioctl(), which you can easily see by studying softdog.</p>

<p>Of interest is:</p>

<pre><code>static const struct file_operations softdog_fops = {
        .owner          = THIS_MODULE,
        .llseek         = no_llseek,
        .write          = softdog_write,
        .unlocked_ioctl = softdog_ioctl,
        .open           = softdog_open,
        .release        = softdog_release,
};
</code></pre>

<p>Where you see the unlocked_ioctl handler going to ... you guessed it, softdog_ioctl().</p>

<p>I think you might be juxtaposing a layer of complexity that really doesn't exist when dealing with ioctl(), it really is that simple. For that same reason, most kernel developers frown on new ioctl interfaces being added unless they are absolutely necessary. Its just too easy to lose track of the type that ioctl() is going to fill vs the magic you use to do it, which is the primary reason that copy_to_user() fails often resulting in the kernel rotting with hordes of userspace processes stuck in disk sleep.</p>

<p>For a timer, I agree, ioctl() is the shortest path to sanity.</p>
"
"<p><strong>Minimal runnable example</strong></p>

<p>Tested in a fully reproducible QEMU + Buildroot environment, so might help others get their <code>ioctl</code> working. GitHub upstream:
<a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/701230021d0a93169f348bf9ec3ef8bc1c2c8c3c/kernel_module/ioctl.c"" rel=""nofollow noreferrer"">kernel module</a> |
<a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/701230021d0a93169f348bf9ec3ef8bc1c2c8c3c/kernel_module/ioctl.h"" rel=""nofollow noreferrer"">shared header</a> |
<a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/701230021d0a93169f348bf9ec3ef8bc1c2c8c3c/kernel_module/user/ioctl.c"" rel=""nofollow noreferrer"">userland</a>.</p>

<p>The most annoying part was understanding that some low ids are hijacked: <a href=""https://stackoverflow.com/questions/10071296/ioctl-is-not-called-if-cmd-2"">ioctl is not called if cmd = 2</a> , you have to use <code>_IOx</code> macros.</p>

<p>Kernel module:</p>

<pre><code>#include &lt;asm/uaccess.h&gt; /* copy_from_user, copy_to_user */
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/printk.h&gt; /* printk */

#include ""ioctl.h""

MODULE_LICENSE(""GPL"");

static struct dentry *dir;

static long unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long argp)
{
    void __user *arg_user;
    union {
        int i;
        lkmc_ioctl_struct s;
    } arg_kernel;

    arg_user = (void __user *)argp;
    pr_info(""cmd = %x\n"", cmd);
    switch (cmd) {
        case LKMC_IOCTL_INC:
            if (copy_from_user(&amp;arg_kernel.i, arg_user, sizeof(arg_kernel.i))) {
                return -EFAULT;
            }
            pr_info(""0 arg = %d\n"", arg_kernel.i);
            arg_kernel.i += 1;
            if (copy_to_user(arg_user, &amp;arg_kernel.i, sizeof(arg_kernel.i))) {
                return -EFAULT;
            }
        break;
        case LKMC_IOCTL_INC_DEC:
            if (copy_from_user(&amp;arg_kernel.s, arg_user, sizeof(arg_kernel.s))) {
                return -EFAULT;
            }
            pr_info(""1 arg = %d %d\n"", arg_kernel.s.i, arg_kernel.s.j);
            arg_kernel.s.i += 1;
            arg_kernel.s.j -= 1;
            if (copy_to_user(arg_user, &amp;arg_kernel.s, sizeof(arg_kernel.s))) {
                return -EFAULT;
            }
        break;
        default:
            return -EINVAL;
        break;
    }
    return 0;
}

static const struct file_operations fops = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = unlocked_ioctl
};

static int myinit(void)
{
    dir = debugfs_create_dir(""lkmc_ioctl"", 0);
    /* ioctl permissions are not automatically restricted by rwx as for read / write,
     * but we could of course implement that ourselves:
     * https://stackoverflow.com/questions/29891803/user-permission-check-on-ioctl-command */
    debugfs_create_file(""f"", 0, dir, NULL, &amp;fops);
    return 0;
}

static void myexit(void)
{
    debugfs_remove_recursive(dir);
}

module_init(myinit)
module_exit(myexit)
</code></pre>

<p>Shared header:</p>

<pre><code>#ifndef IOCTL_H
#define IOCTL_H

#include &lt;linux/ioctl.h&gt;

typedef struct {
    int i;
    int j;
} lkmc_ioctl_struct;
#define LKMC_IOCTL_MAGIC 0x33
#define LKMC_IOCTL_INC     _IOWR(LKMC_IOCTL_MAGIC, 0, int)
#define LKMC_IOCTL_INC_DEC _IOWR(LKMC_IOCTL_MAGIC, 1, lkmc_ioctl_struct)

#endif
</code></pre>

<p>Userland:</p>

<pre><code>#define _GNU_SOURCE
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#include ""../ioctl.h""

int main(int argc, char **argv)
{
    int fd, arg_int, ret;
    lkmc_ioctl_struct arg_struct;

    if (argc &lt; 2) {
        puts(""Usage: ./prog &lt;ioctl-file&gt;"");
        return EXIT_FAILURE;
    }
    fd = open(argv[1], O_RDONLY);
    if (fd == -1) {
        perror(""open"");
        return EXIT_FAILURE;
    }
    /* 0 */
    {
        arg_int = 1;
        ret = ioctl(fd, LKMC_IOCTL_INC, &amp;arg_int);
        if (ret == -1) {
            perror(""ioctl"");
            return EXIT_FAILURE;
        }
        printf(""arg = %d\n"", arg_int);
        printf(""ret = %d\n"", ret);
        printf(""errno = %d\n"", errno);
    }
    puts("""");
    /* 1 */
    {
        arg_struct.i = 1;
        arg_struct.j = 1;
        ret = ioctl(fd, LKMC_IOCTL_INC_DEC, &amp;arg_struct);
        if (ret == -1) {
            perror(""ioctl"");
            return EXIT_FAILURE;
        }
        printf(""arg = %d %d\n"", arg_struct.i, arg_struct.j);
        printf(""ret = %d\n"", ret);
        printf(""errno = %d\n"", errno);
    }
    close(fd);
    return EXIT_SUCCESS;
}
</code></pre>
"
"<p>At least in some contexts, an anonymous inode is an inode without an attached directory entry.  The easiest way to create such an inode is as such:</p>

<pre><code>int fd = open( ""/tmp/file"", O_CREAT | O_RDWR, 0666 );
unlink( ""/tmp/file"" );
// Note that the descriptor fd now points to an inode that has no filesystem entry; you
// can still write to it, fstat() it, etc. but you can't find it in the filesystem.
</code></pre>
"
"<p><strong><code>open</code> with <code>O_TMPFILE</code></strong></p>

<p>This would be a good definition of anonymous inode: it creates an inode inside a given directory without any name, which does not appear at all with <code>ls</code>.</p>

<p>Then when you close the descriptor the file is deleted.</p>

<p>It was added in Linux 3.11.</p>

<pre><code>#define _GNU_SOURCE
#include &lt;assert.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

int main(void) {
    char buf[]  = { 'a', 'b', 'c', 'd' };
    char buf2[]  = { 'e', 'f', 'g', 'h' };
    int f, ret;
    size_t off;

    /* write */
    f = open(""."", O_TMPFILE | O_RDWR, S_IRUSR | S_IWUSR);
    ret = write(f, buf, sizeof(buf));

    /* Interactivelly check if anything changed on directory. It hasn't. */
    /*puts(""hit enter to continue"");*/
    /*getchar();*/

    /* read */
    lseek(f, 0, SEEK_SET);
    off = 0;
    while ((ret = read(f, buf2 + off, sizeof(buf) - off))) {
        off += ret;
    }
    close(f);
    assert(!memcmp(buf, buf2, sizeof(buf)));

    return EXIT_SUCCESS;
}
</code></pre>

<p>Tested in Ubuntu 17.04, Linux 4.10, glibc 2.24, run with:</p>

<pre><code>gcc -o a.out -std=c99 -Wall -Wextra a.c
./a.out
</code></pre>

<p><strong><code>anon_inode_getfd</code> Linux kernel function</strong></p>

<p>If you are dealing with kernel modules, this is a likely definition.</p>

<p>You call it like:</p>

<pre><code>fd = anon_inode_getfd(""random"", &amp;fops_anon, NULL, O_RDONLY | O_CLOEXEC);
</code></pre>

<p>and return <code>fd</code> to user, e.g. from an <code>ioctl</code>.</p>

<p>Now the user has an <code>fd</code> with associated arbitrary <code>file_operations</code> and <code>inode</code>, and when that <code>fd</code> is closed, everything is freed. </p>

<p>This method is useful e.g. if you want to have multiple <code>read</code> syscalls, but don't want to create multiple device files, which further pollutes <code>/dev</code>: you just create extra <code>ioctl</code>s instead.</p>

<p>Minimal runnable example with QEMU Buildroot:</p>

<ul>
<li><a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/de6c179fc0cf122789f0fe85cc69b847a1f4fe9c/kernel_module/anonymous_inode.c"" rel=""nofollow noreferrer"">https://github.com/cirosantilli/linux-kernel-module-cheat/blob/de6c179fc0cf122789f0fe85cc69b847a1f4fe9c/kernel_module/anonymous_inode.c</a></li>
<li><a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/de6c179fc0cf122789f0fe85cc69b847a1f4fe9c/rootfs_overlay/anonymous_inode.sh"" rel=""nofollow noreferrer"">https://github.com/cirosantilli/linux-kernel-module-cheat/blob/de6c179fc0cf122789f0fe85cc69b847a1f4fe9c/rootfs_overlay/anonymous_inode.sh</a></li>
</ul>



<pre><code>#include &lt;asm/uaccess.h&gt; /* copy_from_user, copy_to_user */
#include &lt;linux/anon_inodes.h&gt;
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/errno.h&gt; /* EFAULT */
#include &lt;linux/fs.h&gt;
#include &lt;linux/jiffies.h&gt;
#include &lt;linux/kernel.h&gt; /* min */
#include &lt;linux/module.h&gt;
#include &lt;linux/printk.h&gt; /* printk */

#include ""anonymous_inode.h""

MODULE_LICENSE(""GPL"");

static struct dentry *dir;

static ssize_t read(struct file *filp, char __user *buf, size_t len, loff_t *off)
{
    char kbuf[1024];
    size_t ret;

    ret = snprintf(kbuf, sizeof(kbuf), ""%llu"", (unsigned long long)jiffies);
    if (copy_to_user(buf, kbuf, ret)) {
        ret = -EFAULT;
    }
    return ret;
}

static const struct file_operations fops_anon = {
    .read = read,
};

static long unlocked_ioctl(struct file *filp, unsigned int cmd, unsigned long argp)
{
    int fd;

    switch (cmd) {
        case LKMC_ANONYMOUS_INODE_GET_FD:
            fd = anon_inode_getfd(
                ""random"",
                &amp;fops_anon,
                NULL,
                O_RDONLY | O_CLOEXEC
            );
            if (copy_to_user((void __user *)argp, &amp;fd, sizeof(fd))) {
                return -EFAULT;
            }
        break;
        default:
            return -EINVAL;
        break;
    }
    return 0;
}

static const struct file_operations fops_ioctl = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = unlocked_ioctl
};

static int myinit(void)
{
    dir = debugfs_create_dir(""lkmc_anonymous_inode"", 0);
    debugfs_create_file(""f"", 0, dir, NULL, &amp;fops_ioctl);
    return 0;
}

static void myexit(void)
{
    debugfs_remove_recursive(dir);
}

module_init(myinit)
module_exit(myexit)
</code></pre>
"
"<p>What if you manually insert module into kernel using insmod? Does it work? Any messages in dmesg? </p>

<p>As I remember entries in /dev (/dev/coin) should be created manually using mknod, but you need major number of registered device. Just printk it after register_chrdev().</p>
"
"<p>You must create debugfs files only in your own directory, and you already got that one's dentry when you called <code>debugfs_create_dir()</code>.</p>
"
"<blockquote>
  <p>One is the echo command would stuck if the length of input string is
  over the buffer size.</p>
</blockquote>

<p>This is because it keeps retrying to write to the file while each attempt would fail.</p>

<blockquote>
  <p>The other is the echo ""world"" >>
  /sys/kernel/debugfs/mydir/myfile never append the string. Instead, it
  new a string. </p>
</blockquote>

<p>this is expected with your implementation. you would need to cat the new one to the existing string if you want to have it appended. That is, you need to keep a record of the string length. But this is
different than the f_pos which is specific for a open file of a process. </p>

<blockquote>
  <p>How do I identify what commands(echo > or echo >>) users will use? </p>
</blockquote>

<p>so you mean whether or not the user 'truncates' the file after opening it?
 debugfs doesn't seem to support seek but i suppose you can provide your .open function and also the .llseek function to implement that. You need to see to the end of the file when opening the file if it is for APPEND. </p>

<p>Sorry I could not provide the complete code but just some pointers.</p>
"
"<p>You can find some good examples in kernel itself. Take a look at next files:</p>

<ul>
<li><a href=""http://lxr.free-electrons.com/source/drivers/char/rtc.c"" rel=""nofollow noreferrer"">drivers/char/rtc.c</a></li>
<li><a href=""http://lxr.free-electrons.com/source/fs/proc/kmsg.c"" rel=""nofollow noreferrer"">fs/proc/kmsg.c</a></li>
<li><a href=""http://lxr.free-electrons.com/source/drivers/char/random.c"" rel=""nofollow noreferrer"">drivers/char/random.c</a></li>
</ul>

<p>To add <code>poll()</code> function to your code follow next steps.</p>

<ol>
<li><p>Include needed headers:</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;linux/wait.h&gt;
#include &lt;linux/poll.h&gt;
</code></pre></li>
<li><p>Declare waitqueue variable:</p>

<pre class=""lang-c prettyprint-override""><code>static DECLARE_WAIT_QUEUE_HEAD(fortune_wait);
</code></pre></li>
<li><p>Add <code>fortune_poll()</code> function and add it (as <code>.poll</code> callback) to your file operations structure:</p>

<pre class=""lang-c prettyprint-override""><code>static unsigned int fortune_poll(struct file *file, poll_table *wait)
{
    poll_wait(file, &amp;fortune_wait, wait);
    if (new-data-is-ready)
        return POLLIN | POLLRDNORM;
    return 0;
}

static const struct file_operations proc_test_fops = {
    ....
    .poll = fortune_poll,
};
</code></pre>

<p>Note that you should return <code>POLLIN | POLLRDNORM</code> if you have some new data to read, and <code>0</code> in case there is no new data to read (<code>poll()</code> call timed-out). See <a href=""http://linux.die.net/man/2/poll"" rel=""nofollow noreferrer"">man 2 poll</a> for details.</p></li>
<li><p>Notify your waitqueue once you have new data:</p>

<pre class=""lang-c prettyprint-override""><code>wake_up_interruptible(&amp;fortune_wait);
</code></pre></li>
</ol>

<p>That's the basic stuff about implementing <code>poll()</code> operation. Depending on your task, you may be needed to use some <a href=""http://www.makelinux.net/ldd3/chp-6-sect-2"" rel=""nofollow noreferrer"">waitqueue API</a> in your <code>.read</code> function (like <code>wait_event_interruptible()</code>).</p>

<hr>

<p>See also related question: <a href=""https://stackoverflow.com/questions/34027366/implementing-poll-in-a-linux-kernel-module"">Implementing poll in a Linux kernel module</a>.</p>
"
"<p><strong>Minimal runnable example</strong></p>

<p>Usage:</p>

<pre><code>insmod /poll.ko
mount -t debugfs none /sys/kernel/debug
/poll.out /sys/kernel/debug/lkmc_poll/f
</code></pre>

<p>Outcome: every one second, the following is printed to screen:</p>

<pre><code>loop
POLLIN n=10 buf=&lt;jiffies&gt;
</code></pre>

<p>GitHub upstream with QEMU + Buildroot boilerplate: <a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/f5130eeb5f8f9feee15cc2ca095ae4d2cdb108e7/kernel_module/poll.c"" rel=""nofollow noreferrer"">poll.ko</a>, <a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/f5130eeb5f8f9feee15cc2ca095ae4d2cdb108e7/kernel_module/user/poll.c"" rel=""nofollow noreferrer"">poll.out</a></p>

<p>In this simplified example, we generate poll events from a separate thread. In real life, poll events will likely be triggered by interrupts, when the hardware has finished some job, and new data became available for userland to read.</p>

<p>poll.ko:</p>

<pre><code>#include &lt;asm/uaccess.h&gt; /* copy_from_user, copy_to_user */
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/delay.h&gt; /* usleep_range */
#include &lt;linux/errno.h&gt; /* EFAULT */
#include &lt;linux/fs.h&gt;
#include &lt;linux/jiffies.h&gt;
#include &lt;linux/kernel.h&gt; /* min */
#include &lt;linux/kthread.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/poll.h&gt;
#include &lt;linux/printk.h&gt; /* printk */
#include &lt;linux/wait.h&gt; /* wait_queue_head_t, wait_event_interruptible, wake_up_interruptible  */
#include &lt;uapi/linux/stat.h&gt; /* S_IRUSR */

MODULE_LICENSE(""GPL"");

static char readbuf[1024];
static size_t readbuflen;
static struct dentry *dir;
static struct task_struct *kthread;
static wait_queue_head_t waitqueue;

static ssize_t read(struct file *filp, char __user *buf, size_t len, loff_t *off)
{
    ssize_t ret;
    if (copy_to_user(buf, readbuf, readbuflen)) {
        ret = -EFAULT;
    } else {
        ret = readbuflen;
    }
    /* This is normal pipe behaviour: data gets drained once a reader reads from it. */
    /* https://stackoverflow.com/questions/1634580/named-pipes-fifos-on-unix-with-multiple-readers */
    readbuflen = 0;
    return ret;
}

/*
If you return 0 here, then the kernel will sleep until an event happens in the queue.

This gets called again every time an event happens in the wait queue.
*/
unsigned int poll(struct file *filp, struct poll_table_struct *wait)
{
    poll_wait(filp, &amp;waitqueue, wait);
    if (readbuflen)
        return POLLIN;
    else
        return 0;
}

static int kthread_func(void *data)
{
    while (!kthread_should_stop()) {
        readbuflen = snprintf(readbuf, sizeof(readbuf), ""%llu"", (unsigned long long)jiffies);
        usleep_range(1000000, 1000001);
        wake_up(&amp;waitqueue);
    }
    return 0;
}

static const struct file_operations fops = {
    .owner = THIS_MODULE,
    .read = read,
    .poll = poll
};

static int myinit(void)
{
    dir = debugfs_create_dir(""lkmc_poll"", 0);
    debugfs_create_file(""f"", S_IRUSR | S_IWUSR, dir, NULL, &amp;fops);
    init_waitqueue_head(&amp;waitqueue);
    kthread = kthread_create(kthread_func, NULL, ""mykthread"");
    wake_up_process(kthread);
    return 0;
}

static void myexit(void)
{
    kthread_stop(kthread);
    debugfs_remove_recursive(dir);
}

module_init(myinit)
module_exit(myexit)
</code></pre>

<p>poll.out userland:</p>

<pre><code>#define _XOPEN_SOURCE 700
#include &lt;fcntl.h&gt; /* creat, O_CREAT */
#include &lt;poll.h&gt; /* poll */
#include &lt;stdio.h&gt; /* printf, puts, snprintf */
#include &lt;stdlib.h&gt; /* EXIT_FAILURE, EXIT_SUCCESS */
#include &lt;unistd.h&gt; /* read */

int main(int argc, char **argv) {
    char buf[1024], path[1024];
    int fd, i, n;
    short revents;
    struct pollfd pfd;

    fd = open(argv[1], O_RDONLY | O_NONBLOCK);
    if (fd == -1) {
        perror(""open"");
        exit(EXIT_FAILURE);
    }
    pfd.fd = fd;
    pfd.events = POLLIN;
    while (1) {
        puts(""loop"");
        i = poll(&amp;pfd, 1, -1);
        if (i == -1) {
            perror(""poll"");
            exit(EXIT_FAILURE);
        }
        revents = pfd.revents;
        if (revents &amp; POLLIN) {
            n = read(pfd.fd, buf, sizeof(buf));
            printf(""POLLIN n=%d buf=%.*s\n"", n, n, buf);
        }
    }
}
</code></pre>
"
"<p>Yeah. That advice makes no sense. If CONFIG_DEBUG_FS is not enabled, the value -ENODEV is returned (cast to a pointer). That is clearly not NULL, but also not usable as a valid pointer.</p>

<p>Better would be to instead use IS_ERR_OR_NULL(ptr) on the return value. If CONFIG_DEBUG_FS is not defined, this will catch -ENODEV return. If CONFIG_DEBUG_FS <em>is</em> defined, but the call fails, NULL is returned. This way handles either possibility.</p>
"
"<p>One may interpret -ENODEV as success, until doing with dentry returned something except deleting it(<em>debugfs_remove</em>) and using it as a directory for another file(<em>debugfs_create_</em>-family). All these functions process case, when CONFIG_DEBUG_FS is disabled, correctly.</p>

<p>That's why it is sufficient only for check NULL or !NULL.</p>

<p>In rare cases, when dentry returned by debugfs_create_*() is referred explicitely(e.g, for access inode's private data), it is sufficient to check, that only the first such call doesn't return -ENODEV.</p>
"
"<p>You asked:
<em>""Could you give me any examples about eliminate the need for #ifdef in the calling code?""</em></p>

<p>Well one way to write your code is:</p>

<pre><code>#ifdef CONFIG_DEBUG_FS
  &lt; ... do your debugfs stuff ... &gt;
#endif
</code></pre>

<p>I would guess that that's what the documentation meant.</p>

<p>Many kernel devs consider putting too many <code>#ifdef - #endif</code> pairs in the code to be ugly (""hairy""). <a href=""https://www.kernel.org/doc/Documentation/CodingStyle"" rel=""nofollow"">See this kernel doc</a>. </p>

<p>Relevant snippet from the kernel Coding Style doc:
""Prefer to compile out entire functions, rather than portions of functions or
portions of expressions.  Rather than putting an ifdef in an expression, factor
out part or all of the expression into a separate helper function and apply the
conditional to that function.""</p>

<p>Given that, following it's advice, if you would prefer <em>not</em> to use the #ifdef , then pl go with the answers already posted.</p>
"
"<p>In your code you have two <code>dentry</code>. One that create the directory in <code>/sys/kernel/debug/</code></p>

<pre><code>pDebugfs = debugfs_create_dir(name, NULL);
</code></pre>

<p>and, you are not storing it but it is there, one that create the file you <code>open(2)</code>:</p>

<pre><code>pDebugfs_file = debugfs_create_file(""testFile"", MODE_T, pDebugfs, NULL,  &amp;debugfs_fops)
</code></pre>

<p>The <code>inode</code> you see in <code>debugfs_open</code> is the one associated to the file
and not to the directory.</p>
"
"<p>I'd say the best reference for what you need to do would be the <a href=""https://www.kernel.org/doc/Documentation/filesystems/debugfs.txt"" rel=""nofollow noreferrer"">debugfs.txt</a> documentation file within the kernel source tree.</p>

<p>I also assume you made a mistake in your code sample here:</p>

<pre><code>struct dentry* log_file = debugfs_create_dir (""log"", 0777, log_dir, NULL, NULL);
</code></pre>

<p>Since it looks like you're trying to create a file, not another directory.
So I guess what you wanted to do is more like this:</p>

<pre><code>struct dentry* log_file = debugfs_create_file(""log"", 0777, log_dir, NULL, &amp;log_fops);
</code></pre>

<p>where log_fops would maybe be something like this:</p>

<pre><code>static const struct file_operations log_fops = {
    .owner  =   THIS_MODULE,
    .read   =   log_read,
    .write  =   log_write, /* maybe you don't need this */
};
</code></pre>

<p>And, of course you'd also need to implement your log_read and log_write functions:</p>

<pre><code>ssize_t log_read(struct file *file, char __user *buff, size_t count, loff_t *offset);

ssize_t log_write(struct file *file, const char __user *buff, size_t count, loff_t *offset);
</code></pre>
"
"<p>You might consider <code>printk(KERN_ALERT ""Something else happened\n"")</code> in the case that file1 is not equal to <code>NULL</code> or <code>-ENODEV</code>.  That may provide some interesting results.  Maybe:</p>

<pre><code>if (file1 == NULL)
    printk(KERN_ALERT ""Error occurred\n"");
else if (file1 == -ENODEV)
    printk(KERN_ALERT ""ENODEV occurred\n"");
else
    printk(KERN_ALERT ""Something else occurred\n"");
</code></pre>

<p>I'm not familiar with kernel programming libraries as much, but if there is a similar va_args interface to printk(), you could probably print the value of file1.</p>

<p>Now looking at this though, is there some kind of kernel <code>errno</code>?  Or is that what debugfs_create_file() returns?</p>

<p><strong>UPDATE</strong>:</p>

<p>The only help I can give now is to somehow discover what file1's value is and investigate what that means.  You may want to do some poking around for an <code>errno</code> equivalent and see if its set.  Equivalent to the <code>perror()</code> call in the kernel basically.</p>
"
"<p>For debugfs to work, you actually have to have a debugfs mountpoint:</p>

<pre><code>mount -t debugfs none /sys/kernel/debug
</code></pre>

<p>Not sure if that's what the problem is here, but may be you can check if you have a mounted debugfs
on /sys/kernel/debug</p>
"
"<p>Didn't you hear, ""777 is almost always wrong"" :-)  <code>MAY_*</code> and <code>FMODE_*</code> are not file modes either, but internal flags and file states.</p>

<p>Better:</p>

<pre><code>debugfs_create_file(..., S_ISREG | S_IRUGO | S_IWUSR, ...);
</code></pre>
"
"<p>For a world readable file, use <code>S_IRUGO</code></p>

<pre><code>validation@tb04:~&gt; ls -l /sys/kernel/debug/spc0/registers
-r--r--r-- 1 root root 0 Feb 14  2011 /sys/kernel/debug/spc0/registers
</code></pre>

<p>Internally, this sets <code>S_IRUSR|S_IRGRP|S_IROTH</code> which set read mode for the user, group, and others. See <code>include/stat.h</code> in the kernel for other macro definitions.</p>
"
"<p>Look into code you have given, it seems that you want to handle <code>SIGIO</code> signal</p>

<p>Here is my attempt to solve your problem, </p>

<p><code>signal_kernel.c</code> file : </p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;asm/siginfo.h&gt;
#include &lt;linux/rcupdate.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/signal.h&gt;
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/pid.h&gt;

#define MAX 10

MODULE_LICENSE(""GPL"");

struct dentry *file;

static ssize_t write_conf_pid(struct file *file, const char *buf,
            size_t count, loff_t *position)
{
    char temp_str[MAX];
    int ret;
    int pid = 0;
    struct siginfo sinfo;
    struct task_struct *task;

    /* NEVER TRUST USER INPUT */
    if (count &gt; MAX)
        return -EINVAL;

    if (copy_from_user(temp_str, buf, MAX) != 0)
        return -EFAULT;

    ret = sscanf(temp_str, ""%d"", &amp;pid);
    if (ret != 1) {
        pr_info(""Error in reading PID value from user"");
        return -EINVAL;
    }

    pr_info(""User entered pid %d\n"", pid);
    memset(&amp;sinfo, 0, sizeof(struct siginfo));
    sinfo.si_signo = SIGIO;
    sinfo.si_code = SI_USER;
    task = pid_task(find_vpid(pid), PIDTYPE_PID);
    if (task == NULL) {
        pr_info(""Cannot find PID from user program\r\n"");
        return -ENODEV;
    }
    ret = send_sig_info(SIGIO, &amp;sinfo, task);
    if (ret &lt; 0)
        pr_info(""Error sending signal\n"");
    return count;
}

static const struct file_operations my_fops = {
    .write = write_conf_pid,
};

int init_module()
{
    /* Only root can write to this file */
    file = debugfs_create_file(""pidconf"", 0200, NULL, NULL, &amp;my_fops);
    return 0;
}

void cleanup_module()
{
    pr_info(""\nGoodBye World\n\n"");
}
</code></pre>

<p><code>signal_user.c</code> file :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;

void signal_handler(int signum)
{
    if (signum == SIGIO)
        printf(""SIGIO\r\n"");
    return;
}

int main()
{
    int i = 1;
    signal(SIGIO, signal_handler);
    printf(""My PID is %d.\n"", getpid());
    while (i);
    return 0;
}
</code></pre>

<p>After compiling and running both user space and kernel space program, use <code>debugfs</code> interface to send PID value to Kernel space, </p>

<pre><code>$ insmod signal_kernel.ko
$ ./signal_user
My PID is 17633.

... # Process will run in loop due to while(1)
</code></pre>

<p>From another terminal, provide PID to <code>debugfs</code> interface, </p>

<pre><code>$ echo 17633 &gt; /sys/kernel/debug/pidconf
</code></pre>

<p>There are various ways (<code>sysfs</code>, <code>misc_char_device</code>, <code>char device</code> etc.) to this task, but this will give you brief idea about using <code>copy_from_user()</code> and <code>copy_to_user()</code></p>

<p>Please note that there is little error handling done in <code>signal_user.c</code> and <code>signal_kernel.c</code>.</p>
"
"<p>You can take a look at how kmemleak uses debugfs in mm/kmemleak.c:</p>

<pre><code>static const struct seq_operations kmemleak_seq_ops = {
        .start = kmemleak_seq_start,
        .next  = kmemleak_seq_next,
        .stop  = kmemleak_seq_stop,
        .show  = kmemleak_seq_show,
};

static int kmemleak_open(struct inode *inode, struct file *file)
{
        return seq_open(file, &amp;kmemleak_seq_ops);
}

static int kmemleak_release(struct inode *inode, struct file *file)
{
        return seq_release(inode, file);
}

static ssize_t kmemleak_write(struct file *file, const char __user *user_buf,
                              size_t size, loff_t *ppos)
{...}

static const struct file_operations kmemleak_fops = {
        .owner          = THIS_MODULE,
        .open           = kmemleak_open,
        .read           = seq_read,
        .write          = kmemleak_write,
        .llseek         = seq_lseek,
        .release        = kmemleak_release,
};


dentry = debugfs_create_file(""kmemleak"", S_IRUGO, NULL, NULL,
                             &amp;kmemleak_fops);
</code></pre>
"
"<p>This question is the top search result in Google for mmap debugfs. I am adding here an important information. According to this <a href=""https://lkml.org/lkml/2016/5/21/73"" rel=""nofollow noreferrer"">https://lkml.org/lkml/2016/5/21/73</a> post debugfs_create_file() in the kernel 4.8.0 or higher will ignore .mmap field in the struct file_operations </p>

<p>Use debugfs_create_file_unsafe() as a workaround </p>
"
"<p>First start by writing a generic kernel module. There are multiple places to look up for information but I found <a href=""http://www.tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN121"" rel=""noreferrer"">this link</a> to be very useful. After you have gone through all examples specified there you can start writing your own Linux Driver Module. </p>

<p>Please note, that you will not get away with just copy-pasting the example code and hope it will work, no. Kernel API can sometimes change and examples will not work. Examples provided there should be looked at as a guide how to do something. Depending on the kernel version you are using you have to modify the example in order to work.</p>

<p>Consider using TI platform provided functions as much as you can, because that can really do a lot work for you, like requesting and enabling needed clocks, buses and power supplies. If I recall correctly you can use the functions to acquire memory mapped address ranges for direct access to registers. I have to mention that I have bad experience with TI provided functions because they do not properly release/clean-up all acquired resources, so for some resources I had to call other kernel services to release them during module unload.</p>

<p><strong>Edit 1:</strong></p>

<p>I'm not entirely familiar with Linux SPI implementation but I would start by looking at omap2_mcspi_probe() function in drivers/spi/spi-omap2-mcspi.c file. As you can see there, it registers it's methods to Linux master SPI driver using this API: Linux/include/linux/spi/spi.h. In contrast to char driver the main functions here are *_transfer() functions. Look up at the struct descriptions in spi.h file for further details. Also, have a look at <a href=""https://www.kernel.org/doc/Documentation/spi/spidev"" rel=""noreferrer"">this</a> alternative device driver API, too.</p>
"
"<p>I assume your OMAP4 linux uses one of <code>arch/arm/boot/dts/{omap4.dtsi,am33xx.dtsi}</code> device-tree, thus it compiles <code>drivers/spi/spi-omap2-mcspi.c</code> (if you don't know about device-tree, <a href=""https://stackoverflow.com/questions/22202648/device-tree-driven-kernel-for-raspberry-pi/24048326#24048326"">read this</a>). Then:</p>

<ul>
<li>the SPI master driver is done,</li>
<li>it (most probably) registers with Linux SPI core framework <code>drivers/spi/spi.c</code>,</li>
<li>it (probably) works fine on your OMAP4.</li>
</ul>

<p>You actually don't need to care about the <em>master driver</em> to write your <em>slave device driver</em>. How do I know <code>spi-omap2-mcspi.c</code> is a master driver? It calls <code>spi_register_master()</code>.</p>

<h2>SPI master, SPI slave ?</h2>

<p>Please refer to <code>Documentation/spi/spi_summary</code>. The doc refers to <em>Controller driver</em> (master) and <em>Protocol drivers</em> (slave). From your description, I understand you want to write a <em>Protocol/Device driver</em>.</p>

<h2>SPI protocol ?</h2>

<p>To understand that, you need your slave device datasheet, it shall tell you:</p>

<ul>
<li>the <strong>SPI mode</strong> understood by your device,</li>
<li>the <strong>protocol</strong> it expects on the bus.</li>
</ul>

<p>Contrary to i2c, SPI does not define a protocol or handshake, SPI chips manufacturers have to define their own. So check the datasheet.</p>

<h2>SPI mode</h2>

<p>From <code>include/linux/spi/spi.h</code>:</p>

<pre>
 * @mode: The spi mode defines how data is clocked out and in.
 *  This may be changed by the device's driver.
 *  The ""active low"" default for chipselect mode can be overridden
 *  (by specifying SPI_CS_HIGH) as can the ""MSB first"" default for
 *  each word in a transfer (by specifying SPI_LSB_FIRST).
</pre>

<p>Again, check your SPI device datasheet.</p>

<h2>An example SPI device driver?</h2>

<p>To give you a relevant example, I need to know your SPI device type. You would understand that a <strong>SPI flash device driver</strong> is different from a <strong>SPI FPGA device driver</strong>. Unfortunately there are not so many SPI device drivers out there. To find them:</p>

<pre><code>$ cd linux
$ git grep ""spi_new_device\|spi_add_device""
</code></pre>
"
"<p>I don't know if I understood your question correctly. As m-ric pointed out, there are master drivers and slave drivers.</p>

<p>Usually master drivers are more hardware bound, I mean, they usually manipulate IO registers or do some memory mapped IO.</p>

<p>For some architectures already supported by linux kernel (like omap3 and omap4) master drivers are already implemented (McSPI).</p>

<p>So I assume you want to USE those SPI facilities of omap4 to implement a slave device driver (your protocol, to communicate with your external device through SPI).</p>

<p>I've written the following example for BeagleBoard-xM (omap3). The full code is at <a href=""https://github.com/rslemos/itrigue/blob/master/alsadriver/itrigue.c"" rel=""noreferrer"">https://github.com/rslemos/itrigue/blob/master/alsadriver/itrigue.c</a> (worth a view, but have more initialisation code, for ALSA, GPIO, module parameters). I've tried to set apart code that deals with SPI (maybe I forgot something, but anyway you should get the idea):</p>

<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/spi/spi.h&gt;

/* MODULE PARAMETERS */
static uint spi_bus = 4;
static uint spi_cs = 0;
static uint spi_speed_hz = 1500000;
static uint spi_bits_per_word = 16;

/* THIS IS WHERE YOUR DEVICE IS CREATED; THROUGH THIS YOU INTERACT WITH YOUR EXTERNAL DEVICE */
static struct spi_device *spi_device;


/* SETUP SPI */

static inline __init int spi_init(void) {
    struct spi_board_info spi_device_info = {
        .modalias = ""module name"",
        .max_speed_hz = spi_speed_hz,
        .bus_num = spi_bus,
        .chip_select = spi_cs,
        .mode = 0,
    };

    struct spi_master *master;

    int ret;

    // get the master device, given SPI the bus number
    master = spi_busnum_to_master( spi_device_info.bus_num );
    if( !master )
        return -ENODEV;

    // create a new slave device, given the master and device info
    spi_device = spi_new_device( master, &amp;spi_device_info );
    if( !spi_device )
        return -ENODEV;

    spi_device-&gt;bits_per_word = spi_bits_per_word;

    ret = spi_setup( spi_device );
    if( ret )
        spi_unregister_device( spi_device );

    return ret;
}

static inline void spi_exit(void) {
    spi_unregister_device( spi_device );
}
</code></pre>

<p>To write data to your device:</p>

<pre><code>spi_write( spi_device, &amp;write_data, sizeof write_data );
</code></pre>

<p>The above code is independent of implementation, that is, it could use McSPI, bit-banged GPIO, or any other implementation of an SPI master device. This interface is described in <code>linux/spi/spi.h</code></p>

<p>To make it work in BeagleBoard-XM I had to add the following to the kernel command line:</p>

<pre><code>omap_mux=mcbsp1_clkr.mcspi4_clk=0x0000,mcbsp1_dx.mcspi4_simo=0x0000,mcbsp1_dr.mcspi4_somi=0x0118,mcbsp1_fsx.mcspi4_cs0=0x0000
</code></pre>

<p>So that an McSPI master device is created for omap3 McSPI4 hardware facility.</p>

<p>Hope that helps.</p>
"
"<p><strong>Minimal runnable <code>file_operations</code> example</strong></p>

<p>This example does not interact with any hardware, but it illustrates the simpler <code>file_operations</code> kernel API with debugfs.</p>

<p>Kernel module <a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/68af3477cce1cd22566edce2651f54cf8c184a91/kernel_module/fops.c"" rel=""nofollow noreferrer"">fops.c</a>:</p>

<pre><code>#include &lt;asm/uaccess.h&gt; /* copy_from_user, copy_to_user */
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/errno.h&gt; /* EFAULT */
#include &lt;linux/fs.h&gt; /* file_operations */
#include &lt;linux/kernel.h&gt; /* min */
#include &lt;linux/module.h&gt;
#include &lt;linux/printk.h&gt; /* printk */
#include &lt;uapi/linux/stat.h&gt; /* S_IRUSR */

static struct dentry *debugfs_file;
static char data[] = {'a', 'b', 'c', 'd'};

static int open(struct inode *inode, struct file *filp)
{
    pr_info(""open\n"");
    return 0;
}

/* @param[in,out] off: gives the initial position into the buffer.
 *      We must increment this by the ammount of bytes read.
 *      Then when userland reads the same file descriptor again,
 *      we start from that point instead.
 * */
static ssize_t read(struct file *filp, char __user *buf, size_t len, loff_t *off)
{
    ssize_t ret;

    pr_info(""read\n"");
    pr_info(""len = %zu\n"", len);
    pr_info(""off = %lld\n"", (long long)*off);
    if (sizeof(data) &lt;= *off) {
        ret = 0;
    } else {
        ret = min(len, sizeof(data) - (size_t)*off);
        if (copy_to_user(buf, data + *off, ret)) {
            ret = -EFAULT;
        } else {
            *off += ret;
        }
    }
    pr_info(""buf = %.*s\n"", (int)len, buf);
    pr_info(""ret = %lld\n"", (long long)ret);
    return ret;
}

/* Similar to read, but with one notable difference:
 * we must return ENOSPC if the user tries to write more
 * than the size of our buffer. Otherwise, Bash &gt; just
 * keeps trying to write to it infinitely. */
static ssize_t write(struct file *filp, const char __user *buf, size_t len, loff_t *off)
{
    ssize_t ret;

    pr_info(""write\n"");
    pr_info(""len = %zu\n"", len);
    pr_info(""off = %lld\n"", (long long)*off);
    if (sizeof(data) &lt;= *off) {
        ret = 0;
    } else {
        if (sizeof(data) - (size_t)*off &lt; len) {
            ret = -ENOSPC;
        } else {
            if (copy_from_user(data + *off, buf, len)) {
                ret = -EFAULT;
            } else {
                ret = len;
                pr_info(""buf = %.*s\n"", (int)len, data + *off);
                *off += ret;
            }
        }
    }
    pr_info(""ret = %lld\n"", (long long)ret);
    return ret;
}

/*
Called on the last close:
http://stackoverflow.com/questions/11393674/why-is-the-close-function-is-called-release-in-struct-file-operations-in-the-l
*/
static int release(struct inode *inode, struct file *filp)
{
    pr_info(""release\n"");
    return 0;
}

static loff_t llseek(struct file *filp, loff_t off, int whence)
{
    loff_t newpos;

    pr_info(""llseek\n"");
    pr_info(""off = %lld\n"", (long long)off);
    pr_info(""whence = %lld\n"", (long long)whence);
    switch(whence) {
        case SEEK_SET:
            newpos = off;
            break;
        case SEEK_CUR:
            newpos = filp-&gt;f_pos + off;
            break;
        case SEEK_END:
            newpos = sizeof(data) + off;
            break;
        default:
            return -EINVAL;
    }
    if (newpos &lt; 0) return -EINVAL;
    filp-&gt;f_pos = newpos;
    pr_info(""newpos = %lld\n"", (long long)newpos);
    return newpos;
}

static const struct file_operations fops = {
    /* Prevents rmmod while fops are running.
     * Try removing this for poll, which waits a lot. */
    .owner = THIS_MODULE,
    .llseek = llseek,
    .open = open,
    .read = read,
    .release = release,
    .write = write,
};

static int myinit(void)
{
    debugfs_file = debugfs_create_file(""lkmc_fops"", S_IRUSR | S_IWUSR, NULL, NULL, &amp;fops);
    return 0;
}

static void myexit(void)
{
    debugfs_remove_recursive(debugfs_file);
}

module_init(myinit)
module_exit(myexit)
MODULE_LICENSE(""GPL"");
</code></pre>

<p><a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/68af3477cce1cd22566edce2651f54cf8c184a91/rootfs_overlay/fops.sh"" rel=""nofollow noreferrer"">Userland shell test program</a>:</p>

<pre><code>#!/bin/sh

mount -t debugfs none /sys/kernel/debug

insmod /fops.ko
cd /sys/kernel/debug/lkmc_fops

## Basic read.
cat f
# =&gt; abcd
# dmesg =&gt; open
# dmesg =&gt; read
# dmesg =&gt; len = [0-9]+
# dmesg =&gt; close

## Basic write

printf '01' &gt;f
# dmesg =&gt; open
# dmesg =&gt; write
# dmesg =&gt; len = 1
# dmesg =&gt; buf = a
# dmesg =&gt; close

cat f
# =&gt; 01cd
# dmesg =&gt; open
# dmesg =&gt; read
# dmesg =&gt; len = [0-9]+
# dmesg =&gt; close

## ENOSPC
printf '1234' &gt;f
printf '12345' &gt;f
echo ""$?""
# =&gt; 8
cat f
# =&gt; 1234

## seek
printf '1234' &gt;f
printf 'z' | dd bs=1 of=f seek=2
cat f
# =&gt; 12z4
</code></pre>

<p>You should also write a C program that runs those tests if it is not clear to you what system calls are being called for each of those commands. (or you could also use <code>strace</code> and find out :-)).</p>

<p>The other <code>file_operations</code> are a bit more involved, here are some further examples:</p>

<ul>
<li><a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/68af3477cce1cd22566edce2651f54cf8c184a91/kernel_module/ioctl.c"" rel=""nofollow noreferrer""><code>ioctl</code></a></li>
<li><a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/68af3477cce1cd22566edce2651f54cf8c184a91/kernel_module/poll.c"" rel=""nofollow noreferrer""><code>poll</code></a></li>
<li><a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/68af3477cce1cd22566edce2651f54cf8c184a91/kernel_module/mmap.c"" rel=""nofollow noreferrer""><code>mmap</code></a></li>
</ul>

<p><strong>Start with software models of simplified hardware in emulators</strong></p>

<p>Actual device hardware development is ""hard"" because:</p>

<ul>
<li>you can't always get your hand on a given hardware easily</li>
<li>hardware APIs may be complicated</li>
<li>it is hard to see what is the internal state of the hardware</li>
</ul>

<p>Emulators like QEMU allow us to overcome all those difficulties, by simulating simplified hardware simulation in software.</p>

<p>QEMU for example, has a built-in educational PCI device called <code>edu</code>, which I explained further at: <a href=""https://stackoverflow.com/questions/28315265/how-to-add-a-new-device-in-qemu-source-code/44612957#44612957"">How to add a new device in QEMU source code?</a> and is a good way to get started with device drivers. I've made a simple driver for it <a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/6788a577c394a2fc512d8f3df0806d84dc09f355/kernel_module/pci.c"" rel=""nofollow noreferrer"">available here</a>.</p>

<p>You can then put printf's or use GDB on QEMU just as for any other program, and see exactly what is going on.</p>

<p>There is also an OPAM SPI model for you specific use case: <a href=""https://github.com/qemu/qemu/blob/v2.7.0/hw/ssi/omap_spi.c"" rel=""nofollow noreferrer"">https://github.com/qemu/qemu/blob/v2.7.0/hw/ssi/omap_spi.c</a></p>
"
"<p><strong>Minimal example</strong></p>

<p>The kernel docs contain an example under <a href=""https://github.com/torvalds/linux/blob/v4.9/Documentation/filesystems/seq_file.txt"" rel=""nofollow noreferrer"">Documentation/filesystems/seq_file.txt</a>, but here is a runnable version of that with loop termination.</p>

<p>This example is behaves just like a file that contains:</p>

<pre><code>0
1
2
</code></pre>

<p>However, we only store a single integer in memory
and calculate the file on the fly in an iterator fashion.</p>

<p>The file works for both <code>read</code> and <code>lseek</code> system calls, but there is no <code>write</code> system call equivalent:
<a href=""https://stackoverflow.com/questions/30710517/how-to-implement-a-writable-proc-file-by-using-seq-file-in-a-driver-module"">How to implement a writable proc file by using seq_file in a driver module</a></p>

<p>Play around with the file with <code>cat</code> and <code>dd skip=</code> for the seeks.</p>

<pre><code>#include &lt;asm/uaccess.h&gt; /* copy_from_user, copy_to_user */
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/errno.h&gt; /* EFAULT */
#include &lt;linux/fs.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/printk.h&gt; /* pr_info */
#include &lt;linux/seq_file.h&gt; /* seq_read, seq_lseek, single_release */
#include &lt;linux/slab.h&gt;
#include &lt;uapi/linux/stat.h&gt; /* S_IRUSR */

MODULE_LICENSE(""GPL"");

static int max = 2;
module_param(max, int, S_IRUSR | S_IWUSR);

static struct dentry *debugfs_file;

/* Called at the beginning of every read.
 *
 * The return value is passsed to the first show.
 * It normally represents the current position of the iterator.
 * It could be any struct, but we use just a single integer here.
 *
 * NULL return means stop should be called next, and so the read will be empty..
 * This happens for example for an ftell that goes beyond the file size.
 */
static void *start(struct seq_file *s, loff_t *pos)
{
    loff_t *spos;

    pr_info(""start pos = %llx\n"", (unsigned long long)*pos);
    spos = kmalloc(sizeof(loff_t), GFP_KERNEL);
    if (!spos || *pos &gt;= max)
        return NULL;
    *spos = *pos;
    return spos;
}

/* The return value is passed to next show.
 * If NULL, stop is called next instead of show, and read ends.
 *
 * Can get called multiple times, until enough data is returned for the read.
 */
static void *next(struct seq_file *s, void *v, loff_t *pos)
{
    loff_t *spos;

    spos = v;
    pr_info(""next pos = %llx\n"", (unsigned long long)*pos);
    if (*pos &gt;= max)
        return NULL;
    *pos = ++*spos;
    return spos;
}

/* Called at the end of every read. */
static void stop(struct seq_file *s, void *v)
{
    pr_info(""stop\n"");
    kfree(v);
}

/* Return 0 means success, SEQ_SKIP ignores previous prints, negative for error. */
static int show(struct seq_file *s, void *v)
{
    loff_t *spos;

    spos = v;
    pr_info(""show pos = %llx\n"", (unsigned long long)*spos);
    seq_printf(s, ""%llx\n"", (long long unsigned)*spos);
    return 0;
}

static struct seq_operations my_seq_ops = {
    .next  = next,
    .show  = show,
    .start = start,
    .stop  = stop,
};

static int open(struct inode *inode, struct file *file)
{
    pr_info(""open\n"");
    return seq_open(file, &amp;my_seq_ops);
}

static struct file_operations fops = {
    .owner   = THIS_MODULE,
    .llseek  = seq_lseek,
    .open    = open,
    .read    = seq_read,
    .release = seq_release
};

static int myinit(void)
{
    debugfs_file = debugfs_create_file(
        ""lkmc_seq_file"", S_IRUSR, NULL, NULL, &amp;fops);
    if (debugfs_file) {
        return 0;
    } else {
        return -EINVAL;
    }
}

static void myexit(void)
{
    debugfs_remove(debugfs_file);
}

module_init(myinit)
module_exit(myexit)
</code></pre>

<p><a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/f82c058eb676b9b94a4064dd9cde2c5978d9cdcc/kernel_module/seq_file.c"" rel=""nofollow noreferrer"">GitHub upstream</a>.</p>

<p>Note how the seq_file API makes it much easier to write the <code>read</code> file operation.</p>

<p><strong><code>single_open</code></strong></p>

<p>If you have the entire read output upfront, <code>single_open</code> is an even more convenient version of seq_file.</p>

<p>This example behaves like a file that contains:</p>

<pre><code>ab
cd
</code></pre>

<p>Code:</p>

<pre><code>#include &lt;asm/uaccess.h&gt; /* copy_from_user, copy_to_user */
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/errno.h&gt; /* EFAULT */
#include &lt;linux/fs.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/printk.h&gt; /* pr_info */
#include &lt;linux/seq_file.h&gt; /* seq_read, seq_lseek, single_release */
#include &lt;uapi/linux/stat.h&gt; /* S_IRUSR */

MODULE_LICENSE(""GPL"");

static struct dentry *debugfs_file;

static int show(struct seq_file *m, void *v)
{
    seq_printf(m, ""ab\ncd\n"");
    return 0;
}

static int open(struct inode *inode, struct  file *file)
{
    return single_open(file, show, NULL);
}

static const struct file_operations fops = {
    .llseek = seq_lseek,
    .open = open,
    .owner = THIS_MODULE,
    .read = seq_read,
    .release = single_release,
};

static int myinit(void)
{
    debugfs_file = debugfs_create_file(
        ""lkmc_seq_file_single"", S_IRUSR, NULL, NULL, &amp;fops);
    if (debugfs_file) {
        return 0;
    } else {
        return -EINVAL;
    }
}

static void myexit(void)
{
    debugfs_remove(debugfs_file);
}

module_init(myinit)
module_exit(myexit)
</code></pre>

<p><a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/f82c058eb676b9b94a4064dd9cde2c5978d9cdcc/kernel_module/seq_file_single.c"" rel=""nofollow noreferrer"">GitHub upstream</a>.</p>
"
"<p>Helper functions like <code>debugfs_create_u32()</code> are intended for cases where you want to be able to change a variable without any other helper code.</p>

<p>If you want to do anything but setting a variable, you have to implement your own file operations with <code>debugfs_create_file()</code>.</p>
"
"<p>Okay as it is little tricky, I will tell you what are the steps required to do that.As it is really a tricky one many would not prefer to give the appropriate answer, never the less these are the step you can follow.</p>

<p>1.what you have to do is you can first write  a kernel module. Then You can compile that to generate the <code>.ko</code> file. Which is a loadable kernel module. Write a loadable kernel module in which you can keep an ISR(Interrupt Service Routine) that gets executed when there is an interrupt comes to any particular GPIO. For your information ISR is also a function that automatically gets executed when there is an interrupt received to a particular GPIO.</p>

<p>Keep a provision in your kernel module, to accept the application layer <code>Process ID</code>, so that as soon as there comes an interrupt to the <code>GPIO</code>, the module can send a <code>SIGNAL</code> from Kernel layer to application Layer.</p>

<p>2.Copy that to your <code>ARM target processor</code> and then insert the module to the kernel. You can insert the module by typing</p>

<pre><code>             `insmod &lt;your_module.ko&gt;`
</code></pre>

<ol start=""3"">
<li>Check if the Module has inserted or not by typing <code>lsmod</code> Command on to the terminal of your <code>AM335x</code> target board.</li>
</ol>

<p>3.Then you can write the user level application, where you can send the <code>processID</code> of the process from the application layer to the kernel layer as soon as your process starts running. SO that the kernel module you have written can get the application layer <code>ProcessID</code> to send the <code>SIGNAL</code>.</p>

<p>NOTE: As Linux by default uses the first <code>32</code> <code>SIGNAL</code> so you can use the <code>SIGNAL</code> number from <code>33 to 64</code> for your purpose. Here we are using <code>SIGNAL Number 44</code>.</p>

<p>Example of the Kernel Module:</p>

<pre><code>#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/gpio.h&gt;                 //! &lt;&lt; Required for the GPIO functions
#include &lt;linux/interrupt.h&gt;            //! &lt;&lt; Required for the IRQ code

#include &lt;asm/siginfo.h&gt;            //! &lt;&lt; siginfo
#include &lt;linux/rcupdate.h&gt;         //! &lt;&lt; rcu_read_lock
#include &lt;linux/sched.h&gt;            //! &lt;&lt; find_task_by_pid_type
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/uaccess.h&gt;


MODULE_LICENSE(""GPL"");
MODULE_AUTHOR(""Sudipta Kumar Sahoo"");
MODULE_DESCRIPTION(""A SPI GPIO Interrupt driver for the Sitara"");
MODULE_VERSION(""1.0"");

#define SIG_TEST 44             //! &lt;&lt; we choose 44 as our signal number
                    //! &lt;&lt; (real-time signals are in the range of 33 to 64)
struct dentry *file;

int gPID = 0;
int Return = 0;
struct siginfo stGInfo;
struct task_struct *stGTask;

//static unsigned int resetGPIOInterrupt = 115;   //! &lt;&lt; hard coding the Delphino Interrupt gpio for this in BB P9_27 (GPIO115)
static unsigned int resetGPIOInterrupt = 54;
static unsigned int irqNumber;                 //! &lt;&lt; Used to share the IRQ number within this file
static unsigned int numberPresses = 0;         //! &lt;&lt; For information, store the number of times the SIGNAL is high.

/********************************************************************************/
/**
 * \fn    write_pid(struct file *file, const char __user *buf,
 *                                                  size_t count, loff_t *ppos)
 *
 * @brief The LKM write_pid function
 *        The static keyword restricts the visibility of the function
 *        to within this C file.
 *
 * @return returns 0 if successful
 */
/********************************************************************************/
static ssize_t write_pid(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
        char mybuf[10];
        int pid = 0;
        int ret;
        struct siginfo info;
        struct task_struct *stTask;
        /* read the value from user space */
        if(count &gt; 10)
    {
        return -EINVAL;
    }

        copy_from_user(mybuf, buf, count);      //! &lt;&lt; Copy the Process ID from the Application Process

    /* For Global variables value assignment starts */
    /******************************************************************************************/
    //! Copy the required information to Global variables to send SIGNAL from ISR
    sscanf(mybuf, ""%d"", &amp;gPID);         //! &lt;&lt; Copy to global PID
    memset(&amp;stGInfo, 0, sizeof(struct siginfo));
    stGInfo.si_signo = SIG_TEST;
        //! &lt;&lt; this is bit of a trickery: SI_QUEUE is normally used by sigqueue from user space,
        //! &lt;&lt; and kernel space should use SI_KERNEL. But if SI_KERNEL is used the real_time data
        //! &lt;&lt; is not delivered to the user space signal handler function.
    stGInfo.si_code = SI_QUEUE;
    stGInfo.si_int = 1024;
    /*For Global variables value assignment Ends */
    /******************************************************************************************/

        /* send a SIGNAL to the process to intimate that it received the corresponding PID. */
        sscanf(mybuf, ""%d"", &amp;pid);
        printk(""pid = %d\n"", pid);
        memset(&amp;info, 0, sizeof(struct siginfo));
        info.si_signo = SIG_TEST;
        //! &lt;&lt; this is bit of a trickery: SI_QUEUE is normally used by sigqueue from user space,
        //! &lt;&lt; and kernel space should use SI_KERNEL. But if SI_KERNEL is used the real_time data
        //! &lt;&lt; is not delivered to the user space signal handler function.
        info.si_code = SI_QUEUE;
        info.si_int = 1234;                     //! &lt;&lt; real time signals may have 32 bits of data.

        rcu_read_lock();                //! &lt;&lt; Get the RCU Read lock
    //t = find_task_by_pid_type(PIDTYPE_PID, pid);  //! &lt;&lt; find the task_struct associated with this pid
        stTask = pid_task(find_pid_ns(pid, &amp;init_pid_ns), PIDTYPE_PID);
        if(stTask == NULL)
        {
                printk(""no such pid\n"");
                rcu_read_unlock();
                return -ENODEV;
        }
        rcu_read_unlock();              //! &lt;&lt; Make the RCU Read unlock

        ret = send_sig_info(SIG_TEST, &amp;info, stTask);    //! &lt;&lt;send the signal
        if (ret &lt; 0)
        {
                printk(""error sending signal\n"");
                return ret;
        }
        return count;
}

/********************************************************************************/
/**
 * @brief The LKM mapping user defiend functions to file_operations structure.
 */
/********************************************************************************/
static const struct file_operations my_fops = {
        .write = write_pid,
};

/********************************************************************************/
/**
 * @brief Function prototype for the custom IRQ handler function
 *        see below for the implementation.
 */
/********************************************************************************/
static irq_handler_t  ebbgpio_irq_handler(unsigned int irq, void *dev_id, struct pt_regs *regs);

/********************************************************************************/
/**
 * \fn    __init ebbgpio_init(void)
 *
 *  @brief The LKM initialization function. The static keyword restricts the
 *         visibility of the function to within this C file. The __init macro
 *         means that for a built-in driver (not a LKM) the function is only used
 *         at initialization time and that it can be discarded and its memory
 *         freed up after that point. In this example this function sets up the
 *         GPIOs and the IRQ
 *
 *  @return returns 0 if successful
 */
/********************************************************************************/
static int __init ebbgpio_init(void)
{
   int result = 0;
   printk(KERN_INFO ""GPIO_TEST: Initializing the GPIO_TEST LKM\n"");
   // Is the GPIO a valid GPIO number (e.g., Sitara has 4x32 but not all available)
   if (!gpio_is_valid(resetGPIOInterrupt))
   {
      printk(KERN_INFO ""GPIO_TEST: invalid Button GPIO\n"");
      return -ENODEV;
   }
   //Going to set up the Button. It is a GPIO in input mode and will be zero  by default
   //gpio_set_value(gpioLED, ledOn);                   //! Not required as set by line above (here for reference)
   gpio_request(resetGPIOInterrupt, ""sysfs"");       //! Set up the gpioButton
   gpio_direction_input(resetGPIOInterrupt);        //! Set the resetGPIOInterrupt GPIO to be an input
   gpio_set_debounce(resetGPIOInterrupt, 200);      //! Debounce the resetGPIOInterrupt with a delay of 200ms
   gpio_export(resetGPIOInterrupt, false);          //! Causes gpio115 to appear in /sys/class/gpio
                                           //! the bool argument prevents the direction from being changed

   // Perform a quick test to see that the resetGPIOInterrupt is working as expected on LKM load
   printk(KERN_INFO ""GPIO_TEST: The resetGPIOInterrupt state is currently: %d\n"", gpio_get_value(resetGPIOInterrupt));

   // GPIO numbers and IRQ numbers are not the same! This function performs the mapping for us
   irqNumber = gpio_to_irq(resetGPIOInterrupt);
   printk(KERN_INFO ""GPIO_TEST: The resetGPIOInterrupt is mapped to IRQ: %d\n"", irqNumber);

   // This next call requests an interrupt line
   result = request_irq(irqNumber,                       //! The interrupt number requested
                        (irq_handler_t) ebbgpio_irq_handler, //! The pointer to the handler function below
                        IRQF_TRIGGER_RISING,             //! Interrupt on rising edge (When The Signal is High-1 not at Low-0)
                        ""ebb_gpio_handler"",              //! Used in /proc/interrupts to identify the owner
                        NULL);                           //! The *dev_id for shared interrupt lines, NULL is okay

   printk(KERN_INFO ""GPIO_TEST: The interrupt request result is: %d\n"", result);

   /* we need to know the pid of the user space process
   * -&gt; we use debugfs for this. As soon as a pid is written to
   * this file, a signal is sent to that pid
   */
   /* only root can write to this file (no read) */
   file = debugfs_create_file(""signalconfpid"", 0200, NULL, NULL, &amp;my_fops);

   return result;
}


/********************************************************************************/
/**
 *  \fn    __init ebbgpio_init(void)
 *
 *  @brief The LKM cleanup function Similar to the initialization function,
 *         it is static. The __exit macro notifies that if this code is used for
 *         a built-in driver (not a LKM) that this function is not required. Used
 *         to release the GPIOs and display cleanup messages.
 *
 *  @return returns NULL
 */
/********************************************************************************/
static void __exit ebbgpio_exit(void)
{
   printk(KERN_INFO ""GPIO_TEST: The resetGPIOInterrupt state is currently: %d\n"", gpio_get_value(resetGPIOInterrupt));
   printk(KERN_INFO ""GPIO_TEST: The resetGPIOInterrupt was received %d times\n"", numberPresses);

   free_irq(irqNumber, NULL);                          //! &lt;&lt; Free the IRQ number, no *dev_id required in this case.
   gpio_unexport(resetGPIOInterrupt);               //! &lt;&lt; Unexport the resetGPIOInterrupt GPIO.
   gpio_free(resetGPIOInterrupt);                   //! &lt;&lt; Free the resetGPIOInterrupt GPIO.

   debugfs_remove(file);                   //! &lt;&lt;  Remove the debugfs file.
   printk(KERN_INFO ""GPIO_TEST: Unloading the GPIO_TEST LKM module!\n"");
}

/********************************************************************************/
/**
 *  \fn    ebbgpio_irq_handler(void)
 *  @brief The GPIO IRQ Handler function. This function is a custom interrupt
 *         handler that is attached to the GPIO above. The same interrupt handler
 *         cannot be invoked concurrently as the interrupt line is masked out
 *         until the function is complete. This function is static as it should
 *         not be invoked directly from outside of this file.
 *
 *  @param irq    the IRQ number that is associated with the GPIO--useful for logging.
 *
 *  @param dev_id the *dev_id that is provided -- can be used to identify which
 *                                                device caused the interrupt
 *                                      (Not used in this case as NULL is passed.)
 *
 *  @param regs   h/w specific register values -- only really ever used for debugging.
 *
 *  @return returns IRQ_HANDLED if successful -- should return IRQ_NONE otherwise.
 */
/********************************************************************************/
static irq_handler_t ebbgpio_irq_handler(unsigned int irq, void *dev_id, struct pt_regs *regs)
{
   printk(KERN_INFO ""GPIO_TEST: Interrupt! (resetGPIOInterrupt state is %d)\n"", gpio_get_value(resetGPIOInterrupt));
   numberPresses++;                         // Global counter, will be outputted when the module is unloaded

   /* Sending The Signal to Process Starts */
   rcu_read_lock();
   stGTask = pid_task(find_pid_ns(gPID, &amp;init_pid_ns), PIDTYPE_PID);
   printk(""sending signal From ISR\n"");
   if(stGTask == NULL)
   {
      printk(""no such pid\n"");
      rcu_read_unlock();
      return -ENODEV;
   }
   rcu_read_unlock();

   //This is the Line Important for You. Where we are sending the Signal to the Application layer
   Return = send_sig_info(SIG_TEST, &amp;stGInfo, stGTask);    //send the signal

   if (Return &lt; 0)
   {
      printk(""error sending signal\n"");
      return Return;
   }
   /* Sending The Signal to Process Ends */

   return (irq_handler_t) IRQ_HANDLED;      // Announce that the IRQ has been handled correctly
}

/********************************************************************************/
/// This next calls are  mandatory -- they identify the initialization function
/// and the cleanup function (as above).
/********************************************************************************/
module_init(ebbgpio_init);
module_exit(ebbgpio_exit);
</code></pre>

<p>You can straight forward take the code and generate .ko file for that. Just take care to configure the <code>appropriate GPIO</code> Number as per your requirement. I have configured <code>GPIO-54</code> The code has been written for <code>AM335x</code> processor Only. If you do not know how to create <code>.ko</code> file then just be cool and google <code>""HOW TO BUILD A KERNEL MODULE""</code>, you will get it easily.</p>

<p>Finally you can write a dummy application to test it, The application looks as follow:</p>

<pre><code>/********************************************************************************/
/**
 * @file   userApplication.c
 *
 * @author Sudipta Kumar Sahoo
 *
 * @brief  An Application layer programm implementation to connect with the
 *     kernel layer, That receives the interrupt from the kernel space
 *     once the particular interrupt is received at configured GPIO pin.
 *
 *     NOTE:: Before executing the program first mount the debugfs if it has
 *     not already mounted to the file system and then execute the application
 *     to receive the interrupt Signal in applicatio layer.
 *
 *  The copyright notice does not evidence any actual or intended publication.
*/
/********************************************************************************/

#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;

#define SIG_TEST    44 /* we define our own signal, hard coded since SIGRTMIN
                is different in user and in kernel space */
#define RUNNING     1
/********************************************************************************/
/**
 * \fn    void signalHandler(int n, siginfo_t *info, void *unused)
 *
 * @brief The receiveData function
 *        The function has been registered to the kernel layer debugfs file system
 *        When GPIO gets the interrupt it intimates to appliation process via
 *    signalHandler() function and the appropriate action is taken afterwards.
 *
 * @return NULL
 */
/********************************************************************************/
void signalHandler(int n, siginfo_t *info, void *unused)
{
    printf(""Application received value %i\n"", info-&gt;si_int);
    /* Do what ever you want to do inside this Function upon the receival of the Interrupt */
}

int main ( int argc, char **argv )
{
    int configfd;
    char buf[10];

    /* setup the signal handler for SIG_TEST
     * SA_SIGINFO -&gt; we want the signal handler function with 3 arguments
     */
    struct sigaction sig;

    sig.sa_sigaction = signalHandler;
    sig.sa_flags = SA_SIGINFO;
    sigaction(SIG_TEST, &amp;sig, NULL);

    /* kernel needs to know our pid to be able to send us a signal -&gt;
     * we use debugfs for this -&gt; do not forget to mount the debugfs!
     */
    configfd = open(""/sys/kernel/debug/signalconfpid"", O_WRONLY);
    if(configfd &lt; 0)
    {
        printf(""Could not Open the File\n"");
        perror(""open"");
        return -1;
    }

    sprintf(buf, ""%i"", getpid());               //! &lt;&lt; Get the process ID.

    if (write(configfd, buf, strlen(buf) + 1) &lt; 0)      //! &lt;&lt; Write the details to Kernel Space.
    {
        perror(""fwrite"");
        return -1;
    }

    /*
     * Making the Application to run independently
     */
    while(RUNNING)
    {
        printf(""Waiting for Interrup Signal...\n"");
        sleep(1);
    }

    return 0;
}
</code></pre>

<p><code>signalHandler()</code> is the function in your application layer that gets executed when there an interrupt comes to the particular configured <code>GPIO</code>. Now you can run your application independently and also you will be able to receive the interrupt with out polling</p>

<p><em>""The examples are self explanatory and appropriate comments has been given for your understanding""</em></p>

<p>Hope this Helps.</p>
"
"<p>With the (originally) missing information about <code>RESET_GPIO_VALUE</code>, we can provide a reasonable answer.</p>

<p>Obviously, your ?C's board support package implements the Linux <em>GPIO Sysfs Interface for Userspace</em> (you should read the documentation about that that comes with your Linux BSP).</p>

<p>Basically (if the board and the driver supports it), you can make GPIO's trigger interrupts in user space. Just write <code>rising</code>, <code>falling</code> or <code>both</code> (literally) to <code>/sys/class/gpio/gpioN/edge</code> to select the signal edges your code wants to react on, then do a <code>poll()</code> on an open file descriptor to <code>/sys/class/gpio/gpioN/value</code>.</p>

<p>This poll will return every time <code>value</code> changes accordingly.</p>
"
"<p>Kernel space and user space have no <em>shared</em> mechanisms for concurrent access protection. If you want them, you need to implement them by yourself.</p>

<p>It can be some sort of mutex, implemented within you kernel module, and accessed from user space via special ioctl requests:</p>

<p>Kernel:
</p>

<pre><code>DECLARE_WAIT_QUEUE_HEAD(wq);
int my_mutex_val = 0;

/*
 * Lock mutex.
 *
 * May be used directly by the kernel or via 'ioctl(MY_CMD_LOCK)' by user.
 */
void my_mutex_lock(void)
{
    spin_lock(&amp;wq.lock);
    wait_event_interruptible_locked(&amp;wq, my_mutex_val == 0);
    my_mutex_val = 1;
    spin_unlock(&amp;wq.lock);
}

/*
 * Unlock mutex.
 *
 * May be used directly by the kernel or via 'ioctl(MY_CMD_UNLOCK)' by user.
 */
void my_mutex_unlock(void)
{
    spin_lock(&amp;wq.lock);
    my_mutex_val = 0;
    wake_up(&amp;wq);
    spin_unlock(&amp;wq.lock);
}

long unlocked_ioctl (struct file * filp, unsigned int cmd, unsigned long val)
{
    switch(cmd) {
    case MY_CMD_LOCK:
        my_mutex_lock();
    break;
    case MY_CMD_UNLOCK:
        my_mutex_unlock();
    break;
    }
}
</code></pre>

<p>User:</p>

<pre><code>int main()
{
    ...
    ioctl(MY_CMD_LOCK);
    &lt;read data&gt;
    ioctl(MY_CMD_UNLOCK);
    ...
}
</code></pre>

<p>It can be some sort of spinlock, which value is stored in mmap-ed area (so visible both for kernel space and user space).</p>

<p>In any case, kernel module should be prepared for the case, when <em>user space application doesn't follow locking conventions</em>. This, probably, would cancel any expectation about mmap-ed area content, generated by the kernel, but <strong>kernel module shouldn't crash</strong> in that case. [This is why standard kernel's <code>struct mutex</code> is not used in the code above: user space may use it incorrectly].</p>
"
"<p>The problem with the ioctl is you need a kernel switch every time you want to access the share info->data.  If that is okay then the ioctl is good - but then why not just do a standard character read/write file operation instead?</p>

<p>You can also try a lock-less mechanism.  In the shared info->data area add a barrier variable.  When the user needs access, it will do an atomic_compare_and_xchg on the barrier variable until it is set to 0 (unused) and then set it to 1.  When the kernel needs access it will do the same but set it to 2.  See the gcc atomic builtin documentation.</p>
"
"<p>Spi driver dose not support any llseek or fseek functionality.  It has these many call back functions.</p>

<pre><code> struct spi_driver {
    const struct spi_device_id *id_table;
    int                     (*probe)(struct spi_device *spi);
    int                     (*remove)(struct spi_device *spi);
    void                    (*shutdown)(struct spi_device *spi);
    int                     (*suspend)(struct spi_device *spi, pm_message_t mesg);
    int                     (*resume)(struct spi_device *spi);
    struct device_driver    driver;
</code></pre>

<p>};</p>

<p>Now <strong>drivers/spi/spi-dw.c</strong> is register as a charter-driver(debugfs_create_file(""registers"", S_IFREG | S_IRUGO,
dws->debugfs, (void *)dws, &amp;dw_spi_regs_ops);). So they implement to create a file in the debugfs filesystem. they implement lseek callback function.</p>

<pre><code>static const struct file_operations dw_spi_regs_ops = {
    .owner          = THIS_MODULE,
    .open           = simple_open,
    .read           = dw_spi_show_regs,
    .llseek         = default_llseek,
</code></pre>

<p>};
The file_operations structure is defined in linux/fs.h, and holds pointers to functions defined by the driver that perform various operations on the device. Each field of the structure corresponds to the address of some function defined by the driver to handle a requested operation </p>

<p><strong>lseek -:</strong> lseek is a system call that is used to change the location of the read/write pointer of a file descriptor. </p>

<p><strong>SPI -:</strong> The ""Serial Peripheral Interface"" (SPI) is a synchronous four wire serial link used to connect microcontrollers to sensors, memory, and peripherals. <strong>SPI can not provide any lseek and fseek functionlity.</strong></p>

<p>There are two type of SPI driver (<a href=""https://www.kernel.org/doc/Documentation/spi/spi-summary"" rel=""noreferrer"">https://www.kernel.org/doc/Documentation/spi/spi-summary</a>)</p>

<p>Controller drivers ... controllers may be built into System-On-Chip
    processors, and often support both Master and Slave roles.
    These drivers touch hardware registers and may use DMA.
    Or they can be PIO bitbangers, needing just GPIO pins.</p>

<p>Protocol drivers ... these pass messages through the controller
    driver to communicate with a Slave or Master device on the
    other side of an SPI link.</p>

<p>If you want to user read, write and llseek then you will have to register a charter-driver on top of SPI. Then you will able to achieve your acquirement.</p>
"
"<p>I've resolved this problem following those references : </p>

<p>1- <a href=""http://myclipnotes.blogspot.com/2015/03/reserve-memory-in-linux-driver-module.html"" rel=""nofollow"">Reserve memory in Linux driver module and share it using driver mmap</a></p>

<p>2- <a href=""http://www.linuxquestions.org/questions/linux-kernel-70/mmap-of-several-gb-of-reserved-memory-using-805818/#post3972954"" rel=""nofollow"">mmap of several GB of reserved memory using</a></p>

<p>in my case i am reserving 30M from the offset 2G and bellow is the code </p>

<p>module: </p>

<pre><code>// #include &lt;linux/config.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/moduleparam.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/kernel.h&gt;   /* printk() */
#include &lt;linux/slab.h&gt;   /* kmalloc() */
#include &lt;linux/fs.h&gt;       /* everything... */
#include &lt;linux/errno.h&gt;    /* error codes */
#include &lt;linux/types.h&gt;    /* size_t */
#include &lt;linux/mm.h&gt;
#include &lt;linux/kdev_t.h&gt;
#include &lt;asm/page.h&gt;
#include &lt;linux/cdev.h&gt;

#include &lt;linux/device.h&gt;

#ifndef VM_RESERVED
# define  VM_RESERVED   (VM_DONTEXPAND | VM_DONTDUMP)
#endif

#define RAW_DATA_SIZE 31457280
#define RAW_DATA_OFFSET 0x80000000UL

void *rawdataStart;

struct dentry  *file;



/*
 * Open the device; in fact, there's nothing to do here.
 */
int simple_open (struct inode *inode, struct file *filp)
{
    return 0;
}


/*
 * Closing is just as simpler.
 */
static int simple_release(struct inode *inode, struct file *filp)
{
    return 0;
}



static int simple_remap_mmap(struct file *filp, struct vm_area_struct *vma)
{

    int ret;
        unsigned long mapoffset;
        mapoffset = RAW_DATA_OFFSET + (vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT);
        ret = remap_pfn_range(vma, vma-&gt;vm_start, mapoffset &gt;&gt; PAGE_SHIFT,
                              vma-&gt;vm_end - vma-&gt;vm_start, PAGE_SHARED);

        if ( ret != 0 ) {
            printk(""Error remap_pfn_range. \n"");
            return -EAGAIN;
        }
        return 0;
}

/* Device  uses remap_pfn_range */
static struct file_operations simple_remap_ops = {
    .owner   = THIS_MODULE,
    .open    = simple_open,
    .release = simple_release,
    .mmap    = simple_remap_mmap,
};

/*
 * Module housekeeping.
 */
static int simple_init(void)
{
    file = debugfs_create_file(""mmap_example"", 0644, NULL, NULL, &amp;simple_remap_ops);
    rawdataStart = ioremap(RAW_DATA_OFFSET, RAW_DATA_SIZE);
    if (rawdataStart!=NULL){
        printk(""rawdataStart at:%p  \n"", rawdataStart);
        memset(rawdataStart, 'c', 20971520);
        memset(rawdataStart+20971520, '$', 100);

    }else{
        printk(""rawdataStart is NULL \n"");
        return -1;
    }



    return 0;
}


static void simple_cleanup(void)
{
    debugfs_remove(file);
    if (rawdataStart != NULL) {
            printk(KERN_INFO ""Unmapping memory at %p\n"", rawdataStart);
            iounmap(rawdataStart);
        } else {
            printk(KERN_WARNING ""No memory to unmap!\n"");
        }
}


module_init(simple_init);
module_exit(simple_cleanup);
MODULE_AUTHOR(""Jonathan Corbet"");
MODULE_LICENSE(""Dual BSD/GPL"");
</code></pre>

<p>and the user space App: </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/mman.h&gt;

#define RAW_DATA_SIZE 31457280

int main(int argc, char **argv) {
    int configfd;
    char * address = NULL;
    unsigned long chkSum;
    FILE *fp = fopen(""results.log"", ""w+"");

    configfd = open(""/sys/kernel/debug/mmap_example"", O_RDWR);
    if (configfd &lt; 0) {
        perror(""Open call failed"");
        return -1;
    }

    address = (unsigned char*) mmap(NULL, RAW_DATA_SIZE, PROT_WRITE,
            MAP_PRIVATE, configfd, 0);
    if (address == MAP_FAILED) {
        perror(""mmap operation failed"");
        return -1;
    }

    fputs(address, fp);
    fclose(fp);

    close(configfd);
    return 0;
}
</code></pre>
"
"<p><strong><code>nopat</code> kernel command line argument</strong></p>

<p>Just add that and it works, as mentioned at: <a href=""https://stackoverflow.com/a/36634422/895245"">https://stackoverflow.com/a/36634422/895245</a></p>

<p>Here is my test setup:</p>

<p><a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/2eca9280e12dbab79ccb67d0640b2a0edc2c9ffc/kernel_module/virt_to_phys.c"" rel=""nofollow noreferrer"">kernel module</a>:</p>

<pre><code>#include &lt;asm/io.h&gt; /* virt_to_phys */
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/delay.h&gt; /* usleep_range */
#include &lt;linux/kernel.h&gt;
#include &lt;linux/kthread.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/seq_file.h&gt; /* single_open, single_release */
#include &lt;linux/slab.h&gt; /* kmalloc, kfree */

static volatile u32 *i;

static struct dentry *debugfs_file;

static int show(struct seq_file *m, void *v)
{
    seq_printf(m,
        ""*i 0x%llx\n""
        ""i %p\n""
        ""virt_to_phys 0x%llx\n"",
        (unsigned long long)*i,
        i,
        (unsigned long long)virt_to_phys((void *)i)
    );
    return 0;
}

static int open(struct inode *inode, struct  file *file)
{
    return single_open(file, show, NULL);
}

static const struct file_operations fops = {
    .llseek = seq_lseek,
    .open = open,
    .owner = THIS_MODULE,
    .read = seq_read,
    .release = single_release,
};

static int myinit(void)
{
    i = kmalloc(sizeof(i), GFP_KERNEL);
    *i = 0x12345678;
    debugfs_file = debugfs_create_file(
        ""lkmc_virt_to_phys"", S_IRUSR, NULL, NULL, &amp;fops);
    return 0;
}

static void myexit(void)
{
    debugfs_remove(debugfs_file);
    kfree((void *)i);
}

module_init(myinit)
module_exit(myexit)
MODULE_LICENSE(""GPL"");
</code></pre>

<p><a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/2eca9280e12dbab79ccb67d0640b2a0edc2c9ffc/rootfs_overlay/virt_to_phys.sh"" rel=""nofollow noreferrer""><code>/dev/mem</code> userland</a>:</p>

<pre><code>#!/bin/sh
set -ex
insmod /virt_to_phys.ko
cd /sys/kernel/debug
cat lkmc_virt_to_phys
# *i = 0x12345678
addr=$(grep virt_to_phys lkmc_virt_to_phys | cut -d ' ' -f 2)
devmem2 ""$addr""
devmem2 ""$addr"" w 0x9ABCDEF0
cat lkmc_virt_to_phys
# *i = 0x9ABCDEF0
rmmod virt_to_phys
</code></pre>

<p><code>nopat</code> being passed at: <a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/2eca9280e12dbab79ccb67d0640b2a0edc2c9ffc/runqemu#L65"" rel=""nofollow noreferrer"">https://github.com/cirosantilli/linux-kernel-module-cheat/blob/2eca9280e12dbab79ccb67d0640b2a0edc2c9ffc/runqemu#L65</a></p>

<p>Also try <code>xp</code> on QEMU monitor.</p>

<p>And <code>devmem2</code> is upstreamed by Buildroot itself: <a href=""http://free-electrons.com/pub/mirror/devmem2.c"" rel=""nofollow noreferrer"">http://free-electrons.com/pub/mirror/devmem2.c</a> See also: <a href=""https://stackoverflow.com/questions/12040303/accessing-physical-address-from-user-space/45127890#45127890"">Accessing physical address from user space</a></p>
"
"<p>I would suggest the combination of an own device tree file + a platform driver + character driver</p>

<p><strong>0.) RTF</strong></p>

<p>check how <a href=""http://devicetree.org/Device_Tree_Usage"" rel=""nofollow noreferrer"">device trees(dts)</a> are working</p>

<p>check how a <a href=""https://www.kernel.org/doc/Documentation/driver-model/platform.txt"" rel=""nofollow noreferrer"">platform device</a> works</p>

<p>check how a <a href=""https://lwn.net/Articles/195805/"" rel=""nofollow noreferrer"">character device</a> works</p>

<p>gain some knowledge about gpios and dts</p>

<p><a href=""https://www.kernel.org/doc/Documentation/gpio/board.txt"" rel=""nofollow noreferrer"">@gpio mappings</a></p>

<p><a href=""https://www.kernel.org/doc/Documentation/gpio/drivers-on-gpio.txt"" rel=""nofollow noreferrer"">@subsystems using gpios</a></p>

<p><a href=""https://www.kernel.org/doc/Documentation/devicetree/bindings/gpio/gpio.txt"" rel=""nofollow noreferrer"">@Specifying GPIO information for devices</a></p>

<p>Read the informations provided by your SOC manufacturer.</p>

<p>The <a href=""http://elinux.org/images/9/9b/GPIO_for_Engineers_and_Makers.pdf"" rel=""nofollow noreferrer"">state-of-the-art</a> way to access the gpios is via <code>struct gpio_desc</code> variables. They are created form the device tree.</p>

<p><strong>1.) approach</strong></p>

<p>To toggle a pin under linux you need to make shure, that 3 units are working togehter.</p>

<p>The pin-controller(pinctrl) defines how the output is driven. Open source, pull up etc.</p>

<p>The pin-multiplexer(pinmux) defines different functions for the pin.</p>

<p>The gpio-controller(gpioctrl) translates the gpio number. p.E.: 44 -> GPIO A 11</p>

<p>These components are implemented by the SOC manufacturer. For each platform there are differences. An example for the SAMA5D35xxx follows.</p>

<p>@the device tree</p>

<p>Define the pin controller</p>

<pre><code>pinctrl@fffff200 {
    pinctrl_myPins: myPins {
        atmel,pins = &lt;AT91_PIOA 2 AT91_PERIPH_GPIO AT91_PINCTRL_NONE  // pin 1
            AT91_PIOD 19 AT91_PERIPH_GPIO AT91_PINCTRL_NONE&gt;; // pin 2
    };
};
</code></pre>

<p>Create a node witch is linked to the own platform device:</p>

<pre><code>myPins {
    compatible = ""myPlatformDevice"";

    pinctrl-names = ""default"";
    pinctrl-0 = &lt;&amp;pinctrl_myPins&gt;;

    pin1 = &lt;&amp;pioA 2 GPIO_ACTIVE_HIGH&gt;;
    pin2 = &lt;&amp;pioD 19 GPIO_ACTIVE_HIGH&gt;;
};
</code></pre>

<p>@create platform + char driver (pseudo code):</p>

<pre><code>// ----------------------
// kernel message support(via dmesg)
// ----------------------
#define KMSG_DEBUG(fmt,args...) printk(KERN_DEBUG ""myDrv"" "": ""fmt""\n"", ##args)
#define KMSG_PERR(fmt,args...) printk(KERN_ERR ""myDrv"" "": ""fmt""\n"", ##args)
#define KMSG_PINFO(fmt,args...) printk(KERN_INFO ""myDrv"" "": ""fmt""\n"", ##args)
// ----------------------
// trace support via defining dMyDrvTrace
// ----------------------
#ifndef dMyDrvTrace
    #define TRACE(...)
#else
    #define TRACE(fmt,args...) printk(KERN_INFO ""myDrv"" "": [%s] ""fmt""\n"", __FUNCTION__, ##args)
#endif


typedef struct SMyDrvDrvData {
    struct platform_device *pdev; //!&lt; next device
    // here goes the local/private data
    int gpiod_pin1;
    int gpiod_pin2;

    u32 pin1;
    u32 pin2;
} TMyDrvDrvData;

static struct dentry * gmyPlattformDrvDebugfsRootDir; //!&lt; root dir at debugfs

static int myPlattformDrv_probe(struct platform_device *pdev);
static int myPlattformDrv_remove(struct platform_device *pdev);

#if defined(CONFIG_OF)
    //! filter for the device tree class
    static struct of_device_id gMyPlattformDrvdtsFilter[] = {
        {.compatible = ""myPlatformDevice""},
        {}
    };
    MODULE_DEVICE_TABLE(of, gMyPlattformDrvdtsFilter);
#else
    #define gmyPlattformDrvdtsFilter (NULL)
#endif

static struct platform_device *MyPlattformDrv_devs[] = {
};

static struct platform_driver myPlattformDrv_driver = {
        .driver = {
            .name   = dMyPlattformDrvdriver,
            .owner  = THIS_MODULE,
            .of_match_table =  of_match_ptr(gMyPlattformDrvdtsFilter),
        },
        .probe      = myPlattformDrv_probe,
        .remove     = myPlattformDrv_remove,
};


// char device

static dev_t gMyCharDev;
static struct class *gMyCharDevClass;
static struct cdev gMyCharDev_cdev;

static int dev_open      (struct inode *, struct file *);
static int dev_release   (struct inode *, struct file *);
static ssize_t dev_read  (struct file *, char *, size_t, loff_t *);
static ssize_t dev_write (struct file *, const char *, size_t, loff_t *);

static const struct file_operations gMyCharDevOps =
{
    .read    = dev_read,
    .open    = dev_open,
    .write   = dev_write,
    .release = dev_release
};


//! looks up for the gpio name and request it
static int get_gpio(struct platform_device *pdev, const char * name, int * pGPIOnum)
{
    int n,i;
    int r;
    struct device_node * pDN;

    TRACE(""look at %s for %s ..."", pdev-&gt;name, name);
    // reset return value
    *pGPIOnum = 0;

    // parse device tree

    // get device tree entries associated with the device
    pDN = of_find_node_by_name(NULL, pdev-&gt;name);

    // parse pins
    n = of_gpio_named_count(pDN, name);
    if (n &lt;= 0) {
        TRACE(""no gpios found"");
        return -1;
    }
    for (i = 0; i &lt; n; i++) {
        // get pin number
        *pGPIOnum = of_get_named_gpio(pDN,name, i);
        if (*pGPIOnum == -EPROBE_DEFER) {
            return r;
        }
        // check if pin number is valid
        if (gpio_is_valid(*pGPIOnum)) {
            // yes
            // request pin
            r = devm_gpio_request(&amp;pdev-&gt;dev, *pGPIOnum, name);
            if (r) {
                return r;
            } else {
                r = gpio_direction_output(*pGPIOnum, 0);
                }
                if (r) return r;
            }
        }
    }
    return 0;
}

//! probes the platform driver
static int myPlattformDrv_probe(struct platform_device *pdev)
{
    struct TMyDrvDrvData *priv;
    int i,j,r,gpioNum, ret;

    KMSG_PINFO(""probe my driver ..."");

    priv = kzalloc(sizeof(*priv), GFP_KERNEL);
    if (!priv) {
        KMSG_PERR(""Failed to allocate memory for the private data structure"");
        return -ENOMEM;
    }

    priv-&gt;pdev = pdev;
    platform_set_drvdata(pdev, priv);

    TRACE(""setup gpios ..."");
    r = get_gpio(pdev, ""pin1"", &amp;gpioNum);
    if (r) {
        KMSG_PERR(""Failed to find gpio \""pin1\"" in device tree"");
    }
    // save number
    priv-&gt;gpiod_pin1 = gpioNum;

    // create ""pin1"" debugfs entry
    debugfs_create_u32(""pin1"", S_IRUGO, gmyPlattformDrvDebugfsRootDir, &amp;priv-&gt;Pin1);

    r = get_gpio(pdev, ""pin2"", &amp;gpioNum);
    if (r) {
        KMSG_PERR(""Failed to find gpio \""pin2\"" in device tree"");
    }
    // save number
    priv-&gt;gpiod_pin2 = gpioNum;

    // create ""pin2"" debugfs entry
    debugfs_create_u32(""pin1"", S_IRUGO, gmyPlattformDrvDebugfsRootDir, &amp;priv-&gt;Pin2);


    // create device class
    TRACE(""create myCharDev char device class"");

    // create char dev region
    ret = alloc_chrdev_region(&amp;gMyCharDev, 0, 1, ""myCharDev"");
    if( ret &lt; 0) {
        KMSG_PERR(""alloc_chrdev_region error %i"", ret);
        goto error;
    }

    // create device class
    if((gMyCharDevClass = class_create(THIS_MODULE, dSEK4DevClass)) == NULL)
    {
        KMSG_PERR(""class_create error"");
        goto error_classCreate;
    }

    if(NULL == device_create(gMyCharDevClass, NULL, gMyCharDev, NULL, ""myCharDev""))
    {
        KMSG_PERR(""device_create error"");
        goto error_deviceCreate;
    }

    cdev_init(&amp;gMyCharDev_cdev, &amp;gMyCharDevOps);
    ret = cdev_add(&amp;gMyCharDev_cdev, gMyCharDev, 1);
    if(-1 == ret) {
        KMSG_PERR(""cdev_add error %i"", ret);
        goto error_device_add;
        return -1;
    }
    TRACE(""added myCharDev char device"");

    return 0;
// error handling block
error_std:
error_device_add:
    device_destroy(gMyCharDevClass, gMyCharDev);
error_deviceCreate:
    class_destroy(gMyCharDevClass);
error_classCreate:
    unregister_chrdev_region(gMyCharDev, 1);
error:
    return -1;
}
</code></pre>
"
"<p>As I understand it the splice_* infrastructure does it's very best to minimise the amount of actual copying that is done. At best the reader is reading from the same set of pages the writer is filling.</p>

<p>There are some excellent articles on LWN describing the various bits of splice() including the new system call.</p>
"
"<p>Splice doesn't do any DMA copy. In fact the major usage of splice is to avoid copying at all - it tries to pass references to memory pages instead of copying the buffers.</p>

<p>The DMA mentioned in relation to splice will happen at the ""leaf"" - The origin of these pages that splice passes references to around will be created by, for example, a disk controller DMA into the buffer and will be sent by an Ethernet controller DMA of the content of the page as part of the packet - at least in a ""perfect"" zero copy sceanrio, which is difficult to achieve and rare.</p>

<p>Splice doesn't do the DMA - it enables no copying between the first DMA to the last.</p>
"
"<p>A vector of pointers can be reused for storing objects of sub-classes:</p>

<pre><code>class Person
{
    public:
    virtual const std::string&amp; to_string () = 0;
    virtual ~Person () { }
};

class Student : public Person
{
   const std::string&amp; to_string ()
   {
       // return name + grade
   }
};

class Employee : public Person
{
   const std::string&amp; to_string ()
   {
      // return name + salary
   }
};

std::vector&lt;Pointer*&gt; persons;
person.push_back (new Student (name, grade));
person.push_back (new Employee (name, salary));
person[0]-&gt;to_string (); // name + grade
person[1]-&gt;to_string (); // name + salary
</code></pre>

<p>Ideally the vector should be wrapped up in a class. This makes memory management easier. It also facilitates changing the support data structure (here an <code>std::vector</code>) without breaking existing client code:</p>

<pre><code>class PersonList
{
   public:
   Person* AddStudent (const std::string&amp; name, int grade)
   {
       Person* p = new Student (name, grade);
       persons.push_back (p);
       return p;
   }

   Person* AddEmployee (const std::string&amp; name, double salary)
   {
       Person* p = new Employee (name, salary);
       persons.push_back (p);
       return p;
   }

   ~PersonList ()
   {
      size_t sz = persons.size ();
      for (size_t i = 0; i &lt; sz; ++i)
          delete persons[i];
   }

   private
   std::vector&lt;Person*&gt; persons;
};
</code></pre>

<p>So we can re-write our code as:</p>

<pre><code>{
   PersonList persons;
   Person* student = persons.AddStudent (name, grade);
   Person* employee = persons.AddEmployee (name, salary);
   student.to_string ();
   employee.to_string ();
} // The memory allocated for the Person objects will be deleted when
  // `persons` go out of scope here.
</code></pre>

<p>Getting familiar with the <a href=""http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29"" rel=""nofollow"">Rule of Three</a> will help you decide when to add a copy constructor to a class. Also read about <a href=""http://www.parashift.com/c++-faq-lite/const-correctness.html"" rel=""nofollow"">const correctness</a>. </p>
"
"<p><strong><em>I'm told I have to use a vector of Object Pointers, not Objects. Why? My assignment calls for it specifically, but I'm also told it won't work otherwise.</em></strong></p>

<p>Usually, one would avoid using vector of objects to avoid the problem of <strong><a href=""https://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c""><em>Object Slicing</em></a></strong>. To make polymorphism work You have to use some kind of pointers. I am not sure of how the classes in your assignment are aligned but probably you might have Inheritance there somewhere and hence if vector is storing objects of Base class and you insert objects of Derived class in it then it would cause the derived class members to slice off.</p>

<p>The Best solution will be to use a smart pointer instead of a Raw pointer. The STL has an <code>auto_ptr</code>, but that cannot be used in a standard container.Boost smart pointers would be a best solution but as you already said you can't use Boost So in your case you can use your compiler's implementation of smart pointers, which comes in <code>TR1</code> namespace,remember though that there is some disagreement on the namespace for TR1 functions (Visual C++ puts them in <code>std::</code>, while GCC puts them in <code>std::tr1::</code>).</p>

<p><strong><em>Where should I be creating this vector? Should it be part of my Package Class? How do I go about adding objects into it then?</em></strong><br>
Your example code already has an example of adding a pointer to <code>Package</code> class in a vector. In a nutshell you will dynamically allocate pointers to <code>Package</code> and then add them to the vector.</p>

<p><strong><em>Do I need a copy constructor? Why?</em></strong><br>
The copy constructor generated by the compiler does member-wise copying. Sometimes that is not sufficient. For example:</p>

<pre><code>class MyClass {
    public:
        MyClass( const char* str );
        ~MyClass();
    private:
        char* str;
    };

    MyClass::MyClass( const char* str2 )
    {
        str = new char[srtlen( str2 ) + 1 ];
        strcpy( str, str2 );
    }

    Class::~Class()
    {
        delete[] str;
    }
</code></pre>

<p>In this case member-wise copying of <code>str</code> member will not duplicate the buffer (only the pointer will be copied(<code>shallow copy</code>)), so the first to be destroyed copy sharing the buffer will call <code>delete[]</code> successfully and the second will run into <code>Undefined Behavior</code>. You need <code>deep copying copy constructor</code> (and assignment operator as well) in such a scenario.  </p>

<p>When to use a custom copy constructor is best defined by the <strong><em><a href=""https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three"">Rule Of Three</a></em></strong>:  </p>

<pre><code>Whenever you are writing either one of Destructor, Copy Constructor or Copy Assignment Operator, you probably need to write the other two.
</code></pre>

<p><strong><em>What's the proper way to deconstruct my vector of object pointers?</em></strong><br>
You will have to explicitly call delete on each contained pointer to delete the content it is pointing to.</p>

<p><code>vector::erase</code><br>
Removes from the vector container and calls its destructor but If the contained object is a pointer it doesnt take ownership of destroying it. </p>

<p>Check out <a href=""https://stackoverflow.com/questions/6353149/does-vectorerase-destroy-the-removed-object/6353169#6353169""><strong>this answer</strong></a> here to know how to corrctly delete a vector of pointer to objects.</p>
"
"<p>Question 1:
You mentioned inheritance. Since inherited objects often need more bytes of storage, they don't fit into the place of a base object. If you try to put them in, you get a base object instead. This is called object slicing.</p>

<p>Question 2:
Design first, before you write code. There are a bunch of possible solutions.
For a start you can keep it in main(), but later you will be forced to make a class like <code>PackageContainer</code> for holding your objects.</p>

<p>Question 3 + 4:
You need a copy constructor, an assignment operator= and a destructor, when a class object owns dynamically allocated objects (the Rule of the Big Three). So a <code>PackageContainer</code> will probably need them.
You create objects dynamically using <code>new Object(..)</code>. You are responsible for destroying them and for giving their memory back to the system immediately before your vector of pointers is destroyed: </p>

<pre><code>for (size_t i = 0; i &lt; shipment.size(); ++i)
{
  delete shipment[i];
}
</code></pre>

<p>Since working with naked pointers to dynamically allocated objects is not safe, consider using</p>

<pre><code>std::vector&lt;tr1::shared_ptr&lt;Package&gt; &gt; shipment;
</code></pre>

<p>instead or </p>

<pre><code>std::vector&lt;std::shared_ptr&lt;Package&gt; &gt; shipment;
</code></pre>

<p>if your compiler understands C++0x. The <code>shared_ptr</code> handles freeing memory for you: It implements the Rule of the Big Three for one object pointer. It should be used in production quality code.</p>

<p>But try to get it right with naked pointers also. I think that's what your homework assignment is about. </p>
"
"<p>The comment actually explains it: they are verifying that there are no duplicate values between <code>ha[0..4][</code>x<code>]</code> for each value of x.</p>

<p>As to <em>how</em> it is doing it: each value is assigned a bit position, such that <code>1&lt;&lt;ha[i][</code>x<code>]</code> will yield a number with only the bit in that position set.  x<code>_or</code> will be the OR of those values, while x<code>_add</code> is their sum.  If there is a duplicate value, it will not have an effect on x<code>_or</code> (that bit is already set), but <em>will</em> on x<code>_add</code>; hence, they will be different.</p>
"
"<p>You'll need to divide the size of the array, in bytes, by the size of a single element:</p>

<pre><code>int size = sizeof(src3) / sizeof(*src3);
int size = sizeof(src4) / sizeof(*src4);
</code></pre>
"
"<h2>How do I get the number of elements in <code>char *[]</code> and <code>char **[]</code> ?</h2>

<pre><code>printf(""Number of elements in char* src2[]: %d\n"", (sizeof src2)/(sizeof src2[0]) );
</code></pre>

<p>Same technique for <code>char **[]</code> too,</p>

<pre><code>printf(""Number of elements in char** src4[]: %d\n"", (sizeof src4)/(sizeof src4[0]) );
</code></pre>

<hr>

<h2>How do I alloc dynamic Array to point to C-style-strings ?</h2>

<pre><code>char **d_alloc;
d_alloc = malloc(3 * sizeof *d_alloc);
if(d_alloc == NULL)
{
    printf(""malloc failed !"");
    return -1;
}
d_alloc[0] = ""Created"";
d_alloc[1] = ""Dynamic"";
d_alloc[2] = ""Arrays"";
printf(""%s %s %s\n"",d_alloc[0], d_alloc[1], d_alloc[2]);
</code></pre>

<hr>

<h2>Why the below code doesn't work ?</h2>

<pre><code>char** src5;
src5 = malloc(3 * sizeof(src5));
puts(""Dynamically allotted char*"");
src5[0] = ""lion"";
src5[1] = ""shark"";
printf(""%s %s\n"",src5[0],src[1]);
</code></pre>

<p>You wanted to dynamically allocate space for <code>char *</code>. So, pass <code>malloc()</code> the <code>sizeof *src5</code> and not the <code>sizeof src5</code>. <code>src5</code> is the pointer to <code>char *</code>'s , you will use later to access the dynamically allocated space.</p>

<pre><code>src5 = malloc(3 * sizeof *src5);
</code></pre>

<p><code>*src5</code> is of type <code>char *</code>.</p>
"
"<p><code>sizeof</code> is only working that way because you're creating a static string, assigning it at creation.</p>

<p><code>sizeof</code> will show the size of the data type normally (if you use the pointer method), even after you <code>malloc()</code> the memory. Execute this code to demonstrate:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main ()
{
        char *string;
        char *dynamic;
        dynamic = malloc(10 * sizeof(*dynamic));
        if (!dynamic)
            /* Error, malloc() failed. */
            return 1;

        /* Copy something into the string. */
        strcpy(dynamic, ""testing"");

        printf(""sizeof char pointer:     %d\n"", sizeof(string));
        printf(""sizeof char:             %d\n"", sizeof(*string));
        printf(""dynamic:                 %s\n"", dynamic);
        printf(""sizeof dynamic pointer:  %d\n"", sizeof(dynamic));
        printf(""sizeof dynamic:          %d\n"", sizeof(*dynamic));

        free(dynamic);
        return 0;
}
</code></pre>

<p>For your string lengths, you're probably after <code>strlen()</code>. When you <code>malloc</code> you also need to check whether it returns <code>NULL</code> (if it fails) and also <code>free</code> later. The size is usually a buffer, so to store 50 char in something you're allocating with <code>malloc</code>, you'd use something like this (though the sizeof part isn't needed for <code>char</code>):</p>

<pre><code>char *str;
str = malloc(50 * sizeof(*str));
</code></pre>
"
"<p>You're completely mixing up the abstraction layers involved. If something like your code could even work at all (not sure if it can), it would blow up badly and crash the kernel or lead to runaway wrong code execution if someone happened to make this syscall on a path that didn't actually correspond to an ext2 filesystem.</p>

<p>In the kernel's fs abstraction, the fact that the underlying filesystem is ext2 (or whatever it is) is irrelevant to the task of making a file on it. Rather all of this has to go through fs-type-agnostic layers which in turn end up using the fs-type-specific backends for the fs mounted at the path.</p>
"
"<p>For my part I think that this pattern it is sure because you need to implement the virtual function in the derived classes. This is the philosophy of virtual classes.</p>
"
"<p>There are two problems with your current design. The first is that it violates the rule of five/rule of zero. This means that ordinary usage of these classes is almost certain to result in memory leaks or double deletions.</p>

<p>The second problem is that you are using inheritance to model something that is probably better modelled with composition. <code>base</code> wants <code>d1</code> to provide some extra functionality to its destructor, with the exact form of this functionality specified at run-time. The use of a replaceable interface is therefore internal to <code>base</code>, and so should not be externally visible.</p>

<p>Here is how I would write this code (using <a href=""https://bitbucket.org/martinhofernandes/wheels/src/a3365a24524e4e7c05754689bf44fae160e5ed83/include/wheels/smart_ptr/value_ptr.h%2B%2B"" rel=""nofollow"">wheels::value_ptr</a>):</p>

<pre><code>struct D_interface {
    //Providing virtual functions for run-time modifiable behaviour
    virtual D_interface *clone() const = 0;
    virtual ~D_interface(){}
};

struct D_Delete {
    //Here is the code to call through to the virtual `D` object behaviour:
    void operator()(D_interface *p) {
        // ... do something before delete p;
        delete p;
        // ... do something after delete p;
    }
    //Put (pointers to) relevant data here,
    //initialise them when constructing the `value_ptr`, or
    //at a later stage with get_deleter
};

struct d1 : D_interface {
    wheels::value_ptr&lt;int&gt; mx;
    virtual D_interface *clone() const {
        return new d1(*this);
    }
};

//Nothing derives from `base`, because the polymorphism that is needed is internal
//to the implementation of `base`
//To add new functionality, add a new `D_interface` implementation.
class base
{
    wheels::value_ptr&lt;D_interface, wheels::DefaultCloner&lt;D_interface&gt;, D_Delete&gt; D_impl;
    public:
    base(D_interface *D_impl)
        : D_impl(D_impl)
    {
    }
};
</code></pre>
"
"<p>There's no direct link like that anymore.  The <code>proc_exe_link()</code> function gets this information by looking for the first executable vma in the task that is mapping a file.  You would do that for <code>current</code> with something like:</p>

<pre><code>struct dentry *dentry = NULL;
struct vfsmount *mnt = NULL;
struct vm_area_struct * vma;

down_read(&amp;current-&gt;mm-&gt;mmap_sem);

vma = current-&gt;mm-&gt;mmap;
while (vma) {
    if ((vma-&gt;vm_flags &amp; VM_EXECUTABLE) &amp;&amp; vma-&gt;vm_file)
        break;
    vma = vma-&gt;vm_next;
}

if (vma) {
    mnt = mntget(vma-&gt;vm_file-&gt;f_path.mnt);
    dentry = dget(vma-&gt;vm_file-&gt;f_path.dentry);
}

up_read(&amp;current-&gt;mm-&gt;mmap_sem);

if (dentry) {
    /* inode is dentry-&gt;d_inode */
}
</code></pre>
"
"<p>Well, it is not lost, of course. Just that in recent Linux kernel, it is a bit complex to track it.</p>

<p>For a recent Linux kernel, With a pointer of 'struct task_struct', you first need to get the 'struct mm_struct', by:</p>

<pre><code>    mm = get_task_mm(task);
</code></pre>

<p>and then</p>

<pre><code>    exe_file = get_mm_exe_file(mm);
</code></pre>

<p>now you have the 'struct file' pointer to the exec file, with 'struct file', you can get its inode by:</p>

<pre><code>    struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
</code></pre>

<p>BTW, the definition of get_mm_exe_file() is</p>

<pre><code>struct file *get_mm_exe_file(struct mm_struct *mm)
{
        struct file *exe_file;

        /* We need mmap_sem to protect against races with removal of
         * VM_EXECUTABLE vmas */
        down_read(&amp;mm-&gt;mmap_sem);
        exe_file = mm-&gt;exe_file;
        if (exe_file)
                get_file(exe_file);
        up_read(&amp;mm-&gt;mmap_sem);
        return exe_file;
}
</code></pre>
"
"<p>I would suggest to take a look at linux/fs/ext2/ source code. Files symlink.c, inode.c, namei.c and probably few others. You will get some idea as of what needs to be done. Contrary to expectation, filesystem code of the individual filesystems is actually very short and easy to read.</p>

<p>But maybe instead of creating new virtual filesystem, you might ask yourself another question, wouldn't fuse user level filesystem be enough in my case? They have slightly better documentation to creating virtual filesystems and a few more examples.</p>
"
"<p>Presumably you're using <a href=""http://fuse.sourceforge.net/"" rel=""nofollow noreferrer"">fuse</a>, if you're not, do :)</p>

<p>All you have to do is implement the getattr function to tell the kernel that the object is a symlink, then implement the readlink function and return the path that the link should link to; the kernel will do the rest.</p>
"
"<p>I was able to accomplish it finally. Here is what I did (some details may differ depending on what the filesystem wants to achieve):</p>

<ol>
<li><p>Create inode of the symlink with the S_IFLNK mode and add the target to the i_private field.</p></li>
<li><p>Implement follow_link because generic_readlink requires it to be present</p></li>
</ol>

<pre>
static void *sample_follow_link (struct dentry *dentry, struct nameidata *nd)
{
    nd->depth = 0;
    nd_set_link(nd, (char *)dentry->d_inode->i_private);
    return NULL;
}

static struct inode_operations sample_inode_ops = {
    .readlink = generic_readlink,
    .follow_link = sample_follow_link,
};

.....
//in the function for the dentry and inode creation
inode->i_op = sample_inode_ops

</pre>
"
"<p>The kernel thinks of directories differently from the way you do - it thinks in terms of inode numbers.  It keeps a record of the inode number (and device number) for the directory, and that is all it needs as the current directory.  The fact that you sometimes specify a name to it means it goes and tracks down the inode number corresponding to that name, but it preserves only the inode number because that's all it needs.</p>

<p>So, you will have to code a suitable function.  You can open a directory directly with <code>open()</code> precisely to get a file descriptor that can be used by <code>fchdir()</code>; you can't do anything else with it on many modern systems.  You can also fail to open the current directory; you should be testing that result.  The circumstances where this happens are rare, but not non-existent.  (A SUID program might <code>chdir()</code> to a directory that the SUID privileges permit, but then drop the SUID privileges leaving the process unable to read the directory; the <code>getcwd()</code> call will fail in such circumstances too - so you must error check that, too!)  Also, if a directory is removed while your (possibly long-running) process has it open, then a subsequent <code>getcwd()</code> will fail.</p>

<p>Always check results from system calls; there are usually circumstances where they can fail, even though it is dreadfully inconvenient of them to do so.  There are exceptions - <code>getpid()</code> is the canonical example - but they are few and far between.  (OK: not all that far between - <code>getppid()</code> is another example, and it is pretty darn close to <code>getpid()</code> in the manual; and <code>getuid()</code> and relatives are also not far off in the manual.)</p>

<p>Multi-threaded applications are a problem; using <code>chdir()</code> is not a good idea in those.  You might have to <code>fork()</code> and have the child evaluate the directory name, and then somehow communicate that back to the parent.</p>

<hr>

<p>bignose asks:</p>

<blockquote>
  <p>This is interesting, but seems to go against the querent's reported experience: that getcwd knows how to get the path from the fd. That indicates that the system knows how to go from fd to path in at least some situations; can you edit your answer to address this?</p>
</blockquote>

<p>For this, it helps to understand how - or at least one mechanism by which - the <code>getcwd()</code> function can be written.  Ignoring the issue of 'no permission', the basic mechanism by which it works is:</p>

<ul>
<li>Use stat on the root directory '/' (so you know when to stop going upwards).</li>
<li>Use stat on the current directory '.' (so you know where you are); this gives you a current inode.</li>
<li>Until you reach the root directory:</li>
<li>Scan the parent directory '..' until you find the entry with the same inode as the current inode; this gives you the next component name of the directory path.</li>
<li>And then change the current inode to the inode of '.' in the parent directory.</li>
<li>When you reach root, you can build the path.</li>
</ul>

<p>Here is an implementation of that algorithm.  It is old code (originally 1986; the last non-cosmetic changes were in 1998) and doesn't make use of <code>fchdir()</code> as it should.  It also works horribly if you have NFS automounted file systems to traverse - which is why I don't use it any more.  However, this is roughly equivalent to the basic scheme used by <code>getcwd()</code>.   (Ooh; I see a 18 character string (""../123456789.abcd"") - well, back when it was written, the machines I worked on only had the very old 14-character only filenames - not the modern flex names.  Like I said, it is old code!  I haven't seen one of those file systems in what, 15 years or so - maybe longer.  There is also some code to mess with longer names.  Be cautious using this.)</p>

<hr>

<pre><code>/*
@(#)File:           $RCSfile: getpwd.c,v $
@(#)Version:        $Revision: 2.5 $
@(#)Last changed:   $Date: 2008/02/11 08:44:50 $
@(#)Purpose:        Evaluate present working directory
@(#)Author:         J Leffler
@(#)Copyright:      (C) JLSS 1987-91,1997-98,2005,2008
@(#)Product:        :PRODUCT:
*/

/*TABSTOP=4*/

#define _POSIX_SOURCE 1

#include ""getpwd.h""

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;

#if defined(_POSIX_SOURCE) || defined(USG_DIRENT)
#include ""dirent.h""
#elif defined(BSD_DIRENT)
#include &lt;sys/dir.h&gt;
#define dirent direct
#else
What type of directory handling do you have?
#endif

#define DIRSIZ      256

typedef struct stat   Stat;

static Stat root;

#ifndef lint
/* Prevent over-aggressive optimizers from eliminating ID string */
const char jlss_id_getpwd_c[] = ""@(#)$Id: getpwd.c,v 2.5 2008/02/11 08:44:50 jleffler Exp $"";
#endif /* lint */

/* -- Routine: inode_number */

static ino_t   inode_number(char *path, char *name)
{
    ino_t           inode;
    Stat            st;
    char            buff[DIRSIZ + 6];

    strcpy(buff, path);
    strcat(buff, ""/"");
    strcat(buff, name);
    if (stat(buff, &amp;st))
        inode = 0;
    else
        inode = st.st_ino;
    return(inode);
}

/*
    -- Routine: finddir
    Purpose:    Find name of present working directory

    Given:
        In:  Inode of current directory
        In:  Device for current directory
        Out: pathname of current directory
        In:  Length of buffer for pathname

    Maintenance Log
    ---------------
    10/11/86  JL    Original version stabilised
    25/09/88  JL    Rewritten to use opendir/readdir/closedir
    25/09/90  JL    Modified to pay attention to length
    10/11/98  JL    Convert to prototypes

*/
static int finddir(ino_t inode, dev_t device, char *path, size_t plen)
{
    register char  *src;
    register char  *dst;
    char           *end;
    DIR            *dp;
    struct dirent  *d_entry;
    Stat            dotdot;
    Stat            file;
    ino_t           d_inode;
    int             status;
    static char     name[] = ""../123456789.abcd"";
    char            d_name[DIRSIZ + 1];

    if (stat("".."", &amp;dotdot) || (dp = opendir("".."")) == 0)
        return(-1);
    /* Skip over ""."" and "".."" */
    if ((d_entry = readdir(dp)) == 0 ||
        (d_entry = readdir(dp)) == 0)
    {
        /* Should never happen  */
        closedir(dp);
        return(-1);
    }

    status = 1;
    while (status)
    {
        if ((d_entry = readdir(dp)) == 0)
        {
            /* Got to end of directory without finding what we wanted */
            /* Probably a corrupt file system */
            closedir(dp);
            return(-1);
        }
        else if ((d_inode = inode_number("".."", d_entry-&gt;d_name)) != 0 &amp;&amp;
                 (dotdot.st_dev != device))
        {
            /* Mounted file system */
            dst = &amp;name[3];
            src = d_entry-&gt;d_name;
            while ((*dst++ = *src++) != '\0')
                ;
            if (stat(name, &amp;file))
            {
                /* Can't stat this file */
                continue;
            }
            status = (file.st_ino != inode || file.st_dev != device);
        }
        else
        {
            /* Ordinary directory hierarchy */
            status = (d_inode != inode);
        }
    }
    strncpy(d_name, d_entry-&gt;d_name, DIRSIZ);
    closedir(dp);

    /**
    ** NB: we have closed the directory we are reading before we move out of it.
    ** This means that we should only be using one extra file descriptor.
    ** It also means that the space d_entry points to is now invalid.
    */
    src = d_name;
    dst = path;
    end = path + plen;
    if (dotdot.st_ino == root.st_ino &amp;&amp; dotdot.st_dev == root.st_dev)
    {
        /* Found root */
        status = 0;
        if (dst &lt; end)
            *dst++ = '/';
        while (dst &lt; end &amp;&amp; (*dst++ = *src++) != '\0')
            ;
    }
    else if (chdir(""..""))
        status = -1;
    else
    {
        /* RECURSE */
        status = finddir(dotdot.st_ino, dotdot.st_dev, path, plen);
        (void)chdir(d_name);    /* We've been here before */
        if (status == 0)
        {
            while (*dst)
                dst++;
            if (dst &lt; end)
                *dst++ = '/';
            while (dst &lt; end &amp;&amp; (*dst++ = *src++) != '\0')
                ;
        }
    }

    if (dst &gt;= end)
        status = -1;
    return(status);
}

/*
    -- Routine: getpwd

    Purpose:    Evaluate name of current directory

    Maintenance Log
    ---------------
    10/11/86  JL    Original version stabilised
    25/09/88  JL    Short circuit if pwd = /
    25/09/90  JL    Revise interface; check length
    10/11/98  JL    Convert to prototypes

    Known Bugs
    ----------
    1.  Uses chdir() and could possibly get lost in some other directory
    2.  Can be very slow on NFS with automounts enabled.

*/
char    *getpwd(char *pwd, size_t plen)
{
    int             status;
    Stat            here;

    if (pwd == 0)
        pwd = malloc(plen);
    if (pwd == 0)
        return (pwd);

    if (stat(""/"", &amp;root) || stat(""."", &amp;here))
        status = -1;
    else if (root.st_ino == here.st_ino &amp;&amp; root.st_dev == here.st_dev)
    {
        strcpy(pwd, ""/"");
        status = 0;
    }
    else
        status = finddir(here.st_ino, here.st_dev, pwd, plen);
    if (status != 0)
        pwd = 0;
    return (pwd);
}

#ifdef TEST

#include &lt;stdio.h&gt;

/*
    -- Routine: main
    Purpose:    Test getpwd()

    Maintenance Log
    ---------------
    10/11/86  JL    Original version stabilised
    25/09/90  JL    Modified interface; use GETCWD to check result

*/
int main(void)
{
    char            pwd[512];
    int             pwd_len;

    if (getpwd(pwd, sizeof(pwd)) == 0)
        printf(""GETPWD failed to evaluate pwd\n"");
    else
        printf(""GETPWD: %s\n"", pwd);
    if (getcwd(pwd, sizeof(pwd)) == 0)
        printf(""GETCWD failed to evaluate pwd\n"");
    else
        printf(""GETCWD: %s\n"", pwd);
    pwd_len = strlen(pwd);
    if (getpwd(pwd, pwd_len - 1) == 0)
        printf(""GETPWD failed to evaluate pwd (buffer is 1 char short)\n"");
    else
        printf(""GETPWD: %s (but should have failed!!!)\n"", pwd);
    return(0);
}

#endif /* TEST */
</code></pre>
"
"<p>Jonathan's answer is very fine in showing how it works. But it doesn't show a workaround for the situation you describe.</p>

<p>I would as well use something like you describe:</p>

<pre><code>DIR* save = opendir(""."");
fchdir(fd);
getcwd(path,PATH_MAX);
fchdir(dirfd(save));
closedir(save);
</code></pre>

<p>but, in order to avoid race conditions in with threads, fork another process in order to do that.</p>

<p>That might sound expensive, but if you don't do that too often, it should be ok.</p>

<p>The idea is something like this (no runnable code, just a raw idea):</p>

<pre><code>int fd[2];
pipe(fd);
pid_t pid;
if ((pid = fork()) == 0) {
    // child; here we do the chdir etc. stuff
    close(fd[0]); // read end
    char path[PATH_MAX+1];
    DIR* save = opendir(""."");
    fchdir(fd);
    getcwd(path,PATH_MAX);
    fchdir(dirfd(save));
    closedir(save);
    write(fd[1], path, strlen(path));
    close(fd[1]);
    _exit(EXIT_SUCCESS);
} else {
    // parent; pid is our child
    close(fd[1]); // write end
    int cursor=0;
    while ((r=read(fd[0], &amp;path+cursor, PATH_MAX)) &gt; 0) {
        cursor += r;
    }
    path[cursor]='\0'; // make it 0-terminated
    close(fd[0]);
    wait(NULL);
}
</code></pre>

<p>I am not sure if this will resolve all issues, and I as well do not do any error checking, so that's what you should add.</p>
"
"<p>First I go to /proc directory and the  issue:</p>

<pre><code>ls -al */fd |grep pipe
</code></pre>

<p>(try taking away the ""pipe"" above and u will learn more.) and the results are (just a snapshot):</p>

<pre><code>l-wx------ 1 root     root     64 2011-05-14 23:12 17 -&gt; pipe:[39208]
l-wx------ 1 root     root     64 2011-05-14 23:12 2 -&gt; pipe:[16245]
lr-x------ 1 root     root     64 2011-05-14 23:12 4 -&gt; pipe:[23406]
l-wx------ 1 root     root     64 2011-05-14 23:12 8 -&gt; pipe:[23406]
l-wx------ 1 root     root     64 2011-05-14 23:12 17 -&gt; pipe:[39532]
l-wx------ 1 root     root     64 2011-05-14 23:12 2 -&gt; pipe:[16245]
lr-x------ 1 root     root     64 2011-05-14 23:12 4 -&gt; pipe:[23406]
l-wx------ 1 root     root     64 2011-05-14 23:12 8 -&gt; pipe:[23406]
l-wx------ 1 root     root     64 2011-05-14 23:12 1 -&gt; pipe:[16245]
lr-x------ 1 root     root     64 2011-05-14 23:12 16 -&gt; pipe:[40032]
l-wx------ 1 root     root     64 2011-05-14 23:12 17 -&gt; pipe:[40032]
l-wx------ 1 root     root     64 2011-05-14 23:12 2 -&gt; pipe:[16245]
lr-x------ 1 root     root     64 2011-05-14 23:12 4 -&gt; pipe:[23406]
l-wx------ 1 root     root     64 2011-05-14 23:12 8 -&gt; pipe:[23406]
l-wx------ 1 tteikhua tteikhua 64 2011-05-14 23:13 1 -&gt; pipe:[16245]
l-wx------ 1 tteikhua tteikhua 64 2011-05-14 23:13 12 -&gt; pipe:[66674]
lr-x------ 1 tteikhua tteikhua 64 2011-05-14 23:13 13 -&gt; pipe:[66674]
l-wx------ 1 root root 64 2011-05-14 23:30 1 -&gt; pipe:[101794]
</code></pre>

<p>And if u want to see the process that created the pipe, just remove the ""grep"", for example:</p>

<p>Here it shows that the pid=1 is having a pipe fd at 6759:</p>

<pre><code>1/fd:
total 0
dr-x------ 2 root root  0 2011-05-14 23:29 .
dr-xr-xr-x 7 root root  0 2011-05-14 22:59 ..
lrwx------ 1 root root 64 2011-05-14 23:29 0 -&gt; /dev/console (deleted)
lrwx------ 1 root root 64 2011-05-14 23:29 1 -&gt; /dev/console (deleted)
lrwx------ 1 root root 64 2011-05-14 23:29 2 -&gt; /dev/console (deleted)
lr-x------ 1 root root 64 2011-05-14 23:29 3 -&gt; pipe:[6759]
</code></pre>

<p>And tracing the above back to fs/pipe.c (linux kernel source that print these):</p>

<pre><code>/*
 * pipefs_dname() is called from d_path().
 */
static char *pipefs_dname(struct dentry *dentry, char *buffer, int buflen)
{
        return dynamic_dname(dentry, buffer, buflen, ""pipe:[%lu]"",
                                dentry-&gt;d_inode-&gt;i_ino);
}

static const struct dentry_operations pipefs_dentry_operations = {
        .d_dname        = pipefs_dname,
};
</code></pre>

<p>And reading fs/dcache.c:</p>

<pre><code>char *d_path(const struct path *path, char *buf, int buflen)
{
        if (path-&gt;dentry-&gt;d_op &amp;&amp; path-&gt;dentry-&gt;d_op-&gt;d_dname)
                return path-&gt;dentry-&gt;d_op-&gt;d_dname(path-&gt;dentry, buf, buflen);

and since d_path() is an exported symbol,

EXPORT_SYMBOL(d_path);
</code></pre>

<p>you should be able to call it from anywhere, and derive the information about the path - if it is a pipe then the corresponding pipefs_dname() will be called - it filesystem dependent:</p>

<pre><code>./fs/pipe.c:
    .d_dname    = pipefs_dname,
</code></pre>

<p>Read inode.c: init_inode_always() and u can see that i_pipe is set to NULL.   It is not null only when the inode is a PIPE.    </p>

<p>So u can always loop through all the process and get its opened file descriptor, and it the inode's i_pipe is set to non-NULL, you will know that that value is the inode number of the pipe.</p>

<p>I don't think such codes will exist in the kernel source (so not necessary to hunt for it - I have already tried) as it is much more efficient and safer to do it in userspace (like the ""ls -al"" command I explained earlier) then inside the kernel - generally the smaller the kernel the lesser security bugs and thus better stability etc.</p>
"
"<p>Thread-safety! What if two threads/processes are using the driver simultaneously? </p>
"
"<p>You can also avoid using the private data to store your actual device, which is a common choice if you need private data for something different. In that case you will need to retrieve the minor number in the scull_read routine. It will be something like that:</p>

<pre><code>ssize_t scull_read( struct file *filp,
                     char __user* buf,
                     size_t count,
                    loff_t * f_pos ) {

    int minor = MINOR(filp-&gt;f_dentry-&gt;d_inode-&gt;i_rdev);
    printk( ""reading on minor number %d\n"", minor);
    /* use dev[minor] in ur code */
    return 0;
 }
</code></pre>
"
"<p>I donot think it is a thead-safety issue. It is more like a design choice. If I am not mistaken, thread-safety is achieved by down and up the semaphore in scull_dev. If you dig into the code, you can see open, read, write all used down_interruptible().</p>

<p>I guess the author 1) believes accessing scull_dev directly doesnot look good 2) wants to show us how to use private_data. By putting the point to scull_dev in struct file whose pointer is sent to each operation, each operation can access it without using global variable.</p>
"
"<p>The main reason is so that your driver can manage more than one device. For example, you can create (<code>mknod</code>) several devices <code>/dev/scull1</code>, <code>/dev/scull2</code>, <code>/dev/scull3</code>... and then each of these will have a different <code>scull_dev</code> associated with it.</p>

<p>With a global variable you are limited to one. And even if your driver only supports one such device, there is little reason not to design the code future proof.</p>
"
"<p>The scull driver is implemented with 4 minors, each of which has a separate scull_dev, each scull_dev has ""struct cdev"" embedded in it. Now Let's say User has opened scull0 from /dev/scull0. In the open() function you need to point to the correct scull_dev structure. The scull_dev structures are dynamically allocated.</p>

<p>You can see the full implementation here
<a href=""https://github.com/mharsch/ldd3-samples/blob/master/scull/main.c#L450"" rel=""nofollow noreferrer"">https://github.com/mharsch/ldd3-samples/blob/master/scull/main.c#L450</a></p>
"
"<p>Apparently I can't comment yet, so I will ask a couple questions as an answer...</p>

<p>I see ""EXPORT_SYMBOLL(bloqueados);"" ... was this a mistype just in your copy/paste or is that mistyped in the actual code? This could be a problem...</p>

<p>Whats the reason you are using GFP_ATOMIC vs GFP_KERNEL?</p>

<p>This may help,</p>

<p><a href=""http://www.linuxjournal.com/article/6930"" rel=""nofollow"">http://www.linuxjournal.com/article/6930</a></p>

<p>It recommends not using GFP_ATOMIC if you don't absolutely need it... because it can fail. I might be missing something, but I don't see why you need it... you don't appear to be using any locks.</p>
"
"<p>You can use the following code to move an object into the trash at unlink.</p>

<pre><code>static int move_to_trash(struct dentry * trash, struct dentry * object)
{
    int result;
    char name[32];
    struct dentry * de;

    sprintf(name, ""XX-%lu"", object-&gt;d_inode-&gt;i_ino);

    de = d_alloc_name(trash, name);
    if (!de)
        return -ENOMEM;

    trash-&gt;d_inode-&gt;i_op-&gt;lookup(trash-&gt;d_inode, de, NULL);

    mutex_lock(&amp;trash-&gt;d_inode-&gt;i_mutex);
    result = trash-&gt;d_inode-&gt;i_op-&gt;link(object, trash-&gt;d_inode, de);
    mutex_unlock(&amp;trash-&gt;d_inode-&gt;i_mutex);

    dput(de);

    return result;
}
</code></pre>
"
"<p>Joachim is on the right track, but besides the inode number, one would have to compare its device since each filesystem would likely have an inode 1, inode 2, ...:</p>

<pre><code>if (f1-&gt;f_dentry.d_inode == f2-&gt;f_dentry.d_inode  &amp;&amp;
    !strcmp (f1-&gt;f_vfsmnt-&gt;mnt_devname, f2-&gt;f_vfsmnt-&gt;mnt_devname))
       // it is the exact same file
</code></pre>

<p>I thought there was a major/minor device i.d., but I have not been able to find it.  So comparing the device name (<code>/dev/dsk/hda1</code>) is deterministic, if not as quick.</p>
"
"<p>Have you seen <a href=""http://tldp.org/LDP/lki/lki-3.html"" rel=""nofollow"">this</a> and <a href=""http://csserver.evansville.edu/~amr63/linux/linux_kernel_notes/lk-13.html"" rel=""nofollow"">this</a>:</p>

<blockquote>
  <p>The open(2) system call is implemented in fs/open.c:sys_open function
  and the real work is done by fs/open.c:filp_open() function, which is
  split into two parts:</p>

  <p>open_namei(): fills in the nameidata structure containing the dentry
  and vfsmount structures. dentry_open(): given a dentry and vfsmount,
  this function allocates a new struct file and links them together; it
  also invokes the filesystem specific f_op->open() method which was set
  in inode->i_fop when inode was read in open_namei() (which provided
  inode via dentry->d_inode).</p>
</blockquote>

<p>It is actually set at <code>path_walk</code> function (if file exists):</p>

<pre><code>path_walk(const char *name, struct nameidata *nd) {
/* ... */
               /* if . or .. then special, otherwise: */
                dentry = cached_lookup(nd-&gt;dentry, &amp;this);
/* ... */
                if (!dentry)
                 dentry = real_lookup(nd-&gt;dentry, &amp;this);
</code></pre>

<p>dentry contains the inode information in its <code>d_inode</code> member. So the initialization inode is in open_namei function (or somewhere down there), before the <code>dentry_open</code>. Just track the dentry structure.</p>
"
"<p>File operations are assigned when a dentry object is being created for an existing file. This is done in the file system specific lookup function. Following is the call flow for that.</p>

<p>sys_open-->do_sys_open-->do_filp_open-->path_openat-->do_last-->walk_component-->do_lookup-->d_alloc_and_lookup-->filesystem specific lookup function() </p>

<p>File system specific lookup function for ext2 file system is ext2_lookup() and for ext3 it is ext3_lookup() and for ext4 it is ext4_lookup(). Inside the lookup function there will be a function call like ext2_iget() or ext3_iget() or ext4_iget(). This function fills the i_fop field of inode object.</p>

<p>This is on linux-3.0.</p>
"
"<p>There are special macro definitions at <a href=""http://lxr.linux.no/linux+v3.3/include/linux/stat.h#L24"" rel=""noreferrer"">linux/stat.h</a> that checks <code>inode-&gt;i_mode</code>:</p>

<pre><code>  #define S_ISLNK(m)      (((m) &amp; S_IFMT) == S_IFLNK)
  #define S_ISREG(m)      (((m) &amp; S_IFMT) == S_IFREG)
  #define S_ISDIR(m)      (((m) &amp; S_IFMT) == S_IFDIR)
  #define S_ISCHR(m)      (((m) &amp; S_IFMT) == S_IFCHR)
  #define S_ISBLK(m)      (((m) &amp; S_IFMT) == S_IFBLK)
  #define S_ISFIFO(m)     (((m) &amp; S_IFMT) == S_IFIFO)
  #define S_ISSOCK(m)     (((m) &amp; S_IFMT) == S_IFSOCK)
</code></pre>

<p>It seems that you'll need to use 2 of them - <code>S_ISFIFO</code> and <code>S_ISSOCK</code> in a such way:</p>

<pre><code>if (S_ISFIFO(file-&gt;f_path.dentry-&gt;d_inode-&gt;i_mode)) {...}
if (S_ISSOCK(file-&gt;f_path.dentry-&gt;d_inode-&gt;i_mode)) {...}
</code></pre>
"
"<p>As pointed out by @Ilya, You are hitting a generic case (<code>FIGETBSZ</code> in this case).</p>

<p>In general, you want to compose your ioctl commands using the <a href=""http://lxr.linux.no/linux+v3.3.1/include/asm-generic/ioctl.h#L83"" rel=""nofollow""><code>_IO</code> family of macros</a>, with a unique type, to avoid collisions.</p>

<p>I suggest reading <a href=""http://www.mjmwired.net/kernel/Documentation/ioctl-number.txt"" rel=""nofollow"">ioctl-number.txt</a> from the kernel documentation for more information, including a list of most used types</p>
"
"<p>Take a look on <a href=""http://lxr.linux.no/linux+v3.3.1/fs/ioctl.c#L546"" rel=""noreferrer"">this</a>:</p>

<pre><code> 546 int do_vfs_ioctl(struct file *filp, unsigned int fd, unsigned int cmd,
 547             unsigned long arg)
 548 {
 549        int error = 0;
 550        int __user *argp = (int __user *)arg;
 551        struct inode *inode = filp-&gt;f_path.dentry-&gt;d_inode;
 552
 553        switch (cmd) {
 554        case FIOCLEX:
 555                set_close_on_exec(fd, 1);
 556                break;
 557
 558        case FIONCLEX:
 559                set_close_on_exec(fd, 0);
 560                break;
 561
 562        case FIONBIO:
 563                error = ioctl_fionbio(filp, argp);
 564                break;
 565
 566        case FIOASYNC:
 567                error = ioctl_fioasync(fd, filp, argp);
 568                break;
 569
 570        case FIOQSIZE:
 571                if (S_ISDIR(inode-&gt;i_mode) || S_ISREG(inode-&gt;i_mode) ||
 572                    S_ISLNK(inode-&gt;i_mode)) {
 573                        loff_t res = inode_get_bytes(inode);
 574                        error = copy_to_user(argp, &amp;res, sizeof(res)) ?
 575                                        -EFAULT : 0;
 576                } else
 577                        error = -ENOTTY;
 578                break;
 579
 580        case FIFREEZE:
 581                error = ioctl_fsfreeze(filp);
 582                break;
 583
 584        case FITHAW:
 585                error = ioctl_fsthaw(filp);
 586                break;
 587
 588        case FS_IOC_FIEMAP:
 589                return ioctl_fiemap(filp, arg);
 590
 591        case FIGETBSZ:
 592                return put_user(inode-&gt;i_sb-&gt;s_blocksize, argp);
 593
 594        default:
 595                if (S_ISREG(inode-&gt;i_mode))
 596                        error = file_ioctl(filp, cmd, arg);
 597                else
 598                        error = vfs_ioctl(filp, cmd, arg);
 599                break;
 600        }
 601        return error;
 602
</code></pre>

<p>As you can see, there is some of the switch-cases before <code>vfs_ioctl</code> or <code>file_ioctl</code> call.</p>
"
"<p>The only thing that might work like that is a debugging hardware watch point.</p>

<p>However you are doing something wrong if you go down that route.</p>

<p>In order to share memory between threads, you need to implement appropriate locking and synchronization code. In that you should be able to add notification of changes when the memory is unlocked.</p>
"
"<p>You <strong>CAN</strong> add an <a href=""http://linux.die.net/man/7/inotify"" rel=""nofollow""><strong>inotify watch</strong></a> which will trigger on <a href=""http://linux.die.net/man/2/msync"" rel=""nofollow""><strong>msync()</strong></a> on the mmap-ed file.</p>

<p>This requires patching the Linux Kernel to <a href=""https://gist.github.com/TheCodeArtist/5874669"" rel=""nofollow""><strong>enable support for a new inotify watch</strong></a>. The patch adds a new flag <strong>IN_SYNC</strong> - a new inotify event that is triggered whenever msync() is carried out on the mmap-ed file.</p>

<p>Patch has been tested on v2.6.37 of the Linux Kernel.</p>

<pre><code>From 83edf446e92c86c738337ca4a35eab48e2f4e0eb Mon Sep 17 00:00:00 2001
From: Chinmay V S &lt;cvs268@gmail.com&gt;
Date: Mon, 17 Jun 2013 13:53:57 +0800
Subject: [PATCH] Add mmap-ed file support to inotify

This patch adds a new flag IN_SYNC. This is a new inotify event that is
triggered whenever msync() is carried out on a mmap-ed file.

Signed-off-by: Chinmay V S &lt;cvs268@gmail.com&gt;
---
 fs/sync.c                             |  5 +++++
 include/linux/fsnotify.h              | 16 ++++++++++++++++
 include/linux/fsnotify_backend.h      |  1 +
 include/linux/inotify.h               |  3 ++-
 mm/msync.c                            |  4 ++++
 5 files changed, 28 insertions(+), 3 deletions(-)

diff --git a/fs/sync.c b/fs/sync.c
index ba76b96..174c2af 100644
--- a/fs/sync.c
+++ b/fs/sync.c
@@ -16,6 +16,7 @@
 #include &lt;linux/buffer_head.h&gt;
 #include &lt;linux/backing-dev.h&gt;
 #include ""internal.h""
+#include &lt;linux/fsnotify.h&gt;

 #define VALID_FLAGS (SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE| \
            SYNC_FILE_RANGE_WAIT_AFTER)
@@ -190,6 +191,10 @@ static int do_fsync(unsigned int fd, int datasync)
        ret = vfs_fsync(file, datasync);
        fput(file);
    }
+
+   if (!ret)
+       fsnotify_sync(file-&gt;f_path.dentry);
+
    return ret;
 }

diff --git a/include/linux/fsnotify.h b/include/linux/fsnotify.h
index b10bcde..ef211fb 100644
--- a/include/linux/fsnotify.h
+++ b/include/linux/fsnotify.h
@@ -224,6 +224,22 @@ static inline void fsnotify_modify(struct file *file)
 }

 /*
+ * fsnotify_sync - file was synced
+ */
+static inline void fsnotify_sync(struct dentry *dentry)
+{
+   struct inode *inode = dentry-&gt;d_inode;
+   u32 mask = FS_SYNC;
+
+   if (S_ISDIR(inode-&gt;i_mode))
+       mask |= FS_ISDIR;
+
+   fsnotify_parent(NULL, dentry, mask);
+   fsnotify(inode, mask, inode, FSNOTIFY_EVENT_INODE, NULL, 0);
+
+}
+
+/*
  * fsnotify_open - file was opened
  */
 static inline void fsnotify_open(struct file *file)
diff --git a/include/linux/fsnotify_backend.h b/include/linux/fsnotify_backend.h
index 7380763..35b5cb8 100644
--- a/include/linux/fsnotify_backend.h
+++ b/include/linux/fsnotify_backend.h
@@ -36,6 +36,7 @@
 #define FS_DELETE      0x00000200  /* Subfile was deleted */
 #define FS_DELETE_SELF     0x00000400  /* Self was deleted */
 #define FS_MOVE_SELF       0x00000800  /* Self was moved */
+#define FS_SYNC            0x00001000  /* File was synced */

 #define FS_UNMOUNT     0x00002000  /* inode on umount fs */
 #define FS_Q_OVERFLOW      0x00004000  /* Event queued overflowed */
diff --git a/include/linux/inotify.h b/include/linux/inotify.h
index d33041e..244a132 100644
--- a/include/linux/inotify.h
+++ b/include/linux/inotify.h
@@ -38,6 +38,7 @@ struct inotify_event {
 #define IN_DELETE      0x00000200  /* Subfile was deleted */
 #define IN_DELETE_SELF     0x00000400  /* Self was deleted */
 #define IN_MOVE_SELF       0x00000800  /* Self was moved */
+#define IN_SYNC            0x00001000  /* File was synced */

 /* the following are legal events.  they are sent as needed to any watch */
 #define IN_UNMOUNT     0x00002000  /* Backing fs was unmounted */
@@ -64,7 +65,7 @@ struct inotify_event {
 #define IN_ALL_EVENTS  (IN_ACCESS | IN_MODIFY | IN_ATTRIB | IN_CLOSE_WRITE | \
             IN_CLOSE_NOWRITE | IN_OPEN | IN_MOVED_FROM | \
             IN_MOVED_TO | IN_DELETE | IN_CREATE | IN_DELETE_SELF | \
-            IN_MOVE_SELF)
+            IN_MOVE_SELF | IN_SYNC)

 /* Flags for sys_inotify_init1.  */
 #define IN_CLOEXEC O_CLOEXEC
diff --git a/mm/msync.c b/mm/msync.c
index 632df45..b1665ac 100644
--- a/mm/msync.c
+++ b/mm/msync.c
@@ -13,6 +13,7 @@
 #include &lt;linux/file.h&gt;
 #include &lt;linux/syscalls.h&gt;
 #include &lt;linux/sched.h&gt;
+#include &lt;linux/fsnotify.h&gt;

 /*
  * MS_SYNC syncs the entire file - including mappings.
@@ -83,6 +84,9 @@ SYSCALL_DEFINE3(msync, unsigned long, start, size_t, len, int, flags)
            get_file(file);
            up_read(&amp;mm-&gt;mmap_sem);
            error = vfs_fsync(file, 0);
+               if (!error)
+                   fsnotify_sync(file-&gt;f_path.dentry);
+
            fput(file);
            if (error || start &gt;= end)
                goto out;
--
1.8.2
</code></pre>

<p>Patch has been tested on v2.6.37 of the Linux Kernel.</p>
"
"<p>You could mprotect the corresponding page in RAM (set it read-only) and catch the SIGSEGV signal when a write fails.  In the signal handler, you would need to set the RAM read-write to allow the write to succeed (this is basically reacting to page faults in user-space).  And then, you would need to re-protect the RAM to detect the next writes.</p>

<p>This is hard core C code which is architecture specific (not portable) but I did it in the past (in 2001 on Intel Pentium servers).  This was x86 specific so I am not sure how to do this with x86_64.  I could do some archaeology in my archives to orient you in the right direction if needed (post a comment and I will dive in my old code).</p>
"
"<p>oop, just figured it out by poking around the kernel and looking at other drivers (don't know why it didn't occur to me to do that before). In case anyone else is interested you can get the inode from the file pointer passed into the ioctl as such:</p>

<pre><code>long can_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
    struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
</code></pre>

<p>If anyone knows why this is a bad idea (I just took it from another driver), or if there's a better/preferred way let me know. </p>
"
"<p>You can get the inode from struct file * file in the kernel space. here is the brief struct map</p>

<p>file->f_path.d.dentry->d_inode; you can find the definition followed. </p>

<p>for dentry struct in dcache.h</p>

<pre><code>struct dentry {
    atomic_t d_count;
    unsigned int d_flags;       /* protected by d_lock */
    spinlock_t d_lock;      /* per dentry lock */
    int d_mounted;
    struct inode *d_inode;      /* Where the name belongs to - NULL is
                                 * negative */
    /*
     * The next three fields are touched by __d_lookup.  Place them here
     * so they all fit in a cache line.
     */
    struct hlist_node d_hash;   /* lookup hash list */
</code></pre>

<p>for the file structure in fs.h </p>

<pre><code> file {
           /*
            * fu_list becomes invalid after file_free is called and queued via
            * fu_rcuhead for RCU freeing
            */
           ...
           struct path             f_path;
           #define f_dentry        f_path.dentry
           #define f_vfsmnt        f_path.mnt
           const struct file_operations    *f_op;
           spinlock_t              f_lock;  /* f_ep_links, f_flags, no IRQ */
           #ifdef CONFIG_SMP
</code></pre>
"
"<p>The macro <code>access_ok</code> returns 0 <strong>if the block is invalid</strong> and nonzero if it may be valid. So in your test, if the block is valid you immediately return <code>-EIO</code>. The way things look, you might want to negate the result of <code>access_ok</code>, something like:</p>

<pre><code>if (!access_ok(...))
</code></pre>
"
"<p>Hm.. <code>linux-3.6.2/fs/namei.c</code> contains many similar situations. For example, the <code>rename</code> syscall is actually defined as</p>

<pre><code>SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
{
    return sys_renameat(AT_FDCWD, oldname, AT_FDCWD, newname);
}
</code></pre>

<p>In other words, there is no problem in calling a syscall from another syscall. The issue is that the pointer arguments are <em>userspace</em> pointers, whereas you're trying to supply a <em>kernel</em> pointer: your <code>fileName</code> should be allocated in userspace, but yours is in kernelspace.</p>

<p>The correct solution is to factor out the common code from the two functions (yours and <code>sys_renameat()</code> in <code>fs/namei.c</code>), then call the function from both syscalls. Assuming you're not trying to get this included upstream -- if you are, then it is refactoring and rethinking time --, you can trivially copy the contents of <code>sys_renameat</code> into your own function; it's not that big. It's also a useful point to familiarize yourself with the necessary checks and locking needed for filesystem operations such as this.</p>

<hr>

<p>Edited in an effort to explain the issue and the solution:</p>

<p>In a very real sense, memory allocated by a normal process (<em>userspace</em> memory) and memory allocated by the kernel (<em>kernelspace</em>) are completely separated by the kernel-userspace barrier.</p>

<p>Your code ignores that barrier, and should not work at all. (It probably works somewhat on x86, because the kernel-userspace barrier is easily pierced from the kernel side on that architecture.) You also use a 256 bytes of stack for a file name, which is a no-no: Kernel stack is a very limited resource, and should be used sparingly.</p>

<p>A normal process (<em>userspace process</em>) cannot access any kernel memory. You can try, it won't work. This is the reason the barrier exists. (There are certain embedded systems that have hardware that simply does not support such a barrier, but let's ignore those for the purposes of this discussion. And remember that even though on x86 the barrier is easily pierced from the kernel side, it does not mean it is not there. Don't be a dick and assume because it seems to work for you, it is somehow correct.)</p>

<p>The nature of the barrier is such that on most architectures, <em>the barrier exists for the kernel, too</em>.</p>

<p>To help kernel programmers, pointers that point across the barrier into userspace, are marked <code>__user</code>. This means you cannot just dereference them and expect them to work; you need to use <code>copy_from_user()</code> and <code>copy_to_user()</code>. It is not just syscall parameters: when you access userspace data from the kernel, you need to use those two functions.</p>

<p>All syscalls work on userspace data. Every pointer you see, is (or should be!) marked <code>__user</code>. Every syscall does all the necessary work to access the data from userspace.</p>

<p>Your problem is that you are trying to supply kernelspace data, <code>inputFile</code>, to a syscall. It will not work, because the syscall will always try to reach through the barrier, but <code>inputFile</code> is on the same side of the barrier!</p>

<p>There is really no sane way to copy <code>inputFile</code> to the other side of the barrier. I mean, of course there are ways it can be done, and it is not even that difficult, but it just would not be sane.</p>

<p>So, let us explore the correct solution I described above, and which footy has already rejected once.</p>

<p>First of all, let's see what the <code>renameat</code> syscall actually looks like in current (3.6.2) Linux kernel (remember that this code is licensed under GPLv2). The <code>rename</code> syscall simply calls it using <code>sys_renameat(AT_FDCWD, oldname, AT_FDCWD, newname)</code>. I'll insert my explanations of what the code does:</p>

<pre><code>SYSCALL_DEFINE4(renameat, int, olddfd, const char __user *, oldname,
                int, newdfd, const char __user *, newname)
{
        struct dentry *old_dir, *new_dir;
        struct dentry *old_dentry, *new_dentry;
        struct dentry *trap;
        struct nameidata oldnd, newnd;
        char *from;
        char *to;
        int error;
</code></pre>

<p>In the kernel, stack is a limited resource. You can use quite a few variables, but any local arrays would be a serious problem. The above local variable list is pretty much the largest you'll see in a typical syscall.</p>

<p>For the rename call, the function must locate the parent directories containing the file names first:</p>

<pre><code>        error = user_path_parent(olddfd, oldname, &amp;oldnd, &amp;from);
        if (error)
                goto exit;
</code></pre>

<p>Note: after this point, the old directory and path must be released after use by calling <code>path_put(&amp;oldnd.path); putname(from);</code>.</p>

<pre><code>        error = user_path_parent(newdfd, newname, &amp;newnd, &amp;to);
        if (error)
                goto exit1;
</code></pre>

<p>Note: after this point, the new directory and path must be released after use by calling <code>path_put(&amp;newnd.path); putname(to);</code>.</p>

<p>The next step is to check the two reside on the same filesystem:</p>

<pre><code>        error = -EXDEV;
        if (oldnd.path.mnt != newnd.path.mnt)
                goto exit2;
</code></pre>

<p>The last component in the directories must be a normal directory:</p>

<pre><code>        old_dir = oldnd.path.dentry;
        error = -EBUSY;
        if (oldnd.last_type != LAST_NORM)
                goto exit2;

        new_dir = newnd.path.dentry;
        if (newnd.last_type != LAST_NORM)
                goto exit2;
</code></pre>

<p>and the mount containing the directories must be writable. Note that this will apply a lock to the mount if successful, and must then be always paired with a <code>mnt_drop_write(oldnd.path.mnt)</code> call before the syscall returns.</p>

<pre><code>        error = mnt_want_write(oldnd.path.mnt);
        if (error)
                goto exit2;
</code></pre>

<p>Next, the nameidata lookup flags are updated to reflect that the directories are already known:</p>

<pre><code>        oldnd.flags &amp;= ~LOOKUP_PARENT;
        newnd.flags &amp;= ~LOOKUP_PARENT;
        newnd.flags |= LOOKUP_RENAME_TARGET;
</code></pre>

<p>Next, the two directories are locked for the duration of the rename. This must be paired with the corresponding unlock call, <code>unlock_rename(new_dir, old_dir)</code>.</p>

<pre><code>        trap = lock_rename(new_dir, old_dir);
</code></pre>

<p>Next, the actual existing file is looked up. If this is successful, the dentry must be released by calling <code>dput(old_dentry)</code>:</p>

<pre><code>        old_dentry = lookup_hash(&amp;oldnd);
        error = PTR_ERR(old_dentry);
        if (IS_ERR(old_dentry))
                goto exit3;
        /* source must exist */
        error = -ENOENT;
        if (!old_dentry-&gt;d_inode)
                goto exit4;
        /* unless the source is a directory trailing slashes give -ENOTDIR */
        if (!S_ISDIR(old_dentry-&gt;d_inode-&gt;i_mode)) {
                error = -ENOTDIR;
                if (oldnd.last.name[oldnd.last.len])
                        goto exit4;
                if (newnd.last.name[newnd.last.len])
                        goto exit4;
        }
        /* source should not be ancestor of target */
        error = -EINVAL;
        if (old_dentry == trap)
                goto exit4;
</code></pre>

<p>The entry for the new filename is also looked up (it may exist, after all). Again, if successful, this dentry must also be released using <code>dput(new_dentry)</code> afterwards:</p>

<pre><code>        new_dentry = lookup_hash(&amp;newnd);
        error = PTR_ERR(new_dentry);
        if (IS_ERR(new_dentry))
                goto exit4;
        /* target should not be an ancestor of source */
        error = -ENOTEMPTY;
        if (new_dentry == trap)
                goto exit5;
</code></pre>

<p>At this point, the function has ascertained that everything is in order. Next, it must check if the operation may proceed (with respect to access modes et cetera), by calling <code>security_path_rename(struct path *old_dir, struct dentry *old_dentry, struct path *new_dir, struct dentry *new_dentry)</code>. (The identity details of the userspace process are maintained in <code>current</code>.)</p>

<pre><code>        error = security_path_rename(&amp;oldnd.path, old_dentry,
                                     &amp;newnd.path, new_dentry);
        if (error)
                goto exit5;
</code></pre>

<p>If there was no objection to the rename, then the actual rename can be done using <code>vfs_rename(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry)</code>:</p>

<pre><code>        error = vfs_rename(old_dir-&gt;d_inode, old_dentry,
                           new_dir-&gt;d_inode, new_dentry);
</code></pre>

<p>At this point, all the work is done (successfully if <code>error</code> is zero), and the only thing left is to release the various lookups</p>

<pre><code>exit5:
        dput(new_dentry);
exit4:
        dput(old_dentry);
exit3:
        unlock_rename(new_dir, old_dir);
        mnt_drop_write(oldnd.path.mnt);
exit2:
        path_put(&amp;newnd.path);
        putname(to);
exit1:
        path_put(&amp;oldnd.path);
        putname(from);
exit:
        return error;
}
</code></pre>

<p>That's it for the rename operation. As you can see, there is no explicit <code>copy_from_user()</code> to be seen. The <code>user_path_parent()</code> calls <code>getname()</code> which calls <code>getname_flags()</code>, which does it. If you ignore all the necessary checking, it boils down to</p>

<pre><code>char *result = __getname();  /* Reserve PATH_MAX+1 bytes of kernel memory for one file name */
in    len;

len = strncpy_from_user(result, old/newname, PATH_MAX);
if (len &lt;= 0) {
    __putname(result);
    /* An error occurred, abort! */
}

if (len &gt;= PATH_MAX) {
    __putname(result);
    /* path is too long, abort! */
}

/* Finally, add it to the audit context for the current process. */
audit_getname(result);
</code></pre>

<p>and, after it is no longer needed,</p>

<pre><code>putname(result);
</code></pre>

<p>So, footy, there is no simple solution to your problem. There is no single function call that will magically make your syscall work. You will have to rewrite it, looking at how the stuff is properly done in <code>fs/namei.c</code>. It is not difficult, but you must be careful and meticulous to do it -- and most of all accept that an approach of ""just trying to get this simple thing work with minimal changes"" will not work for this.</p>
"
"<p>I wanted to show exactly how the correct way to achieve what footy wants, but my original answer grew too long, I decided to put the solution in a separate answer. I'll split the code into parts, and explain what each fragment does.</p>

<p>Remember that since we reuse kernel code, the code in this post and the resulting function must be licensed under the GPLv2 license.</p>

<p>First, we start by declaring a one-parameter syscall.</p>

<pre><code>SYSCALL_DEFINE1(myfunc, const char __user *, oldname)
{
</code></pre>

<p>In the kernel, stack space is a scarce resource. You do not create local arrays; you always use dynamic memory management. Fortunately, there are some very useful functions like <code>__getname()</code>, so it is very little additional code. The important thing is to remember to release whatever memory you use when you are done with it.</p>

<p>As this syscall is basically a variant of <code>rename</code>, we reuse almost all of the <code>fs/namei.c:sys_renameat()</code> code. First, the local variable declarations. There are a lot, too; as I said, stack is scarce in kernel, and you won't see much more local variables than this in any syscall function:</p>

<pre><code>    struct dentry *old_dir, *new_dir;
    struct dentry *old_dentry, *new_dentry;
    struct dentry *trap;
    struct nameidata oldnd, newnd;
    char *from;
    char *to = __getname();
    int error;
</code></pre>

<p>The first change to the <code>sys_renameat()</code> is on the <code>char *to = __getname();</code> line above, already. It allocates <code>PATH_MAX+1</code> bytes dynamically, and must be released using <code>__putname()</code> after it is no longer needed. This is the correct way to declare a temporary buffer for a file or directory name.</p>

<p>To construct the new path (<code>to</code>), we also need to be able to access the old name (<code>from</code>) directly. Because of the kernel-userspace barrier, we cannot just access <code>oldname</code> directly. So, we create an in-kernel copy of it:</p>

<pre><code>    from = getname(oldname);
    if (IS_ERR(from)) {
        error = PTR_ERR(from);
        goto exit;
    }
</code></pre>

<p>Although many C programmers have been taught that <code>goto</code> is evil, this is the exception: error handling. Instead of having to remember all the cleanup we need to do (and we already need to do <code>__putname(to)</code> at minimum), we put the cleanup at the end of the function, and skip to the correct point, <code>exit</code> being the last one. <code>error</code> holds the error number, of course.</p>

<p>At this point of our function, we can access <code>from[0]</code> up to the first <code>'\0'</code>, or up to (and including) <code>from[PATH_MAX]</code>, whichever is first. It is a normal kernel-side data, and is accessed in the ordinary fashion you would in any C code.</p>

<p>You also have reserved the memory for the new name as <code>to[0]</code> up to and including <code>to[PATH_MAX]</code>. Remember to make sure it too is terminated using <code>\0</code> (in <code>to[PATH_MAX] = '\0'</code> or an earlier index).</p>

<p>After constructing the contents for <code>to</code>, we need to do the path lookups. Unlike <code>renameat()</code>, we cannot use <code>user_path_parent()</code>. We can, however, look at what <code>user_path_parent()</code> does, and do the same work -- adapting to our own needs, of course. It turns out it just calls <code>do_path_lookup()</code> with error checking. So, the two <code>user_path_parent()</code> calls and their error checks can be replaced with</p>

<pre><code>    error = do_path_lookup(AT_FDCWD, from, LOOKUP_PARENT, &amp;oldnd);
    if (error)
        goto exit0;

    error = do_path_lookup(AT_FDCWD, to, LOOKUP_PARENT, &amp;newnd);
    if (error)
        goto exit1;
</code></pre>

<p>Note that <code>exit0</code> is a new label not found in the original <code>renameat()</code>. We need a new label because at <code>exit</code>, we only have <code>to</code>; but at <code>exit0</code>, we have both <code>to</code> and <code>from</code>. After <code>exit0</code>, we have <code>to</code>, <code>from</code>, and <code>oldnd</code>, and so on.</p>

<p>Next, we can reuse the bulk of <code>sys_renameat()</code>. It does all the hard work at renaming. To conserve space, I'll omit my ramblings on exactly what it does, since you can trust that if <code>rename()</code> works, it'll work too.</p>

<pre><code>    error = -EXDEV;
    if (oldnd.path.mnt != newnd.path.mnt)
        goto exit2;

    old_dir = oldnd.path.dentry;
    error = -EBUSY;
    if (oldnd.last_type != LAST_NORM)
        goto exit2;

    new_dir = newnd.path.dentry;
    if (newnd.last_type != LAST_NORM)
        goto exit2;

    error = mnt_want_write(oldnd.path.mnt);
    if (error)
        goto exit2;

    oldnd.flags &amp;= ~LOOKUP_PARENT;
    newnd.flags &amp;= ~LOOKUP_PARENT;
    newnd.flags |= LOOKUP_RENAME_TARGET;

    trap = lock_rename(new_dir, old_dir);

    old_dentry = lookup_hash(&amp;oldnd);
    error = PTR_ERR(old_dentry);
    if (IS_ERR(old_dentry))
        goto exit3;
    /* source must exist */
    error = -ENOENT;
    if (!old_dentry-&gt;d_inode)
        goto exit4;
    /* unless the source is a directory trailing slashes give -ENOTDIR */
    if (!S_ISDIR(old_dentry-&gt;d_inode-&gt;i_mode)) {
        error = -ENOTDIR;
        if (oldnd.last.name[oldnd.last.len])
            goto exit4;
        if (newnd.last.name[newnd.last.len])
            goto exit4;
    }
    /* source should not be ancestor of target */
    error = -EINVAL;
    if (old_dentry == trap)
        goto exit4;
    new_dentry = lookup_hash(&amp;newnd);
    error = PTR_ERR(new_dentry);
    if (IS_ERR(new_dentry))
        goto exit4;
    /* target should not be an ancestor of source */
    error = -ENOTEMPTY;
    if (new_dentry == trap)
        goto exit5;

    error = security_path_rename(&amp;oldnd.path, old_dentry,
                     &amp;newnd.path, new_dentry);
    if (error)
        goto exit5;

    error = vfs_rename(old_dir-&gt;d_inode, old_dentry,
                   new_dir-&gt;d_inode, new_dentry);
</code></pre>

<p>At this point, all the work has been done, and only releasing the locks, memory, and so on taken by the code above, is left. If everything was successful at this point, <code>error == 0</code>, and we do all cleanup. If we had a problem, <code>error</code> contains the error code, and we have jumped to the correct label to do the cleanup necessary to the point where the error occurred. If the <code>vfs_rename()</code> failed -- it does the actual operation --, we doo all cleanup.</p>

<p>However, compared to the original code, we got hold of <code>from</code> very first (<code>exit</code>), <code>to</code> just after (<code>exit0</code>), followed by the dentry lookups. So, we need to move releasing them to their correct locations (near the very end, since they were done first. Cleanups occur, of course, in the reverse order):</p>

<pre><code>exit5:
    dput(new_dentry);
exit4:
    dput(old_dentry);
exit3:
    unlock_rename(new_dir, old_dir);
    mnt_drop_write(oldnd.path.mnt);
exit2:
    path_put(&amp;newnd.path);
exit1:
    path_put(&amp;oldnd.path);
exit0:
    putname(from);
exit:
    __putname(to);
    return error;
}
</code></pre>

<p>And here we are done.</p>

<p>Of course, there are a lot of details to consider above in the parts we copied from <code>sys_renameat()</code> -- and like I said in the other answer, you should not just copy code like this, but refactor the common code into a helper function; that makes maintenance much easier. Fortunately, because we kept all the checks from <code>renameat()</code> -- we do the path manipulation before any of the <code>renameat()</code> code was copied -- we can be sure that all the necessary checks are done. It's just as if the user specified the manipulated path herself and called <code>renameat()</code>.</p>

<p>If you were to do the modification after some checks have already been done, the situation would be much more complicated. You would have to think what those checks are, how your modifications impact on them, and almost always, re-do those checks.</p>

<p>To remind any reader, the reason you cannot just create a filename or any other string in your own syscall and then call another syscall, is that your just-created string resides on the kernel side of the kernel-userspace boundary, while syscalls expect the data to reside on the other, userspace side. While on x86 you can accidentally pierce the boundary from the kernel side, it does not mean you should do so: there are <code>copy_from_user()</code> and <code>copy_to_user()</code> and their derivatives like <code>strncpy_from_user()</code> that <strong>must</strong> be used for this purpose. It is not a question of having to do magic to call another syscall, but about where (in-kernel, or userspace) the data supplied is.</p>
"
"<p>I think you can do it easily with <code>write</code> system call.  The process is </p>

<ol>
<li>Using <code>write</code> write NULL values to all the bytes of a given file</li>
<li>Delete the file using <code>unlink</code>. </li>
</ol>
"
"<p>There's no good answer here, and certainly not at the level of an individual file.  On simple filesystems (FAT, ext2) it's generally sufficient to simply open the file and overwrite it.  But that fails on almost all modern systems.  Modern filesystems can almost always be configured to journal data changes (though this is rarely default) and that data will live on in the journal until it happens to be overwritten in the future.  Even if you know the filesystem has ""forgotten"" the data the storage system may not -- consider the case of live backups, or of offlining a LVM volume.   Or the driver: NAND drivers routinely remap blocks as they are written, leaving ""stale"" content in place.  Or even the hardware itself: flash technologies like SSDs or MMC do exactly the same kind of block remapping, leaving your old data present for reads via JTAG, etc...</p>

<p>If you want to be sure that your data isn't on persistent storage, the only clean solution in the modern world is never to write it there in the first place.  Cache it in RAM, or write it to a tmpfs (that isn't backed by swap!), or come up with some kind of encryption scheme that makes sure storage compromise won't make it available to an attacker...</p>
"
"<p>Others have discussed the actual situation quite well, so I won't go there (and therefore don't bother modding this answer up, please). I just wanted to describe the code that confuses the OP.</p>

<p>First, this code is a snippet from <code>fs/namei.c:vfs_unlink()</code>:</p>

<pre><code>error = security_inode_unlink(dir, dentry);
if (!error) {
    error = dir-&gt;i_op-&gt;unlink(dir, dentry);
    if (!error)
        dont_mount(dentry);
}
</code></pre>

<p>The <code>security_inode_unlink()</code> call first checks if the <code>current</code> (the current userspace process) has the required rights to remove directory entry <code>dentry</code> from directory <code>dir</code>.</p>

<p>Since Linux supports a number of different filesystems, and each filesystem (may) have their own inode operations, those operations are stored as function pointers in the struct inode (<code>dir</code>), <code>i_op</code> member structure. (Remember that a directory is very similar to a file, in that it contains the metadata for all entries contained in that directory. So having the operations be specific to a directory makes a lot of sense.)</p>

<p>The <code>dir-&gt;i_op-&gt;unlink(dir, entry);</code> simply calls the <code>unlink()</code> function for the directory <code>dir</code>. (Note that the <code>fs/inode.c:vfs_unlink()</code> does check that <code>dir-&gt;i_op-&gt;unlink</code> is non-NULL, before the snippet shown above.)</p>

<p>The final bit, <code>dont_mount(entry);</code>, is a helper function defined in <code>include/linux/dcache.h</code>, and simply marks <code>entry</code> to be ""un-mountable"", not accessible. (Directory entries are cached in dcache. Instead of having to ream the entry out of it, possibly a slow operation, this just marks it invalid. Sometime soon in the future, all stale dcache entries will be removed at once. It's very efficient this way, and quite simple, too, if you think about it.)</p>

<hr>

<p>Sorry. I cannot help myself; I must add my spoon to the soup.</p>

<p>The problem is rather easy to solve, if you break it into manageable steps. If we assume this is for experimentation and learning only, not for security purposes -- for security you need <em>scrubbing</em>, not just clearing the contents --, then you need to do <code>open()</code>+<code>lseek()</code>+<code>ftruncate()</code>+<code>close()</code>, just in-kernel, right?</p>

<p>You don't want to use <code>write()</code>, because the filesystem-specific write functions require an userspace buffer. You'd need to allocate one (say, one page in length -- look at <code>mm/mmap.c:sys_old_mmap()</code> which calls the arch-specific <code>sys_mmap_pgoff()</code>), fill it with the data, write it into the file in a loop, then release the userspace buffer (using <code>mm/mmap.c:vm_munmap()</code>). Such a busy kernel loop is a big no-no; you'd need to move it into a worker thread..</p>

<p>No, it is much better to simply find out the length of the file, then truncate it to zero length, and re-truncate it to the desired length. That is the same as if you wrote zeros into it. Replacing the contents with anything but zero is just too much work, IMO.</p>

<p>For <code>open()</code>, call <code>filp_open()</code>. Remember, you only need the resulting <code>struct file *myfile</code>, not a file descritor, to manipulate a file in kernelspace.</p>

<p>For <code>close()</code>, you just call <code>filp_close(myfile, current-&gt;files)</code>. If you omit the file descriptor maintenance stuff for the <code>current</code> process, that is really the only thing left from <code>fs/open.c:sys_close()</code>.</p>

<p>For <code>lseek()</code>, you can just call <code>loff_t file_length = vfs_lseek(myfile, (off_t)0, SEEK_END);</code>. If you look at <code>fs/read_write.c:sys_lseek()</code>, that's what it does, after all.</p>

<p>For <code>ftruncate()</code>, look at <code>fs/open.c:do_sys_ftruncate()</code>, but remember to omit the file descriptor stuff. You already have the <code>struct file *myfile</code>, corresponding to the <code>struct file *file</code> in that function. Oh, and do remember you need to do it twice: first to zero length, then to <code>file_length</code> you obtained above.</p>

<p>Combining all the above seems to be a pretty feasible way to accomplish this -- assuming we all agree it is only useful for learning and experimentation, nothing practical.</p>

<p>Note that I did not really spend the time necessary to check all four syscalls (<code>sys_open()</code>, <code>sys_lseek()</code>, <code>sys_ftruncate()</code>, <code>sys_close()</code>) to check if there are any locking issues or race conditions I overlooked. You really should do that, because otherwise your experiment may oops your kernel (typical for race conditions). Do what I did, and start at the syscalls, then look at the functions -- and especially their comments, they usually mention if there are any locking requirements to calling that function -- to find out.</p>
"
"<p>You can get the minor number like so:</p>

<pre><code>iminor(filp-&gt;f_path.dentry-&gt;d_inode)
</code></pre>
"
"<p>Did you understand the <a href=""http://git.kernel.org/?p=linux/kernel/git/bwh/linux-3.2.y.git;a=blob;f=fs/namei.c;hb=HEAD"" rel=""nofollow""><code>fs/namei.c:do_unlinkat()</code></a> function at all? It does exactly what you want, except that it uses</p>

<pre><code>     error = user_path_parent(dfd, pathname, &amp;nd, &amp;name);
     if (error)
         return error;
</code></pre>

<p>to look up the <code>struct nameidata</code>. If successful, the kernel-side copy of <code>pathname</code> will be stored in <code>name</code> (which has to be freed using <code>putname(name)</code>).</p>

<p>However, the same file contains the implementation for the <code>user_path_parent()</code> function, too. It is very simple, so you should have no trouble understanding what it does. Indeed, aside from copying the userspace-<code>pathname</code> to kernel-side <code>name</code>, it really just does a <code>do_path_lookup()</code> call, which operates solely on kernel-side structures.</p>

<p>Using the above, you can make minor modifications to <code>do_unlinkat()</code> to implement your own kernel-side <code>unlinkat()</code> function. If this is code you hope will someday be accepted upstream, you should also refactor the two functions so that there is no repeated code. Perhaps something along the lines of</p>

<pre><code>/*
 * Make sure that the actual truncation of the file will occur outside its
 * directory's i_mutex.  Truncate can take a long time if there is a lot of
 * writeout happening, and we don't want to prevent access to the directory
 * while waiting on the I/O.
 */
static long kern_unlinkat(int dfd, const char *name)
{
    long error;
    struct dentry *dentry;
    struct nameidata nd;
    struct inode *inode = NULL;

    error = do_path_lookup(dfd, name, LOOKUP_PARENT, &amp;nd);
    if (error)
        return error;

    error = -EISDIR;
    if (nd.last_type != LAST_NORM)
        goto exit1;

    nd.flags &amp;= ~LOOKUP_PARENT;
    error = mnt_want_write(nd.path.mnt);
    if (error)
        goto exit1;

    mutex_lock_nested(&amp;nd.path.dentry-&gt;d_inode-&gt;i_mutex, I_MUTEX_PARENT);
    dentry = lookup_hash(&amp;nd);
    error = PTR_ERR(dentry);
    if (!IS_ERR(dentry)) {
        /* Why not before? Because we want correct error value */
        if (nd.last.name[nd.last.len])
            goto slashes;
        inode = dentry-&gt;d_inode;
        if (!inode)
            goto slashes;
        ihold(inode);
        error = security_path_unlink(&amp;nd.path, dentry);
        if (error)
            goto exit2;
        error = vfs_unlink(nd.path.dentry-&gt;d_inode, dentry);
exit2:
        dput(dentry);
    }
    mutex_unlock(&amp;nd.path.dentry-&gt;d_inode-&gt;i_mutex);
    if (inode)
        iput(inode);    /* truncate the inode here */
    mnt_drop_write(nd.path.mnt);
exit1:
    path_put(&amp;nd.path);
    return error;

slashes:
    error = !dentry-&gt;d_inode ? -ENOENT :
        S_ISDIR(dentry-&gt;d_inode-&gt;i_mode) ? -EISDIR : -ENOTDIR;
    goto exit2;
}

static long do_unlinkat(int dfd, const char __user *pathname)
{
    long error;
    char *name = getname(pathname);

    if (IS_ERR(name))
        return PTR_ERR(name);

    error = kern_unlinkat(dfd, name);

    putname(name);

    return error;
}

EXPORT_SYMBOL(kern_unlink);
</code></pre>

<p>If the above works -- I didn't bother to test it; all that is up to you --, then you can use <code>kern_unlinkat(directoryfd, pathname)</code> or <code>kern_unlinkat(AT_FDCWD, pathname)</code> in your own kernel module to remove a file by specifying its pathname in a kernel-side string <code>pathname</code>.</p>

<p>If you already have the nameidata, then you can obviously change the above to match what code is common and what is not. But, considering the trickyness of the details (dentry locking in particular), I'd just use the pathname if I were you.</p>

<p>Happy hacking, and good luck.</p>
"
"<p>The EXT4_I() <a href=""http://lxr.linux.no/#linux+v3.2/fs/ext4/ext4.h#L1258"" rel=""nofollow"">function</a> gets you <em>ext4_inode_info</em> from the VFS inode. But the VFS inode's ctime is exactly the <a href=""http://lxr.linux.no/#linux+v3.2/fs/ext4/ialloc.c#L869"" rel=""nofollow"">same</a> as that of the EXT4 inode. So you might as well access <em>inode->i_ctime</em>.</p>
"
"<p>The <a href=""http://lxr.free-electrons.com/source/fs/proc/internal.h?v=4.0#L61"" rel=""nofollow noreferrer""><code>proc_inode</code> struct</a> and <a href=""http://lxr.free-electrons.com/source/fs/proc/internal.h?v=4.0#L75"" rel=""nofollow noreferrer""><code>PROC_I</code> macro</a> are both internal.  See <a href=""http://lkml.iu.edu/hypermail/linux/kernel/1304.2/00394.html"" rel=""nofollow noreferrer"">[PATCH 27/28] proc: Make the PROC_I() and PDE() macros internal toprocfs [RFC]</a>.</p>

<p>Instead, what about iterating over the inode's dentry list?  You could use <a href=""https://stackoverflow.com/q/17216856/196844"">dentry_path_raw()</a> to find a <code>/*/fd/*</code> path name:</p>

<pre class=""lang-c prettyprint-override""><code>//struct inode *proc_inode;

struct dentry *dentry;
pid_t pid;
int found_match = 0;

printk(KERN_DEBUG ""superblock type name: %s\n"", proc_inode-&gt;i_sb-&gt;s_type-&gt;name);

// An inode's dentry list is protected by the i_lock. See:
// - ""dcache-&gt;d_inode-&gt;i_lock protects: i_dentry, d_u.d_alias, d_inode of aliases""
//   http://lxr.free-electrons.com/source/fs/dcache.c?v=4.0#L48
// - The implementation of d_prune_aliases()
//   http://lxr.free-electrons.com/source/fs/dcache.c?v=4.0#L882
spin_lock(&amp;proc_inode-&gt;i_lock);
hlist_for_each_entry(dentry, &amp;proc_inode-&gt;i_dentry, d_u.d_alias) {
    char buf[64];
    const char *path_raw;
    char c;

    path_raw = dentry_path_raw(dentry, buf, sizeof(buf));

    // dentry_path_raw() places the path into `buf'. If `buf' is not large
    // enough, then continue on to the next dentry.
    if (!(buf &lt;= path_raw &amp;&amp; path_raw &lt;= buf + sizeof(buf) - 1)) {
        printk(KERN_DEBUG ""`buf' not large enough, dentry_path_raw() returned %ld\n"", PTR_ERR(path_raw));
        continue;
    }

    printk(KERN_DEBUG ""path_raw = %s\n"", path_raw);

    // We're looking to match: ^/(\d*)/fd/

    if (*path_raw++ != '/') continue;

    pid = 0;
    for (c = *path_raw; c; c = *++path_raw) {
        if ('0' &lt;= c &amp;&amp; c &lt;= '9') {
            pid = 10 * pid + (c - '0');
        } else {
            break;
        }
    }

    if (*path_raw++ != '/') continue;
    if (*path_raw++ != 'f') continue;
    if (*path_raw++ != 'd') continue;
    if (*path_raw != '/' &amp;&amp; *path_raw != '\0') continue;

    // Found a match. Break the dentry list loop.
    found_match = 1;
    printk(KERN_DEBUG ""breaking dentry list loop\n"");
    break;
}
spin_unlock(&amp;proc_inode-&gt;i_lock);

if (found_match) {
    printk(KERN_DEBUG ""pid = %d\n"", (int)pid);
}
</code></pre>

<p><strong>EDIT:</strong> I have uploaded a demonstration project to GitHub:<br>
<a href=""https://github.com/dtrebbien/so16317923-proc-fs-kernel-module"" rel=""nofollow noreferrer"">https://github.com/dtrebbien/so16317923-proc-fs-kernel-module</a></p>
"
"<p>In recent kernels you won't find create_proc_entry() anymore, it's been removed completely. Take a look at <a href=""https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=80e928f7ebb958f4d79d4099d1c5c0a015a23b93"" rel=""nofollow"">https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=80e928f7ebb958f4d79d4099d1c5c0a015a23b93</a>. So, you need to use proc_create(). And, pass ->proc_net as parent directory entry. Take a look at this: <a href=""https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/ipv4/proc.c#n479"" rel=""nofollow"">https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/net/ipv4/proc.c#n479</a>, this will give you a clear idea.</p>

<p>If you're not using a latest kernel, then you might have create_proc_entry(), therefore might consider using create_proc_entry(), rather proc_create(). But, I think it's best if you cope with current approach. Cause you won't get support for create_proc_entry() with latest kernels.</p>
"
"<p>I think the way to do it is :</p>

<p>proc_file = create_proc_entry(""test"", 0644, init_net.proc_net);</p>
"
"<p>You must not use that construction to search for the inode; the file or even directory might have been deleted after the file was opened.</p>

<p>The kernel convention (see chapter 3 of <a href=""http://lwn.net/Kernel/LDD3/"" rel=""nofollow"">Linux Device Drivers</a>) is that</p>

<ol>
<li><p>in your <code>open</code> function, you look up your own data from the inode (or allocate your own data), and set the <code>file-&gt;private_data</code> pointer; and</p></li>
<li><p>in your <code>read</code> function, you then use <code>file-&gt;private_data</code> to access your own stuff.</p></li>
</ol>
"
"<p><code>lseek()</code> as implemented in <code>ext4</code> will just increment the file pointer and do some validation checks. It doesn't depend on the file size, meaning it is <code>O(1)</code>.</p>

<p>Also you can see this in the code, there isn't any loop nor suspicious function calls in there.</p>

<p>However, while this is true on <code>ext4</code>, it might be not true for other filesystems, as this behaviour isn't guaranteed by POSIX. But it is likely unless the filesystem is meant for a very special purpose.</p>
"
"<p><code>lseek</code>'s complexity depends on the representation of file in your system. On most modern systems a file is organized by some clever tree-like data structure resulting into <code>seek</code> being executed in time <code>O(logx(n))</code>, where n is the size of the file and x some system depending number.</p>
"
"<p>Yes, the OS already knows how to find any particular byte in the file.</p>

<p>No, it's not guaranteed to be O(1). The code you posted is O(1), but other filesystems' code might not be.</p>

<p>Yes, it will be fast enough, unless the OS or filesystem is terrible.</p>
"
"<p>You are looking for <code>filp_open</code> function. From file <code>include/linux/fs.h</code>:</p>

<pre><code>struct file *filp_open(const char *filename, int flags, umode_t mode);
</code></pre>

<p>Here is a link to function source and documentation: <a href=""http://lxr.free-electrons.com/source/fs/open.c#L937"" rel=""nofollow noreferrer"">http://lxr.free-electrons.com/source/fs/open.c#L937</a></p>

<p>If you really need FD, you can use <code>sys_open</code> (not exported in newer kernels):</p>

<pre><code>long sys_open(const char __user *filename, int flags, int mode);
</code></pre>

<p>You can find a very good answer on a similar question:
<a href=""https://stackoverflow.com/questions/1184274/how-to-read-write-files-within-a-linux-kernel-module"">How to read/write files within a Linux kernel module?</a></p>

<p>Edit (how to get <code>inode</code>):</p>

<p>You can get cached <code>inode</code> from <code>struct file</code>:</p>

<pre><code>struct file *file = ...;
struct inode *inode = file-&gt;inode;
</code></pre>

<p>If you want it with locking: here is a background: <code>Documentation/filesystems/path-lookup.txt</code></p>

<p>The starting point for traversing is <code>current-&gt;fs-&gt;root</code>. There is a number of function in kernel, that already do the work, you can find them in <code>fs/namei.c</code> source file.</p>

<p>There is a function: <code>kern_path</code>:</p>

<pre><code>int error;
struct inode *inode;
struct path path;

error = kern_path(pathname, LOOKUP_FOLLOW, &amp;path);
if (error) ...;

inode = path.dentry-&gt;d_inode;
</code></pre>
"
"<p>Your code is in the dev_ioctl function ?
If so, then</p>

<pre><code>static long dev_ioctl(struct file *file, unsigned cmd, unsigned long arg)
    struct dev_handle *handle;
    struct inode *inode;
    handle = file-&gt;private_data;
    inode = file-&gt;f_inode;
</code></pre>

<p>There seems to be no sane documentation for locking requirements, so you should probably try to dig up similar code and see how it operates on the <code>f_inode</code> member.</p>
"
"<p><a href=""http://lxr.free-electrons.com/source/fs/namei.c#L4089"" rel=""nofollow"">vfs_rename</a> has a comment:</p>

<pre><code>4089 /**
4090  * vfs_rename - rename a filesystem object
4091  * @old_dir:    parent of source
4092  * @old_dentry: source
4093  * @new_dir:    parent of destination
4094  * @new_dentry: destination
4095  * @delegated_inode: returns an inode needing a delegation break
4096  *
4097  * The caller must hold multiple mutexes--see lock_rename()).
4098  *
4099  * If vfs_rename discovers a delegation in need of breaking at either
4100  * the source or destination, it will return -EWOULDBLOCK and return a
4101  * reference to the inode in delegated_inode.  The caller should then
4102  * break the delegation and retry.  Because breaking a delegation may
4103  * take a long time, the caller should drop all locks before doing
4104  * so.
4105  *
4106  * Alternatively, a caller may pass NULL for delegated_inode.  This may
4107  * be appropriate for callers that expect the underlying filesystem not
4108  * to be NFS exported.
4109  */
</code></pre>

<p>So, it brings us to <a href=""http://lxr.free-electrons.com/source/fs/namei.c#L2443"" rel=""nofollow"">lock_rename</a> function:</p>

<pre><code>2440 /*
2441  * p1 and p2 should be directories on the same fs.
2442  */
2443 struct dentry *lock_rename(struct dentry *p1, struct dentry *p2)
2444 {
2445         struct dentry *p;
2446
2447         if (p1 == p2) {
2448                 mutex_lock_nested(&amp;p1-&gt;d_inode-&gt;i_mutex, I_MUTEX_PARENT);
2449                 return NULL;
2450         }
2451
2452         mutex_lock(&amp;p1-&gt;d_inode-&gt;i_sb-&gt;s_vfs_rename_mutex);
2453
2454         p = d_ancestor(p2, p1);
2455         if (p) {
2456                 mutex_lock_nested(&amp;p2-&gt;d_inode-&gt;i_mutex, I_MUTEX_PARENT);
2457                 mutex_lock_nested(&amp;p1-&gt;d_inode-&gt;i_mutex, I_MUTEX_CHILD);
2458                 return p;
2459         }
2460
2461         p = d_ancestor(p1, p2);
2462         if (p) {
2463                 mutex_lock_nested(&amp;p1-&gt;d_inode-&gt;i_mutex, I_MUTEX_PARENT);
2464                 mutex_lock_nested(&amp;p2-&gt;d_inode-&gt;i_mutex, I_MUTEX_CHILD);
2465                 return p;
2466         }
2467
2468         mutex_lock_nested(&amp;p1-&gt;d_inode-&gt;i_mutex, I_MUTEX_PARENT);
2469         mutex_lock_nested(&amp;p2-&gt;d_inode-&gt;i_mutex, I_MUTEX_CHILD);
2470         return NULL;
2471 }
</code></pre>
"
"<p>Read the manual page for stat(2). This is straight from there:</p>

<pre><code>       struct stat {
           dev_t     st_dev;     /* ID of device containing file */
           ino_t     st_ino;     /* inode number */
           mode_t    st_mode;    /* protection */
           nlink_t   st_nlink;   /* number of hard links */
           uid_t     st_uid;     /* user ID of owner */
           gid_t     st_gid;     /* group ID of owner */
           dev_t     st_rdev;    /* device ID (if special file) */
           off_t     st_size;    /* total size, in bytes */
           blksize_t st_blksize; /* blocksize for file system I/O */
           blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
           time_t    st_atime;   /* time of last access */
           time_t    st_mtime;   /* time of last modification */
           time_t    st_ctime;   /* time of last status change */
       };
</code></pre>
"
"<p>The struct inode contains <code>i_ctime</code> (creation) and <code>i_mtime</code> (modification). </p>

<p>If you are in Kernel space and need to get these values for a given path the procedure is like this: </p>

<p>Declare a <code>struct path</code> then call <code>kern_path</code> with a path name to populate the struct, this allows you to access a <code>struct dentry</code> and within here is the <code>struct inode</code>. So <code>path-&gt;dentry-&gt;d_inode</code>. </p>

<p>Once you have a <code>struct inode</code> it's simply accessed like <code>inode-&gt;ctime.tv_sec</code> / <code>inode-&gt;ctime.tv_nsec</code>.</p>

<p>If you need to modify the values some extra work is required as per this proof of concept:</p>

<p><a href=""https://github.com/linuxthor/inode-ctime/blob/master/inode-ctime.c"" rel=""nofollow"">https://github.com/linuxthor/inode-ctime/blob/master/inode-ctime.c</a></p>
"
"<p><em>Thinking outside the box:</em></p>

<p>Assuming it is feasible with your device, you could consider writing a user space driver using <a href=""http://libusb.info/"" rel=""nofollow"">libusb</a> <a href=""http://www.libusb.org"" rel=""nofollow"">(old link)</a> <a href=""http://sourceforge.net/projects/libusb/"" rel=""nofollow"">(SourceForge)</a> or another user space USB library.  Then you can debug easier, develop and test easier, and you gain the added advantage of potential cross-platform compatibility and without needing to deal with writing a kernel driver.</p>
"
"<p>The device driver can create 3 devices as you originally proposed.  If there is a single IRQ on the device, this model is even more apropos.</p>

<p>With a bit of luck and skill (probably more of the latter), the driver's read and write routines need be implemented only as one function for read and one for write with an extra parameter passed, or the read/write routine infers which device it is by inspecting its <code>struct file *</code> parameter (if named <code>f</code>, then <code>MINOR(f -&gt; f_dentry -&gt; d_inode -&gt; i_rdev</code>) gives the device's minor device I.D.   Since you control minor device assignment in your <code>probe()</code> function with <code>device_create()</code>, you can leverage that to have useful type information associated.</p>

<p>In this way, it is easy to avoid ioctl which really <em>should</em> be avoided for simple read and write operations.  That makes it easy to use the device from bash scripts, command line, etc.  If an ioctl is involved, it means a programming language is required to use it.<br>
The man page for <code>ioctl()</code> says</p>

<blockquote>
  <p>The [ioctl] call is used as a catch-all for operations that don't cleanly fit the UNIX stream I/O model.</p>
</blockquote>
"
"<p>I just wrote my own module and I <em>suspect</em> that your issue is that the process calling dev_write expects dev_write to return the number of bytes written. If you don't return the correct number (I see you are returning count - 1), dev_write will be called again and again.</p>

<p>dev_read I have found to be similar - until it returns 0, the process will repeatedly call it - expecting that there are more characters to be retrieved (this makes sense).</p>

<p>I have written/modified a much more simple module that illustrates using a module as a character buffer (sorry, it's quite hastily written). It should allow you to echo a string to it, and return that string when you cat or otherwise read from it. This is demonstrated when you <code>make run</code>. I am sure you will be able to easily modify it to become FIFO. </p>

<p>I don't accept any liability for crashing your kernel or other problems, and you should be using a VM anyway.</p>

<p>It is long, so on my github:</p>

<pre><code>git clone https://github.com/n-hutton/tempRepo
cd tempRepo
make
make run
</code></pre>
"
"<p>Finally I corrected complete code. It is very much immature, illogical for few logics still it works the I would like to do it. @Nathan Hutton helped a lot in improving it and making it work. I thank him for that. Though there are many things I still have one major doubt, if you could trace it in kernel logs, an extra line feed character is added every time whenever you write to a device with (echo ""test"" |cat >/dev/fifo0)
to run it properly you will also need to create 4 char devices with Major number 240, minor 0,1,2,3. mknod can be used as:
""mknod /dev/fifo(0,1,2,3) c 240 (0,1,2,3) -m 777"" //0,1,2,3 at a time and 777 can be modified for granularity. Finally working code:</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/string.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;asm/uaccess.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/unistd.h&gt;
#include &lt;linux/time.h&gt;
#include &lt;linux/semaphore.h&gt;

#define DEVNO 240
#define DEVNAME ""fifo""
MODULE_LICENSE(""GPL"");
DECLARE_WAIT_QUEUE_HEAD(writing1);
//static short writeFlag1=0;
static DEFINE_SEMAPHORE(flag1);
static DEFINE_SEMAPHORE(flag2);
static struct semaphore buffer1_f;
static struct semaphore buffer2_f;
static struct semaphore buffer1_e;
static struct semaphore buffer2_e;

DECLARE_WAIT_QUEUE_HEAD(writing2);
//static short writeFlag2=0;

static char queue1[10]={0};
static short readPos1=0;
static short writePos1=0;
//static short qsize1=0;

static char queue2[10]={0};
static short readPos2=0;
static short writePos2=0;
//static short qsize2=0;

static int times=0;

static int dev_open(struct inode *,struct file *);
static int dev_rls(struct inode *,struct file *);
static ssize_t dev_read(struct file *,char *,size_t,loff_t *);
static ssize_t dev_write(struct file *,const char *,size_t,loff_t *);

static struct file_operations fops={
  .read=dev_read,
  .write=dev_write,
  .open=dev_open,
  .release=dev_rls,
};

int init_module(void){
  unsigned int devno = 240;
  char *devname = ""fifo"";
  int t;
  sema_init(&amp;buffer1_f,0);
  sema_init(&amp;buffer2_f,0);
  sema_init(&amp;buffer1_e,10);
  sema_init(&amp;buffer2_e,10);
  memset(queue1,0,10);
  memset(queue2,0,10);
  t=register_chrdev(devno,devname,&amp;fops);
  if(t&lt;0) printk(KERN_ALERT ""device reg failed. \n"");
  else printk(KERN_ALERT ""Device registered. \n"");
  return t;
}

void cleanup_module(void) {
  unregister_chrdev(240,""fifo"");
  printk(KERN_ALERT ""Device has been removed"");
}

static int dev_open(struct inode *inod, struct file *fil){
  times++;
  printk(KERN_ALERT ""Device opened %d times\n"",times);
  return 0;
}

static ssize_t dev_read(struct file *filep, char *buff, size_t len, loff_t *off) {
  int mode = iminor((filep-&gt;f_dentry-&gt;d_inode));
  short count;
  printk(KERN_ALERT ""Device minor when read : %d\n"", mode);
  if ((mode == 0) || (mode ==2))
      return -EINVAL;
  else if (mode == 1){
    count = 0;
    printk(KERN_ALERT ""Read position1 when read: %d\n"", readPos1);
    while(len) {  //loop untill we have something to write or empty buffer
      if (readPos1==writePos1){
        printk(KERN_ALERT ""Returning chars put to buffer: %d\n"", count);
        return count;
      }
      if (down_interruptible(&amp;buffer1_f)) {
          printk(KERN_ALERT ""flag1 didn't work"");
          return -ERESTARTSYS;
      }
      else {
        if (down_interruptible(&amp;flag1)){
          return -EINVAL;
        }
        else {
          printk(KERN_ALERT ""Read %c\n"",queue1[readPos1]);
          put_user(queue1[readPos1],buff++);
                    if (writePos1==-1) writePos1=readPos1;
          if (readPos1 == 9) readPos1 = 0;
          else readPos1++;
          count++;
        }
        up(&amp;flag1);
      }
      up(&amp;buffer1_e);
    }
    printk(KERN_ALERT ""Read position1 now: %d\t and count%d\n"", readPos1,count);
    return count;
  }
  else if (mode == 3){
    count = 0;
    printk(KERN_ALERT ""Read position2 when read: %d\n"", readPos2);
    while(len) {  //loop untill we have something to write or empty buffer
      if (readPos2==writePos2){
        printk(KERN_ALERT ""Returning chars put to buffer: %d\n"", count);
        return count;
      }
      if (down_interruptible(&amp;buffer2_f)) {
          printk(KERN_ALERT ""flag2 didn't work"");
          return -ERESTARTSYS;
      }
      else {
        if (down_interruptible(&amp;flag2)){
          return -EINVAL;
        }
        else {
          printk(KERN_ALERT ""Read %c\n"",queue2[readPos2]);
          put_user(queue2[readPos2],buff++);
                    if (writePos2==-1) writePos2=readPos2;
          if (readPos2 == 9) readPos2 = 0;
          else readPos2++;
          count++;
        }
        up(&amp;flag2);
      }
      up(&amp;buffer2_e);
    }
    printk(KERN_ALERT ""Read position2 now: %d\t and count%d\n"", readPos2,count);
    return count;
  }
  else {
    printk(KERN_ALERT ""Not correct mode\n"");
    return -1;
  }
}
static char Message[100] = ""Initial message\n"";
static ssize_t dev_write(struct file *filp, const char *buff, size_t len, loff_t *off) {
  int mode;
  int ind;
  ssize_t count = -ENOMEM;
  int i;
  //Let's copy the message onto our stack so we can be clear what we are getting
  for (i = 0; i &lt; 99 &amp;&amp; i &lt; len; i++){
    char getChar;
    get_user(getChar, buff + i);
    Message[i] = getChar;
  }
  Message[i] = '\0';
    printk(KERN_ALERT ""to be written : %s\n"", Message);
  mode = iminor(filp-&gt;f_dentry-&gt;d_inode);
  printk(KERN_ALERT ""Device minor : %d\n"", mode);
  if ((mode == 1) || (mode ==3))
    return -EINVAL;
  else if (mode == 0){
    count = 0;
    ind = 0;
    if (( buff == NULL) ||  (*buff == 0)) {
      return -ENOMEM;
    }
    printk(KERN_ALERT ""Write position1 : %d\n"", writePos1);
    while(ind&lt;len) {  //loop untill we have something to writer
      if (down_interruptible(&amp;buffer1_e)) { //taking flag first isn't right because that won't allow other guyto give access to our turn.
        printk(KERN_ALERT ""buffer1 flag didn't work\t %d"", buffer1_e.count);
        return -ERESTARTSYS;
      }
      else {
        if (down_interruptible(&amp;flag1)){
          up(&amp;buffer1_e);     //must because we couldn't write it properly
          return -EINVAL;
        }
        else {
          queue1[writePos1] = buff[ind];
          printk(KERN_ALERT ""Write ind:%d writepos:%d readpos;%d char:%c\tascii%d\n"",ind,writePos1,readPos1,queue1[writePos1],(int)queue1[writePos1]);
                    if (readPos1==((writePos1+1)%10)) {
                        writePos1=-1;
                    }
          else if (writePos1 == 9){
             writePos1 = 0;
          }
          else
             writePos1++;
          count++;
        }
                printk(KERN_ALERT ""writepos:%d"",writePos1);
        up(&amp;flag1);
      }
      up(&amp;buffer1_f);
      off += count;
      ind++;
    }
    printk(KERN_ALERT ""Write position1 now: %d\t and count%d\n"", writePos1,(int)count);
    printk(KERN_ALERT ""Note: our allowable buffer length was %d\n"", (int)len);
    return count;
  }
  else if (mode == 2){
    count = 0;
    ind = 0;
    if (( buff == NULL) ||  (*buff == 0)) {
      return -ENOMEM;
    }
    printk(KERN_ALERT ""Write position2 : %d\n"", writePos2);
    while(ind&lt;len) {  //loop untill we have something to writer
      if (down_interruptible(&amp;buffer2_e)) { //taking flag first isn't right because that won't allow other guyto give access to our turn.
        printk(KERN_ALERT ""buffer2 flag didn't work\t %d"", buffer2_e.count);
        return -ERESTARTSYS;
      }
      else {
        if (down_interruptible(&amp;flag2)){
          up(&amp;buffer2_e);     //must because we couldn't write it properly
          return -EINVAL;
        }
        else {
          queue2[writePos2] = buff[ind];
          printk(KERN_ALERT ""Write ind:%d writepos2:%d readpos2;%d char:%c\tascii%d\n"",ind,writePos2,readPos2,queue2[writePos2],(int)queue2[writePos2]);
                    if (readPos2==((writePos2+1)%10)) {
                        writePos2=-1;
                    }
          else if (writePos2 == 9){
             writePos2 = 0;
          }
          else
             writePos2++;
          count++;
        }
                printk(KERN_ALERT ""writepos:%d"",writePos2);
        up(&amp;flag2);
      }
      up(&amp;buffer2_f);
      off += count;
      ind++;
    }
    printk(KERN_ALERT ""Write position2 now: %d\t and count%d\n"", writePos2,(int)count);
    printk(KERN_ALERT ""Note: our allowable buffer length was %d\n"", (int)len);
    return count;
  }
  else {
    printk(KERN_ALERT ""This meant wrong device minor accessed\n"");
    return -1;
  }
}
static int dev_rls(struct inode *inod, struct file *fil) {
  printk(KERN_ALERT ""Device is closed\n"");
  return 0;
}
</code></pre>
"
"<p>The kernel variable DEFAULT_MESSAGE_LOGLEVEL decides what is the default log level of your kernel. To know what is the current value of it, check the value of CONFIG_DEFAULT_MESSAGE_LOGLEVEL in your kernel's config file. </p>

<p>This will give you clue as to why the KERN_INFO is coming to the terminal.</p>
"
"<blockquote>
  <p>Note, that when the block of code inside <code>custom_open</code> is replaced
  with</p>

<pre><code>    printk(KERN_INFO ""intercepted: open(\""%s\"", %X, %X)\n"", file_name, flags, mode);
    if (file_name == ""/dev/sda"" &amp;&amp; TEST_OPEN_FLAGS(flags)) {
        printk(""Intercepted call to write to block device."");
        return -EPERM;
    }
    return real_open(file_name, flags, mode);
</code></pre>

  <p>everything works the way I want it to.</p>
</blockquote>

<p>You are mistaken. That you see no output from the above code does not mean that <code>printk</code> does not output to the console; it is rather likely that the <code>printk</code> is never executed, because the function parameter <code>file_name</code> most probably doesn't point to the memory location of the string literal <code>""/dev/sda""</code> - remember, to compare strings, <code>strcmp</code> is to be used.</p>
"
"<p>You can use the <code>kern_path</code> kernel API to get the inode information from the path string. This function in turn calls the <code>do_path_lookup()</code> function which performs the path look up operation. You can verify the results of the <code>kern_path</code> function by printing the inode number (<code>i_ino</code> field of the inode structure) of the inode you get from your <code>get_inode_from_pathname</code> function and matching it with the inode number from an <code>ls</code> command (<code>ls -i &lt;path of the file&gt;</code>)</p>

<p>I made the following kernel module and it's not crashing the kernel. I am using 2.6.39 kernel.</p>

<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/mount.h&gt;
#include &lt;linux/path.h&gt;
#include &lt;linux/namei.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/namei.h&gt;

char *path_name = ""/home/shubham/test_prgs/temp.c"";

int myinit(void)
{
    struct inode *inode;
    struct path path;
    kern_path(path_name, LOOKUP_FOLLOW, &amp;path);
    inode = path.dentry-&gt;d_inode;
    printk(""Path name : %s, inode :%lu\n"", path_name, inode-&gt;i_ino);
    return 0;
}


void myexit(void)
{
    return;
}

module_init(myinit);
module_exit(myexit);

//MODULE_AUTHOR(""Shubham"");
//MODULE_DESCRIPTION(""Module to get inode from path"");
MODULE_LICENSE(""GPL"");
MODULE_LICENSE(""GPL v2"");
</code></pre>

<p>Can you send the crash stack trace?</p>
"
"<p>I guess the author has already fixed his problem, but this question was the first link in google's search results, so I'll explain it further.</p>

<p>The problem with the code from the question was using __user pointer.
When you hook a function that deals with __user pointers, first thing you have to make is to copy content to your own kernel buffer where you will deal with it or make sure that pointer won't become invalid while you are dealing with it.</p>

<p>To copy it to your buffer you could use copy_from_user function</p>

<pre><code>char path[MAX_PATH] = {0};

if (copy_from_user(path, user_path, strlen_user(user_path))
{
  //error
}
//success
</code></pre>

<p>If you hook sys_open, you can use getname/putname functions, as it is done in do_sys_open function:</p>

<pre><code>1010 long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
1011 {
1012         struct open_flags op;
1013         int fd = build_open_flags(flags, mode, &amp;op);
1014         struct filename *tmp;
1015
1016         if (fd)
1017                 return fd;
1018
1019         tmp = getname(filename);
1020         if (IS_ERR(tmp))
1021                 return PTR_ERR(tmp);
1022
1023         fd = get_unused_fd_flags(flags);
1024         if (fd &gt;= 0) {
1025                 struct file *f = do_filp_open(dfd, tmp, &amp;op);
1026                 if (IS_ERR(f)) {
1027                         put_unused_fd(fd);
1028                         fd = PTR_ERR(f);
1029                 } else {
1030                         fsnotify_open(f);
1031                         fd_install(fd, f);
1032                 }
1033         }
1034         putname(tmp);
1035         return fd;
1036 }
</code></pre>

<p>ps: code from S_S's answer won't crash because in fact it allocated buffer for path inside kernel, so it couldn't become invalid while the module is working with it.</p>
"
"<p>I would say that ""const char __user *buf"" is user space address and vfs_write expects user space address and you are passing kernel space address to it. Also you cannot directly copy user space address to kernel space address. You can try using copy_from_user and copy_to_user functions. I hope you are aware that caeser cipher is insecure.</p>
"
"<p>You are trying to make this change in completely the wrong place. The <code>rmdir</code> command which you want to modify is not part of the kernel, it is a user-space program. On my system, <code>rmdir</code> comes from <a href=""https://www.gnu.org/software/coreutils/"" rel=""nofollow"">GNU coreutils</a>. To find out if yours is the same, try <code>rmdir --help</code> in your shell.</p>

<p>If you confirm that you are also using GNU coreutils, you could download the source code from gnu.org, modify it, recompile, and copy the modified binary into your <code>/bin</code> directory.</p>

<p><em>However</em>, there is a much easier way to do what you want to do: write a little shell script which makes the desired confirmation request, then runs <code>/bin/rmdir</code>. You can call your script <code>rmdir</code> if you want.</p>
"
"<p>Below command would fulfill your requirement.</p>

<pre><code>rm -r --interactive=always &lt;Directory&gt;
</code></pre>

<p>Actually you cannot get any confirmation from kernel space for any operations, Thats why user space programs/applications are designed more interactively. </p>
"
"<p>the <code>dentry</code>, which I have been looking for was moved from beeing a direct child of <code>struct file</code> into <code>struct path</code>.</p>

<pre><code>struct inode* parentDirInode(struct file* file) {
  return file-&gt;f_path.dentry-&gt;d_parent-&gt;d_inode;
}
</code></pre>

<p>still I hope that there is a better solution that does not break when they change the implementation structure. <strong>Are there macros/functions I overlooked?</strong></p>
"
"<p>You can obtain the <code>socket</code> structure pointer from the struct <code>file</code> with the exported function <code>sock_from_file</code>. </p>

<p>It is then cast into a <code>tcp_sock</code>, which contains an <code>inet_connection_sock</code> which contains an <code>inet_sock</code> which contains a <code>sock</code> (not to be confused with <code>socket</code>) which contains <code>sock_common</code>. The two port numbers are ultimately stored in <code>inet_sock</code> and <code>sock_common</code> (well, that's how it works in a recent kernel version anyway).</p>

<p>Making use of these facts in a reliable way would be difficult. The layout and organization of all this is closely dependent on kernel version, and of course that the file descriptor actually represents a connected TCP socket.</p>
"
"<p>Did you include the header file contain PDE declaration?</p>
"
"<p>That has a benefit of reducing copying memory blocks back and forth.</p>

<p>Using this methodology allows the invoked function to only modify certain parts of the passed in struct and no memory is being copied at all.</p>
"
"<p>And what would you do with <a href=""http://lxr.free-electrons.com/source/include/linux/namei.h#L56"">the <code>int</code> that <code>kern_path</code> returns</a>?</p>

<p>It's important for functions to be able to return some kind of error code so the user can ensure the function succeeded. There are two obvious options:</p>

<ol>
<li><p>Return the error code.</p>

<p>This means you must take the other value that you'd like to return as a parameter.</p></li>
<li><p>Return the value.</p>

<p>This means you must take the error code as a parameter.</p></li>
</ol>

<p>Since you can only return 1 value in C, you've got to take something as a parameter, as ultimately you want to return two things to the user (the error code and the value).</p>
"
"<p>Passing in a pointer to a struct that is used for returning data is useful to pass back a large amount of data without having to actually pass it.  You're only passing a pointer back and forth instead of a giant struct.  </p>

<p>Your example only showed one element that gets filled out.  There are drivers that pass back structs with dozens (if not over a hundred) fields.  That would get very expensive memory and cpu wise.  You want to squeeze as much from your kernel as possible.</p>

<p>Another thing this method allows you to do is to let the memory management happen outside of the function, making the function more generic and reusable.</p>

<p>Not to mention that if you want to return more than 1 thing, this is pretty much the only way of doing it.  </p>

<p>A nice side benefit is it allows you to very clearly define the interface to the driver.  Declare a struct and there's your API.  Nothing else goes in or out.</p>
"
"<p>The kernel is a C program with special constraints. In particular, the call stack is not allowed to be deep (IIRC, it is limited to 4Kbytes).</p>

<p>When you return a <code>struct</code>, the ABI (see the <a href=""http://www.x86-64.org/documentation/abi.pdf"" rel=""nofollow noreferrer"">x86-64 ABI</a> ...) mandates that (except for some <em>short</em> <code>struct</code> fitting in two words) the returned <code>struct</code> goes thru the stack. So such a style would favor quite big stack frames, hence would more easily meet the stack limit.</p>

<p>BTW, the usual style would be to return some integer error code, and modify the data pointed by argument pointers.</p>

<p>On x86-64/Linux returning a structure of two scalar values (integers, pointers, enums, doubles, ....) is definitely worth it, see <a href=""https://stackoverflow.com/a/33242625/841108"">this</a>.</p>
"
"<p>The actual reason is far simpler than the other answers: it's just habit, from a constraint that no longer exists. All other justifications have been invented after the fact; there is usually an equal and opposite justification for the opposite.</p>

<p>In old C compilers, <em>all</em> arguments and return-value had to be able to fit in registers. That meant, if they were larger, they would <em>have</em> to be passed by address.</p>
"
"<p>I found a macro called <strong>S_ISDIR()</strong> which can be used to know whether given path is a file or directory. To use this macro, we need <em>inode</em>, which can be obtained from <em>struct path</em>, as follows: </p>

<pre><code>        struct path path;
        int error;
        struct inode *inode;
        error=kern_path(filename,LOOKUP_FOLLOW, &amp;path);
        if(error)
        {
                printk(KERN_INFO ""error"");
        }
        inode = path.dentry-&gt;d_inode;
        printk("" inode :%lu\n inode mode %u"", inode-&gt;i_ino, inode-&gt;i_mode);
        if(S_ISDIR(inode-&gt;i_mode))
        {
                printk(KERN_INFO ""It is a directory!"");
        }
        else
        {
                printk(KERN_INFO ""It is a file!"");
        }
</code></pre>
"
"<p>You got an inode with NULL file_operations. Just add check before the line where you dereference the pointer to the file_operations:</p>

<pre><code>if (!pinode-&gt;i_fop)
    return;
proc_fops = *pinode-&gt;i_fop;
</code></pre>
"
"<p>According to <a href=""http://lxr.free-electrons.com/ident?i=wait_queue_head_t"" rel=""nofollow"">this page</a> <code>wait_queue_head_t</code> might be a keyword, so try changing it to something else.</p>
"
"<p>Incorrect operation in the kernel code doesn't <em>always</em> leads to kernel hang (that is, whole machine becomes irresponsible). Sometimes error crash only current thread, like in your case.</p>

<p>Such ""partial crash"" doesn't mean that error kernel is recovered after the error. After <em>any</em> single error no one can garantee that other kernel parts work correct.</p>

<p>Main reason for not hanging <em>entire kernel</em> on error is allowing user to store unsaved data and collect information, described the error. Again, no one can garantee that user is able to perform these actions after the particular error, but usually he is.</p>

<p>If you want to <em>check</em> whether kernel is correctly works at some moment(no error has been occured until that moment), you can <code>grep</code> dmesg output for word ""BUG"".</p>
"
"<p>If you look at the assembly code(via e.g. objdump -D oops.ko), all of your init_module() is optimized away, presumably because it doesn't do anything.</p>

<p>If you e.g. do <code>p-&gt;i_ino = 1;</code> , you'll likely see different results(Albeit this is undefined behavior, so it's not straight forward to reason about what the code is going to do - better check the assembly in this case too).</p>
"
"<p>Entering ""no member named ?f_dentry?"" into a search engine indicates this to be a <a href=""https://forums.virtualbox.org/viewtopic.php?f=3&amp;t=65299"" rel=""nofollow"">known issue</a> of kernel 3.19 introducing breaking changes to <code>struct file</code>, which makes the (older) VirtualBox 4.3.20 code fail to compile.</p>

<p>Biting my tongue firmly with regards to <a href=""https://www.kernel.org/doc/Documentation/stable_api_nonsense.txt"" rel=""nofollow"">Linux kernel maintainers' policy on such breaking changes</a>, I am afraid you will just have to figure out whether downgrading the kernel or upgrading your VirtualBox is the ""correct"" fix for your problem.</p>
"
"<p>The <code>file_lock</code> is indeed stored in the <code>inode</code> of the corresponding file.</p>

<p>An <code>inode</code> can be referred by several directory entries, which linked in inode's <code>i_dentry</code> field. Even for a unique file might have different <code>filp-&gt;f_dentry</code>, <code>filp-&gt;f_dentry-&gt;d_inode</code> is all refer to the same inode.</p>
"
"<p>Looking more deeply the kernel handling of /dev/video0 node whenever an
application tries to open this file it gets a FILE *fp pointer ,
the linux kernel virtual file system checks whether this is a regular file or
device file, and if it is a device file it checks it's major number to track
the driver which registered it and saves the minor number in i_rdev field of
struct inode *inode which is again embedded in struct file *fp and
passed to that driver.</p>

<p>So for every FILE *fp opened by application there is struct file *fp in
registered driver i.e v4l2 driver in our case. This file pointer is passed on
to kernel ioctl API v4l2_ioctl.</p>

<p>Now internally v4l2 driver maintains an array of pointers to all the
registered video devices
as seen below :
<strong>static struct video_device *video_device[VIDEO_NUM_DEVICES];</strong></p>

<p>Now if we see the implementation of main ioctl call.</p>

<pre><code>static long v4l2_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
        struct video_device *vdev = video_devdata(filp);
    ...
}
</code></pre>

<p>This video device structure is extracted from file pointer which is the key by which we can control the video device i.e. our camera from within the kernel as it contains function pointers to all the registered v4l2 ioctls. So our target is to access the video device structure from within the kernel.</p>

<p>Now again looking at how kernel accesses the video device when it gets a request from application.</p>

<pre><code>struct video_device *video_devdata(struct file *file)

{
        return video_device[iminor(file-&gt;f_path.dentry-&gt;d_inode)];
}
EXPORT_SYMBOL(video_devdata);

static inline unsigned iminor(const struct inode *inode)
{
        return MINOR(inode-&gt;i_rdev);
}
</code></pre>

<p>As seen above it uses i_rdev field for getting the minor number passed from struct file *fp through VFS.</p>

<p><strong>To summarise if we want to access ioctl from within the kernel we need to fill
a dummy file *fp pointer containing minor number in
file->f_path.dentry->d_inode.i_rdev field, v4l2 subsystem will get
video_device structure using this field and will be able to drive further the
ioctl operations from video_device structure by using video_device->ioctl_ops
field as seen below.</strong></p>

<pre><code>struct video_device
{
#if defined(CONFIG_MEDIA_CONTROLLER)
        struct media_entity entity;
#endif
        /* device ops */
        const struct v4l2_file_operations *fops;
    const struct v4l2_ioctl_ops *ioctl_ops;
    ...
}
</code></pre>

<p>To set  file->f_path.dentry->d_inode.i_rdev we need to add references to inode and dentry structure inside file structure as per below pseudocode:</p>

<pre><code>static int enumerate_camera()
{

                        inode.i_rdev = cam_minor_number ;// Saved when camera device registered;
                        dentry.d_inode = inode;
                        file.f_path.dentry = dentry;
                        file.f_dentry-&gt;d_inode = inode;
....
  }
</code></pre>
"
"<p>You can find out if a file is a block or character device by reading it's inode structure member i_rdev:</p>

<pre><code>file-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
</code></pre>

<p>It contains the major,minor value and if it's not 0 it's a device</p>
"
"<p>Solved it using the preprocessor macro:</p>

<pre><code> #define special_file(m) (S_ISCHR(m)||S_ISBLK(m)||S_ISFIFO(m)||S_ISSOCK(m))

 defined in linux/fs.h
</code></pre>

<p>The macro can be then used as follows to determine whether a file pointer 'describes' a special file:</p>

<pre><code>struct file * f;
// ...
if (special_file(file_inode(f)-&gt;i_mode))
{
     /* If we're here then it is a
     block/character device or FIFO/SOCKET file */
}
</code></pre>
"
"<pre><code>1912 /**
1913  * d_lookup - search for a dentry
1914  * @parent: parent dentry
1915  * @name: qstr of name we wish to find
1916  * Returns: dentry, or NULL
1917  *
1918  * d_lookup searches the children of the parent dentry for the name in
1919  * question. If the dentry is found its reference count is incremented and the
1920  * dentry is returned. The caller must use dput to free the entry when it has
1921  * finished using it. %NULL is returned if the dentry does not exist.
1922  */
</code></pre>

<p><code>d_lookup</code> does not create any <code>dentry</code> objects by yourself. Take a look at the <code>do_filp_open</code> logic and it shows how <code>dentries</code> are created.</p>
"
"<p>With so many objects and small map object in each you may hit another problem - memory fragmentation. It could be usable to have <code>std::vector</code> with <code>std::pair&lt;key,value&gt;</code> in it instead and do lookup (I think binary search should be sufficient, but it depends on your situation, it could be cheaper to do linear lookup but not to sort the vector). For property key I would use enum instead of string, unless later is dictated by interface (which you did not show).</p>
"
"<p>I don't think this is your best option, for 25 elements, you will not benefit that much from using a map in terms of lookup performance. Also, it depends on what kinds of properties are you going to have, if it is a fixed set of properties as in your example, then string lookup would be a waste of memory and CPU cycles, you could go for an enum  of all properties or just an integer and use a sequential container for the properties each element has. For such a small number of possible properties, lookup time will be lower than a map because of cache friendliness and integer comparisons, and memory usage will be lower too. For such a small set of properties this solution is marginally better.</p>

<p>Then there is the problem that an <code>int</code> is usually twice as small as a <code>double</code>. And they are different types. So it is not directly possible to store both in a single container, but you could have enough space for a <code>double</code> in each element, and either use a <code>union</code> or just read/write an <code>int</code> from/to the address of the <code>double</code> if the property ""index"" is larger than 14.</p>

<p>So you can have something as simple as:</p>

<pre><code>struct Property {
   int type;
   union {
       int d_int;
       double d_double;
   };
};

class MyObject {
    std::vector&lt;Property&gt; properties;
};
</code></pre>

<p>And for <code>type</code> 1 - 14 you read the <code>d_double</code> field, for <code>type</code> 15 - 25 the <code>d_int</code> field.</p>

<p><strong>BENCHMARKS!!!</strong></p>

<p>Out of curiosity I did some testing, creating 250k objects, each with 5 int and 5 double properties, using a vector, a map and a hash for the properties, and measured memory usage and time taken to set and get the properties, ran each test 3 times in a row to see impact on caching, calculate checksum for getters to verify consistency, and here are the results:</p>

<pre><code>vector | iteration | memory usage MB | time msec | checksum
setting 0 32 54
setting 1 32 13
setting 2 32 13
getting 0 32 77 3750000
getting 1 32 77 3750000
getting 2 32 77 3750000

map | iteration | memory usage MB | time msec | checksum
setting 0 132 872
setting 1 132 800
setting 2 132 800
getting 0 132 800 3750000
getting 1 132 799 3750000
getting 2 132 799 3750000

hash | iteration | memory usage MB | time msec | checksum
setting 0 155 797
setting 1 155 702
setting 2 155 702
getting 0 155 705 3750000
getting 1 155 705 3750000
getting 2 155 706 3750000
</code></pre>

<p>As expected, the vector solution is by far the fastest and most efficient, although it is most influenced by cold cache, even running cold it is way faster than a map or hash implementation. </p>

<p>On a cold run, the vector implementation is 16.15 times faster than map and 14.75 times faster than hash. On a warm run it is even faster - 61 times faster and 54 times faster respectively.</p>

<p>As for memory usage, the vector solution is far more efficient as well, using over 4 times less memory than the map solution and almost 5 times less than the hash solution.</p>

<p>As I said, it is marginally better.</p>

<p>To clarify, the ""cold run"" is not only the first run but also the one inserting the actual values in the properties, so it is fairly illustrative of the insert operations overhead. None of the containers used preallocation so they used their default policies of expanding. As for the memory usage, it is possible it doesn't accurately reflect actual memory usage 100% accurately, since I use the entire working set for the executable, and there is usually some preallocation taking place on OS level as well, it will most likely be more conservative as the working set increases. Last but not least, the map and hash solutions are implemented using a string lookup as the OP originally intended, which is why they are so inefficient. Using integers as keys in the map and hash produces far more competitive results:</p>

<pre><code>vector | iteration | memory usage MB | time msec | checksum
setting 0 32 55
setting 1 32 13
setting 2 32 13
getting 0 32 77 3750000
getting 1 32 77 3750000
getting 2 32 77 3750000

map | iteration | memory usage MB | time msec | checksum
setting 0 47 95
setting 1 47 11
setting 2 47 11
getting 0 47 12 3750000
getting 1 47 12 3750000
getting 2 47 12 3750000

hash | iteration | memory usage MB | time msec | checksum
setting 0 68 98
setting 1 68 19
setting 2 68 19
getting 0 68 21 3750000
getting 1 68 21 3750000
getting 2 68 21 3750000
</code></pre>

<p>Memory usage is much lower for hash and map, while still higher than vector, but in terms of performance the tables are turned, while the vector solution sill wins at inserts, at reading and writing the map solution takes the trophy. So there's the trade-off.</p>

<p>As for how much memory is saved compared to having all the properties as object members, by just a rough calculation, it would take about 80 MB of RAM to have 250k such objects in a sequential container. So you save like 50 MB for the vector solution and almost nothing for the hash solution. And it goes without saying - direct member access would be much faster.</p>
"
"<p>Just an idea (not compiled/tested):</p>

<pre><code>struct property_type
{
  enum { kind_int, kind_double } k;
  union { int i; double d; };
};

enum prop : unsigned char { height, widht, };

typedef std::map&lt; std::pair&lt; int/*data index*/, prop/*property index*/ &gt;, property_type &gt; map_type;

class data_type
{
  map_type m;

public:

  double&amp; get_double( int i, prop p )
  {
    // invariants...
    return m[ std::pair&lt;int,prop&gt;(i,p) ].d;
  }

};
</code></pre>
"
"<p>You're looking up objects by name that you know will be there. So look them up by name. </p>

<blockquote>
  <p>I understand that accessing elements in a std::map goes as the logarithm of its size, but since the number of properties is quite small (about 25), I suppose that this should not slow down the execution of the code too much.</p>
</blockquote>

<p>You will slow down your program by more than one order of magnitude. Lookup of a map may be O(logN) but it's O(LogN) * C. C will be <em>huge</em> compared to direct access of properties (thousands of times slower).</p>

<blockquote>
  <p>implying that the memory for millions of useless int and double is allocated</p>
</blockquote>

<p>A <code>std::string</code> is at least 24 bytes on all the implementations I can think of - assuming you keen the names of properties short (google 'short string optimisation' for details).</p>

<p>Unless 60% of your properties are unpopulated there is no saving using a map keyed by string at all.</p>
"
"<p><strong>TL;DR: it's not worth it.</strong></p>

<p>From carpenters we get: <strong>measure twice, cut once</strong>. Apply it.</p>

<hr>

<p>Your 25 <code>int</code> and <code>double</code> will occupy on a x86_64 processor:</p>

<ul>
<li>14 <code>double</code>: 112 bytes (14 * 8)</li>
<li>11 <code>int</code>: 44 bytes (11 * 4)</li>
</ul>

<p>for a total of 156 bytes.</p>

<hr>

<p>A <code>std::pair&lt;std::string, double&gt;</code> will, on most implementation, consume:</p>

<ul>
<li>24 bytes for the string</li>
<li>8 bytes for the double</li>
</ul>

<p>and a <em>node</em> in the <code>std::map&lt;std::string, double&gt;</code> will add at least 3 pointers (1 parent, 2 children) and a red-black flag for another 24 bytes.</p>

<p>That's at least 56 bytes <em>per property</em>.</p>

<p>Even with a 0-overhead allocator, any time you store 3 elements or more in this <code>map</code> you use more than 156 bytes...</p>

<hr>

<p>A compressed (type, property) pair will occupy:</p>

<ul>
<li>8 bytes for the property (<code>double</code> is the worst case)</li>
<li>8 bytes for the type (you can choose a smaller type, but alignment kicks in)</li>
</ul>

<p>for a total of 16 bytes per pair. Much better than <code>map</code>.</p>

<p>Stored in a <code>vector</code>, this will mean:</p>

<ul>
<li>24 bytes of overhead for the <code>vector</code></li>
<li>16 bytes per property</li>
</ul>

<p>Even with a 0-overhead allocator, any time you store 9 elements or more in this <code>vector</code> you use more than 156 bytes.</p>

<hr>

<p>You know the solution: split that object.</p>
"
"<p>Millions of ints and doubles is still only hundreds of megabytes of data. On a modern computer that may not be a huge issue.</p>

<p>The map route looks like it will be a waste of time but there is an alternative you could use that saves memory while retaining decent performance characteristics: store the details in a separate vector and store an index into this vector (or -1 for unassigned) in your main data type. Unfortunately, your description doesn't really indicate how the property usage actually looks but I'm going to guess you can sub-divide into properties that are always, or usually, set together and some that are needed for every node. Let's say you subdivide into four sets: A, B, C and D. The As are needed for every node whereas B, C and D are rarely set but all elements are typically modified together, then modify the struct you're storing like so:</p>

<pre><code>struct myData {
  int A1;
  double A2;
  int B_lookup = -1;
  int C_lookup = -1;
  int D_lookup = -1;
};

struct myData_B {
  int B1;
  double B2;
  //etc.
};

// and for C and D
</code></pre>

<p>and then store 4 vectors in your main class. When a property in the Bs in accessed you add a new <code>myData_B</code> to the vector of Bs (actually a deque might be a better choice, retaining fast access but without the same memory fragmentation issues) and set the <code>B_lookup</code> value in the original <code>myData</code> to the index of the new <code>myData_B</code>. And the same for Cs and Ds.</p>

<p>Whether this is worth doing depends on how few of the properties you actually access and how you access them to together but you should be able to modify the idea to your tastes.</p>
"
"<p>boost::filesystem::recursive_directory_iterator</p>
"
"<p>Does this work for you?</p>

<pre><code>paths=$(grep path myfile.property |cut -d= -f2)
d_path=$(grep destpath myfile.property |cut -d= -f2)
extname=$(echo $paths | sed 's%^.*/\([^/]*/[^/]*/[^/]*\)$%\1%;s%/%_%g')
filename=$d_path/$extname.zip
</code></pre>

<p>The first substitute in the <code>sed</code> script now removes everything before the last three components of the path - not removing anything if there are only two - and the second maps the remaining slashes to underscores.  Note that you will have problems if the paths have trailing slashes (though you can add a substitute to remove them).  You'd also get a leading underscore in the name if it contained, say, <code>/tmp/pattern</code>.  You might need to worry about using '<code>[^/][^/]*</code>' in place of just '<code>[^/]*</code>' to ensure that there aren't empty component names (and then you might worry about doubled slashes too).  And GNU Sed provides you with extra regex features so you might be able to use '<code>[^/]+</code>' instead.</p>
"
"<p>Since you are using <code>bash</code> (this would also apply to <code>zsh</code> or similar), you could use its in-built parameter substitution.</p>

<pre><code>% path=tmp/inputs/logs/abc
% prefix=${path%%/*/*/*}
% without_prefix=${path##${prefix}/}
% slashes_to_underscores=${without_prefix//\//_}
% filename=${slashes_to_underscores}.zip
% echo $filename
inputs_logs_abc.zip
</code></pre>

<p>You can prepend <code>${d_path}</code> as appropriate to <code>${filename}</code>. <code>$path</code> in my example is hard-coded, you will assign this in a loop over <code>${paths}</code>, as per <a href=""https://stackoverflow.com/questions/3753918/how-to-move-files-from-one-path-to-another-path-in-unix-using-shell-script/3759295#3759295"">fahd's answer</a> to <a href=""https://stackoverflow.com/questions/3753918/how-to-move-files-from-one-path-to-another-path-in-unix-using-shell-script"">your previous question</a>.</p>

<ul>
<li><code>${var//exp/sub}</code> replaces all instances of <code>exp</code> in <code>$var</code> with <code>sub</code></li>
<li><code>${var%%exp}</code> trims any instance of <code>exp</code> from the right of <code>var</code></li>
<li><code>${var##exp}</code> trims any instance of <code>exp</code> from the left of <code>var</code></li>
</ul>

<p><strong>Edit (following some sleep and clarification):</strong></p>

<p><code>prefix=${path%%/*/*/*}</code> does a <em>greedy</em> match from right-to-left. If you have a '/' before tmp this will break (this is not what you said you were doing in your comment, but would give that result). Change this line to be <code>prefix=${path%/*/*/*}</code> (single percentage sign: non-greedy) and this should fix longer and shorter paths.</p>

<p><strong>Edit 2 (following update to question):</strong></p>

<p>I can see three problems:</p>

<ol>
<li>""Paths=<code>grep path myfile.txt |cut -d= -f2</code>"" # This matches ""destpath=abc/xyz"", you should probably <code>grep</code> for <code>'^path='</code> to get just lines that start with ""path="".</li>
<li>You are using <code>${Paths}</code> twice inside the loop where you should use (the curiously-named) <code>${s_Path}</code>.</li>
<li>You are still using the greedy match in the <code>prefix=</code> line. See my previous edit. </li>
</ol>
"
"<p>An example, available for POSIX compliant systems :</p>

<pre><code>/*
 * This program displays the names of all files in the current directory.
 */

#include &lt;dirent.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
  DIR           *d;
  struct dirent *dir;
  d = opendir(""."");
  if (d)
  {
    while ((dir = readdir(d)) != NULL)
    {
      printf(""%s\n"", dir-&gt;d_name);
    }

    closedir(d);
  }

  return(0);
}
</code></pre>

<p>Beware that such an operation is platform dependant in C.</p>

<p>Source : <a href=""http://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1046380353&amp;id=1044780608"" rel=""noreferrer"">http://faq.cprogramming.com/cgi-bin/smartfaq.cgi?answer=1046380353&amp;id=1044780608</a></p>
"
"<p>One tiny addition to <a href=""https://stackoverflow.com/a/4204758/1150918"">JB Jansen's answer</a> - in the main <code>readdir()</code> loop I'd add this:</p>

<pre><code>  if (dir-&gt;d_type == DT_REG)
  {
     printf(""%s\n"", dir-&gt;d_name);
  }
</code></pre>

<p>Just checking if it's really file, not (sym)link, directory, or whatever.</p>

<p>NOTE: more about <code>struct dirent</code> in <a href=""http://www.gnu.org/software/libc/manual/html_node/Directory-Entries.html"" rel=""nofollow noreferrer""><code>libc</code> documentation</a>.</p>
"
"<p>Here is a complete program how to recursively list folder's contents:</p>

<pre><code>#include &lt;dirent.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define NORMAL_COLOR  ""\x1B[0m""
#define GREEN  ""\x1B[32m""
#define BLUE  ""\x1B[34m""



/* let us make a recursive function to print the content of a given folder */

void show_dir_content(char * path)
{
  DIR * d = opendir(path); // open the path
  if(d==NULL) return; // if was not able return
  struct dirent * dir; // for the directory entries
  while ((dir = readdir(d)) != NULL) // if we were able to read somehting from the directory
    {
      if(dir-&gt; d_type != DT_DIR) // if the type is not directory just print it with blue
        printf(""%s%s\n"",BLUE, dir-&gt;d_name);
      else
      if(dir -&gt; d_type == DT_DIR &amp;&amp; strcmp(dir-&gt;d_name,""."")!=0 &amp;&amp; strcmp(dir-&gt;d_name,"".."")!=0 ) // if it is a directory
      {
        printf(""%s%s\n"",GREEN, dir-&gt;d_name); // print its name in green
        char d_path[255]; // here I am using sprintf which is safer than strcat
        sprintf(d_path, ""%s/%s"", path, dir-&gt;d_name);
        show_dir_content(d_path); // recall with the new path
      }
    }
    closedir(d); // finally close the directory
}

int main(int argc, char **argv)
{

  printf(""%s\n"", NORMAL_COLOR);

    show_dir_content(argv[1]);

  printf(""%s\n"", NORMAL_COLOR);
  return(0);
}
</code></pre>
"
"<p>-EFAULT means something's wrong with the ""buf"" pointer. Did you allocate memory first?</p>

<p>EDIT: It looks like you are programming in kernel mode. It turns out ""the"" real path is meaningless in kernel mode.</p>
"
"<p>Get it from the filep in the task struct, e.g. something like</p>

<pre><code>struct task_struct *task;
struct files_struct *files;
struct file *file;
char buf[buflen], *realpath;

task = current /* or some other task */;
get_task_struct(task);
files = get_files_struct(task);
put_task_struct(task);
spin_lock(&amp;files-&gt;file_lock);
file = fcheck_files(files, fdno);
realpath = d_path(file-&gt;f_path, buf, buflen);
spin_unlock(&amp;files-&gt;file_lock);
put_files_struct(files);
</code></pre>

<p>Error handling elided for brevity.</p>
"
"<p>Don't call <code>SYS_readlink</code> - use the same method that <code>procfs</code> does when one of those links is read.  Start with the code in <code>proc_pid_readlink()</code> and <code>proc_fd_link()</code> in <code>fs/proc/base.c</code>.</p>

<p>Broadly, given an <code>int fd</code> and a <code>struct files_struct *files</code> from the task you're interested in (which you have taken a reference to), you want to do:</p>

<pre><code>char *tmp;
char *pathname;
struct file *file;
struct path *path;

spin_lock(&amp;files-&gt;file_lock);
file = fcheck_files(files, fd);
if (!file) {
    spin_unlock(&amp;files-&gt;file_lock);
    return -ENOENT;
}

path = &amp;file-&gt;f_path;
path_get(path);
spin_unlock(&amp;files-&gt;file_lock);

tmp = (char *)__get_free_page(GFP_KERNEL);

if (!tmp) {
    path_put(path);
    return -ENOMEM;
}

pathname = d_path(path, tmp, PAGE_SIZE);
path_put(path);

if (IS_ERR(pathname)) {
    free_page((unsigned long)tmp);
    return PTR_ERR(pathname);
}

/* do something here with pathname */

free_page((unsigned long)tmp);
</code></pre>

<p>If your code is running in process-context (eg. invoked through a syscall) and the file descriptor is from the current process, then you can use <code>current-&gt;files</code> for the current task's <code>struct files_struct *</code>.</p>
"
"<p>I stumbled upon this very helpful page:
<a href=""http://kedar.dumpstack.com/pubs/al_vfsmounts.html"" rel=""nofollow noreferrer"">http://kedar.dumpstack.com/pubs/al_vfsmounts.html</a></p>

<p>(Also posted here in case that goes away):
<a href=""http://kerneltrap.org/node/3749"" rel=""nofollow noreferrer"">http://kerneltrap.org/node/3749</a></p>

<p>While short, this is valuable for anyone trying to begin to understand the workings of the vfs because it goes beyond describing the parts (superblock, inode, dentry, etc.) to describing how they work together to create the namespace users interact with.</p>

<p>Anyway, if I'm reading this correctly, a tree of dentries are rooted from a super block corresponding to a file system, not a vfsmount.  So I have to check to make sure that the d_parent and the dentry have the same vfs mount.  The <code>mnt_root</code> check I mention below accomplishes this.</p>

<p>So, it's not null I need to check at step 1 but these two things (I get this from the implementation of <code>__d_path</code> in <a href=""http://lxr.free-electrons.com/ident?v=2.6.32;i=__d_path"" rel=""nofollow noreferrer"">fs/dcache.c</a>):</p>

<ol>
<li><p><code>mnt_root</code>.  If the f_dentry of f_child is the same as mnt_root of its f_vfsmnt, then I can't look at f_dentry->d_parent.  We're at the root of the mount.  If I want to go above that dentry, I have to move up the tree by looking at the dentry f_vfsmnt->mnt_mountpoint and the vfsmount f_vfsmnt->mnt_parent.</p></li>
<li><p><code>IS_ROOT</code>.  <code>IS_ROOT</code> takes a dentry, and if it returns true, then there is no point looking above that.  We're at the root of the file system, which may not be the root of our namespace.</p></li>
</ol>

<p>Now that I understand some more, I realize that the post by J-16 SDiZ is helpful:</p>

<p><a href=""https://stackoverflow.com/questions/4622812/linux-kernel-dentry-and-inode"">Linux Kernel dentry and inode</a></p>

<p>He references the tomoyo implementation of getting a real path:</p>

<p><a href=""http://lxr.linux.no/linux+v2.6.37/security/tomoyo/realpath.c#L86"" rel=""nofollow noreferrer"">http://lxr.linux.no/linux+v2.6.37/security/tomoyo/realpath.c#L86</a></p>
"
"<p>I have solve it .Because the D_PATH should be the ""/org/freedesktop/DBus"" .</p>
"
"<p>Using @JoachimPileborg's link above: <a href=""http://freedesktop.org/wiki/Software/xdg-user-dirs"" rel=""nofollow"">freedesktop.org/wiki/Software/xdg-user-dirs</a>, I put together this code that should safely give the path to the user's desktop if it can be determined:</p>

<pre><code>import os, re
def get_desktop_path():

    D_paths = list()

    try:

        fs = open(os.sep.join((os.path.expanduser(""~""), "".config"", ""user-dirs.dirs"")),'r')
        data = fs.read()
        fs.close()
    except:
        data = """"

    D_paths = re.findall(r'XDG_DESKTOP_DIR=\""([^\""]*)', data)

    if len(D_paths) == 1:
        D_path = D_paths[0]
        D_path = re.sub(r'\$HOME', os.path.expanduser(""~""), D_path)

    else:
        D_path = os.sep.join((os.path.expanduser(""~""), 'Desktop'))

    if os.path.isdir(D_path):
        return D_path
    else:
        return None
</code></pre>

<p>It simply tries to parse the file where the users directories should be specified and if that fails it tries to use the English default. Finally it verifies that the directory exists. I admit that the regex-expressions could probably be improved, but I think it should be OK.</p>
"
"<p>Instead of reading directly from the <code>~/.config/user-dirs.dirs</code> file you can call the <code>xdg-user-dir</code> utility:</p>

<pre><code>import subprocess
subprocess.check_output(['xdg-user-dir', 'DESKTOP'])
</code></pre>

<p>This will work with any linux distribution that has a DE which follow the freedesktop specification, which means: KDE, Gnome, XFCE and many more(exactly like the solution already posted by the OP).</p>

<p><strong>Edit:</strong></p>

<p>Updated the <code>subprocess.check_output</code> since arguments need to be in a list.
Also worth pointing out that you can change DESKTOP to e.g. DOCUMENTS to get that folder.</p>
"
"<p>The way you designed your module is responsible for system being freeze. Note that, you've used for_each_process(), that means, it'll traverse every process of the system. So, when you put load on the system the number of process gets bigger. Moreover, inside your for_each_process() loop you're calling task_lock/unlock() and tried various operations on processes, all these operations are expensive, cause they all have their own lock to take. When system load is low they're not noticeable, but the complexity of your modules runtime increases as system gets more and more loaded, but remains less noticeable on low load. I'd suggest to use feature like ftrace to instrument your module also avoid over use of printk (cause printk also needs to be scheduled, klogd is used on that purpose). And with low load inspect how your module runs inside kernel. Measure how much time it spends on every loop, you get to know yourself. Kernel is a big beast, a lot of things happens inside...</p>
"
"<p>Try the following:</p>

<pre><code>read_lock(&amp;tasklist_lock);

do_each_thread(g, p) {
  task_lock(p);

  if (check_for_file(p, file)) {
    task_unlock(p);
    goto next;
  }

  task_unlock(p);
} while_each_thread(g, p);

next:

read_unlock(&amp;tasklist_lock);
</code></pre>
"
"<p>I have finally fixed my code.</p>

<p>I have first implemented a kind of caching of the relation between a process and an opened file in a linked list, and re-factored my code in multiples methods (and after having fixed memory leaks) it is now working.</p>

<p>Thank you all for your help.</p>
"
"<p>In Linux and other Unix-like OSs, a file object can be pointed to by any number of names, and the file object itself has no pointers back to any of them. Names are not a feature of the file, they are just an external index.</p>
"
"<p>Actuall you can retrieve the file path used to open the file.  In linux struct file represents an opened file and has the path used to open that file associate with the structure.  Before 2.6.20 it was a member called f_dentry and from 2.6.20 it is a new member called f_path.  You can use function d_path() to retrieve the full path of your file directly.</p>

<p>Refer to the following Linux source code:</p>

<p><a href=""http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.10#L763"" rel=""nofollow noreferrer"">http://lxr.free-electrons.com/source/include/linux/fs.h?v=3.10#L763</a></p>

<p><a href=""http://lxr.free-electrons.com/source/fs/dcache.c?v=3.0#L2626"" rel=""nofollow noreferrer"">http://lxr.free-electrons.com/source/fs/dcache.c?v=3.0#L2626</a></p>

<p>And also answer:
<a href=""https://stackoverflow.com/questions/8250078/how-can-i-get-a-filename-from-a-file-descriptor-inside-a-kernel-module/8250940#8250940"">How can I get a filename from a file descriptor inside a kernel module?</a></p>
"
"<p>In the Linux kernel, the <code>file</code> structure is essentially how the kernel ""sees"" the file. The kernel is not interested in the file name, just the inode of the open file. This means that all of the other information which is important to the user is lost.</p>

<hr>

<p>EDIT: This answer is wrong. You can get the <code>dentry</code> using <code>filp-&gt;f_path.dentry</code>. From there you can get the name of the dentry or the full path using the relevant FS flags.</p>
"
"<p>The path is stored in the file->f_path structure as it's name implies.  Just not in a plane-text form, but parsed into objects that are more useful for kernel operation, namely a chain of dentry structures, and the vfsmount structure pointing to the root of the current subtree.</p>

<p>You can use the d_path function to regenerate a human-readable path name for a struct path like file->f_path.  Note that however this is not a cheap operation and it may slow down your workload significantly.</p>

<p>The above mentioned issues about open but unlinked files, multiple hardlinks and similar are valid for mapping from and inode to a pathname, and open file always has a path associated with it.  If the file has been unlinked d_path will prepend a "" (deleted)"" to the name, and if the filename it has been opened with has been changed to something else using rename since it was opened d_path will not print the original name, but the current name of the entry that was used for opening it.</p>
"
"<p>You can get the filename from <code>struct file *filp</code> with <code>filp-&gt;f_path.dentry-&gt;d_iname</code>.</p>

<p>To get the full path call <code>dentry_path_raw(filp-&gt;f_path.dentry,buf,buflen)</code>.</p>
"
"<p>Did you mean exe file name? You can get the exe of current process as follows :</p>

<pre><code>char *pathname,*p;
mm = current-&gt;mm;
if (mm) {
    down_read(&amp;mm-&gt;mmap_sem);
    if (mm-&gt;exe_file) {
                pathname = kmalloc(PATH_MAX, GFP_ATOMIC);
                if (pathname) {
                      p = d_path(&amp;mm-&gt;exe_file-&gt;f_path, pathname, PATH_MAX);
                    /*Now you have the path name of exe in p*/
                }
            }
    up_read(&amp;mm-&gt;mmap_sem);
}
</code></pre>
"
"<p>You can <code>readlink(2)</code> with the path to <code>/proc/self/exe</code>, which in your case would be a link to the ELF. Metaexample using <code>readlink(1)</code>:</p>

<pre><code>$ readlink /proc/self/exe
/bin/readlink
</code></pre>

<p>Linux-only as far as I know.</p>
"
"<pre><code>Table 1-5: Kernel info in /proc         ..............................................................................
File        Content
apm         Advanced power management info
buddyinfo   Kernel memory allocator information (see text)  (2.5)
bus         Directory containing bus specific information
**cmdline**     Kernel command line
</code></pre>

<p>Ex.</p>

<pre><code>[root@localhost ~]# more /proc/364/cmdline
/usr/sbin/smbd
[root@localhost ~]# more /proc/364/common
/proc/364/common: No such file or directory
[root@localhost ~]# more /proc/364/comm
smbd
[root@localhost ~]#
</code></pre>
"
"<p>Do you mean getcwd()? <a href=""http://man7.org/linux/man-pages/man2/getcwd.2.html"" rel=""nofollow"">http://man7.org/linux/man-pages/man2/getcwd.2.html</a></p>

<pre><code>#include &lt;unistd.h&gt;
char * getcwd(char * buf, size_t size);
</code></pre>

<p>------------------EDIT----------------------</p>

<p>you wanna check another running program's path, you can find it in /proc/$PID/exe:</p>

<pre><code>ll /proc/$PID/exe
</code></pre>

<p>or</p>

<pre><code>ll /proc/$PID | grep exe
</code></pre>

<p>or </p>

<pre><code>readlink /proc/$PID/exe
</code></pre>
"
"<p>The <code>proc</code> filesystem returns this information in <code>/proc/&lt;pid&gt;/exe</code>, so you need to do something similar.</p>

<p><code>proc</code> gets the path of a process in the function <code>proc_exe_link</code> in <code>fs/proc/base.c</code>. This function is adapted from <code>proc_exe_link</code>:</p>

<pre><code>char *get_current_proc_path(char *buf, int buflen)
{
    struct file *exe_file;
    char *result = ERR_PTR(-ENOENT);
    struct mm_struct *mm;

    mm = get_task_mm(current);
    if (!mm) {
        goto out;
    }
    down_read(&amp;mm-&gt;mmap_sem);
    exe_file = mm-&gt;exe_file;
    if (exe_file) {
        get_file(exe_file);
        path_get(&amp;exe_file-&gt;f_path);
    }
    up_read(&amp;mm-&gt;mmap_sem);
    mmput(mm);
    if (exe_file) {
        result = d_path(&amp;exe_file-&gt;f_path, buf, buflen);
        path_put(&amp;exe_file-&gt;f_path);
        fput(exe_file);
    }

out:
    return result;
}
</code></pre>

<p>This will put the path somewhere in <code>buf</code> (not necessarily the beginning of the buffer), and return a pointer to the path. On error, it will return an <code>ERR_PTR</code>, so check that the pointer is valid with <code>IS_ERR</code>.</p>
"
"<p>Solution:</p>

<pre><code>find ""$d_path"" -type d -maxdepth 1 -name R | while IFS= read -r file; do


     nb_fichier_R=""$(find ""$file"" -type f -maxdepth 1 -iname '*.R' | wc -l)""
     echo ""$nb_fichier_R"" #here is fine

    find ""$file"" -type f -maxdepth 1 -iname '*.R' | while IFS= read -r fille; do
        wc -l $fille #here is the problem nothing shown
    done
done
</code></pre>

<p>Explanation:</p>

<p>adding <code>-print0</code> the first find produced no newline so you had to tell <code>read -d ''</code> to tell it not to look for a newline. Your subsequent finds output newlines so you can use read without a delimiter. I removed <code>-print0</code> and <code>-d ''</code> from all calls so it is consistent and idiomatic. Newlines are good in the unix world.</p>
"
"<p>For the command:</p>

<pre><code>find ""$d_path"" -type d -maxdepth 1 -name R -print0
</code></pre>

<p>there can be at most one directory that matches (<code>""$d_path/R""</code>).  For that one directory, you want to print:</p>

<ol>
<li>The number of files matching <code>*.R</code></li>
<li>For each such file, the number of lines in it.</li>
</ol>

<p>Allowing for spaces in <code>$d_path</code> and in the file names is most easily handled, I find, with an auxilliary shell script.  The auxilliary script processes the directories named on its command line.  You then invoke that script from the main <code>find</code> command.</p>

<h3>counter.sh</h3>

<pre><code>shopt -s nullglob;
for dir in ""$@""
do
    count=0
    for file in ""$dir""/*.R; do ((count++)); done
    echo ""$count""
    wc -l ""$dir""/*.R &lt;/dev/null
done
</code></pre>

<p>The <code>shopt -s nullglob</code> option means that if there are no <code>.R</code> files (with names that don't start with a <code>.</code>), then the glob expands to nothing rather than expanding to a string containing <code>*.R</code> at the end.  It is convenient in this script.  The I/O redirection on <code>wc</code> ensures that if there are no files, it reads from <code>/dev/null</code>, reporting 0 lines (rather than sitting around waiting for you to type something).</p>

<p>On the other hand, the <code>find</code> command will find names that start with a <code>.</code> as well as those that do not, whereas the globbing notation will not.  The easiest way around that is to use two globs:</p>

<pre><code>    for file in ""$dir""/*.R ""$dir""/.*.R; do ((count++)); done
</code></pre>

<p>or use <code>find</code> (rather carefully):</p>

<pre><code>    find . -type f -name '*.R' -exec sh -c 'echo $#' arg0 {} +
</code></pre>

<h3>Using counter.sh</h3>

<pre><code>find ""$d_path"" -type d -maxdepth 1 -name R -exec sh ./counter.sh {} +
</code></pre>

<p>This script allows for the possibility of more than one sub-directory (if you remove <code>-maxdepth 1</code>) and invokes <code>counter.sh</code> with all the directories to be examined as arguments.  The script itself carefully handles file names so that whether there are spaces, tabs or newlines (or any other character) in the names, it will work correctly.  The <code>sh ./counter.sh</code> part of the <code>find</code> command assumes that the <code>counter.sh</code> script is in the current directory.  If it can be found on <code>$PATH</code>, then you can drop the <code>sh</code> and the <code>./</code>.</p>

<h3>Discussion</h3>

<p>The technique of having <code>find</code> execute a command with the list of file name arguments is powerful.  It avoids issues with <code>-print0</code> and using <code>xargs -0</code>, but gives you the same reliable handling of arbitrary file names, including names with spaces, tabs and newlines.  If there isn't already a command that does what you need (but you could write one as a shell script), then do so and use it.  If you might need to do the job more than once, you can keep the script.  If you're sure you won't, you can delete it after you're done with it.  It is generally much easier to handle files with awkward names like this than it is to fiddle with <code>$IFS</code>.</p>
"
"<p>Consider this solution:</p>

<pre><code># If `""$dir""/*.R` doesn't match anything, yield nothing instead of giving the pattern.
shopt -s nullglob

# Allows matching both `*.r` and `*.R` in one expression. Using them separately would
# give double results.
shopt -s nocaseglob

while IFS= read -ru 4 -d '' dir; do
    files=(""$dir""/*.R)

    echo ""${#files[@]}""

    for file in ""${files[@]}""; do
        wc -l ""$file""
    done

    # Use process substitution to prevent going to a subshell. This may not be
    # necessary for now but it could be useful to future modifications.
    # Let's also use a custom fd to keep troubles isolated.
    # It works with `-u 4`.
done 4&lt; &lt;(exec find ""$d_path"" -type d -maxdepth 1 -name R -print0)
</code></pre>

<p>Another form is to use <code>readarray</code> which allocates all found directories at once. Only caveat is that it can only read normal newline-terminated paths.</p>

<pre><code>shopt -s nullglob
shopt -s nocaseglob

readarray -t dirs &lt; &lt;(exec find ""$d_path"" -type d -maxdepth 1 -name R)

for dir in ""${dirs[@]}""; do
    files=(""$dir""/*.R)

    echo ""${#files[@]}""

    for file in ""${files[@]}""; do
        wc -l ""$file""
    done
done
</code></pre>
"
"<p>Maybe I'm missing something, but wouldn't this do what you want?</p>

<pre><code>wc -l R/*.[Rr]
</code></pre>
"
"<pre><code>@echo off
PUSHD ""%sourcedir%""
setlocal enableDelayedExpansion

set ""Y=""
set ""M=""
 FOR /F ""skip=1 tokens=1,2"" %%A IN ('WMIC Path Win32_LocalTime Get Year^,Month /Format:table') DO (

    if not defined Y set ""Y=%%B""
    if not defined M set ""M=%%A""

 )

 if %M% lss 10 set M=0%M%
 echo current month : %Y%%M%

 for %%a in (.) do (
    set ""drive=%%~da""
    set ""d_path=%%~fa\""
 )

 set d_path=%d_path:~2%
 set d_path=%d_path:\=\\%


 rem wmic  datafile where ""drive='%drive%' and path like '%d_path%'"" get CreationDate,Name

 for /f ""tokens=* delims="" %%f in ('""wmic  datafile where (drive='%drive%' and path like '%d_path%') get CreationDate^,Name""') do (
    for /f ""tokens=1,2 delims= "" %%y in (""%%f"") do (
      set ""file_date=%%y""
      set ""file_path=%%z""
      set file_ym=!file_date:~0,6!
      echo the file !file_path!  has !file_ym! creation date
      if ""!file_ym!"" NEQ ""%Y%%M%"" (
        MOVE ""!file_path!"" ""D:\ftproot\ftp_db-backup\__REMOVE\""
      )

    )

 )

 endlocal
</code></pre>
"
"<pre class=""lang-dos prettyprint-override""><code>@ECHO Off
SETLOCAL enabledelayedexpansion
SET ""sourcedir=u:\sourcedir""
SET /a month=99
SET /a year=99
PUSHD ""%sourcedir%""
FOR /f ""skip=4tokens=1,2,3,5,*delims=/- "" %%a IN (
  'dir /a-d /tc /-c /od ""*"" '
  ) DO (
 IF ""%%d""=="""" GOTO done
 IF ""%%b-%%c"" equ ""%date:~-7,2%-%date:~-4%"" GOTO done
 IF %%b-%%c neq !month!-!year! (
  ECHO(leave ""%%e"" "".\x\""
  SET month=%%b
  SET year=%%c
 ) ELSE (
  ECHO(MOVE ""%%e"" "".\x\""
 )
)
:done
POPD

GOTO :EOF
</code></pre>

<p>Ah! my favourite - or at least one of them.</p>

<p>Received an angry phone call from someone who'd used one of my software modules. ""It didn't work"" ""Could have cost us millions."" Yeah - turns out they'd used a version modified by a third party who'd left my copyright notice and contact details in-place but hadn't bothered including a notice about their modifications....</p>

<p>Then there was the company which broke their commercial confidentiality agreement with me and gave my rival a copy of my software - which the rival included in their own software without attributing copyright rights - nor even acknowledgement. Fortuantely, they were unable to sell any further implementations of the software, due entirely to their incapacity to understand the business problems to be solved. They'd prefer to get their customers to change their business practices. Astonishingly, their customers seemed to meekly comply. After a few years of effort, they let the project drop entirely - after all, it was the business owner's loss, not theirs. They'd been paid to try (and fail) to understand the system, and it was no skin off of their noses for the boss to lose a few hundred thousand.</p>

<p>So I never again released source code to customers.</p>

<p>As for the current situation:</p>

<p><code>echo(</code> is an undocumented form of the <code>echo</code> statement that allows <code>echo(%emptyvalue%</code> to produce an empty line, whereas <code>echo %emptyvalue%</code> will report <code>echo is on/off</code>. The parenthesis as a <code>part</code> of the <code>echo</code> statement and play no part in the matching-parentheses count. Hence the problem with the <code>else</code> - it follows at a point which is not the <code>if not</code> part of an <code>if</code> statement - becaues the <code>echo(</code> does not open a parenthesised statement-sequence. The <code>(</code> is invisible.</p>

<p>As to the easy solution, restoring the original version; all that's needed is the new line</p>

<pre><code> IF ""%%b-%%c"" equ ""%date:~-7,2%-%date:~-4%"" GOTO done
</code></pre>

<p>so that the routine is forcefully terminated (and hence the files not <code>move</code>d) if the month-year of the file equals the month-year of the current date. The <code>/od</code> on the <code>dir</code> forces sorting in date-order, so the first time that the current date is found in the file-list must mean that the remaining files must also have a date-created of the current month-date, hence there's no point in checking them - they are to be retained.</p>
"
"<p>You are not supposed to call <code>proc_pid_cmdline()</code>.</p>

<p>It is a <a href=""http://lxr.free-electrons.com/source/fs/proc/base.c#L199"" rel=""nofollow"">non-public function</a> in <code>fs/proc/base.c</code>:</p>

<pre><code>static int proc_pid_cmdline(struct seq_file *m, struct pid_namespace *ns,
                            struct pid *pid, struct task_struct *task)
</code></pre>

<p>However, what it does is simple:</p>

<pre><code>get_cmdline(task, m-&gt;buf, PAGE_SIZE);
</code></pre>

<p>That is not likely to return the full path though and it will not be possible to determine the full path in every case. The arg[0] value may be overwritten, the file could be deleted or moved, etc. A process may exec() in a way which obscures the original command line, and all kinds of other maladies.</p>

<p>A scan of my Fedora 20 system /proc/*/cmdline turns up all kinds of less-than-useful results:</p>

<pre><code>-F
BUG:
WARNING: at
WARNING: CPU:
INFO: possible recursive locking detecte
ernel BUG at
list_del corruption
list_add corruption
do_IRQ: stack overflow:
ear stack overflow (cur:
eneral protection fault
nable to handle kernel
ouble fault:
RTNL: assertion failed
eek! page_mapcount(page) went negative!
adness at
NETDEV WATCHDOG
ysctl table check failed
: nobody cared
IRQ handler type mismatch
Machine Check Exception:
Machine check events logged
divide error:
bounds:
coprocessor segment overrun:
invalid TSS:
segment not present:
invalid opcode:
alignment check:
stack segment:
fpu exception:
simd exception:
iret exception:
/var/log/messages
--
/usr/bin/abrt-dump-oops
-xtD
</code></pre>
"
"<p>I have managed to solve a <em>version</em> of this problem. I wanted to access the <code>cmdline</code> of all PIDs but within the kernel itself (as opposed to a <em>kernel module</em> as the question states), but perhaps these principles can be applied to kernel modules as well?</p>

<p>What I did was, I added the following function to <code>fs/proc/base.c</code></p>

<pre><code>int proc_get_cmdline(struct task_struct *task, char * buffer) {
    int i;
    int ret = proc_pid_cmdline(task, buffer);

    for(i = 0; i &lt; ret - 1; i++) {
           if(buffer[i] == '\0')
                   buffer[i] = ' ';
   }
    return 0;
}
</code></pre>

<p>I then added the declaration in <code>include/linux/proc_fs.h</code><br>
<code>int proc_get_cmdline(struct task_struct *, char *);</code>  </p>

<p>At this point, I could access the <code>cmdline</code> of all processes within the kernel.
To access the <code>task_struct</code>, perhaps you could refer to <a href=""https://stackoverflow.com/q/8547332/1761555"">kernel: efficient way to find task_struct by pid?</a>.  </p>

<p>Once you have the <code>task_struct</code>, you should be able to do something like:  </p>

<pre><code>char cmdline[256];
proc_get_cmdline(task, cmdline);
if(strlen(cmdline) &gt; 0)
    printk(""  cmdline :%s\n"", cmdline);
else
    printk(""  cmdline :%s\n"", task-&gt;comm);
</code></pre>

<p>I was able to obtain the commandline of all processes this way.</p>
"
"<p>To get the full path of the binary behind a process.    </p>

<pre><code>char * exepathp;

struct file * exe_file;
struct mm_struct *mm;
char exe_path [1000];

//straight up stolen from get_mm_exe_file
mm = get_task_mm(current);
down_read(&amp;mm-&gt;mmap_sem); //lock read
exe_file = mm-&gt;exe_file;
if (exe_file) get_file(exe_file);
up_read(&amp;mm-&gt;mmap_sem); //unlock read

//reduce exe path to a string
exepathp = d_path( &amp;(exe_file-&gt;f_path), exe_path, 1000*sizeof(char) );
</code></pre>

<p>Where <em>current</em> is the task struct for the process you are interested in. The variable exepathp gets the string of the full path. This is slightly different than the process cmd, this is the path of binary which was loaded to start the process. Combining this path with the process cmd should give you the full path.</p>
"
"<p>That log message comes from the kernel with a fixed format that only includes the first 16 letters of the executable excluding the path as per <a href=""http://lxr.free-electrons.com/source/arch/x86/mm/fault.c#L729"" rel=""nofollow"">show_signal_msg</a>, see other relevant lines for segmentation fault on non x86 architectures.</p>

<p>As mentioned by Makyen, without significant changes to the kernel and a recompile, the message given to klogd which is passed to syslog won't have the information you are requesting.</p>

<p>I am not aware of any log transformation or injection functionality in syslog or klogd which would allow you to take the name of the file and run either locate or file on the filesystem in order to find the full path.</p>

<p>The best way to get the information you are looking for is to use crash interception software like <a href=""https://wiki.ubuntu.com/Apport"" rel=""nofollow"">apport</a> or <a href=""https://github.com/abrt/abrt/wiki/FAQ"" rel=""nofollow"">abrt</a> or <a href=""https://launchpad.net/debian/+source/corekeeper"" rel=""nofollow"">corekeeper</a>. These tools store the process metadata from the /proc filesystem including the process's commandline which would include the directory run from, assuming the binary was run with a full path, and wasn't already in path.</p>

<p>The other more generic way would be to enable core dumps, and then to set /proc/sys/kernel/core_pattern  to include <a href=""http://linux.die.net/man/5/core"" rel=""nofollow"">%E</a>, in order to have the core file name including the path of the binary.  </p>
"
"<p>The short answer is: No, it is not possible without making code changes and recompiling the kernel.  The normal solution to this problem is to instruct your students to name their executable <code>&lt;student user name&gt;_ex3.x</code> so that you can easily have this information.</p>

<p><strong>However, it is possible to get the information you desire</strong> from other methods. <a href=""https://stackoverflow.com/users/1184641/appleman1234"">Appleman1234</a> has provided some alternatives in his answer to this question.</p>

<p><strong>How do we know the answer is ""Not possible to the the full path <em>in the kern.log segfault messages</em> without recompiling the kernel"":</strong></p>

<p>We look in the kernel source code to find out how the message is produced and if there are any configuration options.</p>

<p>The files in question are part of the kernel source. You can download the entire kernel source as an rpm package (or other type of package) for whatever version of linux/debian you are running from a variety of places.</p>

<p>Specifically, the output that you are seeing is produced from whichever of the following files is for your architecture:</p>

<ul>
<li><a href=""http://lxr.free-electrons.com/source/arch/sparc/mm/fault_32.c"" rel=""nofollow noreferrer"">linux/arch/sparc/mm/fault_32.c</a></li>
<li><a href=""http://lxr.free-electrons.com/source/arch/sparc/mm/fault_64.c"" rel=""nofollow noreferrer"">linux/arch/sparc/mm/fault_64.c</a></li>
<li><a href=""http://lxr.free-electrons.com/source/arch/um/kernel/trap.c"" rel=""nofollow noreferrer"">linux/arch/um/kernel/trap.c</a></li>
<li><a href=""http://lxr.free-electrons.com/source/arch/x86/mm/fault.c"" rel=""nofollow noreferrer"">linux/arch/x86/mm/fault.c</a></li>
</ul>

<p>An example of the relevant function from one of the files(<em>linux/arch/x86/mm/fault.c</em>):</p>

<pre><code>/*
 * Print out info about fatal segfaults, if the show_unhandled_signals
 * sysctl is set:
 */
static inline void
show_signal_msg(struct pt_regs *regs, unsigned long error_code,
        unsigned long address, struct task_struct *tsk)
{
    if (!unhandled_signal(tsk, SIGSEGV))
        return;

    if (!printk_ratelimit())
        return;

    printk(""%s%s[%d]: segfault at %lx ip %p sp %p error %lx"",
        task_pid_nr(tsk) &gt; 1 ? KERN_INFO : KERN_EMERG,
        tsk-&gt;comm, task_pid_nr(tsk), address,
        (void *)regs-&gt;ip, (void *)regs-&gt;sp, error_code);

    print_vma_addr(KERN_CONT "" in "", regs-&gt;ip);

    printk(KERN_CONT ""\n"");
}
</code></pre>

<p>From that we see that the variable passed to printout the process identifier is <code>tsk-&gt;comm</code> where <code>struct task_struct *tsk</code> and <code>regs-&gt;ip</code> where <code>struct pt_regs *regs</code></p>

<p>Then from <a href=""http://lxr.free-electrons.com/source/include/linux/sched.h"" rel=""nofollow noreferrer""><em>linux/include/linux/sched.h</em></a></p>

<pre><code>struct task_struct {
    ...
    char comm[TASK_COMM_LEN]; /* executable name excluding path
                                 - access with [gs]et_task_comm (which lock
                                   it with task_lock())
                                 - initialized normally by setup_new_exec */
</code></pre>

<p>The comment makes it clear that the path for the executable is not stored in the structure.</p>

<p>For <code>regs-&gt;ip</code> where <code>struct pt_regs *regs</code>, it is defined in whichever of the following are appropriate for your architecture:</p>

<ul>
<li><a href=""http://lxr.free-electrons.com/source/arch/arc/include/asm/ptrace.h"" rel=""nofollow noreferrer"">arch/arc/include/asm/ptrace.h</a></li>
<li><a href=""http://lxr.free-electrons.com/source/arch/arm/include/asm/ptrace.h"" rel=""nofollow noreferrer"">arch/arm/include/asm/ptrace.h</a></li>
<li><a href=""http://lxr.free-electrons.com/source/arch/arm64/include/asm/ptrace.h"" rel=""nofollow noreferrer"">arch/arm64/include/asm/ptrace.h</a></li>
<li><a href=""http://lxr.free-electrons.com/source/arch/cris/include/arch-v10/arch/ptrace.h"" rel=""nofollow noreferrer"">arch/cris/include/arch-v10/arch/ptrace.h</a></li>
<li><a href=""http://lxr.free-electrons.com/source/arch/cris/include/arch-v32/arch/ptrace.h"" rel=""nofollow noreferrer"">arch/cris/include/arch-v32/arch/ptrace.h</a></li>
<li><a href=""http://lxr.free-electrons.com/source/arch/metag/include/asm/ptrace.h"" rel=""nofollow noreferrer"">arch/metag/include/asm/ptrace.h</a></li>
<li><a href=""http://lxr.free-electrons.com/source/arch/mips/include/asm/ptrace.h"" rel=""nofollow noreferrer"">arch/mips/include/asm/ptrace.h</a></li>
<li><a href=""http://lxr.free-electrons.com/source/arch/openrisc/include/asm/ptrace.h"" rel=""nofollow noreferrer"">arch/openrisc/include/asm/ptrace.h</a></li>
<li><a href=""http://lxr.free-electrons.com/source/arch/um/include/asm/ptrace-generic.h"" rel=""nofollow noreferrer"">arch/um/include/asm/ptrace-generic.h</a></li>
<li><a href=""http://lxr.free-electrons.com/source/arch/x86/include/asm/ptrace.h"" rel=""nofollow noreferrer"">arch/x86/include/asm/ptrace.h</a></li>
<li><a href=""http://lxr.free-electrons.com/source/arch/xtensa/include/asm/ptrace.h"" rel=""nofollow noreferrer"">arch/xtensa/include/asm/ptrace.h</a></li>
</ul>

<p>From there we see that <code>struct pt_regs</code> is defining registers for the architecture. <code>ip</code> is just: <code>unsigned long ip;</code></p>

<p>Thus, we have to look at what <code>print_vma_addr()</code> does.  It is defined in <a href=""http://lxr.free-electrons.com/source/mm/memory.c#L3676"" rel=""nofollow noreferrer""><em>mm/memory.c</em></a></p>

<pre><code>/*
 * Print the name of a VMA.
 */
void print_vma_addr(char *prefix, unsigned long ip)
{
    struct mm_struct *mm = current-&gt;mm;
    struct vm_area_struct *vma;

    /*
     * Do not print if we are in atomic
     * contexts (in exception stacks, etc.):
     */
    if (preempt_count())
        return;

    down_read(&amp;mm-&gt;mmap_sem);
    vma = find_vma(mm, ip);
    if (vma &amp;&amp; vma-&gt;vm_file) {
        struct file *f = vma-&gt;vm_file;
        char *buf = (char *)__get_free_page(GFP_KERNEL);
        if (buf) {
            char *p;

            p = d_path(&amp;f-&gt;f_path, buf, PAGE_SIZE);
            if (IS_ERR(p))
                p = ""?"";
            printk(""%s%s[%lx+%lx]"", prefix, kbasename(p),
                    vma-&gt;vm_start,
                    vma-&gt;vm_end - vma-&gt;vm_start);
            free_page((unsigned long)buf);
        }
    }
    up_read(&amp;mm-&gt;mmap_sem);
}
</code></pre>

<p>Which shows us that <em>a path</em> was available. We would need to check that it was <em>the path</em>, but looking a bit further in the code gives a hint that it might not matter.  We need to see what <code>kbasename()</code> did with the path that is passed to it. <code>kbasename()</code> is defined in <a href=""http://lxr.free-electrons.com/source/include/linux/string.h#L154"" rel=""nofollow noreferrer""><em>include/linux/string.h</em></a> as:</p>

<pre><code>/**
 * kbasename - return the last part of a pathname.
 *
 * @path: path to extract the filename from.
 */
static inline const char *kbasename(const char *path)
{
    const char *tail = strrchr(path, '/');
    return tail ? tail + 1 : path;
}
</code></pre>

<p>Which, even if the full path is available prior to it, chops off everything except for the last part of a pathname, leaving the filename.</p>

<p>Thus, no amount of runtime configuration options will permit printing out the full pathname of the file in the segment fault messages you are seeing.</p>
"
"<p>I was in a similar situation and had to find this on my own. Hope others who come here benefit from my answer. </p>

<p>So I am assuming you want the values corresponding to ""Mapping"" column of a <code>pmap</code> command ouput. The following works for me(tried on v4.6.4):</p>

<pre><code>char filename[50];
if(vmlist-&gt;vm_file){
    strcpy(filename, vmlist-&gt;vm_file-&gt;f_path.dentry-&gt;d_iname);
}
else{ // implies an anonymous mapping i.e. not file backup'ed
    strcpy(filename, ""[ anon ]"");
}
</code></pre>

<p>After getting to the <strong>path</strong>, follow it's <strong>dentry</strong> field and then <strong>d_iname</strong> which is the mapped file's name. Doesn't look quite pretty, but does the job.</p>
"
"<p>Use VFS layer for this (dcache/nameidata in particular).</p>

<pre><code>#include &lt;linux/namei.h&gt;
#include &lt;linux/dcache.h&gt;

...

struct path path;
char buf[256];
char* ptr;
int err = kern_path(""/dev/disk/by-id/dm-name-lkdevel-root"",
                    LOOKUP_FOLLOW, &amp;path);

if(!err) {
    ptr = d_path(&amp;path, buf, 256);

    if(!IS_ERR(ptr)) {
        /* ptr contains real path */
    }
}
</code></pre>

<p>This was tested on vanilla Linux 3.12</p>

<p>Note that <code>d_path()</code> may return weird results for special filesystems and append <code>(deleted)</code> suffix to deleted files.</p>
"
"<p>Try to use sys_readlink() system call.</p>
"
"<p>It is unclear what you try to get, so here are list of options:</p>

<ul>
<li><p><code>execname</code> as it is considered by SystemTap. Simple <code>process-&gt;comm</code> should suffice. That is how <code>comm</code> field defined in Kernel:</p>

<pre><code>char comm[TASK_COMM_LEN]; /* executable name excluding path
                            - access with [gs]et_task_comm (which lock
                            it with task_lock())
                            - initialized normally by setup_new_exec */
</code></pre>

<p>But if <code>bash</code> is a symlink, than comm should contain symlink's name, not the real executable name.</p></li>
<li><p><code>argv[0]</code> first element of command line arguments array as it seen my application (and may be altered by it). There is a <code>get_cmdline()</code> function in kernel, but it seem not to be exported.</p></li>
<li><p>Basename of full path. In this case, do not call <code>d_path</code>, just take <code>d_name</code> field of dentry:</p>

<pre><code>strlcpy(pathname, mm-&gt;exe_file-&gt;f_path-&gt;d_name, PATH_MAX);
</code></pre></li>
</ul>

<p>But it sounds like a XY problem. You trying to get executable names for all forking processes? Why not use <a href=""https://sourceware.org/systemtap/"" rel=""nofollow"">SystemTap</a> directly?</p>

<pre><code># stap -v -e 'probe scheduler.process_fork { println(execname()); }'
</code></pre>
"
"<p>Try the following:</p>

<pre><code>    char *tmp = (char*)__get_free_page(GFP_TEMPORARY);

    file *file = fget(dfd);
    if (!file) {
        goto out
    }

    char *path = d_path(&amp;file-&gt;f_path, tmp, PAGE_SIZE);
    if (IS_ERR(path)) {
        printk(""error: %d\n"", (int)path);
        goto out;
    }

    printk(""path: %s\n"", path);
out:
    free_page((unsigned long)tmp);
</code></pre>
"
"<p><code>.f_inode</code> is actually an inode.</p>

<p><code>.f_path-&gt;dentry</code> is a dentry.</p>

<p>Traversing this dentry via <code>-&gt;d_parent</code> link, until <code>f_path.mnt.mnt_root</code> dentry will be touched, and collecting <code>dentry-&gt;d_name</code> components, will construct the file's path, relative to the mount point. This is done, e.g., with <a href=""http://lxr.free-electrons.com/source/fs/dcache.c?v=3.19#L2939"" rel=""nofollow"">d_path</a>, but in more carefull way.</p>

<p>Instead of <code>fcheck(fd)</code>, which should be used inside RCU read section, you can also use <code>fget(fd)</code>, which should be paired with <code>fput()</code>.</p>
"
"<p>The approach is completely incorrect - see <a href=""http://www.watson.org/~robert/2007woot/"" rel=""nofollow"">http://www.watson.org/~robert/2007woot/</a></p>

<p>Linux already has a reliable mechanism for doing this thing (audit). If you want to implement it anyway (for fun I presume), you want to place your hooks roughly where audit is doing that. Chances are LSM hooks are in appropriate places, have not checked.</p>
"
"<p>Dentry's field <code>d_name</code> is a simple (and mostly used) way for maintain naming of the dentry. In that case filesystem driver needs to specify name of the dentry once, all other work will be done by VFS.</p>

<p>But in some case statically assigned name is not sufficient for filesystems. As you note, this is case for <code>proc</code> filesystem, which exhibits per-process information into the user space. For such cases method <code>-&gt;d_op-&gt;d_dname</code> exists.</p>

<p>Implementation of <a href=""http://lxr.free-electrons.com/source/fs/dcache.c#L3079"" rel=""nofollow"">d_path</a> method may help in understanding of <code>d_name</code> and <code>d_op-&gt;d_dname</code>:</p>

<pre><code>...
if (path-&gt;dentry-&gt;d_op &amp;&amp; path-&gt;dentry-&gt;d_op-&gt;d_dname &amp;&amp;
    (!IS_ROOT(path-&gt;dentry) || path-&gt;dentry != path-&gt;mnt-&gt;mnt_root))
        return path-&gt;dentry-&gt;d_op-&gt;d_dname(path-&gt;dentry, buf, buflen);
rcu_read_lock();
get_fs_root_rcu(current-&gt;fs, &amp;root);
error = path_with_deleted(path, &amp;root, &amp;res, &amp;buflen);
rcu_read_unlock();
...
</code></pre>

<p>As you can see, <code>d_op-&gt;d_dname</code> method's field is checked first. If it is not NULL, then the method is used. Otherwise <code>d_name</code> field is read.</p>
"
"<p>====> Modified code</p>

<pre><code>#include &lt;linux/fs_struct.h&gt;
static int __init hello_init(void){
    struct path path1, path3;
    int err = kern_path(path_name1, LOOKUP_PARENT, &amp;path1);
    printk(""Path name1 : %s, err: %d\n"", path_name1, err);
    if(err == -2)
            err = checkParentPathExist(path_name1, &amp;path1);
    printk(""Path name1 : %s, err: %d\n"", path_name1, err);
    return 0;    // Non-zero return means that the module couldn't be loaded.
}
</code></pre>

<p>=====> <strong>Implemented below code but process memory is getting corrupted and crashing. Not able to understand why it is getting crashed ? Please let me know, what is the issues in below code or kern_path() ?.</strong> </p>

<pre><code>static int checkParentPathExist(char *tmpPath, struct path*  path){
    char *tmpPath4 = NULL;
    int err, flag = 0;

    switch(tmpPath[0]){
            case '/':
            case '.':
                    break;
            default:{
                    char *fname = (char *) __get_free_page(GFP_KERNEL);
                    if (!fname){
                            return -1;
                    }
                    memset(fname, 0, PAGE_SIZE);
                    struct path pwd = current-&gt;fs-&gt;pwd;
                    path_get(&amp;pwd);

                    tmpPath4 = d_path(&amp;pwd, fname, PAGE_SIZE);
                    path_put(&amp;pwd);
                    strcat(tmpPath4,""/"");
                    strcat(tmpPath4,tmpPath);
                    free_page(((unsigned long) fname));
            }
    }

    if(tmpPath4 == NULL){
            flag = 1;
            tmpPath4 = (char *) kmalloc(strlen(tmpPath)+1, GFP_KERNEL);
            if (!tmpPath4)
                    return -1;
            memset(tmpPath4, 0, strlen(tmpPath)+1);
            strcpy(tmpPath4, tmpPath);
    }

    int indx=0, setIndx=0;
    for(;tmpPath4[indx];indx++)
            if(tmpPath4[indx] == '/')
                    setIndx = indx;
    tmpPath4[setIndx] = 0;

    /*================ Getting Issue ================
       Below line issue is (err = kern_path(tmpPath4, LOOKUP_DIRECTORY, path);)
       1. Working fine, and returning success with parent path.
       2. Problem is other process memory is getting corrupted.
       3. Getting continues crashes with bellow message
          i.  BUG: Bad page state in process
          ii. BUG: Bad page map in process
       Message from syslogd@ip-172-31-30-235 at Aug  3 07:20:44 ...
       kernel:[   24.017598] page:ffffea0000eb8380 count:-1 mapcount:0 mapping:          (null) index:0x0
       4. No crashes if below line is commented
    */

    err = kern_path(tmpPath4, LOOKUP_DIRECTORY, path);

    if(flag) {
            kfree(tmpPath4);
    }
    return err;
}
</code></pre>
"
"<p>use this func -> kallsyms_lookup_name(""filename_parentat"") to get the func pointer, than yo</p>
"
"<pre><code>if (vg_bufObj[indice].protocolType == _NO_BLOC)
vg_bufObj[indice].dev_fd = open(d_path, O_RDONLY | O_NONBLOCK);
else
vg_bufObj[indice].dev_fd = open(d_path, O_RDONLY);
</code></pre>

<p>vg_bufObj is struct and declared extern</p>

<p>in other function I read the file with </p>

<pre><code>read_size = read(vg_bufObj[indice].dev_fd, data, 8);
</code></pre>

<p>When the protocolType  is specified _BLOC the file is open blocking, but when I read it from the another function it return empty data and the read size return the max value of the variable.</p>
"
"<p><code>readlink</code> <em>can</em> be used with a link target that's longer than <code>PATH_MAX</code>. There are two restrictions: the name of the link itself must be shorter than <code>PATH_MAX</code> (check, <code>""/proc/self/fd/&lt;fd&gt;""</code> is about 20 characters) and the provided output buffer must be large enough. You might want to call <code>lstat</code> first to figure out how big the output buffer should be, or just call <code>readlink</code> repeatedly with growing buffers.</p>
"
"<p>the limitation of <code>PATH_MAX</code> births from the fact that the unix (or linux, from now) needs to bind the size of parameters passed to the kernel.  There's no limit on how deep a file hierarchy can grow, and always there's the possibility to access all files, independent on how deep they are in the filesystem hierarchy.  What is actually limited is the lenght of the string you can pass or receive from the kernel representing a file name.  This means you cannot create (because you have to pass the target path) a symlink longer than this length, but you can have easily paths far longer this limit.</p>

<p>When you pass a filename to the kernel, you can do that for two reasons, to name a file (or device, or socket, or fifo, or whatever), to open it, etc.  YOu do this and your filename goes first to a routine that converts that path into an inode (which is what the kernel manages actually).  That routine begins scanning from two possible point in the filesystem hierarchi.  Those points are the inode reference of the root inode and the inode reference of the curren working diretory of a process.  The selection of which inode to use as departure inode depends on the presence of a leading <code>/</code> character at the begining of the path.  From this point, up to <code>PATH_MAX</code> characters will be processed each time, but that can lead us deep enough that we cannot get to the root in one step only...</p>

<p>Suppose you use the path to change your current directory, and do a <code>chdir A/B/C/D/E/.../Z</code>.  Once there, you create new directories and do the same thing, <code>chdir AA/AB/AC/AD/AE/.../AZ</code>, then <code>chdir BA/BB/BC/BD/...</code> and so on... there's nothing in the system that forbids you to get so deep in the filesystem (you can try that yourself, I have done and tested before)  You can grow to a map that is by far larger than <code>PATH_MAX</code>.  But this only mean that you cannot get there directly from the filesystem root.  You can go there in steps, as much as the system allows you, and depending on where you fix you root directory (by means of the <code>chroot(2)</code> syscall) or your current directory (by means of the <code>chdir(2)</code> syscall)</p>

<p>probably you have notice (or not) that there's no system call to get your curren working directory path from root... There are several reasons for this:</p>

<ul>
<li>root inode and curren working inode are two local-to-process concepts.  Two processes in the same system can have different working directories, and also different root directories, up to the point that they are able to share nothing in common and no way from one's directory to reach the other.</li>
<li>inode path can be ambiguous.  Well, this is not true for a directory, as it is not allowed two hard links to point to the same directory inode (this was possible in older unices, where directories had to be created with the <code>mknod(2)</code> system call, if you have access to some hp-ux v6 or old Unix SysV R4 you can create directories with a <code>...</code> entry ---pointing to the granparent of a directory or similar things, just being root and knowing how to use the <code>mknod(2)</code> syscall)  The idea is that when two links point to the same inode, which (or both) of then goes to the root, which one is the right path from the root inode to the current dir?</li>
<li>curren inode and root can be separated by a path far enough to not fit in the <code>PATH_MAX</code> limit.</li>
<li>there can be several different filesystems (and filesystem types) involved in getting to the root.  So this is not something that can be obtained only knowing the stored data in the disks, you must know the mounting table.</li>
</ul>

<p>For these reasons, there's no direct support in the kernel to know the root path to a file.  And also there's no way to get the path (and this is what the <code>pwd(1)</code> command does) than to follow the <code>..</code> entry and get to the parent directory and search there a link that gets to the inode number of the current dir... and repeat this until the parent inode is the same as the last inode visited.  Only then you'll be in the root directory (your root directory, that is different in general of other processes root directories)</p>

<p>Just try this exercise:</p>

<pre><code>i=0
while [ ""$i"" -lt 10000 ]
do
    mkdir dir-$i
    cd dir-$i
    i=$(expr ""$i"" + 1)
done
</code></pre>

<p>and see how far you can go from the root directory in your hierarchy.</p>

<h1>NOTE 1</h1>

<p>Another reason to be impossible to get the path to a file from an open descriptor is that you have access only to the inode (the path you used to <code>open(2)</code> it can have no relationship to the actual root path, as you can use symlinks and relative to the working directory, or changed root dir in between the open call and the time you want to access the path, it can even not exist, as you can have <code>unlink(2)</code>d it)  The inode information has no reference to the path to the inode, as there can be multiple (even millions) paths to a file. In the inode you have only a ref count, which means the number of paths that actually finish on that inode.</p>
"
"<p>The idea is wrong and the code is wrong. What is the actual goal? Why is the file not open for writing to begin with? How can the program suddenly start writing to the file if it explicitly opened it for reading? This does not add up whatsoever.</p>

<p>You can't just plop the flag to have the file open for writing either. You will have to re-do all the checks in the open path.</p>

<pre><code>static int __init mainInit(void){
</code></pre>

<p>For the most part the kernel does not use camelCase.</p>

<pre><code>    int pid=13433;
</code></pre>

<p>Missing spaces around '='.</p>

<pre><code>    struct task_struct * task;
</code></pre>

<p>Spurious space between '*' and 'task'.</p>

<pre><code>    struct files_struct * files;
    struct fdtable * filestable;
</code></pre>

<p>The iditom is to name it 'fdt'.</p>

<pre><code>    struct path files_path;

    //Get Task structure from PID
    task = pid_task(find_vpid(pid), PIDTYPE_PID );
</code></pre>

<p>Neither rcu nor tasklist are held, hence this is unsafe.</p>

<pre><code>    //Get open FIles from the task tstructure
    files = task-&gt;files;
</code></pre>

<p>task lock is not held, hence the derefeence is unsafe.</p>

<pre><code>    filestable=files_fdtable(files);
</code></pre>

<p>The kernel itself would tell you the line is wrong if you had debug enabled.</p>

<pre><code>    int i=0;
    char *cwd;
    char *buf = (char *)kmalloc(GFP_KERNEL,100*sizeof(char));
</code></pre>

<p>Why cast, why 100 and why include sizeof(char)? Hardcoded 100 here is additionally wrong as it invites an error prone repetition of the number.</p>

<pre><code>    while(filestable-&gt;fd[i] != NULL){
</code></pre>

<p>Not only fd table lock is not held, hence the traversal is unsafe, it does not work they way you want it to. A process can have unused fds in-between used ones.</p>

<pre><code>        files_path = filestable-&gt;fd[i]-&gt;f_path;
        cwd=d_path(&amp;files_path,buf, 100*sizeof(char));
</code></pre>

<p>Invited error prone repetition of the number 100. What makes you think it is safe to d_path here in the first place?</p>

<pre><code>        printk(KERN_INFO ""Open FD with %d with name %s with access %x\n"", i, cwd,filestable-&gt;fd[i]-&gt;f_mode);

        //printk(KERN_INFO ""FMode read:%x Fmodewrite:%x\n"",FMODE_READ,FMODE_WRITE);


        //Check access mode
        if(filestable-&gt;fd[i]-&gt;f_mode==FMODE_READ){
            printk(KERN_INFO ""File has access FMODE_READ\n"");
        }else if(filestable-&gt;fd[i]-&gt;f_mode==FMODE_WRITE){
            printk(KERN_INFO ""File has access FMODE_WRTIE\n"");
        }
        i++;
    }
    return 0;
}

static void __exit mainExit(void){
    printk(KERN_INFO ""Goodbye Kernel!. Returning to normal useless world!\n"");
}
</code></pre>
"
"<p>To add an element to the tail</p>

<pre><code> searchPool *ptr;
 searchPool *prev = 0;
 searchPool *head = something;

 for(ptr = head; ptr != NULL; ptr = ptr-&gt;next)
   prev = ptr;
 element-&gt;next = 0;
 prev-&gt;next = element;
</code></pre>

<p>To add to the head (faster)</p>

<pre><code> element-&gt;next = head;
 head = element;
</code></pre>

<p>Note head is not stable now.</p>

<p>To add one after the head</p>

<pre><code>element-&gt;next = head-&gt;next;
head-&gt;next = element
</code></pre>

<p>Note that head is now probably  a dummy node without any
data in it, which exists for the sake of having a stable
and constant ""head"" pointer to the linked list;</p>
"
"<p>Your code don't make sense. You don't need to allocate a struct <strong>and</strong> his members. Plus don't <a href=""https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc"">cast the return of malloc</a>. You don't check the return of <code>malloc()</code>. And you don't copy the strings.</p>

<p>In your second function you should return the linked list and check return function of <code>opendir()</code>.</p>

<p>Here a example:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;dirent.h&gt;

typedef struct searchPool searchPool;
struct searchPool {
  char *path;
  char *fileName;
  char *pathFile;
  searchPool *next;
};

static searchPool *mallocStructPool(char *path, char *fileName) {

  searchPool *element = malloc(sizeof *element);
  if (element == NULL) {
    goto error;
  }

  size_t path_size = strlen(path);
  element-&gt;path = malloc(path_size + 1);
  if (element-&gt;path == NULL) {
    goto free_element;
  }

  size_t fileName_size = strlen(fileName);
  element-&gt;fileName = malloc(fileName_size + 1);
  if (element-&gt;fileName == NULL) {
    goto free_path;
  }

  element-&gt;pathFile = malloc(path_size + 1 + fileName_size + 1);
  if (element-&gt;pathFile == NULL) {
    goto free_fileName;
  }

  memcpy(element-&gt;path, path, path_size);
  element-&gt;path[path_size] = '\0';

  memcpy(element-&gt;fileName, fileName, fileName_size);
  element-&gt;fileName[fileName_size] = '\0';

  memcpy(element-&gt;pathFile, path, path_size);
  element-&gt;pathFile[path_size] = '/';
  memcpy(element-&gt;pathFile + path_size + 1, fileName, fileName_size);
  element-&gt;pathFile[path_size + 1 + fileName_size] = '\0';

  return element;
free_fileName:
  free(element-&gt;fileName);
free_path:
  free(element-&gt;path);
free_element:
  free(element);
error:
  return NULL;
}

searchPool *listDir(char *path);

static searchPool *listDir_aux(char *path, struct dirent *dirent) {
  if (dirent-&gt;d_type == DT_DIR &amp;&amp; dirent-&gt;d_type != DT_LNK &amp;&amp;
      strcmp(dirent-&gt;d_name, ""."") != 0 &amp;&amp; strcmp(dirent-&gt;d_name, "".."") != 0) {
    size_t path_size = strlen(path);
    size_t name_size = strlen(dirent-&gt;d_name);
    char *d_path = malloc(path_size + 1 + name_size + 1);
    if (d_path == NULL) {
      return NULL;
    }

    memcpy(d_path, path, path_size);
    d_path[path_size] = '/';
    memcpy(d_path + path_size + 1, dirent-&gt;d_name, name_size);
    d_path[path_size + 1 + name_size] = '\0';

    searchPool *ret = listDir(d_path);

    free(d_path);

    return ret;
  }
  return mallocStructPool(path, dirent-&gt;d_name);
}

searchPool *listDir(char *path) {
  printf(""%s\n"", path);
  DIR *dir = opendir(path);
  if (dir == NULL) {
    perror(""dir()"");
    return NULL;
  }

  searchPool *head = NULL;

  struct dirent *dirent;
  while ((dirent = readdir(dir)) != NULL) {
    searchPool *elem = listDir_aux(path, dirent);
    if (elem != NULL) {
      elem-&gt;next = head;
      head = elem;
    }
  }
  closedir(dir);

  return head;
}

int main(void) {
  searchPool *head = listDir(""/tmp"");
  searchPool *tmp;
  for (searchPool *elem = head; elem != NULL; elem = tmp) {
    printf(""%s, %s, %s\n"", elem-&gt;path, elem-&gt;fileName, elem-&gt;pathFile);
    free(elem-&gt;path);
    free(elem-&gt;fileName);
    free(elem-&gt;pathFile);
    tmp = elem-&gt;next;
    free(elem);
  }
}
</code></pre>
"
"<p>I think you can modify your prototype to add a <code>struct search *</code> param wich gonna be the head pointeur of your list.</p>

<p>And when u need to put an element in your list just add a node in queue (or in head if u want but u need a <code>struct search **</code> instead of a simple pointer.
And then when u need to put an element just call the function which gonna create an element and place it where u want.
After that u will just give to every recursive call the <code>head ptr</code> of your list</p>
"
"<p>You need to create a new <code>search</code> node every time you find a file. Fill in the new node, then add it to the end of the list.</p>

<pre><code>const char *path_format = ""%s/%s"";

// Modified to take a node ptr. This should be the last node in the list
// Returns a node ptr. This is the new last node in the list
search * show_dir_content(char * path, search *node)
{
    DIR * d = opendir(path);
    if(d==NULL) return node;
    struct dirent * dir;
    while ((dir = readdir(d)) != NULL)
    {
        if(dir-&gt; d_type != DT_DIR) {
            // Found a file. Alloc a new search node and fill in
            // (TODO: You should check the return from malloc for failure)
            search *new_node = malloc(sizeof(search));
            // TODO: copy all the names. Hint: strdup
            new_node-&gt;next = NULL;
            // Append to end of list
            node-&gt;next = new_node;
            // Update node pointer to now point to the new node
            node = node-&gt;next;
        }
        else
            if(dir -&gt; d_type == DT_DIR &amp;&amp; strcmp(dir-&gt;d_name,""."")!=0 &amp;&amp; strcmp(dir-&gt;d_name,"".."")!=0 )   // if it is a directory
            {
                // Not sure 255 chars will be enough....
                char d_path[255];                               // here I am using sprintf which is safer than strcat
                sprintf(d_path, path_format, path, dir-&gt;d_name);
                printf(""%s\n"",d_path);
                // Make sure you update the node pointer to reflect any
                // changes made in the recursive call
                node = show_dir_content(d_path, node);
            }
    }
    closedir(d);
    // Return the last node (this may be same as input parameter if no files found
    return node;
}
</code></pre>

<p>Update <code>main</code> to create a root node and pass that to the function</p>

<pre><code>int main(int argc, char **argv)
{
    search root = {0};
    show_dir_content(argv[1], &amp;root);
    // Note that root is a dummy node.
    // The list actually begins at root-&gt;next

    // Also, before you exit, free all mem
    search *node = root.next, *next;
    while (NULL != node) {
        free(node-&gt;path);
        free(node-&gt;fileName);
        free(node-&gt;fullPathToFile);
        next = node-&gt;next;
        free(node);
        node = next;
    }

    return(0);
}
</code></pre>
"
"<p>As pointed out by @unwind in the comments:</p>

<blockquote>
  <p>You're storing the address of a local variable. That will get you undefined behavior. You must dynamically allocate room for the path itself, not just the pointer to it. </p>
</blockquote>

<p>The smallest change would be to change the line:</p>

<pre><code>            filepathlist[*size] = d_path;
</code></pre>

<p>to </p>

<pre><code>            filepathlist[*size] = strdup(d_path); // d_path will go out of scope - copy the string to dynamically allocated memory.
</code></pre>

<p>Make sure you <code>#include &lt;string.h&gt;</code> to get the prototype for <code>strdup</code>.</p>

<p><strong>EDIT:</strong></p>

<p>Another problem is that when you <code>realloc(filepathlist)</code> the variable in <code>main</code> still points to the old location. This can be fixed by letting <code>find_dir_content</code> return the current location of <code>filepathlist</code>:</p>

<pre><code>char **filepathlist(...) {
    ...
    return filepathlist;
}
</code></pre>

<p>and in main:</p>

<pre><code>filepathlist = find_dir_content(""pack"", filepathlist, &amp;sizefilepathlist);
</code></pre>
"
"<p>I think the problem is in this line:</p>

<pre><code>sprintf(d_path,""%s/%s "",*path,ep-&gt;d_name);
                     ^
</code></pre>

<p>where you have an extra space at the end which results in <code>stat()</code> calls failing. You need to remove that space.</p>

<p>By the way, avoid <code>sprintf()</code>. Use <code>snprintf()</code> instead.</p>
"
"<p>I found way to get full path process from pid.
Full path process is symlink of /proc//exe, so I must find symlink of it.
Here is code:</p>

<pre><code>long GetSymLinkOfFile(const char *pzsFilePath, char *pszRealPath, int iSize)
{
    struct path path_struct;
    char pszBuffer[256];
    char *result = ERR_PTR(-ENOENT);
    int err = 0;
    int iLengthOfResult = 0;

    if (pzsFilePath == NULL || pszRealPath == NULL)
    {
        printk(""Buffer is NULL.\n"");
        return -EINVAL;
    }

    err = kern_path(pzsFilePath, LOOKUP_FOLLOW, &amp;path_struct);

    if (err &lt; 0)
    {
        printk(""kern_path error, error code: %d"", err);
        return iLengthOfResult;
    }

    result = d_path(&amp;path_struct, pszBuffer, 256);

    if (IS_ERR(result) == true)
    {
        printk(""d_path GetSymlink error: %s"", result);
        return iLengthOfResult;
    }

    iLengthOfResult = strlen(result);

    if (iLengthOfResult &lt;= iSize)
        strcpy(pszRealPath, result);

    return iLengthOfResult;
}
</code></pre>
"
"<p>Assuming you just want the the first <code>m</code> output frequencies:</p>

<pre><code>int
FUNCTION(gsl_dft_complex,transform) (const BASE data[],
                                     const size_t stride,
                                     const size_t n, // input size
                                     const size_t m, // output size (m &lt;= n)
                                     BASE result[],
                                     const gsl_fft_direction sign)
{

    size_t i, j, exponent;

    const double d_theta = 2.0 * ((int) sign) * M_PI / (double) n;

    /* FIXME: check that m &lt;= n and give error */

    for (i = 0; i &lt; m; i++) // for each of m output bins
    {
        ATOMIC sum_real = 0;
        ATOMIC sum_imag = 0;

        exponent = 0;

        for (j = 0; j &lt; n; j++) // for each of n input points
        {
            double theta = d_theta * (double) exponent;
            /* sum = exp(i theta) * data[j] */

            ATOMIC w_real = (ATOMIC) cos (theta);
            ATOMIC w_imag = (ATOMIC) sin (theta);

            ATOMIC data_real = REAL(data,stride,j);
            ATOMIC data_imag = IMAG(data,stride,j);

            sum_real += w_real * data_real - w_imag * data_imag;
            sum_imag += w_real * data_imag + w_imag * data_real;

            exponent = (exponent + i) % n;
        }
        REAL(result,stride,i) = sum_real;
        IMAG(result,stride,i) = sum_imag;
    }

  return 0;
}
</code></pre>
"
"<blockquote>
  <p>how do I resolve the ""struct file *"" pointers to these eventfds from kernelspace</p>
</blockquote>

<p>You must resolve those pointers into data structures that this interface you've created has published (create new types and read the fields you want from <code>struct file</code> into it).</p>

<blockquote>
  <p>Is there better way to signal events to userspace from kernelspace?</p>
</blockquote>

<p><a href=""http://qos.ittc.ku.edu/netlink/html/"" rel=""nofollow"">Netlink sockets</a> are another convenient way for the kernel to communicate with userspace.  ""Better"" is in the eye of the beholder.</p>
"
"<p>Consult the kernel source here:</p>

<p><a href=""http://lxr.free-electrons.com/source/fs/eventfd.c"" rel=""noreferrer"">http://lxr.free-electrons.com/source/fs/eventfd.c</a></p>

<p>Basically, send your userspace file descriptor, as produced by <code>eventfd()</code>, to your module via <code>ioctl()</code> or some other path.  From the kernel, call <code>eventfd_ctx_fdget()</code> to get an eventfd context, then <code>eventfd_signal()</code> on the resulting context.  Don't forget <code>eventfd_ctx_put()</code> when you're done with the context.</p>
"
"<p>I finally figured out how to do this. I realized that each open file on a system could be identified by the pid of one of the processes which opened it and the fd corresponding to that file (within that process's context). So if my kernel module knows the pid and fd, it can look up the <strong>struct * task_struct</strong> of the process and from that the <strong>struct * files</strong> and finally using the fd, it can acquire the pointer to the eventfd's <strong>struct * file</strong>. Then, using this last pointer, it can write to the eventfd's counter. </p>

<p>Here are the codes for the userspace program and the kernel module that I wrote up to demonstrate the concept (which now work):</p>

<p><strong>Userspace C code (efd_us.c):</strong></p>

<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;     //Definition of uint64_t
#include &lt;sys/eventfd.h&gt;

int efd; //Eventfd file descriptor
uint64_t eftd_ctr;

int retval;     //for select()
fd_set rfds;        //for select()

int s;

int main() {


    //Create eventfd
    efd = eventfd(0,0);
    if (efd == -1){
        printf(""\nUnable to create eventfd! Exiting...\n"");
        exit(EXIT_FAILURE);
    }

    printf(""\nefd=%d pid=%d"",efd,getpid());

    //Watch efd
    FD_ZERO(&amp;rfds);
    FD_SET(efd, &amp;rfds);

    printf(""\nNow waiting on select()..."");
    fflush(stdout);

    retval = select(efd+1, &amp;rfds, NULL, NULL, NULL);

    if (retval == -1){
        printf(""\nselect() error. Exiting..."");
        exit(EXIT_FAILURE);
    } else if (retval &gt; 0) {
        printf(""\nselect() says data is available now. Exiting..."");
        printf(""\nreturned from select(), now executing read()..."");
        s = read(efd, &amp;eftd_ctr, sizeof(uint64_t));
        if (s != sizeof(uint64_t)){
            printf(""\neventfd read error. Exiting..."");
        } else {
            printf(""\nReturned from read(), value read = %lld"",eftd_ctr);
        }
    } else if (retval == 0) {
        printf(""\nselect() says that no data was available"");
    }

    printf(""\nClosing eventfd. Exiting..."");
    close(efd);
    printf(""\n"");
    exit(EXIT_SUCCESS);
}
</code></pre>

<p><strong>Kernel Module C code (efd_lkm.c):</strong></p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/pid.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/fdtable.h&gt;
#include &lt;linux/rcupdate.h&gt;
#include &lt;linux/eventfd.h&gt;

//Received from userspace. Process ID and eventfd's File descriptor are enough to uniquely identify an eventfd object.
int pid;
int efd;

//Resolved references...
struct task_struct * userspace_task = NULL; //...to userspace program's task struct
struct file * efd_file = NULL;          //...to eventfd's file struct
struct eventfd_ctx * efd_ctx = NULL;        //...and finally to eventfd context

//Increment Counter by 1
static uint64_t plus_one = 1;

int init_module(void) {
    printk(KERN_ALERT ""~~~Received from userspace: pid=%d efd=%d\n"",pid,efd);

    userspace_task = pid_task(find_vpid(pid), PIDTYPE_PID);
    printk(KERN_ALERT ""~~~Resolved pointer to the userspace program's task struct: %p\n"",userspace_task);

    printk(KERN_ALERT ""~~~Resolved pointer to the userspace program's files struct: %p\n"",userspace_task-&gt;files);

    rcu_read_lock();
    efd_file = fcheck_files(userspace_task-&gt;files, efd);
    rcu_read_unlock();
    printk(KERN_ALERT ""~~~Resolved pointer to the userspace program's eventfd's file struct: %p\n"",efd_file);


    efd_ctx = eventfd_ctx_fileget(efd_file);
    if (!efd_ctx) {
        printk(KERN_ALERT ""~~~eventfd_ctx_fileget() Jhol, Bye.\n"");
        return -1;
    }
    printk(KERN_ALERT ""~~~Resolved pointer to the userspace program's eventfd's context: %p\n"",efd_ctx);

    eventfd_signal(efd_ctx, plus_one);

    printk(KERN_ALERT ""~~~Incremented userspace program's eventfd's counter by 1\n"");

    eventfd_ctx_put(efd_ctx);

    return 0;
}


void cleanup_module(void) {
    printk(KERN_ALERT ""~~~Module Exiting...\n"");
}

MODULE_LICENSE(""GPL"");
module_param(pid, int, 0);
module_param(efd, int, 0);
</code></pre>

<p>To run this, carry out the following steps:</p>

<ol>
<li>Compile the userspace program (efd_us.out) and the kernel module (efd_lkm.ko)</li>
<li>Run the userspace program (./efd_us.out) and note the pid and efd values that it print. (for eg. ""pid=2803 efd=3"". The userspace program will wait endlessly on select()</li>
<li>Open a new terminal window and insert the kernel module passing the pid and efd as params: <strong>sudo insmod efd_lkm.ko pid=2803 efd=3</strong></li>
<li>Switch back to the userspace program window and you will see that the userspace program has broken out of select and exited.</li>
</ol>
"
"<p>The reason why <code>filemtime()</code> function is always returning the same result is because the result of this function is being cached. See <code>clearstatcache()</code> for more details.</p>

<p>No need to mix <code>date()</code> function with <code>Datetime</code>. </p>

<pre><code>while(new DateTime('@'.filemtime('/path/filename')) &lt; new DateTime('today')) {
    sleep(120);
    clearstatcache();
}
</code></pre>
"
"<p>Problem got solved on <a href=""http://shellcheck.net"" rel=""nofollow"">shellcheck.net</a>. Here is modified code... </p>

<pre><code>parse_comments() {
    local filename=""$1""
    while read -r line; do
    echo ""$line"" | fgrep -e ""*""
    done &lt; ""$filename""
}
parse_comments ""/root/rpmbuild/linux-2.6.32-431.17.1.el6.x86_64/fs/inode.c""
</code></pre>
"
"<blockquote>
  <p>Yet, when I run the ftrace (using the ""function"" tracer), I never see
  <code>__generic_file_write_iter()</code> get called.</p>
</blockquote>

<p>Most probably, <code>__generic_file_write_iter</code> is not listed in <code>/sys/kernel/debug/tracing/available_filter_functions</code> (<em>the functions that <strong>ftrace</strong> can trace</em>, see <a href=""https://www.kernel.org/doc/Documentation/trace/ftrace.txt"" rel=""nofollow"">ftrace - Function Tracer</a> or <a href=""https://lwn.net/Articles/370423/"" rel=""nofollow"">Secrets of the Ftrace function tracer</a>).</p>
"
"<p>They're called ""designated initializers"". It's a feature introduced in C99 and provided as an extension by GNU C (of course you know, the Linux kernel isn't written in C but in GNU C).</p>

<p>This is really syntactic sugar and provides a convenient way to initialize the members of that struct without worrying about their order.</p>
"
"<p>This is a GCC feature to initialize specific fields in the struct. See more <a href=""http://gcc.gnu.org/onlinedocs/gcc-4.0.4/gcc/Designated-Inits.html"" rel=""nofollow"">here</a>.</p>
"
"<p>The Linux kernel is organized in an OOP manner (though written in C). The <code>struct file_operations</code> is really a class, the members (function pointers) are the function members (""methods"" for Java heads) of the class. The code you quote serves to set up the ext3 object by filling in the function pointers. This is done at compile/link time.</p>

<p>The <code>open(2)</code> system call calls this indirectly, by finding out the <code>struct file_operations</code> relevant for the file system at hand, and calling its <code>open</code> member.</p>

<p>I'd suggest you take a look at the <a href=""http://www.kernelnewbies.org"" rel=""nofollow"">kernelnewbies</a> page for an overall view and more detailed help.</p>
"
"<p>fs/block-dev.c defines file operations and address space operations as applicable to block devices. </p>

<pre><code>static const struct address_space_operations def_blk_aops = {
    .readpage       = blkdev_readpage,
    .writepage      = blkdev_writepage,
    .write_begin    = blkdev_write_begin,
    .write_end      = blkdev_write_end,
    .writepages     = generic_writepages,
    .releasepage    = blkdev_releasepage,
    .direct_IO      = blkdev_direct_IO,
    .is_dirty_writeback = buffer_check_dirty_writeback,
};

const struct file_operations def_blk_fops = {
    .open           = blkdev_open,
    .release        = blkdev_close,
    .llseek         = block_llseek,
    .read           = do_sync_read,
    .write          = do_sync_write,
    .aio_read       = blkdev_aio_read,
    .aio_write      = blkdev_aio_write,
    .mmap           = generic_file_mmap,
    .fsync          = blkdev_fsync,
    .unlocked_ioctl = block_ioctl,
#ifdef CONFIG_COMPAT
    .compat_ioctl   = compat_blkdev_ioctl,
#endif
    .splice_read    = generic_file_splice_read,
    .splice_write   = generic_file_splice_write,
};
</code></pre>
"
"<p>Apart from bad formatting you can easily see that <code>do_readv</code> and <code>do_preadv</code> both call <code>vfs_readv</code>. In those functions no hint is seen that they do some reading on their own.</p>

<p>You can also see that <code>vfs_readv</code> doesn't do any reading but only calls <code>do_readv_writev</code>.</p>

<p>The actual reading is done here:</p>

<pre><code>if (type == READ) {
  fn = file-&gt;f_op-&gt;read;
  iter_fn = file-&gt;f_op-&gt;read_iter;
}
...

if (iter_fn)
  ret = do_iter_readv_writev(file, &amp;iter, pos, iter_fn, flags);
else
  ret = do_loop_readv_writev(file, &amp;iter, pos, fn, flags);
</code></pre>

<p>Well, it is not the actual reading, but it is the closest to reading that you can get from your code snippet.
What happens in these functions and more important, what was stored in <code>iter_fn</code> and <code>fn</code> is not visible from your code.</p>

<p>And I am no Linux expert to tell you more details.</p>
"
"<p>Not a complete solution, but some ideas.</p>

<blockquote>
  <p><em>some</em>fs stores files into memory and that memory is bound to certain NUMA node, .. I think there exist some ways to keep track of nodes that requested a file</p>
</blockquote>

<p>There are many methods to trace file access (some basic kinds of; open/read/write/mmap; <em>but not the usage of mmaped regions</em>) in modern Linux (4.x kernels). For single pid you may use <code>strace</code> system call tracer (or <code>ltrace -S</code> which additionaly can catch library calls). For many pids (full system tracing) you may try <code>sysdig</code>.</p>

<p>There are in-kernel (and out-of-tree kernel-mode) tracing frameworks which can be used too. Like something based on perf + probe / ftrace (trace-cmd), or more advanced tracing solution like <code>stap</code>/<code>dtrace</code>/<code>lttng</code> with corresponding tracepoints defined and enabled. Gregg in his <a href=""https://www.slideshare.net/brendangregg/"" rel=""nofollow noreferrer"">presentations</a> and <a href=""http://www.brendangregg.com/"" rel=""nofollow noreferrer"">site</a> lists more tools, both classic (with small list for VFS) <a href=""https://www.slideshare.net/brendangregg/linux-systems-performance-2016#slide=7"" rel=""nofollow noreferrer"">https://www.slideshare.net/brendangregg/linux-systems-performance-2016#slide=7</a>; and bcc/eBPF based: <a href=""https://www.slideshare.net/brendangregg/designing-tracing-tools-67693476#slide=3"" rel=""nofollow noreferrer"">https://www.slideshare.net/brendangregg/designing-tracing-tools-67693476#slide=3</a>. </p>

<p>Most of system-wide tools already have good frameworks to do timestamps and process accounting and to download lot of tracing data from kernel-mode into some log/dump file. Some of them (stap/dtrace/bcc + probes) allow you to write small code fragment to execute when traced function is called.</p>

<p>Example of Gregg's tool is ""iosnoop"" (this on is on top of <code>debugfs &amp; /sys/kernel/debug/tracing</code> which is <a href=""https://www.kernel.org/doc/Documentation/trace/ftrace.txt"" rel=""nofollow noreferrer"">ftrace</a> &amp; <a href=""http://man7.org/linux/man-pages/man1/trace-cmd.1.html"" rel=""nofollow noreferrer""><code>trace-cmd</code></a>). It shows latency of every <strong>real</strong> read/write operation (which goes to real disk; not access to already read data in page cache, like it is in ramfs): </p>

<ul>
<li>doc <a href=""http://www.brendangregg.com/blog/2014-07-16/iosnoop-for-linux.html"" rel=""nofollow noreferrer"">http://www.brendangregg.com/blog/2014-07-16/iosnoop-for-linux.html</a>, </li>
<li>src <a href=""https://github.com/brendangregg/perf-tools/blob/master/iosnoop"" rel=""nofollow noreferrer"">https://github.com/brendangregg/perf-tools/blob/master/iosnoop</a> </li>
<li>(works almost anywhere by <code>nop ftraceing</code> two events:   events/block/block_rq_insert and  events/block/block_rq_complete)</li>
<li>(add debugging save of raw trace by replacing in iosnoop src the <code>cat trace</code> line as <code>cat trace | tee -a ~/iotrace.$$.dump</code> and take a look into it)</li>
</ul>

<blockquote>
  <ol>
  <li>find low level ramfs file operation function(like read or write) </li>
  </ol>
</blockquote>

<p>Unfortunately, ramfs is too basic FS to implement anything interesting. There are address space operations and file operations for ramfs:</p>

<p><a href=""http://elixir.free-electrons.com/linux/v4.7.4/source/fs/ramfs/inode.c#L46"" rel=""nofollow noreferrer"">http://elixir.free-electrons.com/linux/v4.7.4/source/fs/ramfs/inode.c#L46</a></p>

<pre><code>static const struct address_space_operations ramfs_aops = {
    .readpage   = simple_readpage,
    .write_begin    = simple_write_begin,
    .write_end  = simple_write_end,
    .set_page_dirty = __set_page_dirty_no_writeback,
};
</code></pre>

<p><a href=""http://elixir.free-electrons.com/linux/v4.7.4/source/fs/ramfs/file-mmu.c#L33"" rel=""nofollow noreferrer"">http://elixir.free-electrons.com/linux/v4.7.4/source/fs/ramfs/file-mmu.c#L33</a></p>

<pre><code>const struct file_operations ramfs_file_operations = {
    .read_iter  = generic_file_read_iter,
    .write_iter = generic_file_write_iter,
    .mmap       = generic_file_mmap,
    .fsync      = noop_fsync,
    .splice_read    = generic_file_splice_read,
    .splice_write   = iter_file_splice_write,
    .llseek     = generic_file_llseek,
};
</code></pre>

<p><code>simple_</code> / <code>generic_file_</code> operations are defined in libfs/ or mm/ (with elixir/lxr web sites you can just click on function to find its definition and usage) <a href=""http://elixir.free-electrons.com/linux/v4.7.4/source/fs/libfs.c#L409"" rel=""nofollow noreferrer"">http://elixir.free-electrons.com/linux/v4.7.4/source/fs/libfs.c#L409</a>, and they are used in several more linux FS implementations, so it can be unsafe to unconditionally trace them all.</p>

<p>You may try to rewrite implementation of ramfs; just define similar <code>simple_</code> / <code>generic_file_</code> operations inside your variant with different name. You will be able to trace only them.</p>

<blockquote>
  <ol start=""2"">
  <li>get the node number of the thread that is executing that function </li>
  </ol>
</blockquote>

<p>I think, there is another approach to this. Get the pid/tid of process/thread when access is detected; but don't do anything to find NUMA node (it is possible is you will modify ramfs implementation and adds your own variants of <code>aops</code> with reading of <code>current</code> ptr and finding the NUMA Node from <a href=""http://elixir.free-electrons.com/linux/v4.7.4/source/include/linux/sched.h#L1458"" rel=""nofollow noreferrer""><code>struct task_struct</code></a>; but where to write it?). </p>

<p>What is easier when there is advanced tracing framework - is to record all actions of scheduler - when and which pid was planned to every CPU (like in <a href=""http://elinux.org/images/6/64/Elc2011_rostedt.pdf"" rel=""nofollow noreferrer"">kernelshark</a> or in perf/stap/lttng tracing of <code>sched_</code> functions - <code>sched_switch</code> with arguments probably; even ftrace will allow you to combine two tracing, both io and sched in single filter).</p>

<p>You will have some postprocess to sort output and combine info, but this should do the task</p>

<blockquote>
  <ol start=""3"">
  <li>store that node number into somewhere(like inode of a.txt or something)</li>
  </ol>
</blockquote>

<p>Don't reinvent the wheel, use tracing frameworks.</p>
"
"<p>I have tested by writing a new file system and found if we initialise both pointers then <code>.read</code> is called if I use <strong>cat</strong> command. If I use <strong>cat</strong> command without initialising <code>.read</code> but initialising <code>.read_iter</code> the <code>.read_iter</code> is called. </p>
"
"<p>You're looking at it from the wrong end:  names like <code>do_sys_open</code> are system call entry points, and will ultimately go through the VFS layer to find the ext2 <code>open</code> routine <em>after</em> validating permissions.</p>
"
"<p>I think you got sidetracked by the ACL code; once the permission has been granted, follow <code>nameidata_to_filp</code> to <code>__dentry_open</code>:</p>

<p>Within <code>__dentry_open()</code>:</p>

<pre><code>    f-&gt;f_op = fops_get(inode-&gt;i_fop);
    /* ... */
    if (!open &amp;&amp; f-&gt;f_op)
            open = f-&gt;f_op-&gt;open;
    if (open) {
            error = open(inode, f);
            if (error)
                    goto cleanup_all;
    }
</code></pre>

<p>This saves the <code>inode-&gt;i_fop-&gt;open</code> function pointer to the autovariable <code>open</code>, then proceeds to call it on the <code>inode</code> and <code>f</code>.</p>
"
"<p>Generally speaking, you should <strong>never</strong> mount same filesystem twice -- if OS drivers will decide to write twice to the same block, you'll get filesystem corruption. Use bind-mounts in such cases.</p>

<p>Linux, however, is smart enough to help you with that -- it will reuse older filesystem mount <code>super_block</code> (with all mountpoint flags) for a to a location. </p>

<p>I couldn't find it in documentation, but it is traceable through kernel source in <a href=""http://lxr.free-electrons.com/source/fs/super.c#L437"" rel=""nofollow""><code>sget()</code></a> which is called by <code>mount_bdev()</code>:</p>

<pre><code>hlist_for_each_entry(old, &amp;type-&gt;fs_supers, s_instances) {
        if (!test(old, data))
                continue;
        if (!grab_super(old))
                goto retry;
        if (s) {
                up_write(&amp;s-&gt;s_umount);
                destroy_super(s);
                s = NULL;
        }
        return old;
}
</code></pre>

<p>In this snippet it'll seek for previous instance of <code>super_block</code> corresponding to a block device, and if it already exists -- simply returns it.</p>

<hr>

<p>Some practical proof using SystemTap:</p>

<pre><code># stap -e 'probe kernel.function(""sget"").return {
        sb = $return;
        active = @cast(sb, ""super_block"")-&gt;s_active-&gt;counter;
        fsi = @cast(sb, ""super_block"")-&gt;s_fs_info;
        uid = fsi == 0 ? -1
            : @cast(fsi, ""msdos_sb_info"", ""vfat"")-&gt;options-&gt;fs_uid;
        printf(""%p active=%d uid=%d\n"", sb, active, uid);
    }'
</code></pre>

<p>Setting uid in second mount doesn't alter option, but increases number of active mounts (obvious): </p>

<pre><code>  # mount /dev/sdd1 /tmp/mnt1
  0xffff8803ce87e800 active=1 uid=-1
  # mount -o uid=1000 /dev/sdd1 /tmp/mnt2
  0xffff8803ce87e800 active=2 uid=0
</code></pre>

<p>Mounting in reverse order also inherits mount options:</p>

<pre><code>  # mount -o uid=1000 /dev/sdd1 /tmp/mnt2
  0xffff8803cc609c00 active=1 uid=-1
  # mount /dev/sdd1 /tmp/mnt1
  0xffff8803cc609c00 active=2 uid=1000
</code></pre>

<hr>

<p>If you wish to know who was responsible for such behavior, ask Linus, similiar code exists since 0.11:</p>

<pre><code>struct super_block * get_super(int dev)
{
    struct super_block * s;

    if (!dev)
        return NULL;
    s = 0+super_block;
    while (s &lt; NR_SUPER+super_block)
        if (s-&gt;s_dev == dev) {
            wait_on_super(s);
            if (s-&gt;s_dev == dev)
                return s;
            s = 0+super_block;
        } else
            s++;
    return NULL;
}
</code></pre>

<p>(but when this code was in charge, <code>sys_mount()</code> explicitly checked that no other mountpoints exist for that superblock). </p>

<p>You can possibly try to ask a question at LKML.</p>
"
"<p>The ambiguity comes from having two possible conversion operators; either: </p>

<pre><code>operator handle_t () const;
operator unspecified_bool_type() const;
</code></pre>

<p>or:</p>

<pre><code>operator handle_t () const;
operator bool () const;
</code></pre>

<p>Both can be used in a boolean expression, so you have ambiguity.</p>
"
"<pre><code>AutoHandleTemplate&lt;ModuleHandlePolicy&gt; hModule( ... );
HMODULE raw_handle = hModule; // if we want to this line works,
// AutoHandleTemplate&lt;ModuleHandlePolicy&gt; should \
//    be implicitly converted to it's raw handle type - HMODULE.
</code></pre>

<p>If one smart-ptr can implicitly converted to it's raw handle type and the raw handle type could be used in a boolean test itself, like :</p>

<pre><code>HMODULE the_raw_handle = ...;
if ( the_raw_handle ) {}  // this line is ok
</code></pre>

<p>For those smart-ptrs, there is no need (and should not) to define conversions to bool,void* or safe_bool, otherwise, ambiguity.</p>

<p>operator bool(), void*(), safe_bool() are used for the smart-ptrs which could not be implicitly convert to it's raw handle or it's raw handle couldn't used in a boolean context.</p>

<p>Try this code :</p>

<pre><code>template&lt;typename HandlePolicy&gt;
class AutoHandleTemplate
{
public :
      typedef typename HandlePolicy::handle_t handle_t;
      typedef AutoHandleTemplate&lt;HandlePolicy&gt; this_type;
      {details omitted}

      operator handle_t () const {
            return m_handle==HandlePolicy::InvalidHandleValue()? 0: m_handle;
      }

      // no more conversion functions

private :
      handle_t m_handle;
      {details omitted}
};
</code></pre>
"
"<p>All the idioms suck, really.</p>

<p>The best solution is:</p>

<p>1) don't have any implicit conversion operators</p>

<p>2) have an operator! override with bool return type. Yes, this means that some test might need to be written as if(!!myObject), but that's a small price to pay.</p>
"
"<p>You can use the <code>lock()</code> member of <code>boost::weak_ptr</code> to be able to test (then use) the value of the <code>weak_ptr</code> without dealing with exceptions.</p>
"
"<p>This is a common thing in game development. Typically a system of object handles is used rather than Boost weak pointers, because we need the underlying lookup table to be constant memory and because sometimes we need some additional information or guarantees that Boost hasn't got. </p>

<p>The usual approach is to use an elaboration on pointers to pointers. An entity is referred to by handle rather than by pointer. The handle is an index into a big array of pointers to entities. When an entity dies, it NULLs out the pointer in its entity table.</p>

<pre><code>struct handle_t
{
   uint32 serialnumber;  // this is a GUID for each entity; it increases
                         // monotonically over the life of the process
   uint   entityindex;
   inline Entity *Get();
}

struct entityinfo_t
{
   Entity *pEntity;  // an entity's destructor NULLs this out on deletion
   uint32  serialnumber;
}

entityinfo_t g_EntityTable[MAX_ENTITIES];

Entity *handle_t::Get()
{
  entityinfo_t &amp;info = g_EntityTable[entityIndex];
  if ( serialnumber == info.serialnumber )
  {
     return info.pEntity;
  }
  else
  {
      return NULL;
  }
}
</code></pre>

<p>The serial number is necessary because the array is of constant size -- eventually, you will need to recycle entity table entries, and there's a possibility that you might store a handle to, say, index #743, long enough that the object gets deleted and cell #743 reused for something else. If you simply had a pointer to a list of pointers, you would end up having a handle that points to an entirely different object rather than going NULL. So, we give each entity a globally unique number and store that in the handle as well. </p>

<p>You could use a std vector or a map or a dictionary or some other kind of data structure for the entity table, of course, but our requirements have typically been for constant memory, cache coherency, and absolute maximal performance (since handle_t::Get() gets called thousands of times per frame).</p>
"
"<p>You could manage your objects using smart pointers and compare the pointers for equality inside your register / deregister functions. </p>

<p>If you only have stack allocated objects that are never copied between an register and deregister call you could also pass a pointer instead of the reference. </p>

<p>You could also do:</p>

<pre><code>typedef iterator handle_t;
</code></pre>

<p>and hide the fact that your giving out internal iterators if exposing internal data structures worries you. </p>
"
"<p>You are safe unless the client object has two derivations of ostream without using virtual inheritance.</p>

<p>In short, that is the fault of the user -- they should not be multiply inheriting an interface class twice in two different ways.</p>

<p>Use the address and be done with it. In these cases, I take a pointer argument rather than a reference to make it explicit that I will store the address. It also prevents implicit conversions that might kick in if you decided to take a const reference.</p>

<pre><code>   class Log {
   public:
       void AddSink( ostream* Sink );
       void RemoveSink( ostream* Sink );
   };
</code></pre>

<p>You can create an RAII object that calls AddSink in the constructor, and RemoveSink in the destructor to make this pattern exception-safe.</p>
"
"<p>In your previous question, <a href=""https://stackoverflow.com/questions/1307547/determine-object-identity-from-a-reference-to-a-superclass/1307564#1307564"">Konrad Rudolph posted an answe</a>r (that you did not accept but has the highest score), saying that everything should be fine if you use base class pointers, which you appear to do.</p>
"
"<p>You have to manually edit those files in order to replace them with code that isn't likely to be buggy and nonportable.</p>
"
"<p>Casting a pointer to an int is horrible from a portability perspective. The size of int is defined by the mix of compiler and architecture. This is why the stdint.h header was created, to allow you to explicitly state the size of the type you're using across many different platforms with many different word sizes.</p>

<p>You'd be better off casting to a uintptr_t or intptr_t (from stdint.h, and choose the one that best matches the signedness you need).</p>
"
"<p>You can try to use <code>intptr_t</code> for best portability instead of int where pointer casts are required, such as callbacks.</p>
"
"<p>The issue is that, in 32bits, an <strong>int</strong> (which is a 32bit integer) will hold a pointer value.</p>

<p>When you move to 64bit, you can no longer store a pointer in an int - it isn't large enough to hold a 64bit pointer.  The <a href=""http://en.cppreference.com/w/c/types/integer"" rel=""noreferrer"">intptr_t</a> type is designed for this.</p>
"
"<p>You do not want to suppress these errors because most likely, they are indicating a problem with the code logic.</p>

<p>If you suppresses the errors, this could even work for a while.  While the pointer points to an address in the first 4 GB, the upper 32 bits will be 0 and you won't lose any data.  But once you get an address > 4GB, your code will start 'mysteriously' not working.</p>

<p>What you should do is modify any int that can hold a pointer to intptr_t.</p>
"
"<p>It's an error for a reason: <code>int</code> is only half as big as <code>void*</code> on your machine, so you can't just store a <code>void*</code> in an <code>int</code>. You would loose half of the pointer and when the program later tries to get the pointer out of that <code>int</code> again, it won't get anything useful.</p>

<p>Even if the compiler wouldn't give an error the code most likely wouldn't work. The code needs to be changed and reviewed for 64bit compatibility.</p>
"
"<p>Suppressing the warnings are a bad idea, but there <em>may</em> be a compiler flag to use 64-bit ints, depending on your compiler and architecture, and this is a safe way to fix the problem (assuming of course that the code didn't also assume ints are 32-bit). For gcc, the flag is -m64.</p>

<p>The best answer is still to fix the code, I suppose, but if it's legacy third-party code and these warnings are rampant, I can't see this refactoring as being a very efficient use of your time. Definitely don't cast pointers to ints in any of your new code, though.</p>
"
"<p>Your code is broken. It won't become any less broken by ignoring the warnings the compiler gives you.</p>

<p>What do you <em>think</em> will happen when you try to store a 64-bit wide pointer into a 32-bit integer? Half your data will get thrown away. I can't imagine many cases where that is the correct thing to do, or where it won't cause errors.</p>

<p>Fix your code. Or stay on the 32-bit platform that the code currently works on.</p>

<p>If your compiler defines <code>intptr_t</code> or <code>uintptr_t</code>, use those, as they are integer types guaranteed to be large enough to store a pointer.</p>

<p>If those types are not available, <code>size_t</code> or <code>ptrdiff_t</code> are also large enough to hold a pointer on <em>most</em> (not all) platforms. Or use <code>long</code> (is typically 64-bit on 64-bit platforms on the GCC compiler) or <code>long long</code> (a C99 types which most, but not all compilers, support in C++), or some other implementation-defined integral type that is at least 64 bits wide on a 64-bit platform.</p>
"
"<p>As defined by the current C++ standard, there is no integer type which is guaranteed to hold a pointer.  Some platforms will have an intptr_t, but this is not a standard feature of C++.  Fundamentally, treating the bits of a pointer as if they were an integer is not a portable thing to do (although it can be made to work on many platforms).</p>

<p>If the reason for the cast is to make the pointer opaque, then void* already achieves this, so the code could use void* instead of int.  A typedef might make this a little nicer in the code</p>

<pre><code>typedef void * handle_t;
</code></pre>

<p>If the reason for the cast is to do pointer arithmetic with byte granularity, then the best way is probably to cast to a (char const *) and do the math with that.</p>

<p>If the reason for the cast is to achieve compatibility with some existing library (perhaps an older callback interface) which cannot be modified, then I think you need to review the documentation for that library.  If the library is capable of supporting the functionality that you require (even on a 64-bit platform), then its documentation may address the intended solution.</p>
"
"<p>My guess is OP's situation is a void* is being used as general storage for an int, where the void* is larger than the int. So eg:</p>

<pre><code>int i = 123;
void *v = (void*)i;    // 64bit void* being (ab)used to store 32bit value
[..]
int i2 = (int)v;       // we want our 32bits of the 64bit void* back
</code></pre>

<p>Compiler doesn't like that last line.</p>

<p>I'm not going to weigh in on whether it's right or wrong to abuse a void* this way. If you really want to fool the compiler, the following technique seems to work, even with -Wall:</p>

<pre><code>int i2 = *((int*)&amp;v);
</code></pre>

<p>Here it takes the address of v, converts the address to a pointer of the datatype you want, then follows the pointer.</p>
"
"<p>I faced similar problem. I solved it in the following way:</p>

<pre><code> #ifdef 64BIT
 typedef uint64_t tulong;
 #else
 typedef uint32_t tulong;
 #endif

 void * ptr = NULL; //Whatever you want to keep it.
 int  i;
 i = (int)(tulong)ptr;
</code></pre>

<p>I think, the problem is of typecasting a pointer to a shorter data type. But for a larger type to <code>int</code>, it works fine.</p>

<p>I converted this problem from typecasting a pointer to <code>long</code> to typecasting a 64-bit integer to 32-bit integer and it worked fine. I am still in the search of a compiler option in GCC/Clang.</p>
"
"<p>Sometimes it is sensible to want to split up a 64-bit item into 2 32-bit items.  This is how you would do it:</p>

<p>Header file:</p>

<pre><code>//You only need this if you haven't got a definition of UInt32 from somewhere else
typedef unsigned int UInt32;

//x, when cast, points to the lower 32 bits
#define LO_32(x) (*( (UInt32 *) &amp;x))

//address like an array to get to the higher bits (which are in position 1)
#define HI_32(x) (*( ( (UInt32 *) &amp;x) + 1))
</code></pre>

<p>Source file:</p>

<pre><code>//Wherever your pointer points to
void *ptr = PTR_LOCATION

//32-bit UInt containing the upper bits
UInt32 upper_half = HI_32(ptr);

//32-bit UInt containing the lower bits
UInt32 lower_half = LO_32(ptr);
</code></pre>
"
"<p>You can define the struct in a separate header fine msg_data.h, and then include it in both projects. If needed you may have to typecaset the MessageStructure_t pointer into MsgData_t.</p>

<p>hence MsgData.h:</p>

<pre><code>struct MsgData_t {
   float a;
   int i;
}__attribute__((packed));
</code></pre>

<p>messageStruct.hpp:</p>

<pre><code>#include ""MsgData.h""

class MessageStructure_t {
  public:
    MsgData_t msgdata_m;
}
</code></pre>

<p>Appliaction.c:</p>

<pre><code>#include ""MsgData.h""

//...
</code></pre>
"
"<p>I think that the best way would be to create an extern ""C"" function to access the structure.</p>
"
"<p>When you want to access C++ classes and their objects from C, there are a few well-known patterns around. Google for them. </p>

<p>An easy one is to wrap it in a piece of OO C: </p>

<pre><code>typedef void* my_handle_t;

handle_t create(void);  // returns address of new'ed object
void destroy(handle_t); // deletes object

MsgData_t* get_data(handle_t); // returns address of data in object
</code></pre>

<p>That leaves the question of how to make <code>MsgData_t</code> accessible from C. I see three possibilities: </p>

<ol>
<li>move its definition into its own header (IMO best, but you already said you're not allowed to do it)</li>
<li>duplicate its definition (easy, but IMO worst alternative)</li>
<li>fiddle with the preprocessor (<code>#ifndef __cplusplus</code>) to make the C++ header accessible for a C parser (hackish, but avoids the code duplication of #2)  </li>
</ol>
"
"<p>Why not use a pimpl approach? You're almost there, anyway. Create <code>WinLockFileImpl</code> and <code>PosixLockFileImpl</code> which both inherit an abstract <code>LockFileImpl</code>. Then, put one <code>ifdef</code> around the following code to determine which class is used at compile time. You must already have an <code>ifdef</code> that removes the windows code when compiling on other platforms anyway, right?</p>

<pre><code>LockFile::LockFile(const File &amp;f)
#ifdef POSIX
    : p( new PosixLockFileImpl(f.handle()) )
#else
    : p( new WinLockFileImpl(f.handle()) )
#endif
</code></pre>

<p>Oh, and you'll need to move your code into the implementation classes which changes <code>LockFile</code> to look more like this:</p>

<pre><code>void LockFile::unlock() const
{
    p-&gt;unlock();
}
</code></pre>
"
"<p>We have very limited locking requirements but the following code seems to work to mimic POSIX fcntl enough for our purposes. Note the hack to discriminate between read and write locks based on locked region size (this hack might work for you based on your example). The code below assumes files are less than 4GB.</p>

<pre><code>// fcntl flock definitions
#define F_SETLK  8   // Non-Blocking set or clear a lock
#define F_SETLKW 9   // Blocking set or clear a lock
#define F_RDLCK  1   // read lock
#define F_WRLCK  2   // write lock
#define F_UNLCK  3   // remove lock
struct flock {
    short l_type;   // F_RDLCK, F_WRLCK, or F_UNLCK
    short l_whence; // flag to choose starting offset, must be SEEK_SET
    long  l_start;  // relative offset, in bytes, must be 0
    long  l_len;    // length, in bytes; 0 means lock to EOF, must be 0
    short l_pid;    // unused (returned with the unsupported F_GETLK)
    short l_xxx;    // reserved for future use
};

// only works for (SEEK_SET, start=0, len=0) file locking.
__inline int fcntl(int fd, int cmd, ...)
{
    va_list a;
    va_start(a, cmd);
    switch(cmd)
    {
    case F_SETLK:
        {
            struct flock *l = va_arg(a, struct flock*);
            switch(l-&gt;l_type)
            {
            case F_RDLCK:
                {
                    OVERLAPPED o = { 0 };
                    HANDLE h = (HANDLE)_get_osfhandle(fd);
                    if (l-&gt;l_whence != SEEK_SET || l-&gt;l_start != 0 || l-&gt;l_len != 0)
                    {
                        _set_errno(ENOTSUP);
                        return -1;
                    }
                    if (!LockFileEx(h, LOCKFILE_FAIL_IMMEDIATELY, 0, 0, 1, &amp;o)) // read lock
                    {
                        unsigned long x = GetLastError();
                        _set_errno(GetLastError() == ERROR_LOCK_VIOLATION ? EAGAIN : EBADF);
                        return -1;
                    }
                    UnlockFile(h, 0, 0, 1, 1); // write lock
                }
                break;
            case F_WRLCK:
                {
                    OVERLAPPED o = { 0 };
                    HANDLE h = (HANDLE)_get_osfhandle(fd);
                    if (l-&gt;l_whence != SEEK_SET || l-&gt;l_start != 0 || l-&gt;l_len != 0)
                    {
                        _set_errno(ENOTSUP);
                        return -1;
                    }
                    if (!LockFileEx(h, LOCKFILE_FAIL_IMMEDIATELY|LOCKFILE_EXCLUSIVE_LOCK, 0, 1, 1, &amp;o)) // write lock
                    {
                        unsigned long x = GetLastError();
                        _set_errno(GetLastError() == ERROR_LOCK_VIOLATION ? EAGAIN : EBADF);
                        return -1;
                    }
                    UnlockFile(h, 0, 0, 0, 1); // read lock
                }
                break;
            case F_UNLCK:
                {
                    HANDLE h = (HANDLE)_get_osfhandle(fd);
                    if (l-&gt;l_whence != SEEK_SET || l-&gt;l_start != 0 || l-&gt;l_len != 0)
                    {
                        _set_errno(ENOTSUP);
                        return -1;
                    }
                    UnlockFile(h, 0, 0, 0, 1); // read lock
                    UnlockFile(h, 0, 0, 1, 1); // write lock
                }
                break;
            default:
                _set_errno(ENOTSUP);
                return -1;
            }
        }
        break;
    case F_SETLKW:
        {
            struct flock *l = va_arg(a, struct flock*);
            switch(l-&gt;l_type)
            {
            case F_RDLCK:
                {
                    OVERLAPPED o = { 0 };
                    HANDLE h = (HANDLE)_get_osfhandle(fd);
                    if (l-&gt;l_whence != SEEK_SET || l-&gt;l_start != 0 || l-&gt;l_len != 0)
                    {
                        _set_errno(ENOTSUP);
                        return -1;
                    }
                    if(!LockFileEx(h, 0, 0, 0, 1, &amp;o)) // read lock
                    {
                        unsigned long x = GetLastError();
                        return -1;
                    }
                    UnlockFile(h, 0, 0, 1, 1); // write lock
                }
                break;
            case F_WRLCK:
                {
                    OVERLAPPED o = { 0 };
                    HANDLE h = (HANDLE)_get_osfhandle(fd);
                    if (l-&gt;l_whence != SEEK_SET || l-&gt;l_start != 0 || l-&gt;l_len != 0)
                    {
                        _set_errno(ENOTSUP);
                        return -1;
                    }
                    if (!LockFileEx(h, LOCKFILE_EXCLUSIVE_LOCK, 0, 1, 1, &amp;o)) // write lock
                    {
                        unsigned long x = GetLastError();
                        return -1;
                    }
                    UnlockFile(h, 0, 0, 0, 1); // read lock
                }
                break;
            case F_UNLCK:
                {
                    flock *l = va_arg(a, flock*);
                    HANDLE h = (HANDLE)_get_osfhandle(fd);
                    if (l-&gt;l_whence != SEEK_SET || l-&gt;l_start != 0 || l-&gt;l_len != 0)
                    {
                        _set_errno(ENOTSUP);
                        return -1;
                    }
                    UnlockFile(h, 0, 0, 0, 1); // read lock
                    UnlockFile(h, 0, 0, 1, 1); // write lock
                }
                break;
            default:
                _set_errno(ENOTSUP);
                return -1;
            }
        }
        break;
    default:
        _set_errno(ENOTSUP);
        return -1;
    }

    return 0;
}
</code></pre>

<p>The main problem with fcntl locking to FileLock locking is, as you noted, that little caveat that (from the docs):</p>

<blockquote>
  <p>If the same range is locked with an exclusive and a shared lock, two unlock operations are necessary to unlock the region; the first unlock operation unlocks the exclusive lock, the second unlock operation unlocks the shared lock.</p>
</blockquote>

<p>This means you cannot go from just a shared lock to just an exclusive lock of the same region without first releasing the lock completely on that region. Your method of using flags comes close and I think if you added another flag that says i_have_both_locks_but_only_really_want_the_exclusive_lock then your solution could work. We didn't have the luxury of writing our own interface (we were stuck with fcntl). But, luckily, the code using fcntl only just ever wanted to lock the entire file and the files were small. An alternative solution would have been to put a std::map in the fcntl call to keep track of the fcntl locks vs the FileLock locks owned.</p>
"
"<p>Your struct's name needs to match the typedef:</p>

<pre><code>struct Handle_t {
    /* ... */
};
</code></pre>
"
"<pre><code>typedef struct Handle_t Handle
</code></pre>

<p>The struct you defined is called <code>Handle</code>, not <code>Handle_t</code>, which is what you're typedeffing.</p>
"
"<p>typedef struct Handle_t Handle</p>

<p>you type defined struct Handle_t to Handle, but the structure is Struct Handle,so either change struct Hadle to Struct handle_t or type def.</p>
"
"<p>I used to get the <code>typedef</code> wrong often until I started to think of it like two parts: <strong>type</strong> and <strong>def</strong>. The <strong>type</strong> first, then the <b>def</b>inition of a new name.</p>

<pre><code>typedef &lt;type&gt; &lt;name&gt;;
typedef struct Handle Handle_t; /* defines Handle_t as struct Handle */
typedef char *c_string;         /* defines c_string as char * */
</code></pre>
"
"<p><code>struct Handle_t</code> is not defined by the time the compiler reaches the line with the error.</p>

<p>you have defined a <code>struct Handle</code> and aliased the type <code>Handle</code> to the inexistent type <code>struct Handle_t</code>. It's ok to have inexistent types for lots of things in <code>C</code>, but not for a <code>sizeof</code> argument.</p>
"
"<p>It looks like a compiler bug to me. To be sure, I put your code into <code>clang</code> and instantiated <code>btree&lt;int&gt;::caching_storage_t</code>, all working fine also with the comment chars removed. </p>

<p>It also works on GCC4.5.1 <a href=""http://ideone.com/nclMd"" rel=""nofollow"">and GCC4.3.4</a>.</p>
"
"<p>One way would be to add something like</p>

<pre><code>#define MODULE_HANDLE_SIZE (4711)
</code></pre>

<p>to the public <code>module.h</code> header. Since that creates a worrying requirement of keeping this in sync with the actual size, the line is of course best auto-generated by the build process.</p>

<p>The other option is of course to actually expose the structure, but document it as being opaque and forbidding access through any other means than through the defined API. This can be made more clear by doing something like:</p>

<pre><code>#include ""module_private.h""

typedef struct handle_t
{
  handle_private_t private;
};
</code></pre>

<p>Here, the actual declaration of the module's handle has been moved into a separate header, to make it less obviously visible. A type declared in that header is then simply wrapped in the desired <code>typedef</code> name, making sure to indicate that it is private.</p>

<p>Functions inside the module that take <code>handle_t *</code> can safely access <code>private</code> as a <code>handle_private_t</code> value, since it's the first member of the public struct.</p>
"
"<p>You can use the _alloca function. I believe that it's not exactly Standard, but as far as I know, nearly all common compilers implement it. When you use it as a default argument, it allocates off the caller's stack.</p>

<pre><code>// Header
typedef struct {} something;
int get_size();
something* create_something(void* mem);

// Usage
handle* ptr = create_something(_alloca(get_size()); // or define a macro.

// Implementation
int get_size() {
    return sizeof(real_handle_type);
}
something* create_something(void* mem) {
    real_type* ptr = (real_type_ptr*)mem;
    // Fill out real_type
    return (something*)mem;
}
</code></pre>

<p>You could also use some kind of object pool semi-heap - if you have a maximum number of currently available objects, then you could allocate all memory for them statically, and just bit-shift for which ones are currently in use.</p>

<pre><code>#define MAX_OBJECTS 32
real_type objects[MAX_OBJECTS];
unsigned int in_use; // Make sure this is large enough
something* create_something() {
     for(int i = 0; i &lt; MAX_OBJECTS; i++) {
         if (!(in_use &amp; (1 &lt;&lt; i))) {
             in_use &amp;= (1 &lt;&lt; i);
             return &amp;objects[i];
         }
     }
     return NULL;
}
</code></pre>

<p>My bit-shifting is a little off, been a long time since I've done it, but I hope that you get the point.         </p>
"
"<p>I'm a little confused why you say you can't use malloc(). Obviously on an embedded system you have limited memory and the usual solution is to have your own memory manager which mallocs a large memory pool and then allocates chunks of this out as needed. I've seen various different implementations of this idea in my time.</p>

<p>To answer your question though, why don't you simply statically allocate a fixed size array of them in module.c add an ""in-use"" flag, and then have create_handle() simply return the pointer to the first free element.</p>

<p>As an extension to this idea, the ""handle"" could then be an integer index rather than the actual pointer which avoids any chance of the user trying to abuse it by casting it to their own definition of the object.</p>
"
"<p>Unfortunately, I think the typical way to deal with this problem is by simply having the programmer treat the object as opaque - the full structure implementation is in the header and available, it's just the responsibility of the programmer to not use the internals directly, only through the APIs defined for the object.</p>

<p>If this isn't good enough, a few options might be:</p>

<ul>
<li>use C++ as a 'better C' and declare the internals of the structure as <code>private</code>.</li>
<li>run some sort of pre-processor on the headers so that the internals of the structure are declared, but with unusable names.  The original header, with good names, will be available to the implementation of the APIs that manage the structure. I've never seen this technique used - it's just an idea off the top of my head that might be possible, but seems like far more trouble than it's worth.</li>
<li>have your code that uses opaque pointers declare the statically allocated objects as <code>extern</code> (ie., globals) Then have a special module that has access to the full definition of the object actually declare these objects.  Since only the 'special' module has access to the full definition, the normal use of the opaque object remains opaque. However, now you have to rely on your programmers to not abuse the fact that thee objects are global.  You have also increased the change of naming collisions, so that need to be managed (probably not a big problem, except that it might occur unintentionally - ouch!).</li>
</ul>

<p>I think overall, just relying on your programmers to follow the rules for the use of these objects might be the best solution (though using a subset of C++ isn't bad either in my opinion).  Depending on your programmers to follow the rules of not using the structure internals isn't perfect, but it's a workable solution that is in common use.</p>
"
"<p>One solution if to create a static pool of <code>struct handle_t</code> objects, and provide then as neceessary.  There are many ways to achieve that, but a simple illustrative example follows:</p>

<pre><code>// In file module.c
struct handle_t
{
    int foo;
    void* something;
    int another_implementation_detail;

    int in_use ;
} ;

static struct handle_t handle_pool[MAX_HANDLES] ;

handle_t* create_handle()
{
    int h ;
    handle_t* handle = 0 ;
    for( h = 0; handle == 0 &amp;&amp; h &lt; MAX_HANDLES; h++ )
    {
        if( handle_pool[h].in_use == 0 )
        {
            handle = &amp;handle_pool[h] ;
        }
    }

    // other initialization
    return handle;
}

void release_handle( handle_t* handle )
{
    handle-&gt;in_use = 0 ;
}
</code></pre>

<p>There are faster faster ways of finding an unused handle, you could for example keep a static index that increments each time a handle is allocated and 'wraps-around' when it reaches MAX_HANDLES; this would be faster for the typical situation where several handles are allocated before releasing any one.  For a small number of handles however, this brute-force search is probably adequate.</p>

<p>Of course the handle itself need no longer be a pointer but could be a simple index into the hidden pool.  This would enhance data hiding and protection of the pool from external access.</p>

<p>So the header would have:</p>

<pre><code>typedef int handle_t ;
</code></pre>

<p>and the code would change as follows:</p>

<pre><code>// In file module.c
struct handle_s
{
    int foo;
    void* something;
    int another_implementation_detail;

    int in_use ;
} ;

static struct handle_s handle_pool[MAX_HANDLES] ;

handle_t create_handle()
{
    int h ;
    handle_t handle = -1 ;
    for( h = 0; handle != -1 &amp;&amp; h &lt; MAX_HANDLES; h++ )
    {
        if( handle_pool[h].in_use == 0 )
        {
            handle = h ;
        }
    }

    // other initialization
    return handle;
}

void release_handle( handle_t handle )
{
    handle_pool[handle].in_use = 0 ;
}
</code></pre>

<p>Because the handle returned is no longer a pointer to the internal data, and inquisitive or malicious user cannnot gain access to it through the handle.</p>

<p>Note that you may need to add some thread-safety mechanisms if you are getting handles in multiple threads.</p>
"
"<p>The least grim solution I've seen to this has been to provide an opaque struct for the caller's use, which is large enough, plus maybe a bit, along with a mention of the types used in the real struct, to ensure that the opaque struct will be aligned well enough compared to the real one:</p>

<pre><code>struct Thing {
    union {
        char data[16];
        uint32_t b;
        uint8_t a;
    } opaque;
};
typedef struct Thing Thing;
</code></pre>

<p>Then functions take a pointer to one of those:</p>

<pre><code>void InitThing(Thing *thing);
void DoThingy(Thing *thing,float whatever);
</code></pre>

<p>Internally, not exposed as part of the API, there is a struct that has the true internals:</p>

<pre><code>struct RealThing {
    uint32_t private1,private2,private3;
    uint8_t private4;
};
typedef struct RealThing RealThing;
</code></pre>

<p>(This one just has <code>uint32_t' and</code>uint8_t' -- that's the reason for the appearance of these two types in the union above.)</p>

<p>Plus probably a compile-time assert to make sure that <code>RealThing</code>'s size doesn't exceed that of <code>Thing</code>:</p>

<pre><code>typedef char CheckRealThingSize[sizeof(RealThing)&lt;=sizeof(Thing)?1:-1];
</code></pre>

<p>Then each function in the library does a cast on its argument when it's going to use it:</p>

<pre><code>void InitThing(Thing *thing) {
    RealThing *t=(RealThing *)thing;

    /* stuff with *t */
}
</code></pre>

<p>With this in place, the caller can create objects of the right size on the stack, and call functions against them, the struct is still opaque, and there's some checking that the opaque version is large enough.</p>

<p>One potential issue is that fields could be inserted into the real struct that mean it requires an alignment that the opaque struct doesn't, and this won't necessarily trip the size check. Many such changes will change the struct's size, so they'll get caught, but not all. I'm not sure of any solution to this.</p>

<p>Alternatively, if you have a special public-facing header(s) that the library never includes itself, then you can probably (subject to testing against the compilers you support...) just write your public prototypes with one type and your internal ones with the other. It would still be a good idea to structure the headers so that the library sees the public-facing <code>Thing</code> struct somehow, though, so that its size can be checked.</p>
"
"<p>It is simple, simply put the structs in a privateTypes.h header file. It will not be opaque anymore, still, it will be private to the programmer, since it is inside a <em>private</em> file.</p>

<p>An example here:
<a href=""https://stackoverflow.com/questions/2672015/hiding-members-in-a-c-struct/15340872#15340872"">Hiding members in a C struct</a></p>
"
"<p>I faced a similar problem in implementing a data structure in which the header of the data structure, which is opaque, holds all the various data that needs to be carried over from operation to operation.</p>

<p>Since re-initialization might cause a memory leak, I wanted to make sure that data structure implementation <em>itself</em> never actually overwrite a point to heap allocated memory.</p>

<p>What I did is the following:</p>

<pre><code>/**
 * In order to allow the client to place the data structure header on the
 * stack we need data structure header size. [1/4]
**/
#define CT_HEADER_SIZE  ( (sizeof(void*) * 2)           \
                        + (sizeof(int) * 2)             \
                        + (sizeof(unsigned long) * 1)   \
                        )

/**
 * After the size has been produced, a type which is a size *alias* of the
 * header can be created. [2/4]
**/
struct header { char h_sz[CT_HEADER_SIZE]; };
typedef struct header data_structure_header;

/* In all the public interfaces the size alias is used. [3/4] */
bool ds_init_new(data_structure_header *ds /* , ...*/);
</code></pre>

<p>In the implementation file:</p>

<pre><code>struct imp_header {
    void *ptr1,
         *ptr2;
    int  i,
         max;
    unsigned long total;
};

/* implementation proper */
static bool imp_init_new(struct imp_header *head /* , ...*/)
{
    return false;
}

/* public interface */
bool ds_init_new(data_structure_header *ds /* , ...*/)
{
    int i;

    /* only accept a zero init'ed header */
    for(i = 0; i &lt; CT_HEADER_SIZE; ++i) {
        if(ds-&gt;h_sz[i] != 0) {
            return false;
        }
    }

    /* just in case we forgot something */
    assert(sizeof(data_structure_header) == sizeof(struct imp_header));

    /* Explicit conversion is used from the public interface to the
     * implementation proper.  [4/4]
     */
    return imp_init_new( (struct imp_header *)ds /* , ...*/);
}
</code></pre>

<p>client side:</p>

<pre><code>int foo()
{
    data_structure_header ds = { 0 };

    ds_init_new(&amp;ds /*, ...*/);
}
</code></pre>
"
"<p>This is an old question, but since it's also biting me, I wanted to provide here a possible answer (which I'm using).</p>

<p>So here is an example :</p>

<pre><code>// file.h
typedef struct { size_t space[3]; } publicType;
int doSomething(publicType* object);

// file.c
typedef struct { unsigned var1; int var2; size_t var3; } privateType;

int doSomething(publicType* object)
{
    privateType* obPtr  = (privateType*) object;
    (...)
}
</code></pre>

<p><strong>Advantages</strong> :
<code>publicType</code> can be allocated on stack.</p>

<p>Note that correct underlying type must be selected in order to ensure proper alignment (i.e. don't use <code>char</code>).
Note also that <code>sizeof(publicType) &gt;= sizeof(privateType)</code>.
I suggest a static assert to make sure this condition is always checked.
As a final note, if you believe your structure may evolve later on, don't hesitate to make the public type a bit bigger, to keep room for future expansions without breaking ABI.</p>

<p><strong>Disadvantage</strong> :
The casting from public to private type can trigger <a href=""http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html"" rel=""nofollow"">strict aliasing warnings</a>.</p>

<p>I discovered later on that this method has similarities with <code>struct sockaddr</code> within BSD socket, which meets basically the same problem with strict aliasing warnings.</p>
"
"<p>Few examples to explain few scenarios. </p>

<p>A. Move one file one one place to another in same filesystem.
  This will have several tasks
  a. make entry into new directory file
  b. Delete entry from old file
In this <code>A</code> is transaction and <code>a,b</code> are handles. </p>

<p>B. Writing to a file
  Tasks involved are
  a. changing content of the changed block.
  b. change last modified time in inode.
In this <code>B</code> is transaction and <code>a,b</code> are handles.   </p>
"
"<p>Your object has two string and an int. You can define such an object in the IDL source file and pass them around after the compiler spits out the necessary stubs.</p>

<p>Start <a href=""http://msdn.microsoft.com/en-us/library/aa367271%28v=vs.85%29.aspx"" rel=""nofollow"">here</a> to do the reading.</p>
"
"<p>If you have a choice in the matter, use <code>BSTR</code> (i.e. <code>SysAllocString</code>).  RPC knows all about this data type and how to copy it and find its length.</p>

<p>Just</p>

<pre><code>[out, retval] BSTR* pstrName
</code></pre>

<p>is enough, no separate length parameter needed.</p>
"
"<p>Where you have written:</p>

<pre><code>*nLength = name.length();
</code></pre>

<p>I believe you need</p>

<pre><code>*nLength = (name.length() + 1) * sizeof(WCHAR);
</code></pre>

<p>In particular, if you have an empty (length zero) string, then returning a <code>size_is(0)</code> array is not legal -- so you must add space for the string-terminating NUL (<code>L'\0'</code>).  </p>

<p>You also want to supply the size in bytes, where each Unicode character uses two bytes -- therefore you must multiply by the character size.</p>
"
"<p>The server is not able to pass string value back to client since it doesn't know how to marshall the string..</p>

<p>When you use  BSTR type, the server knows to the length of the string. BSTR must be preceded by a 4-byte length field and terminated by a single null 2-byte character.</p>
"
"<p>Well, not quite sure but reading between the lines in the <a href=""http://msdn.microsoft.com/en-us/library/aa374215%28v=vs.85%29.aspx"" rel=""nofollow"">MSDN doc</a> (which says that the last argument is <strong>Pointer to the client-side calling stack</strong>) it sounds like the <code>NdrClientCall2</code> function can take the STUB_DESC structure, figure out what the argument types and sizes are, extract them from the stack, do the work of calling the remote interface and then write the results back into the proper locations on the stack (for OUT parameters).</p>
"
"<p>Without looking too deep into it, it seems to me that by passing the address of the first argument on the stack (&amp;IDL_handle) the implementation of NdrClientCall2 can see the subsequent arguments that are also on the stack. The second argument to NdrClientCall2 indicates the number and size of the varargs.</p>
"
"<p>This is not something a binomial heap is supposed to do. </p>

<p>A usual way to solve your problem would be: use a hash map (or other data structure you like) to store a mapping between values and <code>handle</code>s. You can then query the hash map for the handle. If it exists, this handle will let you modify the value in the heap. If it doesn't exist, you can just add a new value to the heap (of course, and a new mapping in the hash map)</p>

<p>Another way to solve the problem is to use a tree set/map, which is easier and may be more efficient than the solution I described above, depending on the actual use case.</p>
"
"<blockquote>
  <p>Do I now need to declare _db using a std::shared_ptr in my TestGet class</p>
</blockquote>

<p>No, you can leave it as it is, but you'll have to initialize it in the initialization lists of all <code>TestGet</code> constructors.</p>

<pre><code> TestGet() :
 _txHandle(11),
 _db(someInterface)
 {
     _interface.get = mockGet;
 }
</code></pre>
"
"<p>This should work:</p>

<pre><code>TestGet()
: _interface()
, _txHandle(11)
, _db(_interface)
{
    _interface.get = mockGet;
}
</code></pre>

<p>It depends, though, whether the constructor of <code>DB</code> does anything non-trivial. As long as it just stores the reference, this should be fine. That is, <code>DB</code> should look like this:</p>

<pre><code>struct DB
{
    Interface_T &amp; _interface;
    explicit DB(Interface_T &amp; interface) : _interface(interface) { }
};
</code></pre>

<p>If you need further initialization, you could either add an <code>init()</code> function to <code>DB</code>, or make an initialization function for <code>Interface_T</code> that you can use in the constructor of <code>TestGet</code>.</p>
"
"<p>Yes:</p>

<p>I see several that will cause undefined behavior.</p>

<p>All warnings should be considered logical errors (in at least your thinking) and should be looked at and made silent. Either by explicitly changing the code / by by using compiler directives to silence the warnings (then write a long comment as to why you quietened the warning, this also shows it has been looked at deliberately).</p>

<p>A quick scan of the ones I would check first (dupes removed).</p>

<p>These definitely sound bad:</p>

<pre><code>stub.c(138) : warning C4295: 'eye' : array is too small to include a terminating null character
exit1.c(157) : warning C4295: 'publickey' : array is too small to include a terminating null
</code></pre>

<p>These may be bad:</p>

<pre><code>api.c(554) : warning C4310: cast truncates constant value

chp.c(250) : warning C4244: '=' : conversion from 'SOCKET' to 'ULONG_T', possible loss of data

api.c(1216) : warning C4057: 'function' : 'LPDWORD' differs in indirection to slightly different base types from 'LONG_T *'

neto.c(2209) : warning C4057: 'function' : 'int *' differs in indirection to slightly different base types from 'LONG *'

td.c(760) : warning C4244: '=' : conversion from 'uintptr_t' to 'int', possible loss of data

msc.c(287) : warning C4133: 'function' : incompatible types - from 'long *' to 'time_t *'

arb.c(166) : warning C4267: '=' : conversion from 'size_t' to 'LONG_T', possible loss of data

arb.c(226) : warning C4244: '=' : conversion from 'int' to 'CHAR_T', possible loss of data

api.c(665) : warning C4311: 'type cast' : pointer truncation from 'HANDLE_T' to 'LONG'
</code></pre>

<p>These I would not leave in the code but are probably benign:</p>

<pre><code>api.c(559) : warning C4702: unreachable code

td.c(2104) : warning C4054: 'type cast' : from function pointer 'FARPROC' to data pointer 'PVOID'
</code></pre>
"
"<p>I suggest you simply get better at reading the error messages.  They are written in plain language.  You can Google for terms you don't yet understand.</p>

<p>Let's go through a bunch, shall we?</p>

<blockquote>
  <p>pcd.c(248) : warning C4996: 'getenv': This function or variable may be unsafe. Consider using _dupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</p>
</blockquote>

<p>I'd worry about this only if you call <code>getenv</code> while changing variables from another thread.  The problem with these routines is that they rely on global state, which becomes problematic when multiple threads are used.  The newer version is also clearer about who owns what allocation.</p>

<blockquote>
  <p>pcd.c(377) : warning C4244: '=' : conversion from 'uintptr_t' to 'ULONG', possible loss of data</p>
</blockquote>

<p>Looks suspicious.  Are you doing funky things with casting pointers to integers?  Around the time 64-bit Windows was introduced, they added <code>ULONG_PTR</code> for this.</p>

<blockquote>
  <p>pcd.c(236) : warning C4100: 'argv' : unreferenced formal parameter</p>

  <p>i.c(183) : warning C4100: 'lpReserved' : unreferenced formal parameter</p>
</blockquote>

<p>Can safely be ignored or supressed.</p>

<blockquote>
  <p>api.c(506) : warning C4996: 'stricmp': The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _stricmp. See online help for details.</p>
</blockquote>

<p>Not terribly concerning.  The name with the underscore might end up making you less portable with *nix systems.</p>

<blockquote>
  <p>api.c(554) : warning C4310: cast truncates constant value</p>
</blockquote>

<p>Looks suspicious.  Please provide examples.</p>

<blockquote>
  <p>api.c(719) : warning C4996: 'strcpy': This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</p>

  <p>api.c(2217) : warning C4996: 'sprintf': This function or variable may be unsafe. Consider using sprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</p>
</blockquote>

<p>These are age-old problems that every decent C programmer should know or understand.  Please do a google search or something to read about buffer overflows and why these functions should be avoided where possible.  Note that while the <code>_s</code> names are in the C1x standard, they might not be so common on *nix systems.  There's also <code>snprintf</code> and <code>strncpy</code> which conform to older standards.</p>

<blockquote>
  <p>api.c(2892) : warning C4312: 'type cast' : conversion from 'ULONG_T' to 'HANDLE_T' of greater size</p>
</blockquote>

<p>Not sure what <code>HANDLE_T</code> is, but in Win32 <code>HANDLE</code> is the size of a pointer.  This is pretty bad.  I would suggest <code>ULONG_PTR</code> as before.</p>

<blockquote>
  <p>api.c(559) : warning C4702: unreachable code</p>
</blockquote>

<p>Exactly what it says.</p>

<blockquote>
  <p>stdio.h(234) : see declaration of 'fopen'</p>
</blockquote>

<p>Did you see it?</p>

<blockquote>
  <p>api.c(2217) : warning C4996: 'sprintf': This function or variable may be unsafe. Consider using sprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</p>
</blockquote>

<p>Similar to above.</p>

<blockquote>
  <p>prm.c(681) : warning C4996: 'fopen': This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details. C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\INCLUDE\stdio.h(234) : see declaration of 'fopen'</p>
</blockquote>

<p>This is another C11 feature that the MS compiler starts recommending.  This one is kind of dubious.  <code>fopen</code> is probably OK.  Read documentation as appropriate.</p>

<blockquote>
  <p>host.c(410) : warning C4311: 'type cast' : pointer truncation from 'PVOID_T' to 'unsigned long'</p>
</blockquote>

<p>Use <code>ULONG_PTR</code> or <code>uintptr_t</code> instead of <code>unsigned long</code>.</p>

<blockquote>
  <p>stub.c(138) : warning C4295: 'eye' : array is too small to include a terminating null character</p>
</blockquote>

<p>My guess is you declared a string like this:</p>

<pre><code>char foo[n] = ""blah"";
</code></pre>

<p>Where <code>n</code> is a size that is too small to fit the string.  Just remove the integer.</p>

<blockquote>
  <p>api.c(1216) : warning C4057: 'function' : 'LPDWORD' differs in indirection to slightly different base types from 'LONG_T *'</p>
</blockquote>

<p><code>DWORD</code> and <code>LONG</code> are distinct types, and you're taking pointers to one and using it as the other.  This is illegal.  (In this case it won't cause you problems, but you should fix it.)</p>

<blockquote>
  <p>neto.c(595) : warning C4152: nonstandard extension, function/data pointer conversion in expression</p>
</blockquote>

<p>Hmm, not sure how you did this one.  Maybe you assigned a function pointer into <code>void *</code>?  There are several libraries which require this, though it is technically illegal by the standard.</p>

<blockquote>
  <p>neto.c(2115) : warning C4213: nonstandard extension used : cast on l-value</p>
</blockquote>

<p>My guess is you did something like this:</p>

<pre><code>*(char*)foo = bar;
</code></pre>

<p>Illegal.</p>

<blockquote>
  <p>neto.c(2209) : warning C4057: 'function' : 'int *' differs in indirection to slightly different base types from 'LONG *'</p>
</blockquote>

<p>Similar situation to using <code>PDWORD</code> and <code>LONG</code> interchangeably.</p>

<blockquote>
  <p>td.c(2104) : warning C4054: 'type cast' : from function pointer 'FARPROC' to data pointer 'PVOID'</p>
</blockquote>

<p>Similar to neto.c, line 595.</p>
"
"<p>There are three kinds of warnings:</p>

<ol>
<li><p>Warnings about unsafe/deprecated functions. Some of these warnings you might have gotten before, since those functions were unsafe/nonstandard and maybe deprecated before. However, if you have a look at them and ensure to use them correctly (having in mind that the size of some types changes in 64bit), you can continue to use them. However, I'd try to use standard functions where possible. At the very least you should turn off the warnings individually if you are sure to use the functions correctly.</p></li>
<li><p>Warnings that should've been there before too, such as ""unreferenced parameters"", signed/unsigned mismatches, unreachable code and some nasty things like warnings C4295, C4054, C4133. You should fix those, all of them. Some are not very grave (e.g. signed/unsigned mismatch), but also very easy to fix, so fix them just to silence the compiler.</p></li>
<li><p>Warnings resulting from different sizes in 64bit on Windows with MSVC. In 32 bit, int, long, long long, pointers, size_t etc. have 32 bit size. You could convert them seamlessly, without data losses. However, in 64 bit, long long, size_t and pointers have 64 bit size, while long and int remain 32 bit. Converting them might lose information, especially if pointers are involved. Try to use the correct types, don't use narrowing conversions. That also applies for various typedefs to those types, e.g. PVOID, DWORD and all those typedefs WinAPI uses just to have other names for the same things.</p></li>
</ol>

<p>In general: Warnings are there for a reason. Try to silence your compiler as much as possible, by attending each single warning and apply appropiate changes to the code. If you absolutely must do conversions and are sure they won't affect the validity of your program, use explicit casts (i.e. <code>static_cast</code> in most cases). By doing so you can be sure you don't miss the single warning that hints at the really stupid mistake you will do one day that completely breaks the whole program and that won't be found until after long days of debugging. I know it's tedious, especially on 32/64 bit dual platform compilation, but its worth the effort in the long term.</p>
"
"<p>Use the source, Luke - from <a href=""http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=blob;f=fs/ext3/inode.c#l1555"" rel=""nofollow"">Linux <code>fs/ext3/inode.c</code></a> (line number for the link correct as per this writing, but the URL is Linus' head tree so this may eventually change): </p>

<pre><code>/*
 * Note that we always start a transaction even if we're not journalling
 * data.  This is to preserve ordering: any hole instantiation within
 * __block_write_full_page -> ext3_get_block() should be journalled
 * along with the data so we don't crash and then get metadata which
 * refers to old data.
[ ... ]
static int ext3_ordered_writepage(struct page *page,
                                struct writeback_control *wbc)
{
        struct inode *inode = page->mapping->host;
        struct buffer_head *page_bufs;
        handle_t *handle = NULL;
        int ret = 0;
        int err;
[ ... ]
        handle = ext3_journal_start(inode, ext3_writepage_trans_blocks(inode));
[ ... ]
        ret = block_write_full_page(page, ext3_get_block, wbc);
[ ... ]

        /*
         * And attach them to the current transaction.  But only if
         * block_write_full_page() succeeded.  Otherwise they are unmapped,
         * and generally junk.
         */
        if (ret == 0) {
                err = walk_page_buffers(handle, page_bufs, 0, PAGE_CACHE_SIZE,
                                        NULL, journal_dirty_data_fn);
                if (!ret)
                        ret = err;
        }
        walk_page_buffers(handle, page_bufs, 0,
                        PAGE_CACHE_SIZE, NULL, bput_one);
        err = ext3_journal_stop(handle);
        if (!ret)
                ret = err;
[ ... ]
        return ret;
}
[ ... ]
/*
 * ext3_truncate()
 *
 * We block out ext3_get_block() block instantiations across the entire
 * transaction, and VFS/VM ensures that ext3_truncate() cannot run
 * simultaneously on behalf of the same inode.
 *
 * As we work through the truncate and commit bits of it to the journal there
 * is one core, guiding principle: the file's tree must always be consistent on
 * disk.  We must be able to restart the truncate after a crash.
 *
[ ... ]
 */
void ext3_truncate(struct inode *inode)
{
        handle_t *handle;
[ ... ]
        handle = start_transaction(inode);
[ ... ]
        /*
         * OK.  This truncate is going to happen.  We add the inode to the
         * orphan list, so that if this truncate spans multiple transactions,
         * and we crash, we will resume the truncate when the filesystem
         * recovers.  It also marks the inode dirty, to catch the new size.
         *
         * Implication: the file must always be in a sane, consistent
         * truncatable state while each transaction commits.
         */
        if (ext3_orphan_add(handle, inode))
                goto out_stop;
[ ... ]
        if (n == 1) {           /* direct blocks */
                ext3_free_data(handle, inode, NULL, i_data+offsets[0],
                               i_data + EXT3_NDIR_BLOCKS);
                goto do_indirects;
        }
[ ... ]
do_indirects:
        /* Kill the remaining (whole) subtrees */
        switch (offsets[0]) {
        default:
                nr = i_data[EXT3_IND_BLOCK];
                if (nr) {
                        ext3_free_branches(handle, inode, NULL, &nr, &nr+1, 1);
                        i_data[EXT3_IND_BLOCK] = 0;
                }
        case EXT3_IND_BLOCK:
                nr = i_data[EXT3_DIND_BLOCK];
                if (nr) {
                        ext3_free_branches(handle, inode, NULL, &nr, &nr+1, 2);
                        i_data[EXT3_DIND_BLOCK] = 0;
                }
        case EXT3_DIND_BLOCK:
                nr = i_data[EXT3_TIND_BLOCK];
                if (nr) {
                        ext3_free_branches(handle, inode, NULL, &nr, &nr+1, 3);
                        i_data[EXT3_TIND_BLOCK] = 0;
                }
        case EXT3_TIND_BLOCK:
                ;
        }
[ ... ]
        ext3_journal_stop(handle);
[ ... ]
}
</code></pre>

<p>This clearly states file extensions / truncations (i.e. the allocation and/or release of direct/indirect blocks of any level) are always transacted. There's also the code in <code>ext3_get_blocks()</code> itself which will open a transaction even if called without previously having created a transaction - that's used for direct I/O writes.</p>

<p>So in short - yes, as long as the ext3 has a journal, then modifications of direct/indirect blocks of any level are always transacted.</p>
"
"<p>If I find no better alternative, I'll need to save the handle inside each corresponding element for later usage (c++1y code):</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;boost/heap/fibonacci_heap.hpp&gt;

using namespace boost::heap;

template&lt;typename T&gt;
struct heap_data
{
    typedef typename fibonacci_heap&lt;heap_data&gt;::handle_type handle_t;
    handle_t handle;
    T data;

    heap_data(const T &amp;data_) : data(data_) {}

    bool operator&lt;(heap_data const &amp; rhs) const
    {
        return data &lt; rhs.data;
    }
};

void setup_handle(fibonacci_heap&lt;heap_data&lt;int&gt;&gt;::handle_type &amp;&amp;handle)
{
    (*handle).handle = handle;
}

int main()
{
    fibonacci_heap&lt;heap_data&lt;int&gt;&gt; heap;

    setup_handle(heap.emplace(1));
    setup_handle(heap.emplace(2));
    setup_handle(heap.emplace(3));

    std::find_if(heap.ordered_begin(), heap.ordered_end(),
    [&amp;heap](const heap_data&lt;int&gt; &amp;e)
    {
        if(e.data == 2)
        {
            const_cast&lt;heap_data&lt;int&gt; &amp;&gt;(e).data += 2;
            heap.increase(e.handle);
            return true;
        }
        return false;
    });

    std::for_each(heap.ordered_begin(), heap.ordered_end(),
    [](const heap_data&lt;int&gt; &amp;e)
    {
        std::cout &lt;&lt; e.data &lt;&lt; std::endl;
    });
}
</code></pre>
"
"<p>Your requirements are not very clear to me.  But how about std::multimap or std::multiset?  Update operations are O(log n).  I think traversal should be O(n) (<a href=""http://en.wikipedia.org/wiki/Binary_search_tree#Traversal"" rel=""nofollow"">BST traversal</a>), but it's not documented in my standard C++ references (cppreference.com, cplusplus.com).  Looks like <a href=""http://www.boost.org/doc/libs/1_53_0/doc/html/heap/concepts.html#heap.concepts.iterators"" rel=""nofollow"">boost::heap traversal</a> is amortized O(n log n).</p>
"
"<p>I would say yes because a Move Constructor and Move Assignment operator are now compiler defined for objects that do not define/protect a destructor, copy constructor, or copy assignment. </p>

<p>This means that if you have the following code...</p>

<pre><code>struct intContainer
{
    std::vector&lt;int&gt; v;
}

intContainer CreateContainer()
{
    intContainer c;
    c.v.push_back(3);
    return c;
}
</code></pre>

<p>The code above would be optimized simply by recompiling with a compiler that supports move semantics. Your container c will have compiler defined move-semantics and thus will call the manually defined move operations for std::vector without any changes to your code.</p>
"
"<h3>TL;DR</h3>

<p>This is definitely something new and it goes well beyond just being a way to avoid copying memory.</p>

<h3>Long Answer:  Why it's new and some perhaps non-obvious implications</h3>

<p>Move semantics are just what the name implies--that is, a way to explicitly declare instructions for moving objects rather than copying.  In addition to the obvious efficiency benefit, this also affords a programmer a standards-compliant way to have objects that are <em>movable but not copyable</em>.  Objects that are movable and not copyable convey a very clear boundary of resource ownership via standard language semantics.  This was possible in the past, but there was no standard/unified (or STL-compatible) way to do this.</p>

<p>This is a big deal because having a standard and unified semantic benefits both programmers and compilers.  Programmers don't have to spend time potentially introducing bugs into a move routine that can reliably be generated by compilers (most cases); compilers can now make appropriate optimizations because the standard provides a way to inform the compiler when and where you're doing standard moves.</p>

<p>Move semantics is particularly interesting because it very well suits the RAII idiom, which is a long-standing a cornerstone of C++ best practice.  RAII encompasses much more than just this example, but my point is that move semantics is now a standard way to concisely express (among other things) movable-but-not-copyable objects.</p>

<p>You don't always have to explicitly define this functionality in order to prevent copying.  A compiler feature known as <em>""copy elision""</em> will eliminate quite a lot of unnecessary copies from functions that pass by value.</p>

<h3>Criminally-Incomplete Crash Course on RAII (for the uninitiated)</h3>

<p>I realize you didn't ask for a code example, but here's a really simple one that might benefit a future reader who might be less familiar with the topic or the relevance of Move Semantics to RAII practices.  (If you already understand this, then skip the rest of this answer)</p>

<pre class=""lang-c prettyprint-override""><code>// non-copyable class that manages lifecycle of a resource
// note:  non-virtual destructor--probably not an appropriate candidate
//        for serving as a base class for objects handled polymorphically.
class res_t {
  using handle_t = /* whatever */;
  handle_t* handle;  // Pointer to owned resource
public:
  res_t( const res_t&amp; src ) = delete;            // no copy constructor
  res_t&amp; operator=( const res_t&amp; src ) = delete; // no copy-assignment

  res_t( res_t&amp;&amp; src ) = default;                // Move constructor
  res_t&amp; operator=( res_t&amp;&amp; src ) = default;     // Move-assignment

  res_t();                                       // Default constructor
  ~res_t();                                      // Destructor
};
</code></pre>

<p>Objects of this class will allocate/provision whatever resource is needed upon construction and then free/release it upon destruction.  Since the resource pointed to by the data member can never accidentally be transferred to another object, the rightful owner of a resource is never in doubt.  In addition to making your code less prone to abuse or errors (and easily compatible with STL containers), <em>your intentions will be immediately recognized</em> by any programmer familiar with this standard practice.</p>
"
"<p>Since move semantics only apply in the presence of rvalue
references, which are declared by a new token, <code>&amp;&amp;</code>, it seems
very clear that they are something new.</p>

<p>In principle, they are purely an optimizing techique, which
means that:
1. you don't use them until the profiler says it is necessary, and
2. in theory, optimizing is the compiler's job, and move
semantics aren't any more necessary than <code>register</code>.</p>

<p>Concerning 1, we may, in time, end up with an ubiquitous
heuristic as to how to use them: after all, passing an argument
by const reference, rather than by value, is also an
optimization, but the ubiquitous convention is to pass class
types by const reference, and all other types by value.</p>

<p>Concerning 2, compilers just aren't there yet.  At least, the
usual ones.  The basic principles which could be used to make
move semantics irrelevant are (well?) known, but to date, they
tend to result in unacceptable compile times for real programs.</p>

<p>As a result: if you're writing a low level library, you'll
probably want to consider move semantics from the start.
Otherwise, they're just extra complication, and should be
ignored, until the profiler says otherwise.</p>
"
"<p>There is absolutely something new going on here. Consider <code>unique_ptr</code> which can be moved, but not copied because it uniquely holds ownership of a resource. That ownership can then be transferred by moving it to a new <code>unique_ptr</code> if needed, but copying it would be impossible (as you would then have two references to the owned object).</p>

<p>While many uses of moving may have positive performance implications, the movable-but-not-copyable types are a much bigger functional improvement to the language.</p>

<p>In short, use the new techniques <em>where it indicates the meaning</em> of how your class should be used, or where (significant) performance concerns can be alleviated by movement rather than copy-and-destroy.</p>
"
"<p>In the Turing Tar Pit, there is nothing new under the sun.  Everything that move semantics does, can be done without move semantics -- it just takes a lot more code, and is a lot more fragile.</p>

<p>What move semantics does is takes a particular common pattern that massively increases efficiency and safety in a number of situations, and embeds it in the language.</p>

<p>It increases efficiency in obvious ways.  Moving, be it via <code>swap</code> or <code>move</code> construction, is much faster for many data types than copying.  You can create special interfaces to indicate when things can be moved from: but honestly people didn't do that.  With move semantics, it becomes relatively easy to do.  Compare the cost of moving a <code>std::vector</code> to copying it -- <code>move</code> takes roughly copying 3 pointers, while copying requires a heap allocation, copying every element in the container, and creating 3 pointers.</p>

<p>Even more so, compare <code>reserve</code> on a move-aware <code>std::vector</code> to a copy-only aware one: suppose you have a <code>std::vector</code> of <code>std::vector</code>.  In C++03, that was performance suicide if you didn't know the dimensions of every component ahead of time -- in C++11, move semantics makes it as smooth as silk, because it is no longer repeatedly copying the sub-<code>vector</code>s whenever the outer vector resizes.</p>

<p>Move semantics makes every ""<code>pImpl</code> pattern"" type to have blazing fast performance, while means you can start having complex objects that behave like values instead of having to deal with and manage pointers to them.</p>

<p>On top of these performance gains, and opening up complex-class-as-value, move semantics also open up a whole host of safety measures, and allow doing some things that where not very practical before.</p>

<p><code>std::unique_ptr</code> is a replacement for <code>std::auto_ptr</code>. They both do roughly the same thing, but <code>std::auto_ptr</code> treated copies as moves.  This made <code>std::auto_ptr</code> ridiculously dangerous to use in practice.  Meanwhile, <code>std::unique_ptr</code> <em>just works</em>.  It represents unique ownership of some resource extremely well, and transfer of ownership can happen easily and smoothly.</p>

<p>You know the problem whereby you take a <code>foo*</code> in an interface, and sometimes it means ""this interface is taking ownership of the object"" and sometimes it means ""this interface just wants to be able to modify this object remotely"", and you have to delve into API documentation and sometimes source code to figure out which?</p>

<p><code>std::unique_ptr</code> actually solves this problem -- interfaces that want to take onwership can now take a <code>std::unique_ptr&lt;foo&gt;</code>, and the transfer of ownership is obvious at both the API level and in the code that calls the interface.  <code>std::unique_ptr</code> is an <code>auto_ptr</code> that <em>just works</em>, and has the unsafe portions removed, and replaced with move semantics.  And it does all of this with nearly perfect efficiency.</p>

<p><code>std::unique_ptr</code> is a transferable RAII representation of resource whose value is represented by a pointer.</p>

<p>After you write <code>make_unique&lt;T&gt;(Args&amp;&amp;...)</code>, unless you are writing really low level code, it is probably a good idea to <em>never call <code>new</code> directly again</em>.  Move semantics basically have made <code>new</code> obsolete.</p>

<p>Other RAII representations are often non-copyable.  A port, a print session, an interaction with a physical device -- all of these are resources for whom ""copy"" doesn't make much sense.  Most every one of them can be easily modified to support move semantics, which opens up a whole host of freedom in dealing with these variables.</p>

<p>Move semantics also allows you to put your return values in the return part of a function.  The pattern of taking return values by reference (and documenting ""this one is out-only, this one is in/out"", or failing to do so) can be somewhat replaced by returning your data.</p>

<p>So instead of <code>void fill_vec( std::vector&lt;foo&gt;&amp; )</code>, you have <code>std::vector&lt;foo&gt; get_vec()</code>.  This even works with multiple return values -- <code>std::tuple&lt; std::vector&lt;A&gt;, std::set&lt;B&gt;, bool &gt; get_stuff()</code> can be called, and you can load your data into  local variables efficiently via <code>std::tie( my_vec, my_set, my_bool ) = get_stuff()</code>.</p>

<p>Output parameters can be semantically output-only, with very little overhead (the above, in a worst case, costs 8 pointer and 2 <code>bool</code> copies, regardless of how much data we have in those containers -- and that overhead can be as little as 0 pointer and 0 <code>bool</code> copies with a bit more work), because of move semantics.</p>
"
"<p>No answer is complete without a reference to Thomas Becker's painstakingly exhaustive write up on rvalue references, perfect forwarding, reference collapsing and everything related to that.</p>

<p>see here: <a href=""http://thbecker.net/articles/rvalue_references/section_01.html"" rel=""nofollow"">http://thbecker.net/articles/rvalue_references/section_01.html</a></p>
"
"<p>Yes, that will work fine as long as the C code never needs to see ""inside"" the <code>handle_tag</code> structure, and the appropriate C++ construction/destruction is performed by the C++ code (which I preseume the <code>construct</code> and <code>destruct</code> are for). </p>

<p>All that the C code needs is a pointer to some datastructure - it won't know what the contents is, so the content can be anything you like it to to be, including constructor/destructor reliant data. </p>

<p>Edit:
I should point out that this, or methods similar to it (e.g. using a <code>void *</code> to record the address of an object for the C portion to <code>hold</code>), is a fairly common way to interface C-code to C++ functionality. </p>

<p>Edit2:
It is critical that the C++ code called doesn't ""leak"" exceptions into the C code. That is undefined behaviour, and very much liable to cause crashes, or worse, ""weird things"" that don't crash... So unless the code is guaranteed to not cause exceptions (and for example <code>std::string</code> is liable to throw <code>bad_alloc</code> in case of low memory), it is required to use a <code>try/catch</code> block inside code like <code>construct</code> anf <code>func</code> in the C++ side. </p>
"
"<p>Won't work quite as is, but the concept's ok.  When the functions are <em>defined</em>, you also need to make sure the names aren't mangled so that the C code can find them.  That means <code>#include ""api.h""</code> should be added atop your api.cpp file.</p>
"
"<p>Previously I had recommended a singleton, but there are is a fair amount of criticism of using that pattern - <a href=""http://blogs.msdn.com/b/scottdensmore/archive/2004/05/25/140827.aspx"" rel=""nofollow"">one example</a>.</p>

<p>If you want something more exotic (perhaps you need to store some kind of local state in your classes), you could embed your own reference counting in the object itself:</p>

<pre><code>// Psuedo code
class Resource
{
    static unsigned _refCount;

public:
    Resource() {++_refCount;}
    ~Resource() {--_refCount;  if(_refCount == 0) // cleanup!;}
};
</code></pre>

<p>You will notice this is basically the same scheme as a shared_ptr, but it would allow using items on the stack via instantiation instead of passing pointers around (you will have to store the resource in a static member, also, for all instances to have access to it).  As one of the comments suggested, you should prefer shared_ptr and only reject it if you can verify via profile that it is too slow for your needs.</p>
"
"<p>The answer to this question depends on the lifetime policy you are trying to achieve.</p>

<p>If you want reference counting so resources are deallocated when the last handle goes out of scope then shared_ptr and intrusive_ptr are the only options that I'm aware of.  You could handroll something, but I'd think long and hard before doing that.  If your program is single threaded then the easiest thing to do may be to use Boost shared pointers with the atomic counting disabled:</p>

<pre><code>#define BOOST_SP_DISABLE_THREADS
#include &lt;boost/shared_ptr.hpp&gt;
</code></pre>

<p>That should reduce the cost significantly.  Of course the comment above is correct that before going this route you would normally profile the code to make sure it really is a bottleneck, but that discussion is a bit of a digression from the question you asked.</p>

<p>If, instead of reference counting, you are OK with the resources being persistent you could use a static cache:</p>

<pre><code>// In the header.
#include &lt;memory&gt;
#include &lt;functional&gt;

namespace detail {
  using deleter_t = std::function&lt;void (void *)&gt;;
  using  handle_t = std::unique_ptr&lt;void, deleter_t&gt;;

  void *search_persistent_cache(std::string const &amp;id);
  void  add_to_persistent_cache(std::string const &amp;id, void *);
}

template&lt;typename T, typename... Args&gt;
T &amp;get_persistent_resource(std::string const &amp;id, Args&amp;&amp;... args) {
  auto resource = search_persistent_cache(id);

  if(resource) {
    return *static_cast&lt;T*&gt;(resource);
  }

  auto uniq_instance = std::unique_ptr&lt;T&gt;(std::forward&lt;Args&gt;(args)...);
  auto  raw_instance = uniq_instance.get();

  detail::deleter_t deleter = [](void *resource) -&gt; void {
    delete static_cast&lt;T*&gt;(resource);
  };

  try {
    add_to_persistent_cache(id,
        detail::handle_t { uniq_instance.release(), std::move(deleter); });
  } catch(...) {
    delete instance;
    return nullptr;
  }
}
</code></pre>

<p>That should be enough for the general idea.  I will leave it up to you to implement the static storage and undefined functions in a source file.  There are some tweaks that you can make, such as if you don't need the resources indexed by an identifier or you want to avoid using void* so debug builds can work using boost::polymorphic_down_cast.</p>

<p>I can't think of any other lifetime management strategies that are not significantly more complex than the ones shown above.</p>
"
"<p>Since you declared your heap as mutable, the <code>push</code> operation is supposed to return the <code>handle_t</code> you typedefed as the <code>handle_type</code>:</p>

<pre><code>mpl::if_c&lt; is_mutable, handle_type, void &gt;::type push(value_type const &amp; v);
</code></pre>

<p>In the respect of obtaining the handle, your code is fine. To simplify a bit to make it clearer:</p>

<pre><code>void push (const myType * c) {
    handle_t handle = heap_.push(c);
    handles_[c-&gt;getIndex()] = handle;
}
</code></pre>

<p>As a side-note, you should have a typedef for the heap instead of repeating it in the declarations, and the <code>typename</code> is superfluous (at least in the snippet you posted in the question.)</p>
"
"<p>Looking at the header, the <code>boost::heap::fibonacci_heap</code> <a href=""http://www.boost.org/doc/libs/1_55_0/doc/html/boost/heap/fibonacci_heap.html"" rel=""nofollow"">does have multiple copy constructors</a> :</p>

<pre><code>fibonacci_heap(fibonacci_heap const &amp;);
fibonacci_heap(fibonacci_heap &amp;);
</code></pre>

<p>(The compiler message is not about <code>EdgeHeap</code> or one of your types)</p>

<p>As per the <a href=""http://msdn.microsoft.com/en-us/library/e02fwk4s.aspx"" rel=""nofollow"">VS documentation</a>, it is an informational warning, nothing to worry about in this case.</p>
"
"<p>A very big warning should be mentioned before even attempting the code shown in this answer. Doing this is most likely very very undefined and not portable behavior. I would highly suggest not doing this as it could very well break a long time into the future and you will have a very hard time finding out why.</p>

<p>That being said, it appears to work on at least my compiler. Results may vary for other compilers. I use a union to convert between a class instance and a void *, don't know of any other clean way to do this. This should work as long as <code>sizeof( Class ) &lt;= sizeof( void * )</code>, but I make no guarantees on behavior with different compilers or even with the exact same compiler I used on my exact same setup.</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

class Small {
public:
    int i;
};

void *castToVoid( Small&amp; s ) {
    union {
        Small s;
        void *p;
    } un;
    un.s = s;
    return un.p;
}

Small castToSmall( void *p ) {
    union {
        Small s;
        void *p;
    } un;
    un.p = p;
    return un.s;
}

int main( ) {
    Small s;
    s.i = 100;

    void *p = castToVoid( s );

    s.i = 200;
    cout &lt;&lt; p &lt;&lt; endl; // Prints 0x64

    Small s2 = castToSmall( p );
    cout &lt;&lt; s2.i &lt;&lt; endl; // Prints 100
}
</code></pre>

<p>or this example for converting to/from a void *</p>

<pre><code>void *castToVoid( Small&amp; s ) {
    void **p = reinterpret_cast&lt; void ** &gt;( &amp;s );
    return *p;
}

Small castToSmall( void *p ) {
    Small *s = reinterpret_cast&lt; Small * &gt;( &amp;p );
    return *s;
}
</code></pre>
"
"<p>It's implementation-defined behavior according to the C++ standard (draft N3797).</p>

<p>? 3.7.4.2/p4</p>

<blockquote>
  <p>Indirection through an invalid pointer value and passing an invalid
  pointer value to a deallocation function have undefined behavior. <strong>Any
  other use of an invalid pointer value has implementation-defined
  behavior</strong>.</p>
</blockquote>

<p>footnote 38:</p>

<blockquote>
  <p>Some implementations might define that copying an invalid pointer
  value causes a system-generated runtime fault</p>
</blockquote>

<p>? 3.7.4.3/p4</p>

<blockquote>
  <p>An implementation may have relaxed pointer safety, in which case the
  validity of a pointer value does not depend on whether it is a
  safely-derived pointer value. Alternatively, an implementation may
  have strict pointer safety, in which case a pointer value referring to
  an object with dynamic storage duration that is not a safely-derived
  pointer value is an invalid pointer value unless the referenced
  complete object has previously been declared reachable (20.7.4) [...] <strong>It is implementation
  defined whether an implementation has relaxed or strict pointer safety</strong>.</p>
</blockquote>

<p>(emphasis mine)</p>

<p>So it is safe if the implementation has relaxed pointer safety, and we can use the <code>union</code> trick as shown in the <a href=""https://stackoverflow.com/a/26666941/2969631"">answer</a> from <a href=""https://stackoverflow.com/users/3935776/smith-61"">@Smith_61</a> to avoid strict aliasing.</p>
"
"<p>Indeed, you're invoking <a href=""https://en.wikipedia.org/wiki/Undefined_behavior"" rel=""nofollow"">Undefined Behaviour</a>.</p>

<p>Run your program under valgrind?:</p>

<pre><code>sehe@desktop:/tmp$ valgrind --db-attach=yes ./test
==14185== Memcheck, a memory error detector
==14185== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==14185== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==14185== Command: ./test
==14185==
first element in heap is :1 0.25
size of heap is :10
size of heap after pop is :9
first element in heap is now :8 1.23
element index 2 has time :3.6
==14185== Invalid read of size 8
==14185==    at 0x400F21: main (test.cpp:47)
==14185==  Address 0x5aa6d78 is 24 bytes inside a block of size 72 free'd
==14185==    at 0x4C2C2BC: operator delete(void*) (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==14185==    by 0x402789: __gnu_cxx::new_allocator&lt;boost::heap::detail::marked_heap_node&lt;node&gt; &gt;::deallocate(boost::heap::detail::marked_heap_node&lt;node&gt;*, unsigned long) (new_allocator.h:110)
==14185==    by 0x401D2C: boost::heap::fibonacci_heap&lt;node, boost::heap::compare&lt;compare_node&gt;, boost::parameter::void_, boost::parameter::void_, boost::parameter::void_, boost::parameter::void_&gt;::finish_erase_or_pop(boost::heap::detail::marked_heap_node&lt;node&gt;*) (fibonacci_heap.hpp:745)
==14185==    by 0x4015E7: boost::heap::fibonacci_heap&lt;node, boost::heap::compare&lt;compare_node&gt;, boost::parameter::void_, boost::parameter::void_, boost::parameter::void_, boost::parameter::void_&gt;::pop() (fibonacci_heap.hpp:398)
==14185==    by 0x400E1C: main (test.cpp:34)
==14185==
==14185==
==14185== ---- Attach to debugger ? --- [Return/N/n/Y/y/C/c] ----
</code></pre>

<p>See, you're reading memory that was previously deleted. Oops.</p>

<p>Anything can happen. What happens depends on your luck, your computer etc.</p>

<p>? I used a cleaned up version of the code: <strong><a href=""http://coliru.stacked-crooked.com/a/8fdc46198a9b2cdc"" rel=""nofollow"">Live On Coliru</a></strong>, so you can cross reference the line numbers</p>
"
"<p>You want what's called <em>non-type template parameters</em> with <em>template specialization</em>:</p>

<pre><code>template&lt;Handlers H&gt; void handle();  // default

template&lt;&gt; void handle&lt;MESSAGE1&gt;() {
    // ...
}

template&lt;&gt; void handle&lt;MESSAGE2&gt;() {
    // ...
}
</code></pre>
"
"<p>You can use <code>std::integral_constant</code> (or write your own empty type wrapper to do the same thing) to wrap your enums into types:</p>

<pre><code>template &lt;Handler H&gt;
using handle_t = std::integral_constant&lt;Handler, H&gt;;
</code></pre>

<p>And then overload on different types:</p>

<pre><code>void handle(handle_t&lt;MESSAGE1&gt; ) { ... }
void handle(handle_t&lt;MESSAGE2&gt; ) { ... }
</code></pre>

<p>which you can call via:</p>

<pre><code>handle(handle_t&lt;MESSAGE1&gt;{} );
</code></pre>
"
"<p>You don't need to have a platform-agnostic base class, because your code is only compiled for a single concrete platform at a time.</p>

<p>Just set the include path to, for example, <code>-Iinclude/generic -Iinclude/platform</code>, and have a separate Thread class in each supported <em>platform</em>'s include directory.</p>

<p>You can (and should) write platform-agnostic tests, compiled &amp; executed by default, which confirm your different platform-specific implementations adhere to the same interface and semantics.</p>

<p>PS. As StoryTeller says, Thread is a bad example since there's already a portable <code>std::thread</code>. I'm assuming there's some other platform-specific detail you really do need to abstract.</p>

<p>PPS. You still need to figure out the correct split between <em>generic</em> (platform-agnostic) code and platform-specific code: there's no magic bullet for deciding what goes where, just a series of tradeoffs between reuse/duplication, simple versus highly-parameterized code, etc.</p>
"
"<p>You seem to want value semantics for your <code>Thread</code> class and wonder where to add the indirection to make it portable. So you use the pimpl idiom, and some conditional compilation.<br>
Depending on where you want the complexity of your build tool to be, and if you want to keep all the low level code as self contained as possible, You do the following:</p>

<p>In you high level header <code>Thread.hpp</code>, you define:</p>

<pre><code>class Thread
{
  class Impl:
  Impl *pimpl; // or better yet, some smart pointer
public:
  Thread ();
  ~Thread();
  // Other stuff;
};
</code></pre>

<p>Than, in your thread sources directory, you define files along this fashion:</p>

<p><code>Thread_PlatformA.cpp</code></p>

<pre><code>#ifdef PLATFORM_A

#include &lt;Thread.hpp&gt;

Thread::Thread()
{
  // Platform A specific code goes here, initialize the pimpl;
}

Thread::~Thread()
{
  // Platform A specific code goes here, release the pimpl;
}

#endif
</code></pre>

<p>Building <code>Thread.o</code> becomes a simple matter of taking all <code>Thread_*.cpp</code> files in the Thread directory, and having your build system come up with the correct <code>-D</code> option to the compiler.</p>
"
"<p>I am curious, what would it be like to design this situation like the following (just sticking to the thread):</p>

<pre><code>// Your generic include level:
// thread.h
class Thread : public
#ifdef PLATFORM_A
    PlatformAThread
#elif PLATFORM_B
    PlatformBThread
// any more stuff you need in here
#endif
{
    Thread();
    virtual ~Thread();

    void start();
    void stop();

    virtual void callback() = 0;
}?;
</code></pre>

<p>which does not contain anything about implementation, just the interface</p>

<p>Then you have:</p>

<pre><code>// platformA directory
class PlatformAThread { ... };
</code></pre>

<p>and this will automatically result that when you create your ""generic"" <code>Thread</code> object you automatically get also a platform dependent class which automatically sets up its internals, and which might have platform specific operations, and certainly your <code>PlatformAThread</code> class might derive from a generic <code>Base</code> class having common things you might need.</p>

<p>You will also need to set up your build system to automatically recognize the platform specific directories.</p>

<p>Also, please note, that I have the tendency to create hierarchies of class inheritances, and some people advise against this: <a href=""https://en.wikipedia.org/wiki/Composition_over_inheritance"" rel=""nofollow"">https://en.wikipedia.org/wiki/Composition_over_inheritance</a></p>
"
"<p>I don't know what ""safe"" means, but the behavior of a program that uses this code is undefined. You can convert a pointer into an integer type that's large enough to hold the value, and you can convert that value back into a pointer <strong>with the same type as the original</strong>. The code in the question doesn't do that: it converts the value into a pointer <strong>with a different type from the original</strong>.</p>
"
"<p>In that particular case the code is safe. That's because the safety of <em>upcasting</em>. This is always allowed for public inheritance, <em>without an explicit type cast</em>.</p>

<p>In short you're just force something could be consider as implicit.</p>

<p>The passage of <code>B</code> type's address with a <code>uintptr_t</code> is useless also but allowed because ""<em>the same type</em>"".</p>

<h1>Edit</h1>

<p>About <a href=""http://www.cplusplus.com/reference/cstdint/"" rel=""nofollow""><code>uintptr_t</code></a>.</p>

<blockquote>
  <p>Integer type capable of holding a value converted from a void pointer and then be converted back to that type with a value that compares equal to the original pointer.</p>
</blockquote>

<p>Note ""<em>compares equal to the original pointer</em>"".</p>
"
"<p>What you are asking for is basically not possible with C++.  <code>target_func</code> is passed its argument by value, so there is no way for it (or the mocked version of it), to know how the value was calculated.  The call could be <code>obj.target_func(global_handle_1);</code> or it could be <code>obj.target_func(global_handle_2 - 1);</code> (if those expressions happen to have identical value).</p>

<p>I think your best option is to give each global variable a unique value, and then <code>EXPECT</code> the correct value.  I would a) space the unique values well apart; b) rely on code reviews to spot people doing arithmetic on handle values.</p>

<p>If <code>target_fun</code> took it's argument by reference, then you <em>might</em> be able to do an <code>EXPECT</code> based on the address of the reference - but I wouldn't bother.</p>
"
"<p>If after you pass for reference, you access to variable and find changed the value memorized in the variable, then somewhere in the code you assigned that value to that pointer</p>
"
"<blockquote>
  <p>Why does pointer variable change after passed through multiple
  functions</p>
</blockquote>

<p>It cant, if you dont modify the content (It might be a pointer pointing to same piece of memory) or where the does the pointer point it self.</p>

<hr>

<blockquote>
  <p>I'm passing a variable by reference</p>
</blockquote>

<p>Its not possible in C, from <a href=""http://www-cs-students.stanford.edu/~sjac/c-to-cpp-info/references"" rel=""nofollow noreferrer"">www-cs-students.stanford.edu</a>:</p>

<blockquote>
  <p>In C, Pass-by-reference is simulated by passing the address of a
  variable (a pointer) and dereferencing that address within the
  function to read or write the actual variable. This will be referred
  to as ""C style pass-by-reference.""</p>
</blockquote>

<hr>

<p>Look at the example below, we are passing pointer through various functions, but both pointer address and content are still same.</p>

<pre><code>void f3(char **p)
{
    printf(""f3: Address: %p, Value: %s\n"", *p, *p);
}

void f2(char **p)
{
    printf(""f2: Address: %p, Value: %s\n"", *p, *p);
    f3(p);
}

void f1(char **p)
{
    printf(""f1: Address: %p, Value: %s\n"", *p, *p);
    f2(p);
}

int main(void)
{
    char *p = malloc((int)strlen(""hello""));
    strcpy(p, ""hello"");

    printf(""Main 1: Address: %p, Value: %s\n"", p, p);

    f1(&amp;p);

    printf(""Main 2: Address: %p, Value: %s\n"", p, p);

    return 0;
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>Main 1: Address: 0x1a7c010, Value: hello
f1    : Address: 0x1a7c010, Value: hello
f2    : Address: 0x1a7c010, Value: hello
f3    : Address: 0x1a7c010, Value: hello
Main 2: Address: 0x1a7c010, Value: hello
</code></pre>

<hr>

<p>Take a look here (inside <code>zl_get_dsp</code> function)</p>

<pre><code>z_handle_t *z = NULL;
</code></pre>

<p>You have created local variable <code>z</code> which contains an array <code>pn</code>. Here you assign some string to <code>pn</code> which is inside <code>z</code>.</p>

<pre><code>z = z_open(hdl, ds)
</code></pre>

<p>Then if you print it inside same function, everything is ok and string shows up</p>

<pre><code>fprintf(stdout, ""zl_get_dsp: '%s'\n"", *p)
</code></pre>

<p>But after you return back to previous function, <code>z</code> is out of scope, which means the array <code>pn</code> is aswell out of scope and string inside <code>pn</code> doesnt exist anymore if you are trying to print him in another functions. If you want to return pointer to something it <strong>cant</strong> be local, becouse after return from function it out of scope, so you have to declare <code>z</code> as global or assign him some dynamical memory with <code>malloc</code>.</p>
"
"<p>The code </p>

<pre><code>void sendData(handle_t IDL_handle, int numIn, int *numOut){
    numOut = new int[3];
    numOut[0] = 1;
    numOut[1] = 2;
    numOut[2] = 3;
}
</code></pre>

<p>only changes the value copy of the pointer parameter and leaves you with a memory leak.</p>

<p>I'd suspect an implementation should rather look like</p>

<pre><code>void sendData(handle_t IDL_handle, int numIn, int *numOut){
    *numOut = 42;
}
</code></pre>

<p>To return an array with an <code>[out]</code> parameter the signature would rather look like</p>

<pre><code>void sendData(handle_t IDL_handle, int numIn, int **numOut);
</code></pre>

<p>Check your IDL definitions again.</p>
"
"<p>There's certainly nothing wrong with using <code>std::weak_ptr</code> to grant access to an object that might be destroyed, that's what it was invented for. But it does necessitate that the object itself be held by a <code>std::shared_ptr</code>. Not only does this mask your intent to have the object lifetime controlled by its parent, it forces dynamic allocation of the object and precludes it from being a member variable of the parent.</p>

<p>An alternate approach is to keep track of the pointer through a handle, and have a handle manager that tracks whether the object is alive or dead. The safest way to implement this is to make the manager a base class of the object you're tracking, that way RAII ensures it is always up to date. Here's a sample implementation of that concept. Note: untested.</p>

<pre><code>template&lt;class Derived&gt;
class HandleBased
{
public:
    typedef uint64_t handle_t;

    HandleBased() : m_Handle(NextHandle())
    {
        Map()[m_Handle] = this;
    }

    ~HandleBased()
    {
        auto it = Map().find(m_Handle);
        Map().erase(it);
    }

    handle_t ThisHandle()
    {
        return m_Handle;
    }

    static Derived* FindPtr(handle_t h)
    {
        auto it = Map().find(h);
        if (it == Map().end())
            return null_ptr;
        return static_cast&lt;Derived*&gt;(it-&gt;second);
    }

private:
    static handle_t NextHandle()
    {
        static handle_t next = 0;
        return next++;
    }

    static std::unordered_map&lt;handle_t, HandleBased*&gt;&amp; Map()
    {
        static std::unordered_map&lt;handle_t, HandleBased*&gt; the_map;
        return the_map;
    }

    handle_t m_Handle;
};
</code></pre>

<p>And here's an example of how you'd use it:</p>

<pre><code>class RenderNode : public HandleBased&lt;RenderNode&gt;
{
};

class RenderComponent
{
    std::unique_ptr&lt;RenderNode&gt; node1;
    RenderNode node2;

public:
    void Setup(RenderSystem&amp; rs)
    {
        node1 = new RenderNode;
        rs.nodes.push_back(node1-&gt;ThisHandle());
        rs.nodes.push_back(node2.ThisHandle());
    }
};

class RenderSystem
{
public:
    std::list&lt;RenderNode::Handle&gt; nodes;

    void DoRender()
    {
        for (auto it = nodes.begin(); it != nodes.end(); )
        {
            RenderNode* p = RenderNode::FindPtr(*it);
            if (p == NULL)
                it = nodes.erase(it);
            else
            {
                p-&gt;DoSomething();
                ++it;
            }
        }
    }
};
</code></pre>
"
"<p><code>iput</code> is the opposite of <code>iget</code> which searches for an inode,
allocates memory for it if necessary and returns a reference to the inode to the
caller.</p>

<p><code>iput</code> takes this inode ""back"", i.e. frees the memory if needed.</p>

<p>There is a reference counter system, such that one inode can be used
in parallel by more than one caller and can therefore
be only dropped (i.e. removed from memory) if there is no user of it
anymore (every user has called <code>iput</code>).</p>

<pre class=""lang-c prettyprint-override""><code>/**
* iget_locked - obtain an inode from a mounted file system
* @sb:         super block of file system
* @ino:        inode number to get
*
* Search for the inode specified by @ino in the inode cache and if present
* return it with an increased reference count. This is for file systems
* where the inode number is sufficient for unique identification of an inode.
*
* If the inode is not in cache, allocate a new inode and return it locked,
* hashed, and with the I_NEW flag set.  The file system gets to fill it in
* before unlocking it via unlock_new_inode().
*/
struct inode *iget_locked(struct super_block *sb, unsigned long ino)
</code></pre>
"
"<p><code>put</code> is common terminology in kernel code for decrementing an object's reference count. It's the complement of <code>get</code>, which increases the reference count. You can find it lots of places, not just with inodes. </p>

<p>Reference counts are used to keep shared objects from being destroyed as long as they're in use. Code using an object <code>get</code>s the object, uses it, then <code>put</code>s it to release it.</p>
"
"<p>Basically a process has a File Descriptor Table, which includes an file pointer point to the files the process open, the file pointer is actually a pointer point to an item of the Open File Table(which is maintained by kernel). And the Open File Table will have an inode pointer point to the item in I-node Table(also maintained by kernel). The I-node table contains all the information of file(file info and pointer to blocks store file data)</p>

<p>When you open a file, an inode item is added to the I-node table. In order to achieve and free inode faster, the system will maintain an inode cache. When the I-node Table needs a new item, it will use iget() to get an inode from the cache, and when a file is closed, it will return the related inode to the cache using iput().</p>

<p>So the iput() means PUT the inode to the inode cache, and DROPPING means reduce the reference of an inode in the I-node Table. Refer to <a href=""http://www.tldp.org/LDP/lki/lki-3.html"" rel=""nofollow"">this page</a> to get more details.</p>
"
"<p>Why not treat the key as present even if all the values are removed, and provide explicit API for removing the key?</p>
"
"<p>In .NET 3.5, there is <code>ILookup&lt;TKey,TValue&gt;</code> and <code>Lookup&lt;TKey,TValue&gt;</code> that act as a multi-map. The in-built implementation (<code>Lookup&lt;TKey,TValue&gt;</code>) is immutable, but I have written an <code>EditableLookup&lt;TKey,TValue&gt;</code> in <a href=""http://www.yoda.arachsys.com/csharp/miscutil/"" rel=""nofollow noreferrer"">miscutil</a>.</p>

<p>In that version; yes - I remove the key if the last item (with that key) is removed. This makes it easier to look at which keys exist (i.e. <code>.Keys</code> etc).</p>
"
"<p>It depends on your usage pattern. If you're going to be adding and removing a lot of items, then those empty collections will be using up memory. My guess would be that you won't save that much time by keeping the collections around. As always, if it's that important to your performance, you should measure instead of guessing which way is better.</p>

<p>If you really think that creating those collections is expensive, then instead of creating new ones all the time, put the unused ones into a list and reuse them when new keys get added to your hashmap. I think this might be the flyweight pattern. You should probably keep the unused collection list less than half the size of the main hashmap (again, measure to see how the ratio affects performance).</p>
"
"<p>I would remove the collections so that your MultiMap has consistent behavior. If I used your MultiMap I would be very surprised (and unhappy) to find that a missing key behaves differently depending on whether a key was previously in the MultiMap or not.</p>

<p>Does Clear() remove the the Collections?</p>

<p>You may also create an unintended memory leak if you do not remove the collections. A developer may add many items, then remove them. Memory usage (after GC) should return to the same amount as before those items were added.</p>

<p>I would not worry about the cost of creating Collections. I would worry about the contract you create for your MultiMap. If after profiling your application you find that to be a concerned, you could modify or create a special MultiMap for that behavior. Don't fall into the trap of premature optimization.</p>
"
"<p>You can use functors and pass it to your lookup method. That I mean is, define class which will overload <code>bool operator( vectorElement element)</code> and within this operator you will choose method how do you want to lookup the values.</p>

<pre><code>template &lt;typename T&gt;
class ILookUp
{
    bool operator( vector&lt;T&gt; elem)
    {
      if (elem == something)
          return true;
      false;
    }
};

class VectorStorage
{
     std::vector&lt;Elements&gt; lookup( ILookUp&lt;Elements&gt; lookup)
     {

         .....

         if ( lookup(elem))
         {
              //add element to vector or whatever.
         }

          .....

         return result;
     }

          .....

}
</code></pre>
"
"<p>It might be worth taking a look at std::find defined in algorithm and boost::lambda</p>
"
"<p>You can use a template and pointer to member.</p>

<pre><code>typedef vector&lt;myClass&gt; myVector;

template&lt;typename T&gt;
bool FindDataById(const T &amp;id, T myClass::* idMember, myClass &amp;theClass,
                                                       const myVector &amp;theVector)
{
   for(myVector::const_iterator itr = theVector.begin(); itr != myVector.end();
                                                                          ++itr){
       if((*itr).*idMember == id){
          theClass = *itr;
          return true;
   }

   return false;
}
</code></pre>

<p>Then call using, e.g.,</p>

<pre><code>FindDataById(string(""name""), &amp;myClass::foo, theClass, theVector)
FindDataById(5, &amp;myClass::x, theClass, theVector)
FindDataById(5.25f, &amp;myClass::z, theClass, theVector)
</code></pre>

<p>Or, go with the <code>find_if</code> idea:</p>

<pre><code>template&lt;typename T&gt;
struct Finder {
   T val_;
   T myClass::* idMember_;

   Finder(T val, T myClass::* idMember) : val_(val), idMember_(idMember) {}
   bool operator()(const myClass &amp;obj) { return obj.*idMember_ == val_; }
};
</code></pre>

<p>And use:</p>

<pre><code>find_if(theVector.begin(), theVector.end(), Finder&lt;string&gt;(""name"", &amp;myClass::foo))
find_if(theVector.begin(), theVector.end(), Finder&lt;int&gt;(5, &amp;myClass::x))
find_if(theVector.begin(), theVector.end(), Finder&lt;float&gt;(3.25f, &amp;myClass::z))
</code></pre>

<p>See the answer of MSalters for a way to deduce the template argument automatically.</p>
"
"<p><code>std::find_if</code> has already been suggested, but without a code sample, so here's a more detailed version:</p>

<p>Define two functors to identify the object you're interested in:</p>

<pre><code>struct z_equals {
  z_equals(float z) : z(z) {}

  bool operator()(const myClass&amp; obj)
    return z == obj.z;
  }

  float z;
};


struct foo_equals {
  foo_equals(const std::string&amp; foo) : foo(foo) {}

  bool operator()(const myClass&amp; obj)
    return foo == obj.foo;
  }

  const std::string&amp; foo;
};
</code></pre>

<p>And now, to search for elements where z == 42.0f, or foo == ""hello world"":</p>

<pre><code>std::find_if(myVector.begin(), myVector.end(), z_equals(42.0f));
std::find_if(myVector.begin(), myVector.end(), foo_equals(""hello world""));
</code></pre>
"
"<p>Without lambda's you'd need to write some predicates, or at least instantiate them:</p>

<pre>
template
struct member_select : public std::unary_function
{
  T t;
  T U::* m_u;
  member_select(T const& t, T U::* m_u) : t(t), m_u(m_u) {}
  bool operator()(U const& u) const { return u.*m_u == t; }
};

template
member_select make_member_select(T const& t, T U::* m_u)
{
  return member_select(t, m_u);
}
</pre>

<p>Use: <code>std::find_if(..., make_member_select(""x"", &amp;myClass::foo));</code></p>
"
"<p>The easiest optimization isto convert commonCodes from a <code>string[]</code> to a faster lookup structure such as a <code>Dictionary&lt;string,object&gt;</code> or a <code>HashSet&lt;string&gt;</code> if you are using .Net 3.5 or above.  This will reduce the big O complexity of this loop and depending on the size of commonCodes should make this loop execute faster.</p>
"
"<p>Jared has correctly pointed out that you can optimize this with a <code>HashSet</code>, but I would also like to point out that the entire method is unnecessary, wasting memory for the output list and making the code less clear.</p>

<p>You could write the entire method as:</p>

<pre><code>var commonCodesLookup = new HashSet&lt;int&gt;(commonCodes);
var filteredCars = cars.Where(c =&gt; commonCodesLookup.Contains(c.Code));
</code></pre>

<p>Execution of the <code>filteredCars</code> filtering operation will be deferred, so that if the consumer of it only wants the first 10 elements, i.e. by using <code>filteredCars.Take(10)</code>, then this doesn't need to build the entire list (or any list at all).</p>
"
"<p>you could use the linq join command, like </p>

<pre><code>var filteredListOfCars = cars.Join(commonCodes, c =&gt; c.Code, cC =&gt; cC, (car, code) =&gt; car).ToArray();
</code></pre>
"
"<p>Here's an alternative to the linq options (which are also good ideas): If you're trying to do filtering quickly, I would suggest taking advantage of built in types. You could create a <code>DataTable</code> that has two fields, the id of the car in your array, and the code (you can add the other 10 things if they matter as well). Then you can create a <code>DataView</code> around it and use the filter property of that. It uses some really fast indexing internally (B-trees I believe) so you probably won't be able to beat its performance manually unless you're an algorithms whiz, which if you were, you wouldn't be asking here. It depends what you're doing and how much performance matters.</p>
"
"<p>To do what you want, I would use the Linq ToLookup method to create an ILookup instead of using a dictionary.  ToLookup was made especially for this type of scenario.  It is basically an indexed look up on groups.  You want to group your cars by <code>Code</code>.</p>

<pre><code>var carCodeLookup = cars.ToLookup(car =&gt; car.Code);
</code></pre>

<p>The creation of the carCodeLookup would be slow but then you can use it for fast lookup of cars based on <code>Code</code>. To get your list of cars that are in your list of common codes you can do a fast lookup.</p>

<pre><code>var filteredCarsQuery = commonCodes.SelectMany(code =&gt; carCodeLookup[code]);
</code></pre>

<p>This assumes that your list of cars does not change very often and it is your commonCodes that are dynamic between queries.</p>
"
"<p>It looks like what you're really checking is whether the ""code"" is common, not the car.  You could consider a fly weight pattern, where cars share common instances of Code objects. The code object can then have an IsCommon property and a Value property.
You can then do something to the effect of updating the used Code objects whenever the commoncodes list changes.
Now when you do your filtering you only need to check each car code's IsCommon property</p>
"
"<p>Long is a struct, it has a different construction and memory footprint than an object, which is apparently slower and I believe larger.</p>
"
"<p>Running your full example as you provided </p>

<pre><code>Fast time: 00:00:01.6187793
Slow time: 00:00:01.3977344
</code></pre>

<p>Only if I run in debug mode is the slow time actually slower. That is because in debug mode methods are never inlined, and there are NOPs littered everywhere to allow you to break, e.g. inside the Id getter.</p>

<hr>

<p>Since you obviously care about run speed, I'll point out an unrelated inefficiency: you're running the query twice: once for count and once for iterating over the children. Running it only once (and increasing count by 1 in the loop) should speed things up.</p>

<hr>

<p>The way I'd usually solve this problem, by the way, is if it ever makes sense to call the <code>GetChildren</code> method directly with an id, provide two overloads. Otherwise, provide the one (<code>Structure</code>) overload and get the id before the query, as in <code>long id = aStructure.id;</code>.</p>
"
"<p>Well, even though the property access is inlined, it's still got to do a nullity check on each iteration, I suspect. That's an extra condition, which may be screwing up branch prediction for example.</p>

<p>It would be interesting to play with a complete example, but I <em>suspect</em> it's just the fact that you're performing an extra operation on every single delegate call. It's also possible that that ""extra little bit"" has turned off some other bit of inlining to do with the delegate, causing a sort of domino performance effect.</p>
"
"<p>In ""Functionality continues"", do you use childrenQuery again?  Do you realize this re-enumerates theStructures each time?  Don't enumerate the large dataset so many times and the access cost of a property on each item won't hurt so bad.</p>

<pre><code>IList&lt;Structure&gt; theStructures = new List&lt;Structure&gt;();
ILookup&lt;int, Structure&gt; byParentId = null;

public int GetChildren(Structure aStructure){
   if (byParentId = null)
   {
     byParentId = theStructures.ToLookup(x =&gt; x.ParentStructureId);
   }
   List&lt;Structure&gt; children = byParentId[aStructure.Id].ToList();
   int count = children.Count;
   //Functionality continues...
}
</code></pre>
"
"<p>The property value cannot easily be statically determined to be safely cacheable because side effects are allowed in C#.  For example, imagine if this was your code:</p>

<pre><code>public IEnumerable&lt;Structure&gt; FetchChildren()
{
    for (int i = 0; i &lt; 10; i++)
    {
        aStructure.Id++;
        yield return GetChild(a.Structure.Id);
    }
}

public int GetChildrenSlow(Structure aStructure){
   IEnumerable&lt;Structure&gt; childrenQuery =
                         from structure in FetchChildren()
                         where structure.ParentStructureId == aStructure.Id
                         select structure;
   int count = childrenQuery.Count();
   //Functionality continues...
}
</code></pre>

<p>As you can see, <code>aStructure.Id</code> changes while you enumerate.  True, in your case, none of your enumeration code has side effects, but C# isn't smart enough to know that.  Also, it's not only enumeration that could have the side effects.  For example:</p>

<pre><code>IList&lt;Structure&gt; theStructures = new List&lt;Structure&gt;();
public int GetChildrenSlow(Structure aStructure){
   IEnumerable&lt;Structure&gt; childrenQuery =
        theStructures.Where(s =&gt; s.ParentStructureId == aStructure.Id++);
   int count = childrenQuery.Count();
   //Functionality continues...
}
</code></pre>

<p>And there's always multi-threading that can mess things up as well.  Because of the possibility of mutation, the hit you'd take for checking the property value is just a necessity.</p>
"
"<p>Create a Dictionary that stores a List of items per lookup code - <code>Dictionary&lt;string, List&lt;Code&gt;&gt;</code> (assuming that lookup code is a string and the objects are of type Code).</p>

<p>Then when you need to query based on <code>lookupDate</code>, you can run your query directly off of <code>dict[lookupCode]</code>:</p>

<pre><code>var z_fk = (from z in dict[lookupCode]
            where z.VALIDFROM &lt;= lookupDate &amp;&amp;
                  z.VALIDUNTIL &gt;= lookupDate
            select z.id).SingleOrDefault();
</code></pre>

<p>Then just make sure that whenever you have a new Code object, that it gets added to the <code>List&lt;Code&gt;</code> collection in the <code>dict</code> corresponding to the <code>lookupCode</code> (and if one doesn't exist, then create it).</p>
"
"<p>This to me sounds like a situation where this could all happen on the database via a single statement.  Then you can use indexing to keep the query fast and avoid having to push data over the wire to and from your database.</p>
"
"<p>A simple improvement would be to use...</p>

<pre><code>//in initialization somewhere
ILookup&lt;string, T&gt; l_z_lookup = l_z.ToLookup(z=&gt;z.CODE);

//your repeated code:
var z_fk = (from z in lookup[lookupCode]
            where z.VALIDFROM &lt;= lookupDate &amp;&amp; z.VALIDUNTIL &gt;= lookupDate
            select z.id).SingleOrDefault();
</code></pre>

<p>You could further use a more complex, smarter data structure storing dates in sorted fashion and use a binary search to find the id, but this may be sufficient.  Further, you speak of <code>SqlBulkCopy</code> - if you're dealing with a database, perhaps you can execute the query on the database, and then simply create the appropriate index including columns CODE, VALIDUNTIL and VALIDFROM.</p>

<p>I generally prefer using a <code>Lookup</code> over a <code>Dictionary</code> containing <code>Lists</code> since it's trivial to construct and has a cleaner API (e.g. when a key is not present).</p>
"
"<p>We don't have enough information to give very prescriptive advice - but there are some general things you should be thinking about.</p>

<p>What types are the time values?  Are you comparing date times or some primitive value (like a time_t).  Think about how your data types affects performance.  Choose the best ones.</p>

<p>Should you really be doing this in memory or should you be putting all these rows in to SQL and letting it be queried on there?  It's really good at that.</p>

<p>But let's stick with what you asked about - in memory searching.</p>

<p>When searching is taking too long there is only one solution - search fewer things.  You do this by partitioning your data in a way that allows you to easily rule out as many nodes as possible with as few operations as possible.</p>

<p>In your case you have two criteria - a code and a date range.  Here are some ideas...</p>

<p>You could partition based on code - i.e.  Dictionary> - if you have many evenly distributed codes your list sizes will each be about N/M in size (where N = total event count and M = number of events).  So a million nodes with ten codes now requires searching 100k items rather than a million.  But you could take that a bit further.  The List could itself be sorted by starting time allowing a binary search to rule out many other nodes very quickly.  (this of course has a trade-off in time building the collection of data).  This should provide very quick</p>

<p>You could partition based on date and just store all the data in a single list sorted by start date and use a binary search to find the start date then march forward to find the code.  Is there a benefit to this approach over the dictionary?  That depends on the rest of your program.  Maybe being an IList is important.  I don't know.  You need to figure that out.</p>

<p>You could flip the dictionary model partition the data by start time rounded to some boundary (depending on the length, granularity and frequency of your events).  This is basically bucketing the data in to groups that have similar start times.  E.g., all the events that were started between 12:00 and 12:01 might be in one bucket, etc.  If you have a very small number of events and a lot of highly frequent (but not pathologically so) events this might give you very good lookup performance.</p>

<p>The point?  Think about your data.  Consider how expensive it should be to add new data and how expensive it should be to query the data.  Think about how your data types affect those characteristics.  Make an informed decision based on that data.  When in doubt let SQL do it for you.</p>
"
"<p>You'll need to use <code>Dictionary&lt;TKey,TValue&gt;</code>, where the <code>TKey</code> is built on the search type.  However, if you're using something like <code>FirstName</code> as a search term, you may have multiple values with the same key, which will cause problems.</p>

<p>A potentially better option would be to use <a href=""http://msdn.microsoft.com/en-us/library/bb549073.aspx"" rel=""nofollow"">ToLookup</a> to generate an <code>ILookup</code> for you.  For example:</p>

<pre><code>IEnumerable&lt;Person&gt; people = GetPeople();

var nameLookup = people.ToLookup(p =&gt; p.FirstName);
</code></pre>

<p>You could then do:</p>

<pre><code>var peopleNamedFred = nameLookup[""Fred""];
foreach(var fred in peopleNamedFred)
    Console.WriteLine(""{0} {1}, fred.FirstName, fred.LastName);
</code></pre>
"
"<p>Create an implementation of <code>System.Collections.ObjectModel.KeyedCollection</code>.<br>
According to the <a href=""http://msdn.microsoft.com/en-us/library/ms132438.aspx"" rel=""nofollow"">MSDN reference</a> it "" provides both O(1) indexed retrieval and keyed retrieval that approaches O(1).""  However, it still has the limitations that <code>Dictionary' and</code>HashTable` have with duplicate keys not being allowed.  If you need duplicate key values, or you need to be able to use different items as keys at different times, then Reed Copsey gives a very good solution.</p>
"
"<p>It depends. If you're working with objects that are DataContext based, then the join gets translated all the way down into the SQL server via the select statement.  IF its a POCO (or more specifically a Plain Old CLR collection) or something else, then yes, its utilized as ILookup.</p>
"
"<p><code>dumpe2fs</code>, a part of the <code>e2fsprogs</code> package, can dump information on inodes in ext* filesystems.</p>
"
"<ol>
<li><strong>Simplest/naive way</strong>: Iterate over all possible values (perhaps all possible 32-bit values) and probe for each of them using either <code>ilookup5()</code> or <code>ilookup()</code> (depending on your usecase).</li>
<li><strong>For kernel verion 2.4</strong>: Iterate over the list of in use and not in use lists of inodes. These lists will have only those inodes that are valid. The problem with this approach is there does not seem to be any interface provided by VFS layer to access these lists, so you will have to access them directly, which is not a good idea.</li>
</ol>
"
"<p>Not really an answer, just a really large comment:</p>

<p>I would remove multi-threading from your plans unless the UBMatrix API states it is thread-safe, thinking of all the disc I/O when generating the XBRL.</p>

<p>Have your profiled your app for memory usage? I am thinking of the 15-30K rows of data being loaded, then possible transferred into an an object model prior to processing and writing to file. If you start to reach the 2GB limit (32 bit), then your process will be doing a lot of paging, which is sooo slooow.</p>

<p>Would this alternative be a possibility?
Pre-generate the data to file, possibly in xml format. Then, hoping the UBMatrix has an api which accepts a file path and streams data, you could just pass off the path to your file data. (This is more in case it is a memory issue, but could still speed things up if the data queries are long running.)</p>
"
"<p>30k queries in 30 minutes is just 16 queries per second. That is not very much unless the queries are expensive.</p>

<p>To find out, run SQL Profiler and check the execution time of each query. Multiply with the number of queries. If that is reasonably close to 30 minutes you are lucky if you can rewrite all those queries to a join and put the result in a <code>Dictionary</code> or <code>ILookup</code>.</p>

<p>If you need to resort to multi threading. Check if you have the possibility to upgrade to .NET 4. Then you can use <a href=""http://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.foreach.aspx"" rel=""nofollow""><code>Parallel.ForEach</code></a> or some other suitable method in TPL to parallelize your work.</p>
"
"<p>Without seeing the code I cannot tell what classes you are using for data access but from your mention of DataTable.Rows I am assuming you are using DataSet/DataTable.  If you switch to using an <a href=""http://msdn.microsoft.com/en-us/library/system.data.idatareader.aspx"" rel=""nofollow"">IDataReader</a> with <a href=""http://msdn.microsoft.com/en-us/library/system.data.commandbehavior.aspx"" rel=""nofollow"">CommandBehavior.SequentialAccess</a> you can avoid a lot of the unnecessary overhead that comes with DataSet/DataTable.</p>
"
"<p>I suggest profiler but for .NET app. Check where does it spend most of the time and attack that place. If it is calls to get data from DB you may look at database and possibly add some new indexes and/or redesign queries. If it is in calls to UBMatrix there is probably not much you can do except get an explanation to whoever gave you this task. But before you give up you can try parallel processing, first making sure that UBMatrix is thread safe, as Simon pointed. If it's not or you cannot tell you can run parallel processing as separate AppDomains to imitate thread safety. This will come at a cost of resources and more complex code though. Parallel processing will only make sense if during normal app run you can observe CPU usage below about 70% and disk is not used excessively (check with Resource Monitor) so there are spare resources to be used.</p>

<p>If disk is used a lot, one other way could be to check if making xml files to be written to a RAM-drive would improve anything.</p>

<p>Anyway, start with profiling your .NET application - that should give you a good starting point. Here is a free .NET profiler: <a href=""http://www.eqatec.com/tools/profiler/"" rel=""nofollow"">http://www.eqatec.com/tools/profiler/</a></p>
"
"<p>Consider your second function, the one that </p>

<pre><code> takes a IDictionary&lt;TKey, IEnumerable&lt;TValue&gt; &gt;
</code></pre>

<p>Now, if you give me a <code>IDictionary&lt;TKey, IEnumerable&lt;TValue&gt;&gt;</code>, one of the things I should be able to do is set the value of one of the keys to a <code>new TValue[]</code>, right? After all, a <code>TValue[]</code> is an <code>IEnumerable&lt;TValue&gt;</code>, so it meets the constraint.</p>

<p>However, if somehow what you'd given me was (underneath the interface) a <code>IDictionary&lt;TKey, List&lt;TValue&gt;&gt;</code>, I definitely <em>shouldn't</em> be allowed to set the value of a key to a <code>TValue[]</code>, since a <code>TValue[]</code> is not a <code>List&lt;TValue&gt;</code>!</p>

<p>This is exactly the problem in the question you have linked, of course.</p>

<p>Now, if you are happy to only ever <strong>read</strong> the parameter I pass you, you have a potential solution in moving from dictionaries to <a href=""http://msdn.microsoft.com/en-us/library/bb534291.aspx"" rel=""nofollow""><code>ILookup&lt;TKey, TValue&gt;</code></a>, which is a bit like a <em>read-only</em> dictionary from a key to a <em>list</em> of values. If your methods respectively return and accept an <code>ILookup&lt;TKey, TValue&gt;</code> there's of course no problem.</p>
"
"<p>Write your own loop instead of the linq and see how it performs:</p>

<p>Note: this code assumes you will always have 2 IP addresses in the ips collection, as stated in the comments on the question.</p>

<pre><code>foreach(var device in Devices)
{
      if(device.IPaddress1 == ips[0] || device.IPaddress2 == ips[0] || device.IPaddress3 == ips[0] || device.IPaddress1 == ips[1] || device.IPaddress2 == ips[1] || device.IPaddress3 == ips[1] )
      return device;
}
</code></pre>

<p>This unrolls one of the loops and takes advantage of being able to return as soon as a match is found.</p>

<p>Further optimization can be performed by letting the database do the work instead.</p>
"
"<pre><code>var device =
    Devices.FirstOrDefault(
        x =&gt; ips.Contains(x.IPaddress1)
             || ips.Contains(x.IPaddress2)
             || ips.Contains(x.IPaddress3));
</code></pre>

<p>Is going to enumerate <code>ips</code> <em>three</em> times in the worst possible case (no matches). I would re-write it as:</p>

<pre><code>var device =
    Devices.FirstOrDefault(
        x =&gt; ips.Any(y =&gt; y == x.IPaddress1
             || y == x.IPaddress2
             || y == x.IPaddress3);
</code></pre>

<p>So it only enumerates it once, checking each possible ""match condition"" as it goes and returning as soon as it finds one.</p>

<p>As some of the commenters have said, finding a way to do a simple number comparison will also be faster than a string comparison if it is possible.</p>
"
"<p>Instead of having one dictionary with all 3 IP Addresses you could have 3 dictionaries:</p>

<pre><code>private List&lt;Device&gt; Devices = new List&lt;Device&gt;();

private Dictionary&lt;string, Device&gt; mapIP1;
private Dictionary&lt;string, Device&gt; mapIP2;
private Dictionary&lt;string, Device&gt; mapIP3;
</code></pre>

<p>You'd have to initialize them before doing the search:</p>

<pre><code>public void InitializeDictionaries()
{
    mapIP1 = Devices.ToDictionary(x =&gt; x.IPaddress1);
    mapIP2 = Devices.ToDictionary(x =&gt; x.IPaddress2);
    mapIP3 = Devices.ToDictionary(x =&gt; x.IPaddress3);
}
</code></pre>

<p>The search itself can use <code>TryGetValue</code>:</p>

<pre><code>public Device TryFindDeviceInNetworks(ALL_Sims sim)
{
    Device device = null;

    if (sim.IP1 != null)
    {
        if (mapIP1.TryGetValue(sim.IP1, out device))
            return device;
        if (mapIP2.TryGetValue(sim.IP1, out device))
            return device;
        if (mapIP3.TryGetValue(sim.IP1, out device))
            return device;
    }

    if (sim.IP2 != null)
    {
        if (mapIP1.TryGetValue(sim.IP2, out device))
            return device;
        if (mapIP2.TryGetValue(sim.IP2, out device))
            return device;
        if (mapIP3.TryGetValue(sim.IP2, out device))
            return device;
    }

    return device;
}
</code></pre>

<p>You'd have to be sure that there is no elements in <code>Devices</code> list that share the same address though, as <code>Dictionary&lt;TKey, TValue&gt;</code> can't work with duplicate keys.</p>
"
"<p>Create lookups for each of your three keys.  It won't make much of a difference if you were only doing the search once, but if you're doing it a hundred thousand times, being able to lookup the values based on the IP in constant time will be a <em>huge</em> win:</p>

<pre><code>public class Foo
{
    private List&lt;FSKDevice&gt; Devices = _db.Devices.ToList();
    private IList&lt;ILookup&lt;string, FSKDevice&gt;&gt; lookups;

    public Foo()
    {
        lookups = new[]{
            Devices.ToLookup(device =&gt; device.IPaddress1),
            Devices.ToLookup(device =&gt; device.IPaddress2),
            Devices.ToLookup(device =&gt; device.IPaddress3),
        };
    }

    public FSKDevice TryFindDeviceInNetworks(ALL_Sims sim)
    {
        var ips =  new[] { sim.IP1, sim.IP2 }
            .Where(ip =&gt; ip != null);

        return (from ip in ips
                from lookup in lookups
                let matches = lookup[ip]
                where matches.Any()
                select matches.First())
                    .FirstOrDefault();
    }
}
</code></pre>
"
"<p>You might want to read your ini file <em>duplicate keys</em> into <a href=""https://msdn.microsoft.com/en-us/library/bb460184.aspx"" rel=""nofollow"">lookup</a> instance.</p>

<p>Something like below might help: </p>

<pre><code>System.IO.StreamReader YourIniFile = new System.IO.StreamReader(""yourIniFilePath"");
string fileText = YourIniFile.ReadToEnd();
string[] splitText = fileText.Split(new string[] {""\n"", ""\r\n""}, StringSplitOptions.RemoveEmptyEntries);
ILookup&lt;string, string&gt; ini = splitText.ToLookup(key=&gt; key.Substring(0, key.IndexOf(""="")),
                               value =&gt; value.Substring(value.IndexOf(""="")));
</code></pre>
"
"<p>You can build a loadable kernel module if you don't want to build the whole kernel - e.g. see <a href=""http://www.linux-tutorial.info/modules.php?name=Howto&amp;pagename=Module-HOWTO"" rel=""nofollow"">http://www.linux-tutorial.info/modules.php?name=Howto&amp;pagename=Module-HOWTO</a>. </p>
"
"<p>All the code you write, compile and run as user programs run as ... well, user programs, in user mode. The kernel runs in kernel mode. Both modes are separated and cannot see each other directly. They communicate through defined interfaces. These interfaces are the C system calls (as opposed to the C library calls).</p>

<p>To be able to access the task_struct structures, your code has to be running in kernel mode. The best choice for this is to write a kernel module, and to load it in the kernel.</p>
"
"<p>You do not need to compile the whole kernel, but you have to at least create a kernel module, which is far easier to compile. You should have a look at a tutorial, such as <a href=""http://tldp.org/LDP/lkmpg/2.6/html/index.html"" rel=""nofollow"">this</a>, or even a full blown book like <a href=""http://lwn.net/Kernel/LDD3/"" rel=""nofollow"">this</a>.</p>

<p>Keep in mind that not all kernel code can be moved to a module - just those that use the public (exported) interfaces of the kernel. Code that is intrinsic to the kernel core parts (e.g. the VM or the scheduler) is probably inaccessible from the rest of the kernel.</p>

<p>Also keep in mind that trying out kernel code on your development machine is not advised - a
slight mistake can easily bring the whole system down. You should look at trying out your kernel code in a separate virtual machine e.g. in <a href=""http://www.virtualbox.org/"" rel=""nofollow"">VirtualBox</a>.</p>

<p>A detail that makes thing harder: in general you can only insert a module in the kernel that it was built for. A module compiled on the host system can be used on the testing VM <em>if and only if</em> the kernel is identical, i.e. the same kernel package version from the same distribution. Considering that you will want to upgrade your host distribution, in my opinion it is just simpler to build the module on the testing system.</p>

<p>Since you need a <a href=""http://www.kernel.org/doc/Documentation/Changes"" rel=""nofollow"">full development suite for C</a>, you should probably install one of the popular Linux distrbutions. It should be more stable and you can have access to its user community. If you want to keep its size down, you can just install the base system without an X server or graphical applications.</p>

<p>BTW Netbeans is designed to develop userspace applications. You can probably adapt it for kernel code, but it will never be as suited as it is for userspace programming. As a matter of fact, no IDE is really suitable. Kernel code cannot be run from userspace (let alone using a separate VM), which breaks down the normal edit->compile->run->debug workflow cycle that IDEs automate.</p>

<p>Most kernel developers just use a souped-up editor with syntax highlighting for C, such as <a href=""http://www.vim.org/"" rel=""nofollow"">Vim</a> or <a href=""http://www.gnu.org/software/emacs/"" rel=""nofollow"">Emacs</a>. Emacs is actually an IDE (and so much more) but, as I mentioned above, you cannot easily use an IDE-based workflow for kernel code development.</p>
"
"<p>Very little kernel code can run outside the kernel in any form. Most kernel code is <em>very</em> 'intertwingled' (to use a phrase I learned from a coworker years ago to describe excessive coupling) with other portions of kernel code. Functions 'know' structure definitions for many many structures away from what they are working on. Typical software engineering people <em>hate</em> code like this:</p>

<pre><code>    if (unlikely(inode_init_always(sb, inode))) {
            if (inode-&gt;i_sb-&gt;s_op-&gt;destroy_inode)
                    inode-&gt;i_sb-&gt;s_op-&gt;destroy_inode(inode);
            else
                    kmem_cache_free(inode_cachep, inode);
            return NULL;
    }
</code></pre>

<p>This routine has to <em>know</em> how to destroy inodes through three structures <em>and</em> the calling convention of a function pointer on the other end of the chain. The kernel community knows all these functions very well, and are quite happy to modify member names in structures all throughout the kernel when changes are made, but this sort of tight coupling makes running portions of the kernel in userspace on their own extremely difficult. (And believe me, sometimes I wish I could write tests on <em>my</em> small portions of kernel code that would run in userspace.)</p>

<p>If you want to play around, it's not too hard to get a virtual system up and running these days with qemu+kvm or virtualbox or uml to try making modifications to the kernel. It is pretty hard to just ""play"" with structures on a live running system, but it is much more feasible than trying to compile portions of the kernel in userspace.</p>

<p>Good luck. :)</p>
"
"<p>You might enjoy using systemtap as a wrapper for small bits of kernel module code:</p>

<pre><code># stap -g -e 'probe begin { your_function() exit() }
%{
#include &lt;linux/whatever.h&gt;
%}
function your_function() %{
   ... insert safe c code here ...
%}'
</code></pre>

<p>It can automatically cross-compile too (if you use <code>stap --remote=VIRTMACHINE ...</code>).</p>
"
"<p>It checkes permissions on open(); with immutable flag, e.g., one can't open the file for writing, even if reading is also requested. For example:</p>

<pre><code>$ python
&gt;&gt;&gt; f = file('/tmp/11', 'r+')
Traceback (most recent call last):
  File ""&lt;stdin&gt;"", line 1, in &lt;module&gt;
IOError: [Errno 13] Permission denied: '/tmp/11'
&gt;&gt;&gt; f = file('/tmp/11', 'r')
&gt;&gt;&gt; print f
&lt;open file '/tmp/11', mode 'r' at 0x7f87b9ba1660&gt;
</code></pre>

<p>For checking the file attribute against open operation, see inode_permission() in fs/namei.c.</p>
"
"<p>When you <em>access</em> (read, write..etc) a file, the very first thing is the OS does is to check if the the permission of the associated with the user/process is allowed has necessary permissions which is accomplished using <code>fstat64</code> which returns a stat strcture containing information about inode, UID, GID etc. If the permissions are sufficient then the inode data structure is accessed to do whatever the action that was requested. Call to fstat64 is <em>free</em> i.e. there's no special privileges required for a process (which calls fstat64) to access the metadata about a file.</p>
"
"<p>It is the ModemManager that sends those commands. After stopping ModemManager there are no more commands to the adapter.</p>
"
"<p>I believe you are looking for <a href=""http://osxbook.com/book/bonus/chapter8/core/"" rel=""noreferrer"">this information</a></p>

<p>Specifically:</p>

<pre><code>/* UNIX Third Edition, circa early 1973 */
/* ken/sig.c */

core()
{
int s, *ip;
extern schar;

/* u is the user area */
u.u_error = 0;          /* reset error code to ""no error"" */
u.u_dirp = ""core"";      /* file name to search for */
ip = namei(&amp;schar, 1);  /* do search; schar means it's a kernel string */

if (ip == NULL) {       /* failed to find */
    if (u.u_error)      /* because of some error */
        return(0);      /* so bail out */
    ip = maknode(0666); /* didn't exist; so create it */
}

if (!access(ip, IWRITE)) { /* check ""write"" permission; 0 means OK */
    itrunc(ip);            /* truncate the core file */

    /* first we write the user area */
    u.u_offset[0] = 0;     /* offset for I/O */
    u.u_offset[1] = 0;     /* offset for I/O */
    u.u_base = &amp;u;         /* base address for I/O (user area itself) */
    u.u_count = USIZE*64;  /* bytes remaining for I/O; USIZE=8 */
    u.u_segflg = 1;        /* specify kernel address space */
    writei(ip);            /* do the write */

    /*
     * u_procp points to the process structure
     * p_size is the size of the process's swappable image (x 64 bytes) */
     */
    s = u.u_procp-&gt;p_size - USIZE; /* compute size left to write */

    /*
     * This sets up software prototype segmentation registers to implement
     * text(=0 here), data(=s here), and stack(=0 here) sizes specified.
     */
    estabur(0, s, 0);

    u.u_base = 0;          /* base address for I/O (start of space) */
    u.u_count = s*64;      /* s is in units of 64 bytes, so adjust */
    u.u_segflg = 0;        /* specify user address space */
    writei(ip);            /* do the write */
}
iput(ip);                  /* decrement inode reference count */
return(u.u_error==0);      /* done */
}
</code></pre>
"
"<p>yes, something like what u said - the address_space pointer is called i_mapping for a inode.</p>

<p>So for example, inside fs/drop_cache.c is a function that enumerate all the pagecache for a superblock:</p>

<pre><code>static void drop_pagecache_sb(struct super_block *sb, void *unused)
{
        struct inode *inode, *toput_inode = NULL;

        spin_lock(&amp;inode_sb_list_lock);
        list_for_each_entry(inode, &amp;sb-&gt;s_inodes, i_sb_list) {
                spin_lock(&amp;inode-&gt;i_lock);
                if ((inode-&gt;i_state &amp; (I_FREEING|I_WILL_FREE|I_NEW)) ||
                    (inode-&gt;i_mapping-&gt;nrpages == 0)) {
                        spin_unlock(&amp;inode-&gt;i_lock);
                        continue;
                }
                __iget(inode);
                spin_unlock(&amp;inode-&gt;i_lock);
                spin_unlock(&amp;inode_sb_list_lock);
                invalidate_mapping_pages(inode-&gt;i_mapping, 0, -1);
                iput(toput_inode);
                toput_inode = inode;
                spin_lock(&amp;inode_sb_list_lock);
        }
        spin_unlock(&amp;inode_sb_list_lock);
        iput(toput_inode);
}
</code></pre>

<p>So instead of calling ""invalidate_mapping_pages()"" will use the i_mapping pointer to enumerate all the pagecache component.</p>

<p>As for enumerate the blocks, and thus identifying the page's PFN, u can follow this here:</p>

<p><a href=""http://www.makelinux.net/books/ulk3/understandlk-CHP-15-SECT-2#understandlk-CHP-15-SECT-2.6"" rel=""nofollow"">http://www.makelinux.net/books/ulk3/understandlk-CHP-15-SECT-2#understandlk-CHP-15-SECT-2.6</a></p>

<p>(15.2.6. Searching Blocks in the Page Cache).</p>
"
"<p>I think it's clear that after running <code>get_real_path(pathname, name, realpathname, 0, 0)</code> the <code>realpathname</code> cannot possibly start with a slash. </p>

<p>Provided the function executes successfully, the <code>memmove(realpath + position, name, strlen(name))</code> ensures that <code>realpath</code> starts with <code>name</code>, as the <code>position</code> variable always contains zero at the first invocation of <code>memmove</code>.
I'd suggest something like </p>

<pre><code>if(*path == '/') {
   ip = iget(ROOTDEV, ROOTINO); // ip gets the root
   realpath[position++] = '/';
} else
   ip = idup(proc-&gt;cwd); // ip gets the current working directory
</code></pre>

<p>P.S. I'm not sure why you put a slash into the <code>realpathname</code> before executing the <code>get_real_path</code>, since at this point you don't really know whether the path provided is an absolute one.</p>
"
"<p>Ok, found the problem...
The problem was deeper than what i thought...
Somehow the realpath was changed sometimes with no visible reason... but the reason was the line:
name = newpath;</p>

<p>the solution was to change that line to
strcpy(name,newpath);</p>

<p>the previous line made a binding between the name and the realpath... which can be ok if we were not dealing with softlinks. When dereferencing a subpath, this binding ruined everything.</p>

<p>Thanks for the attempts </p>
"
"<p>Just use fgetc. I assume you're using this to break out of the loop, so to update your example:</p>

<pre><code>#include &lt;stdio.h&gt;

char iput;

while(true){
    printf(""looping"");
    iput = fgetc(stdin);
    if(iput == 'n')
      break;
}
</code></pre>
"
"<p>You can also use </p>

<pre><code>fflush(stdin)
</code></pre>

<p>before calling getch</p>

<p>regards</p>
"
"<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
#include&lt;stdlib.h&gt;
void main()
{
   while(1)
 {
   printf(""\nlooping"");
   char t=getch();
   if(t=='n')
   exit(0);
 }
}
</code></pre>
"
"<p>This should be fairly quick considering what you are trying to do:</p>

<pre><code>awk -F: '{ for (i=1; i&lt;=NF; i++) print $i &gt; i"".out"" }' file.txt
</code></pre>
"
"<p>In perl you can do:
</p>

<pre><code>#!/usr/bin/perl -w
my $n = 3;
my @FILES;
for my $i (1..$n) {
  my $f;
  open ($f, ""&gt; $i.out"") or die;
  push @FILES, $f;
}
while (&lt;&gt;) {
  chomp;
  @a = split(/:/);
  for my $i (0..$#a) {
    print $FILES[$i] $a[$i],""\n"";
  }
}
close($f) for $f in @FILES;
</code></pre>
"
"<p>Python version</p>

<pre><code>#!/bin/env python

with open('file.txt', 'r') as ih:
    while True:
        line = ih.readline()
        if line == '': break
        for i,element in enumerate(line.strip().split(':')):
            outfile = ""%d.out"" % (i+1)
            with open(outfile, 'a') as oh:
                oh.write(""%s\n"" % element)
</code></pre>

<p>This might be a bit faster, as it only goes through the original file once.  Note that it could be further optimized by leaving the output files open (as it is, I close each of them and re-open them for each write).</p>

<p><strong>EDIT</strong></p>

<p>For example, something like:</p>

<pre><code>#!/bin/env python

handles = dict()

with open('file.txt', 'r') as ih:
    while True:
        line = ih.readline()
        if line == '': break
        for i,element in enumerate(line.strip().split(':')):
            outfile = ""%d.out"" % (i+1)

            if outfile not in handles:
                handles[outfile] = open(outfile, 'a');

            handles[outfile].write(""%s\n"" % element)

for k in handles:
    handles[k].close()
</code></pre>

<p>This leaves the handles open for the duration of the execution, then closes them all before continuing / ending.</p>
"
"<p>With coreutils if you know that there are three columns:</p>

<pre><code>&lt; file.txt tee &gt;(cut -d: -f1 &gt; 1.out) &gt;(cut -d: -f2 &gt; 2.out) &gt;(cut -d: -f3 &gt; 3.out) &gt; /dev/null
</code></pre>

<p>To make it more generic, here's one way to automate the command-line generation:</p>

<pre><code># Determine number of fields and generate tee argument
arg=""""
i=1
while read; do
  arg=""$arg &gt;(cut -d: -f$i &gt; $((i++)).out)""
done &lt; &lt;(head -n1 file.txt | tr ':' '\n')
</code></pre>

<p><code>arg</code> is now:</p>

<pre><code>&gt;(cut -d: -f1 &gt; 1.out) &gt;(cut -d: -f2 &gt; 2.out) &gt;(cut -d: -f3 &gt; 3.out)
</code></pre>

<p>Save to a script file:</p>

<pre><code>echo ""&lt; file.txt tee $arg &gt; /dev/null"" &gt; script
</code></pre>

<p>And execute:</p>

<pre><code>. ./script
</code></pre>
"
"<p>Here's a bash script that uses a feature I don't see often: asking bash to allocate a file descriptor for a file and storing the descriptor in a variable:</p>

<pre><code># Read the first line to get a count of the columns
IFS=: read -a columns &lt; file.txt

# Open an output file for each column, saving the file descriptor in an array
for c in ""${columns[@]}""; do
    exec {a}&gt;$((++i)).txt
    fds+=( $a )
done

# Iterate through the iput, writing each column to the file opened for it
while IFS=: read -a fields; do
    for f in ""${fields[@]}""; do
        printf ""$f\n"" &gt;&amp;${fds[++i]}
    done
done &lt; file.txt

# Close the file descriptors
for fd in ""${fds[@]}""; do
    exec {fd}&gt;&amp;-
done
</code></pre>
"
"<p><code>first_n</code> and <code>last_n</code> are arrays of characters (i.e. think a single string)</p>

<p>Your <code>fscanf</code> is treating them more like you think they are an array of strings. You are reading into the string one character further along each time i.e. The first time through you put the string at offset 0, The second time through it's at offset 1...</p>

<p>Try this:</p>

<pre><code>while ( fscanf( iput,""%s %s"", last_n,first_n ) !=  EOF )
{
    i++;
    printf(""%s %s\n"",last_n,first_n);
}
</code></pre>

<p>Your final print will only print the last ""record"" read. Perhaps you really did want an array of strings?
That would look a bit like this (I'm not saying this is the best way to solve the problem, but it is in the spirit of your original code...)</p>

<pre><code>/* Limited to 20 names of 70 chars each */
char first_names[20][70];
char last_names[20][70];

int i=0;
FILE *oput;
FILE *iput;

iput = fopen( ""names.txt"",""r"" );
while ( fscanf( iput,""%s %s"", &amp;last_names[i],&amp;first_names[i] ) !=  EOF )
{
    printf(""%s %s\n"",last_names[i],first_names[i]);
    i++;
}

oput=fopen(""user_name_info.txt"",""wt""); //opens output file
i--; /* ensure i points to the last valid data */
while(i &gt;= 0) {
    fprintf(oput, ""Last\t\tFirst\n------------\t-------------\n%s\t%s\n"",last_names[i],first_names[i]);
    i--;
}
return 0;
</code></pre>
"
"<p>First of all, you forgot to initialize <code>sumval</code>. You want it to be <code>0</code> at the beginning.</p>

<p>If you want the size of the array to be decided at runtime, you have to allocate it dynamically using <code>malloc</code>, for example like this:</p>

<pre><code>int n;
float *values,sumval=0,svmean,tmp;
scanf(""%d"", &amp;n);
values = (float *) malloc (n * sizeof(float));
</code></pre>

<p>Later, you should release the memory allocated by calling <code>free</code>:</p>

<pre><code>free(values);
</code></pre>
"
"<p>Initialize sumVal to o. Because for first iteration it adds garbage+values[i] into sumValue.</p>

<pre><code> #include &lt;stdio.h&gt;
 #define n 3
 int main()
 {
 int i;
 float values[n],sumval=0,svmean,tmp;
 for(i=0;i&lt;n;++i){
 scanf(""%f"",&amp;tmp);
 values[i]=tmp;
 sumval = sumval + values[i];
 }
  sumean = sumval/n;
  printf(""%f \n"",svmean);
  return(0);
</code></pre>

<p>}</p>
"
"<p>The problem is that you do not initialize <code>sumval</code>. You should set it to <code>0.0</code> before you <code>for</code> loop.</p>

<p>The change occurring when including/not-including <code>stdio.h</code> is probably due to some initialization functions using the stack, and changing the values in memory, before you enter your function, and it happen that this memory is used for your <code>sumval</code> variable.</p>

<p>But you should <strong>NOT</strong> rely on this.</p>
"
"<p>You can allocate an array with variable size in the heap of the program like that:</p>

<pre><code>#include &lt;stdio.h&gt;
int main(int argc, char **argv)
{
   int i;
   //Get the size of the array from input parameter
   int n = atoi(argv[1]);
   float sumval,svmean,tmp;
   //Allocate the array of values
   float *values = malloc(sizeof(float)*n);
   // Initialize sumval
   for(sumval=0,i=0;i&lt;n;++i){
      scanf(""%f"",&amp;tmp);
      values[i]=tmp;
      sumval = sumval + values[i];
   }
   svmean = sumval/n;
   printf(""%f \n"",svmean);
   //Free it
   free( values );
   return(0);
  }
</code></pre>

<p>You also need to initialize sumval to 0. The parameter of the size of the array is passed when launching the program (if you use an IDE you should check how it does that)</p>
"
"<p><strong>Question A answer</strong>
In the code you posted there is no need for stdlib.h. This library is needed if you use a function for allocating memory dynamically, such as malloc().</p>

<p><strong>Question B answer:</strong>
This is a way to do what you want:</p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int i, choice;
    float *values,sumval,svmean,tmp;
    printf(""Please enter the size of the array: "");
    scanf(""%d"", &amp;choice);
    values = (float*) malloc(choice*sizeof(float));
    for(i=0;i&lt;n;i++){
        scanf(""%f"",&amp;tmp);
        values[i]=tmp;
        sumval = sumval + values[i];
    }
    svmean = sumval/n;
    printf(""%f \n"",svmean);
    free(values);
    return 0;
}
</code></pre>

<p>Also, I modified the incrementation of i in the for statement to increase after running the loop.</p>
"
"<p>Try this.. </p>

<pre><code>#include &lt;stdio.h&gt;

int main()
{
    int i = 0;
    int n = 0;
    float sumval = 0;
    float svmean = 0;
    float tmp = 0;

    printf(""Enter count : "");
    scanf(""%d"", &amp;n);

    for (i = 0; i &lt; n; ++i) {
        scanf(""%f"", &amp;tmp);
        sumval = sumval + tmp;
    }

    svmean = sumval/n;
    printf(""%f \n"",svmean);

    return(0);
}
</code></pre>

<p>In your code, values[] array is not necessary to calculate output. Are you storing the values for any reason??..</p>
"
"<p>Just change the <code>scanf</code> line:</p>

<pre><code>scanf(""%s"", s);
</code></pre>

<p>As you have it (<code>scanf(""%s\n"", s);</code>), it requires a sequnce of characters ending in <code>\n</code>, then another <code>\n</code> to indicate when the input is finished.</p>
"
"<p><code>argv[]</code> is the array that holds your command line parameters, <code>argv[1]</code> is the first one (other than the command representation itself in <code>argv[0]</code>, of course). You assign it to <code>s</code> then immediately overwrite <code>s</code>, so it's not really needed here.</p>

<p>The reason you're having to enter <em>two</em> lines is the <code>\n</code> at the end of your input format. It requires whatever can match the format string followed by a newline, hence the <code>%s\n</code> is <em>eating</em> your first newline so that <code>scanf</code> has to go back for another one.</p>

<p><code>%s</code> on it's own will fix that problem but introduce another one if what you're after is a full <em>line</em> of input - it will only read up to the first whitespace. For a proper line input function, see <a href=""https://stackoverflow.com/questions/4023895/how-to-read-string-entered-by-user-in-c/4023921#4023921"">here</a>.</p>

<p>It does full line input with protection against buffer overflows and detection/cleanup of lines that were too long, something sorely missing in the <code>scanf(""%s"")</code> input method.</p>

<p>In addition, the <code>if</code> statement within the <code>while</code> is superfluous here since the <code>while</code> itself will catch the end of the string, and it makes little sense to have both <code>input</code> and <code>s</code> refer to the same array (it <em>would</em> make sense if you changed <code>s</code> at some point, but that's not happening here).</p>

<p>So, a variant <em>without</em> the advanced line iput function could be as simple as:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main (int argc, char* argv[]) {
    char input[256];
    int str_length = 0;

    printf (""Please enter a string: "");
    scanf (""%s"", input);
    while (input[str_length] != '\0')    /* Or consider using strlen() */
        str_length++;

    printf (""%d\n"", str_length);

    return 0;
}
</code></pre>

<p>If you enter <code>Hello</code>, you'll see that it prints out <code>5</code> immediately. You'll also see <code>5</code> if you enter <code>Hello Pax</code>, which is one reason to choose the advanced input function (the other, very important, reason is to avoid introducing a buffer overflow vulnerability into your program).</p>
"
"<p>argv is used to pass process arguments. this means you can run your program like</p>

<pre><code>a.out 123 abcd
</code></pre>

<p>argv[1] will already be assigned to a value of 123. you do not have to read it as you are doing now. in your current code , you are overwriting the reference of s to a new string after assigning it  with argv[1]. </p>
"
"<p>This is what you want</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAX 100

int main(int argc, char* argv[]){
    char tmp[MAX];
    printf(""Plese enter a string:\n"");
    scanf(""%s"", tmp);
    printf(""the length is %d\n"", strlen(tmp));

    return 0;
}
</code></pre>

<p>The argv and argc is another thing like this:
argv[0] = a.exe
argv[1] = 12345</p>

<pre><code>int main(int argc, char* argv[]){
    printf(""the length is %d\n"", strlen(argv[1]));

    return 0;
}
/*-------------------- Output --------------------
 &gt; a.out 12345
 the length is 5
  ------------------------------------------------*/
</code></pre>
"
"<p>Assuming input isn't null terminated:</p>

<pre><code>char* input = new char [input_max];
for (char* inputPtr = input; inputPtr &lt; input + input_max;
        inputPtr++) {
  inputPtr[0]++;
}
</code></pre>

<p>for the null terminated case:</p>

<pre><code>for (char* inputPtr = input; inputPtr[0]; inputPtr++) {
      inputPtr[0]++;
}
</code></pre>

<p>but generally this is as good as you can get. Using <code>std::vector</code>, or <code>std::string</code> may enable cleaner and more elegant options though.</p>
"
"<p>I would do:</p>

<pre><code>inputPtr = input; // init inputPtr always at the last moment.
while (*inputPtr != '\0') {      // Assume the string last with \0
       // some code
       inputPtr++; // After ""some code"" (instead of what you wrote).
}
</code></pre>

<p>Which is equivalent to the for-loop suggested by greatwolf. It's a personal choice.</p>

<p>Be careful, with both of your examples, you are testing the current position and then you increment. Therefore, you are using the next character!</p>
"
"<p>Assuming input string is null-terminated:</p>

<pre><code>for(char *inputPtr = input; *inputPtr; ++inputPtr)
{
  // some code
}
</code></pre>

<p>Keep in mind that the example you posted may not give the results you want. In your while loop condition, you're always performing a post-increment. When you're inside the loop, you've already passed the first character. Take this example:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
  const char *str = ""apple\0"";
  const char *it = str;
  while(*it++)
  {
    cout &lt;&lt; *it &lt;&lt; '_';
  }
}
</code></pre>

<p>This outputs:</p>

<blockquote>
  <p>p_p_l_e__</p>
</blockquote>

<p>Notice the missing first character and the extra <code>_</code> underscore at the end. Check out <a href=""https://stackoverflow.com/questions/8380960/why-the-c-compiler-does-not-give-precedence-increment-operator-under-assigmen/8381173#8381173"">this related question</a> if you're confused about pre-increment and post-increment operators.</p>
"
"<p>You can use <code>strptime</code> to parse dates in any format if you want, and then <code>mktime</code> to convert the <code>tm</code> structure to a <code>time_t</code> value which you can compare.</p>
"
"<p>To compare two dates in year-month-day format, <code>strcmp</code> is sufficient:</p>

<pre><code>assert(strcmp(""2012/09/13"", ""2012/09/12"") &gt; 0);
assert(strcmp(""2012/10/13"", ""2013/01/12"") &lt; 0);
</code></pre>
"
"<p>For what its worth since your example dates <code>string curr_date = ""2012/09/13""</code> and <code>string curr_date = ""2012/09/13""</code> appear to be in  <a href=""http://en.wikipedia.org/wiki/ISO_8601"" rel=""nofollow"">ISO8601</a> format (apart from the use of '/' as a separator). The joy of ISO8601 is that lexicographic order is the same as chronological order... that is sort the strings and you sort by time as well.</p>

<p>This is appealing becuase it provides a nice way to deal with many dates (as opposed to just 2)</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

using namespace std;

int main()
{

   vector&lt;string&gt; v = getDates(); //Made up function returning a vector of ISO dates
   sort(v, v.begin(), v.end()); //Done
   //Do whatever you have to
   return 0;
}
</code></pre>
"
"<p><a href=""http://linux.die.net/man/3/strptime"" rel=""nofollow""><code>strptime()</code></a> is what you're looking for. Unfortunately its not easy to get it to work on windows.</p>

<p>Although after much googling I finally found a implementation linked on <a href=""https://ffmpeg.org/trac/ffmpeg/ticket/992"" rel=""nofollow"">ffmpeg.org</a> which will do the job. The implementation is found on <em>plibc.sourceforge.net (A POSIX compliant libc for Windows)</em> <a href=""http://plibc.sourceforge.net/doxygen/strptime_8c-source.html"" rel=""nofollow"">here</a>.</p>

<p>You're going to have to remove the line numbers if you're going to copy it from doxygen with this regex <code>00([0-9])([0-9])([0-9])</code>. Also theres a error @ line 115 <code>enum locale_status { not, loc, raw };</code> has to be changed to <code>enum locale_status { nott, loc, raw };</code>.</p>

<p><strong>Alternatively if you're too lazy for all that heres the version I used:</strong></p>

<pre><code>/* Convert a string representation of time to a time value.
    Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper &lt;drepper@cygnus.com&gt;, 1996.

    The GNU C Library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public License as
    published by the Free Software Foundation; either version 2 of the
    License, or (at your option) any later version.

    The GNU C Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public
    License along with the GNU C Library; see the file COPYING.LIB.  If not,
    write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.  */

 void get_locale_strings(void);

 /* XXX This version of the implementation is not really complete.
    Some of the fields cannot add information alone.  But if seeing
    some of them in the same format (such as year, week and weekday)
    this is enough information for determining the date.  */

 #include &lt;ctype.h&gt;
 #include &lt;limits.h&gt;
 #include &lt;string.h&gt;
 #include &lt;time.h&gt;

 #define match_char(ch1, ch2) if (ch1 != ch2) return NULL

 #ifndef Macintosh
 #if defined __GNUC__ &amp;&amp; __GNUC__ &gt;= 2
 # define match_string(cs1, s2) \
   ({ size_t len = strlen (cs1);                                               \
      int result = strncasecmp ((cs1), (s2), len) == 0;                        \
      if (result) (s2) += len;                                                 \
      result; })
 #else
 /* Oh come on.  Get a reasonable compiler.  */
 # define match_string(cs1, s2) \
   (strncasecmp ((cs1), (s2), strlen (cs1)) ? 0 : ((s2) += strlen (cs1), 1))
 #endif
 #else
 # define match_string(cs1, s2) \
   (strncmp ((cs1), (s2), strlen (cs1)) ? 0 : ((s2) += strlen (cs1), 1))
 #endif /* mac */

 /* We intentionally do not use isdigit() for testing because this will
    lead to problems with the wide character version.  */
 #define get_number(from, to, n) \
   do {                                                                        \
     int __n = n;                                                              \
     val = 0;                                                                  \
     while (*rp == ' ')                                                        \
       ++rp;                                                                   \
     if (*rp &lt; '0' || *rp &gt; '9')                                               \
       return NULL;                                                            \
     do {                                                                      \
       val *= 10;                                                              \
       val += *rp++ - '0';                                                     \
     } while (--__n &gt; 0 &amp;&amp; val * 10 &lt;= to &amp;&amp; *rp &gt;= '0' &amp;&amp; *rp &lt;= '9');        \
     if (val &lt; from || val &gt; to)                                               \
       return NULL;                                                            \
   } while (0)
 # define get_alt_number(from, to, n) \
   /* We don't have the alternate representation.  */                          \
   get_number(from, to, n)
 #define recursive(new_fmt) \
   (*(new_fmt) != '\0'                                                         \
    &amp;&amp; (rp = strptime_internal (rp, (new_fmt), tm, decided)) != NULL)

 /* This version: may overwrite these with versions for the locale */
 static char weekday_name[][20] =
 {
     ""Sunday"", ""Monday"", ""Tuesday"", ""Wednesday"",
     ""Thursday"", ""Friday"", ""Saturday""
 };
 static char ab_weekday_name[][10] =
 {
     ""Sun"", ""Mon"", ""Tue"", ""Wed"", ""Thu"", ""Fri"", ""Sat""
 };
 static char month_name[][20] =
 {
     ""January"", ""February"", ""March"", ""April"", ""May"", ""June"",
     ""July"", ""August"", ""September"", ""October"", ""November"", ""December""
 };
 static char ab_month_name[][10] =
 {
     ""Jan"", ""Feb"", ""Mar"", ""Apr"", ""May"", ""Jun"",
     ""Jul"", ""Aug"", ""Sep"", ""Oct"", ""Nov"", ""Dec""
 };

 static char am_pm[][4] = {""AM"", ""PM""};


 # define HERE_D_T_FMT ""%a %b %e %H:%M:%S %Y""
 # define HERE_D_FMT ""%y/%m/%d""
 # define HERE_T_FMT_AMPM ""%I:%M:%S %p""
 # define HERE_T_FMT ""%H:%M:%S""

 static const unsigned short int __mon_yday[2][13] =
 {
     /* Normal years.  */
     { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
     /* Leap years.  */
     { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
 };


 /* Status of lookup: do we use the locale data or the raw data?  */
 enum locale_status { nott, loc, raw };

 # define __isleap(year) \
   ((year) % 4 == 0 &amp;&amp; ((year) % 100 != 0 || (year) % 400 == 0))

 /* Compute the day of the week.  */
 void
 day_of_the_week (struct tm *tm)
 {
     /* We know that January 1st 1970 was a Thursday (= 4).  Compute the
        the difference between this data in the one on TM and so determine
        the weekday.  */
     int corr_year = 1900 + tm-&gt;tm_year - (tm-&gt;tm_mon &lt; 2);
     int wday = (-473
                 + (365 * (tm-&gt;tm_year - 70))
                 + (corr_year / 4)
                 - ((corr_year / 4) / 25) + ((corr_year / 4) % 25 &lt; 0)
                 + (((corr_year / 4) / 25) / 4)
                 + __mon_yday[0][tm-&gt;tm_mon]
                 + tm-&gt;tm_mday - 1);
     tm-&gt;tm_wday = ((wday % 7) + 7) % 7;
 }

 /* Compute the day of the year.  */
 void
 day_of_the_year (struct tm *tm)
 {
     tm-&gt;tm_yday = (__mon_yday[__isleap (1900 + tm-&gt;tm_year)][tm-&gt;tm_mon]
                    + (tm-&gt;tm_mday - 1));
 }

 char *
 strptime_internal (const char *rp, const char *fmt, struct tm *tm,
                    enum locale_status *decided)
 {
     const char *rp_backup;
     int cnt;
     size_t val;
     int have_I, is_pm;
     int century, want_century;
     int have_wday, want_xday;
     int have_yday;
     int have_mon, have_mday;

     have_I = is_pm = 0;
     century = -1;
     want_century = 0;
     have_wday = want_xday = have_yday = have_mon = have_mday = 0;

     while (*fmt != '\0')
     {
         /* A white space in the format string matches 0 more or white
            space in the input string.  */
         if (isspace (*fmt))
         {
             while (isspace (*rp))
                 ++rp;
             ++fmt;
             continue;
         }

         /* Any character but `%' must be matched by the same character
            in the iput string.  */
         if (*fmt != '%')
         {
             match_char (*fmt++, *rp++);
             continue;
         }

         ++fmt;

         /* We need this for handling the `E' modifier.  */
     start_over:

         /* Make back up of current processing pointer.  */
         rp_backup = rp;

         switch (*fmt++)
         {
         case '%':
             /* Match the `%' character itself.  */
             match_char ('%', *rp++);
             break;
         case 'a':
         case 'A':
             /* Match day of week.  */
             for (cnt = 0; cnt &lt; 7; ++cnt)
             {
                 if (*decided != loc
                     &amp;&amp; (match_string (weekday_name[cnt], rp)
                         || match_string (ab_weekday_name[cnt], rp)))
                 {
                     *decided = raw;
                     break;
                 }
             }
             if (cnt == 7)
                 /* Does not match a weekday name.  */
                 return NULL;
             tm-&gt;tm_wday = cnt;
             have_wday = 1;
             break;
         case 'b':
         case 'B':
         case 'h':
             /* Match month name.  */
             for (cnt = 0; cnt &lt; 12; ++cnt)
             {
                 if (match_string (month_name[cnt], rp)
                     || match_string (ab_month_name[cnt], rp))
                 {
                     *decided = raw;
                     break;
                 }
             }
             if (cnt == 12)
                 /* Does not match a month name.  */
                 return NULL;
             tm-&gt;tm_mon = cnt;
             want_xday = 1;
             break;
         case 'c':
             /* Match locale's date and time format.  */
             if (!recursive (HERE_T_FMT_AMPM))
                 return NULL;
             break;
         case 'C':
           /* Match century number.  */
           get_number (0, 99, 2);
           century = val;
           want_xday = 1;
           break;
         case 'd':
         case 'e':
           /* Match day of month.  */
           get_number (1, 31, 2);
           tm-&gt;tm_mday = val;
           have_mday = 1;
           want_xday = 1;
           break;
         case 'F':
           if (!recursive (""%Y-%m-%d""))
             return NULL;
           want_xday = 1;
           break;
         case 'x':
           /* Fall through.  */
         case 'D':
           /* Match standard day format.  */
           if (!recursive (HERE_D_FMT))
             return NULL;
           want_xday = 1;
           break;
         case 'k':
         case 'H':
           /* Match hour in 24-hour clock.  */
           get_number (0, 23, 2);
           tm-&gt;tm_hour = val;
           have_I = 0;
           break;
         case 'I':
           /* Match hour in 12-hour clock.  */
           get_number (1, 12, 2);
           tm-&gt;tm_hour = val % 12;
           have_I = 1;
           break;
         case 'j':
           /* Match day number of year.  */
           get_number (1, 366, 3);
           tm-&gt;tm_yday = val - 1;
           have_yday = 1;
           break;
         case 'm':
           /* Match number of month.  */
           get_number (1, 12, 2);
           tm-&gt;tm_mon = val - 1;
           have_mon = 1;
           want_xday = 1;
           break;
         case 'M':
           /* Match minute.  */
           get_number (0, 59, 2);
           tm-&gt;tm_min = val;
           break;
         case 'n':
         case 't':
           /* Match any white space.  */
           while (isspace (*rp))
             ++rp;
           break;
         case 'p':
           /* Match locale's equivalent of AM/PM.  */
           if (!match_string (am_pm[0], rp))
             if (match_string (am_pm[1], rp))
               is_pm = 1;
             else
               return NULL;
           break;
         case 'r':
           if (!recursive (HERE_T_FMT_AMPM))
             return NULL;
           break;
         case 'R':
             if (!recursive (""%H:%M""))
                 return NULL;
             break;
         case 's':
         {
             /* The number of seconds may be very high so we cannot use
                the `get_number' macro.  Instead read the number
                character for character and construct the result while
                doing this.  */
             time_t secs = 0;
             if (*rp &lt; '0' || *rp &gt; '9')
                 /* We need at least one digit.  */
                 return NULL;

             do
             {
                 secs *= 10;
                 secs += *rp++ - '0';
             }
             while (*rp &gt;= '0' &amp;&amp; *rp &lt;= '9');

             if ((tm = localtime (&amp;secs)) == NULL)
                 /* Error in function.  */
                 return NULL;
         }
         break;
         case 'S':
             get_number (0, 61, 2);
             tm-&gt;tm_sec = val;
             break;
         case 'X':
             /* Fall through.  */
         case 'T':
             if (!recursive (HERE_T_FMT))
                 return NULL;
             break;
         case 'u':
             get_number (1, 7, 1);
             tm-&gt;tm_wday = val % 7;
             have_wday = 1;
             break;
         case 'g':
             get_number (0, 99, 2);
             /* XXX This cannot determine any field in TM.  */
             break;
         case 'G':
             if (*rp &lt; '0' || *rp &gt; '9')
                 return NULL;
             /* XXX Ignore the number since we would need some more
                information to compute a real date.  */
             do
                 ++rp;
             while (*rp &gt;= '0' &amp;&amp; *rp &lt;= '9');
             break;
         case 'U':
         case 'V':
         case 'W':
             get_number (0, 53, 2);
             /* XXX This cannot determine any field in TM without some
                information.  */
             break;
         case 'w':
             /* Match number of weekday.  */
             get_number (0, 6, 1);
             tm-&gt;tm_wday = val;
             have_wday = 1;
             break;
         case 'y':
             /* Match year within century.  */
             get_number (0, 99, 2);
             /* The ""Year 2000: The Millennium Rollover"" paper suggests that
                values in the range 69-99 refer to the twentieth century.  */
             tm-&gt;tm_year = val &gt;= 69 ? val : val + 100;
             /* Indicate that we want to use the century, if specified.  */
             want_century = 1;
             want_xday = 1;
             break;
         case 'Y':
             /* Match year including century number.  */
             get_number (0, 9999, 4);
             tm-&gt;tm_year = val - 1900;
             want_century = 0;
             want_xday = 1;
             break;
         case 'Z':
             /* XXX How to handle this?  */
             break;
         case 'E':
             /* We have no information about the era format.  Just use
                the normal format.  */
             if (*fmt != 'c' &amp;&amp; *fmt != 'C' &amp;&amp; *fmt != 'y' &amp;&amp; *fmt != 'Y'
                 &amp;&amp; *fmt != 'x' &amp;&amp; *fmt != 'X')
                 /* This is an invalid format.  */
                 return NULL;

             goto start_over;
         case 'O':
             switch (*fmt++)
             {
             case 'd':
             case 'e':
                 /* Match day of month using alternate numeric symbols.  */
                 get_alt_number (1, 31, 2);
                 tm-&gt;tm_mday = val;
                 have_mday = 1;
                 want_xday = 1;
                 break;
             case 'H':
                 /* Match hour in 24-hour clock using alternate numeric
                    symbols.  */
                 get_alt_number (0, 23, 2);
                 tm-&gt;tm_hour = val;
                 have_I = 0;
                 break;
             case 'I':
                 /* Match hour in 12-hour clock using alternate numeric
                    symbols.  */
                 get_alt_number (1, 12, 2);
                 tm-&gt;tm_hour = val - 1;
                 have_I = 1;
                 break;
             case 'm':
                 /* Match month using alternate numeric symbols.  */
                 get_alt_number (1, 12, 2);
                 tm-&gt;tm_mon = val - 1;
                 have_mon = 1;
                 want_xday = 1;
                 break;
             case 'M':
                 /* Match minutes using alternate numeric symbols.  */
                 get_alt_number (0, 59, 2);
                 tm-&gt;tm_min = val;
                 break;
             case 'S':
                 /* Match seconds using alternate numeric symbols.  */
                 get_alt_number (0, 61, 2);
                 tm-&gt;tm_sec = val;
                 break;
             case 'U':
             case 'V':
             case 'W':
                 get_alt_number (0, 53, 2);
                 /* XXX This cannot determine any field in TM without
                    further information.  */
                 break;
             case 'w':
                 /* Match number of weekday using alternate numeric symbols.  */
                 get_alt_number (0, 6, 1);
                 tm-&gt;tm_wday = val;
                 have_wday = 1;
                 break;
             case 'y':
                 /* Match year within century using alternate numeric symbols.  */
                 get_alt_number (0, 99, 2);
                 tm-&gt;tm_year = val &gt;= 69 ? val : val + 100;
                 want_xday = 1;
                 break;
             default:
                 return NULL;
             }
             break;
         default:
             return NULL;
         }
     }

     if (have_I &amp;&amp; is_pm)
         tm-&gt;tm_hour += 12;

     if (century != -1)
     {
         if (want_century)
             tm-&gt;tm_year = tm-&gt;tm_year % 100 + (century - 19) * 100;
         else
             /* Only the century, but not the year.  Strange, but so be it.  */
             tm-&gt;tm_year = (century - 19) * 100;
     }

     if (want_xday &amp;&amp; !have_wday) {
         if ( !(have_mon &amp;&amp; have_mday) &amp;&amp; have_yday)  {
             /* we don't have tm_mon and/or tm_mday, compute them */
             int t_mon = 0;
             while (__mon_yday[__isleap(1900 + tm-&gt;tm_year)][t_mon] &lt;= tm-&gt;tm_yday)
                 t_mon++;
             if (!have_mon)
                 tm-&gt;tm_mon = t_mon - 1;
             if (!have_mday)
                 tm-&gt;tm_mday = tm-&gt;tm_yday - __mon_yday[__isleap(1900 + tm-&gt;tm_year)][t_mon - 1] + 1;
         }
         day_of_the_week (tm);
     }
     if (want_xday &amp;&amp; !have_yday)
         day_of_the_year (tm);

     return (char *) rp;
 }

 char *
 strptime (const char *buf, const char *format, struct tm *tm)
 {
     enum locale_status decided;
 #ifdef HAVE_LOCALE_H
     if(!have_used_strptime) {
         get_locale_strings();
         /* have_used_strptime = 1; might change locale during session */
     }
 #endif
     decided = raw;
     return strptime_internal (buf, format, tm, &amp;decided);
 }

 #ifdef HAVE_LOCALE_H
 void get_locale_strings(void)
 {
     int i;
     struct tm tm;
     char buff[4];

     tm.tm_sec = tm.tm_min = tm.tm_hour = tm.tm_mday = tm.tm_mon
         = tm.tm_isdst = 0;
     tm.tm_year = 30;
     for(i = 0; i &lt; 12; i++) {
         tm.tm_mon = i;
         strftime(ab_month_name[i], 10, ""%b"", &amp;tm);
         strftime(month_name[i], 20, ""%B"", &amp;tm);
     }
     tm.tm_mon = 0;
     for(i = 0; i &lt; 7; i++) {
         tm.tm_mday = tm.tm_yday = i+1; /* 2000-1-2 was a Sunday */
         tm.tm_wday = i;
         strftime(ab_weekday_name[i], 10, ""%a"", &amp;tm);
         strftime(weekday_name[i], 20, ""%A"", &amp;tm);
     }
     tm.tm_hour = 1;
     /* in locales where these are unused, they may be empty: better
        not to reset them then */
     strftime(buff, 4, ""%p"", &amp;tm);
     if(strlen(buff)) strcpy(am_pm[0], buff);
     tm.tm_hour = 13;
     strftime(buff, 4, ""%p"", &amp;tm);
     if(strlen(buff)) strcpy(am_pm[1], buff);
 }
 #endif
</code></pre>

<p><strong>And heres a working exemple:</strong></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;time.h&gt;
#include &lt;stdio.h&gt;
#include ""strptime.h""

using namespace std;

int main()
{
    struct tm tm1, tm2;
    time_t t1, t2;

    memset(&amp;tm1, 0, sizeof(struct tm));
    memset(&amp;tm2, 0, sizeof(struct tm));

    strptime(""12 February 2010"", ""%d %b %Y"", &amp;tm1);
    strptime(""11 February 2010"", ""%d %b %Y"", &amp;tm2);

    t1 = mktime(&amp;tm1);
    t2 = mktime(&amp;tm2);

    cout &lt;&lt; t1 &lt;&lt; endl;
    cout &lt;&lt; t2 &lt;&lt; endl;

    if (t1 &gt; t2)
    {
        cout &lt;&lt; ""t1 &gt; t2"" &lt;&lt; endl;
    }
    else if (t1 == t2)
    {
        cout &lt;&lt; ""t1 == t2"" &lt;&lt; endl;
    }
    else if (t1 &lt; t2)
    {
        cout &lt;&lt; ""t1 &lt; t2"" &lt;&lt; endl;
    }

    cout &lt;&lt; (t1 - t2) &lt;&lt; endl;

    return 0;
}
</code></pre>

<p><strong>Outputs:</strong></p>

<pre><code>1265925600
1265839200
t1 &gt; t2
86400
</code></pre>
"
"<p>My suggestion would be to use a functor.  Doing so will allow you determine exactly how you want to compare those dates and also give you the ability to later define another functor which compares the dates a different way.</p>

<p>For example, you could define a functor as such:</p>

<pre><code>struct DateLessThan
{
    BOOL operator()(const std::string&amp; lhs, const std::string&amp; rhs)
    {
        // the following is pseudocode
        split lhs and rhs into arrays of strings based on the delimiter ""/""

        convert the string arrays into integers and store them in vars (possibly lhs_day, lhs_month, etc.)

        if (lhs_year &lt; rhs_year)
            return true;
        else if (lhs_year == rhs_year)
        {
            if (lhs_month &lt; rhs_month)
                return true;
            else if (lhs_month == rhs_month)
            {
                if (lhs_day &lt; rhs_day)
                    return true;
            }
        }

        return false;
    }
};
</code></pre>
"
"<p>In your main thread: </p>

<pre><code>if( ++iput == MAX_THREAD)
            iput = 0;// so iput is 0 --&gt; MAX_THREAD
</code></pre>

<p>And in your sub thread:</p>

<pre><code> if ( ++iget == MAX_THREAD )
            iget = 0;// So iget is 0 --&gt; MAX_THREAD
</code></pre>

<p>Since the sub thread and the main thread runs at the ""<strong>same time</strong>"",and they are golbal values .the iput maybe equare to iget sometime.</p>
"
"<p>From ""UNIX Network Prgramming Volume 1, 2nd Edition"", chapter 27.12, page 757, from the annotations to  the lines 27-38 of <code>server/serv08.c</code>: </p>

<blockquote>
  <p>We also check that the <code>iput</code> index has not caught up with the <code>iget</code> index, which indicates that our array is not big enough.</p>
</blockquote>

<p>For reference the lines mentioned above (<a href=""https://github.com/nirocfz/unp/blob/master/server/serv08.c"" rel=""nofollow"">take from here</a>):</p>

<pre><code>27 for ( ; ; ) {
28   clilen = addrlen;
29   connfd = Accept(listenfd, cliaddr, &amp;clilen);
30   Pthread_mutex_lock(&amp;clifd_mutex);
31   clifd[iput] = connfd;
32   if (++iput == MAXNCLI)
33     iput = 0;
34   if (iput == iget)
35     err_quit(""iput = iget = %d"", iput);
36   Pthread_cond_signal(&amp;clifd_cond);
37   Pthread_mutex_unlock(&amp;clifd_mutex);
38 }
</code></pre>
"
"<p>What you have there is a typical circular buffer implementation. </p>

<p>The head and tail pointers/indices point to the same location when the circular buffer is empty. You can see this being tested in the code <code>while (iget == iput) ...</code> which means ""while the queue is empty ..."".</p>

<p>If, after an insertion at the head of a circular buffer, head points to tail, that is a problem. The buffer has overflowed. <strong>It is a problem because now the buffer now looks empty even though it is full.</strong></p>

<p>That is to say, one unused location is reserved in the buffer; if the buffer has 4096 entries, we can only fill 4095. If we fill 4096, it then we have overflow: it looks like an empty circular buffer.</p>

<p>(We could use all 4096 locations if we allowed the index to go from 0 to 8192, using an extra bit to resolve the ambiguity, so that instead of wrapping to zero past 4095, the pointers would keep going to 4096 ... 8191. We would have to remember to access the array modulo 4096, of course. It's a big cost in complexity for the sake of recovering one wasted element.)</p>

<blockquote>
  <p>It looks like the code bails on circular buffer overflow because it is structured such that this condition cannot happen, and so it constitutes an internal error. The circular buffer overflows when there are too many descriptors being passed from the producer to the consumer in a single bout.</p>

  <p>In general, circular buffer code cannot just bail when the buffer is full. Either the insertion operation has to balk and return an error, or it has to block for more space. So this is a special case based on assumptions particular to the example program.</p>
</blockquote>
"
"<p>if your requirement is to work in browsers other than IE
then you can follow <a href=""https://stackoverflow.com/questions/4459379/preview-an-image-before-it-is-uploaded"">this link</a> and it has the perfect answer for you</p>

<p>but if your requirement also includes IE
then you do a few steps
Step 1 : create a different form , other than your main form , this different form cant be inside the main form as form inside a form cant be submitted .</p>

<p>Step 2 : inside your new form keep</p>

<pre><code>&lt;input type=""file"" name=""imageFileChooser""/&gt;
</code></pre>

<p>Step 3 : on change event of the file field call an ajax function</p>

<p>Step 4 : this ajax function submits your new form with only image field , and stores the image on server side</p>

<p>Step 5 : when you want to give the preview of the form you need to call the temporarily saved image from your server .</p>

<p>Step 6 : after preview and submission submit the main form and take image from the temporary location of the server or you can also keep a hidden file iput tag carrying the same file .</p>
"
"<p>in HTML: </p>

<pre><code>&lt;input type='file' onchange=""readURL(this);"" /&gt;
</code></pre>

<p>Javascript/JQuery through the Type <code>FileReader</code> </p>

<pre><code>if (input.files &amp;&amp; input.files[0]) {
    var reader = new FileReader();
    reader.onload = function (e) {
            $('#blah').attr('src', e.target.result);
        }
        reader.readAsDataURL(input.files[0]);
    }
</code></pre>

<p>where <code>input</code> is the <code>&lt;input type=""file""&gt;</code> element
if you use AjaxToolKit AsyncFileUpload, you can get the input using: <code>fileUploadElement.get_inputFile()</code></p>

<p>Please refere to: <a href=""https://stackoverflow.com/questions/16207575/how-to-preview-a-image-before-and-after-upload"">how to preview a image before and after upload?</a></p>
"
"<pre><code>procdump(void) is missing a final ""}"".

void
procdump(void)
{
  static char *states[] = {
  [UNUSED]    ""unused"",
  [EMBRYO]    ""embryo"",
  [SLEEPING]  ""sleep "",
  [RUNNABLE]  ""runble"",
  [RUNNING]   ""run   "",
  [ZOMBIE]    ""zombie""
  };
  int i;
  struct proc *p;
  char *state;
  uint pc[10];

  for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){
    if(p-&gt;state == UNUSED)
      continue;
    if(p-&gt;state &gt;= 0 &amp;&amp; p-&gt;state &lt; NELEM(states) &amp;&amp; states[p-&gt;state])
      state = states[p-&gt;state];
    else
      state = ""???"";
    cprintf(""%d %s %s"", p-&gt;pid, state, p-&gt;name);
    if(p-&gt;state == SLEEPING){
      getcallerpcs((uint*)p-&gt;context-&gt;ebp+2, pc);
      for(i=0; i&lt;10 &amp;&amp; pc[i] != 0; i++)
        cprintf("" %p"", pc[i]);
    } // end if
    cprintf(""\n"");

} // end for

} // you need to add this
</code></pre>
"
"<p>As chris said, your loops</p>

<pre><code>for(i=0;i&lt;=100;i++ )
</code></pre>

<p>Should almost definitely be </p>

<pre><code>for(i=0;i&lt;100;i++ )
</code></pre>

<p>It may not completely solve your issue, but it's a start. </p>
"
"<p>I will make no assumption about what problem your code is supposed to cope with. But there is at least three problems in your code.</p>

<p>First, you better check your array bounds because your have a buffer overflow which always leads to troubles. In C/C++, array are zero-indexed, therefore when you declare <code>A[100]</code> you have 100 elements ranging from <code>A[0]</code> to <code>A[99]</code>. Your three loops are wrongs, stop condition must be <code>i&lt;100</code> instead of <code>i&lt;=100</code>. </p>

<p>Second, your last check is not what you think it is. You are not comparing three integers together. You are comparing a mix of integer and boolean promoted to integer, since the first <code>==</code> will return a boolean and it will be promoted to resolve the next <code>==</code>. You must write <code>(A[i]!=B[j])&amp;&amp;(B[j]!=C[h])</code> instead.</p>

<p>Third, you are not filling all vectors but only the first element of each. You must check the content of your data before you process it.</p>
"
"<p>You are making some very basic mistakes like not even taking the iput correctly ,not checking runtime errors like the one by accessing an array element out of bounds.</p>

<p>I suggest that you should debug your code properly before you post here.</p>

<p>As far as the answer to your code is concerned, this is gonna be the algo..
<strong><em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em></strong><em>LOGIC</em><strong><em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>***</strong></p>

<p>First of all sort all the three arrays.</p>

<p>Secondly pick up the first element of any array (say C), and compare it the second one (say B) until you find a number in B which is greater than or equal to C[0].If they are equal start finding the number in A (if you find any such number it is connctive) else take the next element of C.</p>

<p><em><strong></em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>***</strong><em>LOGIC ENDS</em><strong><em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>*</strong></p>

<p><em><strong></em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em></strong><em>CODE</em><strong><em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**<em>*</em>**</strong></p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

void sort_array(int * X);

int main()

{

    int A[5] , B[5] , C[5];

    int i=0,j,h;

    cout &lt;&lt; ""THE PROGRAM TAKES 3 GRAGHS ONLY\n"";

    cout &lt;&lt; ""\n enter the Graph 1 \n"";
    for (i=0 ; i&lt;5 ; i++)
        cin &gt;&gt; A[i];


    cout &lt;&lt; ""\n enter the Graph 2 \n"";
    for (i=0 ; i&lt;5 ; i++)
        cin &gt;&gt; B[i];


    cout &lt;&lt; ""\n enter the Graph 1 \n"";
    for (i=0 ; i&lt;5 ; i++)
        cin &gt;&gt; C[i];

    sort_array(A);
    sort_array(B);
    sort_array(C);


    i=0;
    for (j=0;j&lt;5;j++)
    {
        for(h=0;h&lt;5;h++)
        {
            if (C[j]&lt;=B[h])
            {
                break;
            }
        }
        if (C[j]==B[h])
        {
            for(; i&lt;5 ;i++)
            {
                if(A[i]&gt;=C[j])
                {
                    break;
                }
            }
            if(A[i]==C[j])
            {
                cout&lt;&lt;""\n  ""&lt;&lt;A[i]&lt;&lt;""  connective\n"";
            }
        }
    }

    return 0;

}

void sort_array(int * X)

{

    for( int i=0; i&lt;4 ; i++)
    {
         for( int j=0; j&lt;5-i ; j++)
        {
            if(X[i]&gt;X[i+1])
            {
                swap(X[i],X[i+1]);
            }
        }
    }
}

******************************CODE ENDS**************************************
</code></pre>
"
"<blockquote>
  <p>Is my theory correct that the reason this happens is that it takes longer to assign to variables that aren't in the current scope?</p>
</blockquote>

<p>No.</p>

<p>Your profiler is lying to you, and pinpointing the wrong source for the delay. Short of parallelisation this code cannot be optimised meaningfully without any knowledge of <code>someQuickCalc</code>. All the other operations are quite elementary.</p>
"
"<p>There are limits to what a profiler can do.  If you've compiled
with optimization, the compiler has probably rearranged a fair
bit of code, so the profiler can't necessarily tell which line
number is associated with any one particular instruction.  And
both the compiler and the hardware will allow for a good deal of
overlapping; in many cases, the hardware will just go on to the
next instruction, even if the preceding one hasn't finished,
leaving a number of operations in the pipeline (and the compiler
will arrange the code so that the hardware can do this most
effectively).  Thus, for example, the sub-expression <code>inArr[i]</code>
involves a memory access, which is probably significantly slower
than anything else.  But the execution doesn't wait for it; the
execution doesn't wait until it actually needs the results.  (If
the compiler is really clever, it may remark that <code>arr[i]</code>
accesses uninitialized memory, which is undefined behavior, so
it can skip the access, and give you any old random value.)</p>

<p>In your case, the compiler is probably only doing full
optimization within the loop, so the execution is only stalling
for the pipelined operations to finish when you write to
a variable outside the loop.  And the profiler thus attributes
all of the time to this write.</p>

<p>(I've simplified greatly: for more details, I'd have to know
more about the actual processor, and look at the generated code
with and without optimization.)</p>
"
"<p>In your post:</p>

<p>Personnage.cpp</p>

<pre><code>#include ""Arme.h""
#include&lt;string&gt;
#include&lt;iostream&gt;
using namespace std;
Arme::Arme():idArme(0),nomArme(0)
{

}
</code></pre>

<p>Surely you don't really want to repeate <code>Arme::Arme</code> in Personage.cpp?</p>
"
"<p>Need to switch to answer for lack of space. I cant reproduce the behaviour you are describing except for -O0 (cygwin on XP gcc 4.8.2):</p>

<pre><code>-O0
sc.c:8:8:mfunc  24      static
sc.c:18:8:test1call     40      static
sc.c:28:8:test2call     64      static
sc.c:39:5:main  80      dynamic,bounded
-O1
sc.c:8:8:mfunc  4       static
sc.c:18:8:test1call     4       static
sc.c:28:8:test2call     4       static
sc.c:39:5:main  80      dynamic,bounded
-O2
sc.c:8:8:mfunc  4       static
sc.c:18:8:test1call     4       static
sc.c:28:8:test2call     4       static
sc.c:39:5:main  16      static
-O3
sc.c:8:8:mfunc  4       static
sc.c:18:8:test1call     4       static
sc.c:28:8:test2call     4       static
sc.c:39:5:main  16      static
</code></pre>

<p>As to '(1) : stack usage of a function would be proportional to the number of sub-call it makes'. I'd be shocked if that was true. Nested calls foo(x){ f(g(h(x)));} increase the level (in the activation tree) so the stack must (well, almost true) grow, but in sequential calls foo(x) { f(x); g(x); h(x); } the stack is reused. The standard activation/return sequence (Aho, Lam, Sethi, Ullman: Compilers Chp 7.2) is actually very small, if you run out of 1M stack in non-recursive calls you must be having (a) large number of local variables, or (b) extremely long argument lists, or (c) you are using a C++ compiler which allocates temporary objects on the stack.</p>

<p>'On the opposite, I've always thought that stack state should be restored at all (sub-)call return'. In C the caller clear up the stack.</p>

<p>I guess (1) you are either on some strange (for me) architecture or (2) you have some unusual compiler options set (CFLAGS?).</p>

<p>Your best bet is 'gcc -S' and examine the assembly output.</p>
"
"<p>Getchar is not required to be a cancellation point.    Select and pselect are.  Even if you want to continue to use a countdown thread you could still provide a cancellation point in the opposing thread by use of select.</p>

<p>I had reasonable behavior with the following modified wait_for_input()</p>

<pre><code>    // Waits for the user to pass input through the tty
    void * wait_for_input(void *args)
    {
      WaitStruct *wait_str = (WaitStruct *) args;
      int c = 0;
      fd_set  readFds;
      int numFds=0;
      FD_ZERO(&amp;readFds);

      do {
        struct timeval timeout={.tv_sec=8,.tv_usec=0};
        /* select here is primarily to serve as a cancellation
         * point.  Though there is a possible race condition
         * still between getchar() getting called right as the
         * the timeout thread calls cancel.().
         * Using the timeout option on select would at least
         * cover that, but not done here while testing.
         *******************************************************/
        FD_ZERO(&amp;readFds);
        FD_SET(STDOUT_FILENO,&amp;readFds);
        numFds=select(STDOUT_FILENO+1,&amp;readFds,NULL,NULL,&amp;timeout);
        if(numFds==0 )
        {
          /* must be timeout if no FD's selected */
          break;
        }
        if(FD_ISSET(STDOUT_FILENO,&amp;readFds))
        {
          printf(""Only get here if key pressed\n"");
          c = getchar();
        }
      } while (!(c == '1' || c == '2'));
      *(wait_str-&gt;key) = c;
      // Cancel the other thread
      pthread_cancel(*(wait_str-&gt;thread));
      return NULL;
    }
</code></pre>
"
"<p>You need to consume both stdout and stderr <em>whilst the process is running</em>, rather than once its completed.</p>

<p>Note that you have to do this in separate threads, otherwise your process runs the risk of blocking. See my answer <a href=""https://stackoverflow.com/a/882795/12960"">here</a> for more details.</p>
"
"<p>Use <a href=""http://msdn.microsoft.com/en-us/library/windows/desktop/bb776391.aspx"" rel=""nofollow""><code>CommandLineToArgvW()</code></a> to parse a <code>wchar_t*</code>, such as from a <code>std::wstring</code>, into a <code>wchar_t*[]</code> array that you can loop through, just like with <code>argv</code>/<code>argc</code>.  For example:</p>

<pre><code>void GetArguments()
{
    std::wstring inputStr;
    std::wcout &lt;&lt; L""Enter arguments ..."" &lt;&lt; std::endl;
    std::wcin &gt;&gt; inputStr;

    int numArgs;
    LPWSTR *args = CommandLineToArgvW(inputStr.c_str(), &amp;numArgs);
    if (args)
    {
        for (int i = 0; i &lt; numArgs; ++i)
        {
            // use args[i] as needed...
        }
        LocalFree(args);
    }
}
</code></pre>

<p>This is a Windows-specific solution, since your question is tagged for Visual Studio.  If you are looking for a pure C++ solution, you will have to tokenize <code>inputStr</code> manually, splitting it on whitespace and quotations as needed. There are tons of examples of that floating around.</p>
"
"<p>Try slowing down the interval on the interrupt. It is possible that due to several <code>if</code> statements running under <code>isr_timer()</code>that the main loop <em>may</em> be locking up. I have a sneaking suspicion you are trying to do too much!</p>

<blockquote>
  <p>Be careful about trying to execute too complicated of an interrupt at too high of a frequency, or the CPU may never enter the main loop and your program will 'lock up'. <a href=""http://playground.arduino.cc/code/timer1"" rel=""nofollow"">Reference</a></p>
</blockquote>

<p>Saying that and to check that your main loop is actually running why not add a simple debug at the bottom of the main <code>loop()</code> to flash the on board led..</p>

<pre><code>int onBoardLED = 13;

void setup()
 {
    pinMode(onBoardLED, OUTPUT);

    // And all the rest
 }

void loop()
 {
    // Doing stuff

    if (onBoardLED == LOW) digitalWrite(ledPin, HIGH);
    else digitalWrite(ledPin, LOW);
 }
</code></pre>

<p>At least then you will know if the main <code>loop()</code> is even actually executing.
It obviously runs once as you are getting a single SMS through but really with no other way of telling its a guess after that...</p>

<p>If all looks good try adding some further flags around the place just to see whats getting executed and what is not. Other than that suggestion i cant spot anything further but interested to find out! Best of luck</p>

<p><strong>Update</strong><br>
Just dug this link out of my bookmarks. You may find it useful.<br>
- <a href=""http://gammon.com.au/interrupts"" rel=""nofollow"">Nick Gammon - Interrupts</a></p>
"
"<p>You could go <code>fseek</code>ing backwards through the file, but that's not a good option, in my opinion.</p>

<p>Just read in the whole line and store it in a <code>char</code> buffer. Your code does that with repeated calls to <code>fscanf(fp, ""%c"", &amp;c)</code>, which is needlessly clumsy. There is already a function that does this, <code>fgets</code>:</p>

<pre><code>char line[80];

while (fgets(line, sizeof(line), fp) != NULL) {
    // Now scan line instead of fp
}
</code></pre>

<p>Now you can parse <code>line</code> depending on your iput format: <code>sscanf(line, ..)</code> if you have a fixed format. <code>strtok</code> repeatedly if you need to extract tokens, and so on. (You don't show the format of your input, but there's probably a function to deal with it better than coding it by hand.)</p>

<p>One potential problem with <code>fgets</code> is that you need to specify a maximum length, which may not be suitable if you can have arbitrarily long lines. There's also the annoyance of the new-line character that's left at the end of each line.</p>
"
"<p>You're overwriting the contents of arr on each iteration of the loop. Try something like this (<a href=""https://ideone.com/cXp76K"" rel=""nofollow"">live demo here</a>):</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main() {
    int sum = 0;
    int iter;

    cin &gt;&gt; iter;
    int arr[2];

    for (int i=0; i&lt;iter; i++) {
        for (int n=0; n&lt;2; n++) {
            // Enter numbers
            cin &gt;&gt; arr[n];
        }
        for (int num=0; num&lt;2; num++) {
            sum+=arr[num];
        }

        cout &lt;&lt; sum &lt;&lt; endl;

    }

    return 0;
}
</code></pre>
"
"<pre><code>for (int i=0; i&lt;iter; i++) {
    for (int n=0; n&lt;2; n++) {
        // Enter numbers
        cin &gt;&gt; arr[n];
    }
}
</code></pre>

<p>In first iteration values are entered in <code>arr</code> and again in second iteration previous values are overwritten (similar in next iterations if any ). This is the  problem .</p>

<p><a href=""https://ideone.com/7Cmk39"" rel=""nofollow"">Solution</a> -</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
    int iter;
    cin &gt;&gt; iter;
    int arr[2];
    int sum[iter];             // declare sum as array with iter number of elements
   for(int i=0;i&lt;iter;i++){
        sum[i]=0;                 // initialize elements of sum to 0
     }
   for (int i=0; i&lt;iter; i++) {
       for (int n=0; n&lt;2; n++) {
        // Enter numbers
           cin &gt;&gt; arr[n];               // take iput
           sum[i]+=arr[n];              // add numbers and store in sum
        }
    }


   for (int i=0; i&lt;iter; i++) {
      // Get the sum of numbers
       cout &lt;&lt; sum[i] &lt;&lt; endl;          // print values in sum after taing all inputs
    }
  return 0;
 }
</code></pre>
"
"<p>Use the code of the 'open' system call found in function sys_open() in sysfile.c, and assign the 'path' and 'omode' variables yourself. </p>

<p>(If you want to avoid code duplications, you can edit sys_open to call another function with the 'path', 'omode' variables, and use that function in your code in proc.c)</p>
"
"<p>You should study the kernel file system.
There you will see the relevant kernel functions.</p>

<p>Specifically You need the <code>create</code>, <code>writei</code>, <code>iput</code> functions.
You will also need <code>begin_trans</code> and <code>comnit_trans</code> (since you are writing).</p>
"
"<p>You try and use <code>a</code> before validating whether the input is valid. This could lead to unexpected behavior. You need to validate your input, something like:</p>

<pre><code>if (scanf(""%lf %lf"", &amp;a, &amp;b) != 2) {
    // handle bad input
}
</code></pre>
"
"<p>I'm not sure what you're trying to accomplish here. Your code basically adds 16 to every element of the array. </p>

<p>Error you're getting is caused by bad alignment of memory. When you're loading word from memory which is 4 bytes in MIPS32, the address needs to be divisible by 4. To guarantee this in mips your data section you need to add <em>.align 4</em> before declaring your array.</p>

<pre><code>.data #This for all the data for the program like variables in c++
   Message : .asciiz ""Hello world !\n"" #Display this message on the simulator
   .align 4
   MyArray : .space 24
   Prompt : .asciiz ""Enter the value\n ""
   Message2: .asciiz ""End world !\n""
   Space : .asciiz "" , ""
</code></pre>
"
"<p>In Linux this is implemented around <code>ext2_delete_inode</code> function of fs/ext2/inode.c file:
<a href=""http://lxr.free-electrons.com/source/fs/ext2/inode.c?v=2.6.32#L59"" rel=""nofollow noreferrer"">http://lxr.free-electrons.com/source/fs/ext2/inode.c?v=2.6.32#L59</a></p>

<pre><code> 56 /*
 57  * Called at the last iput() if i_nlink is zero.
 58  */
 59 void ext2_delete_inode (struct inode * inode)
 60 {
 61         truncate_inode_pages(&amp;inode-&gt;i_data, 0);
  ..
 65         EXT2_I(inode)-&gt;i_dtime  = get_seconds();
 66         mark_inode_dirty(inode);
 67         ext2_write_inode(inode, inode_needs_sync(inode));
 68
 69         inode-&gt;i_size = 0;
 70         if (inode-&gt;i_blocks)
 71                 ext2_truncate (inode);
 72         ext2_free_inode (inode);
 73
 74         return;
  ..
 77 }
</code></pre>

<p>So, it removes pages from page cache in <a href=""http://lxr.free-electrons.com/source/mm/truncate.c?v=2.6.32#L184"" rel=""nofollow noreferrer""><code>truncate_inode_pages</code></a>, <strong>sets dtime  (deletion time)</strong> and marks inode as dirty - <a href=""http://lxr.free-electrons.com/source/include/linux/fs.h?v=2.6.32#L1589"" rel=""nofollow noreferrer""><code>I_DIRTY</code> which is combination of  <code>(I_DIRTY_SYNC | I_DIRTY_DATASYNC | I_DIRTY_PAGES)</code></a>:</p>

<pre><code>1601  * I_DIRTY_SYNC         Inode is dirty, but doesn't have to be written on
1602  *                      fdatasync().  i_atime is the usual cause.
1603  * I_DIRTY_DATASYNC     Data-related inode changes pending. We keep track of
1604  *                      these changes separately from I_DIRTY_SYNC so that we
1605  *                      don't have to write inode on fdatasync() when only
1606  *                      mtime has changed in it.
1607  * I_DIRTY_PAGES        Inode has dirty pages.  Inode itself may be clean.
</code></pre>

<p>Then write modified inode, change <strong>it size to zero</strong>, truncate all blocks linked from inode with <code>ext2_truncate()</code> (the actual marking of data blocks as free is done there): <a href=""http://lxr.free-electrons.com/source/fs/ext2/inode.c?v=2.6.32#L1025"" rel=""nofollow noreferrer"">http://lxr.free-electrons.com/source/fs/ext2/inode.c?v=2.6.32#L1025</a></p>

<pre><code>1025 void ext2_truncate(struct inode *inode)
1026 {
..
1059         n = ext2_block_to_path(inode, iblock, offsets, NULL);
 99 /*      ext2_block_to_path - parse the block number into array of offsets
105  *      To store the locations of file's data ext2 uses a data structure common
106  *      for UNIX filesystems - tree of pointers anchored in the inode, with
107  *      data blocks at leaves and indirect blocks in intermediate nodes.
108  *      This function translates the block number into path in that tree -
109  *      return value is the path length and @offsets[n] is the offset of
110  *      pointer to (n+1)th node in the nth one. If @block is out of range
111  *      (negative or too large) warning is printed and zero returned. */
1069         if (n == 1) {
1070                 ext2_free_data(inode, i_data+offsets[0],
1071                                         i_data + EXT2_NDIR_BLOCKS);
1072                 goto do_indirects;
1073         }
..
1082                 ext2_free_branches(inode, &amp;nr, &amp;nr+1, (chain+n-1) - partial);
..
1084         /* Clear the ends of indirect blocks on the shared branch */
1085         while (partial &gt; chain) {
1086                 ext2_free_branches(inode,
1087                                    partial-&gt;p + 1,
1088                                    (__le32*)partial-&gt;bh-&gt;b_data+addr_per_block,
1089                                    (chain+n-1) - partial);
..
1094 do_indirects:
1095         /* Kill the remaining (whole) subtrees */
1096         switch (offsets[0]) {
1097                 default:
1098                         nr = i_data[EXT2_IND_BLOCK];
1099                         if (nr) {
1100                                 i_data[EXT2_IND_BLOCK] = 0;
1101                                 mark_inode_dirty(inode);
1102                                 ext2_free_branches(inode, &amp;nr, &amp;nr+1, 1);
1103                         }
1104                 case EXT2_IND_BLOCK:
1105                         nr = i_data[EXT2_DIND_BLOCK];
1106                         if (nr) {
1107                                 i_data[EXT2_DIND_BLOCK] = 0;
1108                                 mark_inode_dirty(inode);
1109                                 ext2_free_branches(inode, &amp;nr, &amp;nr+1, 2);
1110                         }
1111                 case EXT2_DIND_BLOCK:
1112                         nr = i_data[EXT2_TIND_BLOCK];
1113                         if (nr) {
1114                                 i_data[EXT2_TIND_BLOCK] = 0;
1115                                 mark_inode_dirty(inode);
1116                                 ext2_free_branches(inode, &amp;nr, &amp;nr+1, 3);
1117                         }
1118                 case EXT2_TIND_BLOCK:
1119                         ;
1120         }
</code></pre>

<p>(why <code>EXT2_TIND_BLOCK</code> is not cleared?)</p>

<p>Then we can free inode structure in kernel memory.</p>

<blockquote>
  <p>how does the file system know that the file is deleted?</p>
</blockquote>

<p>The check is there in the <code>ext2_iget</code> function: <a href=""http://lxr.free-electrons.com/source/fs/ext2/inode.c?v=2.6.32#L1251"" rel=""nofollow noreferrer"">http://lxr.free-electrons.com/source/fs/ext2/inode.c?v=2.6.32#L1251</a></p>

<pre><code>1251         /* We now have enough fields to check if the inode was active or not.
1252          * This is needed because nfsd might try to access dead inodes
1253          * the test is that same one that e2fsck uses
1254          * NeilBrown 1999oct15
1255          */
1256         if (inode-&gt;i_nlink == 0 &amp;&amp; (inode-&gt;i_mode == 0 || ei-&gt;i_dtime)) {
1257                 /* this inode is deleted */
1258                 brelse (bh);
1259                 ret = -ESTALE;
1260                 goto bad_inode;
1261         }
</code></pre>

<p>So, deleted inode is inode which has no incoming links (it not mentioned in any directory <a href=""http://www.tldp.org/LDP/lki/lki-3.html"" rel=""nofollow noreferrer"">i_nlink</a>) and have either zero mode or non-zero deletion time.</p>
"
"<p>In order to return different types from a function, the types must be related (see below). In addition, the return type must be a pointer or a smart pointer.</p>

<p>If you wish to communicate data of unrelated types back to the caller, you have two options:</p>

<ul>
<li>Take reference parameters to <code>struct</code> of each possible kind, or</li>
<li>Take a callback that accepts elements of each possible kind.</li>
</ul>

<p>First approach:</p>

<pre><code>enum shape_t {Cube, Sphere};
shape_t parse(vector&lt;uint8_t&gt; data, cube &amp;c, sphere&amp; s) {
    if (&lt;data represents a cube&gt;) {
        c.width = ...
        c.volume = ...
        return Cube;
    } else if (&lt;data represents a sphere&gt;) {
        s.diameter = ...
        s.mass = ...
        return Sphere;
    } else {
        ... // Handle error
    }
}
</code></pre>

<p>Second approach:</p>

<pre><code>struct parse_callback {
    virtual void cube(const cube&amp; c);
    virtual void sphere(const sphere&amp; s);
};
...
void parse(vector&lt;uint8_t&gt; data, parse_callback&amp; cb) {
    ...
    if (&lt;data represents a cube&gt;) {
        cube c;
        c.width = ...
        c.volume = ...
        cb.cube(c);
    } else if (&lt;data represents a sphere&gt;) {
        sphere s;
        s.diameter = ...
        s.mass = ...
        cb.sphere(s);
    }
}
</code></pre>

<p>If you do not mind making your classes inherit from a common base, you can return a smart pointer to a polymorphic type:</p>

<pre><code>enum shape_kind {Cube, Sphere};

struct shape {
    virtual ~shape() {}
    virtual shape_kind kind() = 0;
};

struct cube : public shape {
    shape_kind kind() { return Cube; }
};
struct sphere : public shape {
    shape_kind kind() { return Sphere; }
};

shared_ptr&lt;shape&gt; parse(const vector&lt;uint8_t&gt; data) {
    if (&lt;data represents a cube&gt;) {
        return shared_ptr&lt;shape&gt;(new cube);
    } else {
        return shared_ptr&lt;shape&gt;(new sphere);
    }
}
</code></pre>

<p><a href=""http://ideone.com/PK6I0c"" rel=""nofollow noreferrer"">Demo.</a></p>
"
"<p>void find_struct(vector  input, cube &amp;c1, sphere &amp;sp1)
{</p>

<pre><code>if ( input[0] == 0x10 )
{
    c1.width = input[1];
    c1.volume = input[2];
}
else if (input[0] == 0x20)
{
    sp1.diameter = input[1];
    sp1.mass = input[2];
}
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>vector &lt;unsigned int&gt; input1 = { 0x10, 0x02, 0x03 };
vector &lt;unsigned int&gt; input2 = { 0x20, 0x05, 0x02 };

cube c1;
c1.volume = 0;
c1.width = 0;

sphere s1;
s1.diameter = 0;
s1.mass = 0;

find_struct(input1,c1,s1);

if (c1.volume != 0)
{
    std::cout &lt;&lt; ""cube is returned"" &lt;&lt; std::endl;
}
if (s1.diameter != 0)
{
    std::cout &lt;&lt; ""sphere is returned"" &lt;&lt; std::endl;
}
</code></pre>

<p>}</p>

<p>As an alternative, assign struct member 0 as default.</p>

<p>Then send both cube and sphere instance to the function <strong><em>find_struct</em></strong>,
This function returns the modified <strong>c1</strong> ans <strong>sp1</strong></p>

<p>Check if struct value is not zero !!!!</p>
"
"<p>Only to keep it simple and still <em>correct</em> I think it is better to keep the approach suggested by m.antkowicz and return a pointer to a base object inorder to provide a polymorphic behavior:</p>

<pre><code>struct shape {
    //...
};

struct cube: shape { };
struct sphere: shape { };

// ---

shape* foo(vector&lt;uint8_&gt; v) {
    //...
}
</code></pre>

<p>In this way your method will be able to return either a sphere or a cube, or even add new shapes easily in the future with no breaking changes.</p>

<p>Of course that instead of returning a simple pointer to shape (<code>shape*</code>) it could be a smart pointer as <code>std::shared_ptr&lt;shape&gt;</code> but for now I find important to keep the answer simple and focused on the actual solution.</p>
"
"<p>Here is a proposal based on union and with a strong C-flavor, i.e. little object orientation.<br>
(OP invited a proposal with unions, I guess the often quoted risks of unions are not a problem for the sake of this discussion.)<br>
The main design descion is the use of a union.  </p>

<p>UPDATE: Change to API with return value.</p>

<p>I added demonstrator code, showing the possibility of using information available inside the variable for error handling and for detecting the kind of shape.<br>
I believe that any client code (which handles the result of the parser) needs to find out which kind of shape is inside. It is not enough to design an API which can use a single datatype.<br>
I speculate (not blaming OP for lack of info) that if different parts of client code could be called, each of which implicitly being aware of the kind of shapes it receives,<br>
then there would not be a need to find a data design to carry all shapes in one type.</p>

<pre><code>typedef enum tenCubeOrSphere_tag
{
    nenInvalid   = 0x0,
    nenCube      = 0x10,
    nenSphere    = 0x20
} tenCubeOrSphere;

typedef struct tstCube_tag
{
    tenCubeOrSphere enWhich;
    // Note that this is the same for cube and for sphere

    int width;
    int volume;
} tstCube;

typedef struct tstSphere_tag
{
    tenCubeOrSphere enWhich;
    // Note that this is the same for cube and for sphere

    int diameter;
    int mass;
} tstSphere;

typedef union tunShape_tag
{
    tstCube   Cube;
    tstSphere Sphere;
    tstCube   Unknown;
    /* just for selfexplaining client code,
       could also be tstSphere, same thing */
} tunShape;

// That's it, below is just demonstrator code.

tunShape parse(/* assume here an input parameter,
               a reference to parseable vector */)
{   tunShape Out;

    { /* parsing happens here,
         assume it finds a cube */
         Out.Cube.enWhich=nenCube;
         Out.Cube.volume = /* let's say ... */   5;
         Out.Cube.width  = /* hmm...        */ 125;

      /* in case of sphere */
         Out.Sphere.enWhich =nenSphere;
         Out.Sphere.diameter= /* let's say ... */ 30;
         Out.Sphere.mass    = /* hmm...        */ 14000;
    }

    return Out;
}

void client (void)
{   tunShape unReceiver;
    unReceiver = parse(/* iput vector */);
    if        (unReceiver.Unknown.enWhich == nenInvalid)
    {/* error handling */
    } else if (unReceiver.Unknown.enWhich == nenCube)
    {   std::cout &lt;&lt; ""It is a cube: ""   &lt;&lt; unReceiver.Cube.volume &lt;&lt; "","" &lt;&lt; unReceiver.Cube.width &lt;&lt; std::endl;
    } else /* obviously a sphere */
    {   std::cout &lt;&lt; ""It is a sphere: "" &lt;&lt; unReceiver.Sphere.mass &lt;&lt; "","" &lt;&lt; unReceiver.Sphere.diameter &lt;&lt; std::endl;
    }
}
</code></pre>
"
"<p>Technically when certain allocation fails then Kernel will try to free memory.Depending upon memory failures(soft failure/hard failure). Hard failures causes Kernel to enter into direct reclaim path. Direct reclaim is costly operation which might take undefined time to complete and even after that allocation might fail.</p>

<p>Here you have two options:</p>

<p>1) Play with VM settings like dirty_ratio,dirty_background_ratio etc to maintain free ram. see : <a href=""https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/s-memory-tunables.html"" rel=""nofollow"">https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/s-memory-tunables.html</a></p>

<p>2) Write a kernel daemon, which calls kernel function which handles drop_cache (because drop_cache migh sleep). </p>
"
"<p><strong>TL;DR</strong> : Scan for active superblocks and drop references to non-dirty ones until you have reclaimed as much system memory as you need. (or you finally run out of references to active superblocks.)</p>

<hr>

<blockquote>
  <p>How to write kernel code to dynamically shrink the <strong>fs page-cache</strong>,<br>
  to recover just enough space so that a subsequent call to <code>dma_alloc_coherent()</code> succeeds?</p>
</blockquote>

<p>To answer this question, let us take a look at what the ""<code>drop_caches</code> operation"" did to reduce the fs page-cache from 27GB to 94MB on your system.</p>

<ol>
<li><p><code>echo 1 &gt; /proc/sys/vm/drop_caches</code><br>
invokes<br>
<a href=""http://lxr.free-electrons.com/source/fs/drop_caches.c#L40"" rel=""nofollow""><code>drop_caches_sysctl_handler()</code></a></p></li>
<li><p>which in turn invokes <a href=""http://lxr.free-electrons.com/source/fs/super.c#L497"" rel=""nofollow""><code>iterate_supers()</code></a> and<br>
passes it the pointer to the function <a href=""http://lxr.free-electrons.com/source/fs/drop_caches.c#L16"" rel=""nofollow""><code>drop_pagecache_sb()</code></a>.</p></li>
</ol>

<p>What happens next is that <code>iterate_supers()</code> scans for active superblocks and everytime it finds one, it calls <code>drop_pagecache_sb()</code>, passing it a reference to the active superblock.</p>

<p>This iterative procedure continues until references to all the active superblocks are freed from the fs page-cache. This is a non-destructive operation and will only free blocks that are completely unused. Dirty-objects will continue to be in use until written out to disk and are not free-able. If you run <code>sync</code> first to flush them out to disk, the ""<code>drop_caches</code> operation"" tends to free more memory.</p>

<blockquote>
  <p>Since you are interested in running this process to reclaim a limited/known amount of memory i.e. what is soon going to be requested using <code>dma_alloc_coherent()</code>, you simply need to implement the above functionality with an additional check at the end of each iteration and abort the superblock scan immediately once the amount of free system memory crosses the desired level.</p>
</blockquote>

<hr>

<p>A couple of points to keep in mind to further optimise this procedure :</p>

<ul>
<li><p><strong>Is there a preference for certain block devices over others?</strong><br>
You may want to iterate over active superblocks of the block devices that you do not care about first. If enough memory is not reclaimed, then scan the block devices that you would prefer to retain in the fs page-cache unless absolutely necessary to reclaim required memory. <a href=""http://lxr.free-electrons.com/source/fs/super.c#L631"" rel=""nofollow"">get_active_super()</a> might be of help here.</p></li>
<li><p><strong><a href=""http://lxr.free-electrons.com/source/fs/super.c#L532"" rel=""nofollow"">iterate_supers_type()</a> seems interesting</strong><br>
It allows one to iterate over superblocks of specific <a href=""http://lxr.free-electrons.com/source/include/linux/fs.h#L1892"" rel=""nofollow"">file_system_type</a></p></li>
</ul>

<p><sub>
<em>Please note that this is a speculative solution based purely on the analysis of existing code within the Linux kernel that you have observed to already solve your problem. Once the above approach is implemented, it will only allow you to control the same i.e. attempt to reclaim fs page-cache memory only to the extent required for your immediate needs.</em>
</sub></p>
"
"<p>FAT (and similarly VFAT) file systems don't actually store inode numbers on disk. Instead, Linux invents inode numbers on-the-fly for files as they are seen. These generated inode numbers are stored in a cache to try and keep them consistent, but this cache has a fixed size; once it is full, older entries are thrown away.</p>

<p>Presumably the act of mounting your second filesystem is sufficient to cause the inode number cache on the VFAT filesystem to forget about your files, causing new inode numbers to be allocated, and presenting the problem you observe.</p>

<p>More information:</p>

<ul>
<li><a href=""http://www.mail-archive.com/bug-findutils@gnu.org/msg01212.html"" rel=""noreferrer"">Discussion</a> about a bug related to this problem on the findutils mailing list</li>
<li>Linux kernel sources: <a href=""http://www.kneuro.net/cgi-bin/lxr/http/source/fs/fat/inode.c?a=ppc#L133"" rel=""noreferrer"">fs/fat/inode.c</a> (in particular, the call to <code>iunique</code> in <code>fat_build_inode</code> which performs the inode number allocation).</li>
</ul>
"
"<p>Not sure it's fastest (will depend on the number of duplicates,etc), but you can join two copies of the data together, and then drop duplicates (middle line is to randomise the row-order, so the chosen one is truly random):</p>

<pre><code>mirrored &lt;- rbind (dframe, dframe[,c(1,3,2)])
mirrored &lt;- mirrored[sample(nrow(mirrored)),]
dedup &lt;- mirrored[!duplicated(mirrored),]
</code></pre>
"
"<p>I assume that <em>random choice</em> means that it does not matter which bidirectional hit we choose:</p>

<pre><code>df &lt;- read.table(textConnection(""V1 V2 V3
1  T  Y
1  Y  T
1  O  P
2  Q  E
2  E  Q
2  C  V
2  V  C
2  Y  T""), header=TRUE)

rows1 &lt;- apply(df, 1, paste0, collapse="""")
## swap the order of column 2,3
rows2 &lt;- apply(df[, c(1, 3:2)], 1, paste0, collapse="""")

rows &lt;- rbind(rows1, rows2)
rows
#       [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]
# rows1 ""1TY"" ""1YT"" ""1OP"" ""2QE"" ""2EQ"" ""2CV"" ""2VC"" ""2YT""
# rows2 ""1YT"" ""1TY"" ""1PO"" ""2EQ"" ""2QE"" ""2VC"" ""2CV"" ""2TY""

vrows &lt;- as.vector(rows)
vrows
# [1] ""1TY"" ""1YT"" ""1YT"" ""1TY"" ""1OP"" ""1PO"" ""2QE"" ""2EQ""
# [9] ""2EQ"" ""2QE"" ""2CV"" ""2VC"" ""2VC"" ""2CV"" ""2YT"" ""2TY""

iunique &lt;- which(!duplicated(vrows))
iunique
#  [1]  1  2  5  6  7  8 11 12 15 16

## because of the rbind above we have need only every second entry and
## divide it by 2
i &lt;- iunique[seq(2, length(iunqiue), by=2)]/2

df[i, ]
#   V1 V2 V3
# 1  1  T  Y
# 3  1  O  P
# 4  2  Q  E
# 6  2  C  V
# 8  2  Y  T
</code></pre>
"
"<p>You seem to have answered your questions yourself :)</p>

<p>Let's consider the case of EXT4:</p>

<p>The file system inode is stored on disk in the format as exactly described by <code>struct ext4_inode</code>. The <code>struct ext4_inode_info</code> is just an in-memory representation of the same. The VFS inode also an in-memory object that contains inode information that is common irrespective of the file system type and thus can be abstracted. It is allocated from the inode cache (a memory pool got using the slab allocator).The VFS struct inode is embedded in the filesystem specific in-memory struct inode. For example, <code>struct ext4_inode_info</code> has a member called <code>struct inode vfs_inode</code>. Given a VFS inode, you can get the FS specific inode using the standard container_of macro found in the kernel code. Thus any FS can get to it's own inode struct when it is handed over the generic inode struct by VFS.</p>

<p>Checkout what happens when a new inode is created using <a href=""http://lxr.free-electrons.com/source/fs/ext4/ialloc.c?v=4.6#L742"" rel=""nofollow"">__ext4_new_inode()</a></p>

<p>FAT usually stores the metadata (i.e. inode information) on a directory entry. So the linux fat driver just <a href=""http://lxr.free-electrons.com/source/fs/fat/inode.c?v=4.6#L502"" rel=""nofollow"">reads</a> it, populates the necessary fields in memory. Since there's no concept of inodes in FAT, the inode number is a random number- a call to iunique() to be precise.</p>

<p>Some good resources on VFS:</p>

<p><a href=""http://www.win.tue.nl/~aeb/linux/lk/lk-8.html"" rel=""nofollow"">http://www.win.tue.nl/~aeb/linux/lk/lk-8.html</a></p>

<p><a href=""http://lxr.free-electrons.com/source/Documentation/filesystems/vfs.txt"" rel=""nofollow"">http://lxr.free-electrons.com/source/Documentation/filesystems/vfs.txt</a></p>
"
"<p>Seen the large number of calls into kernel routines, it looks that your code is writing/mapping files on a journaled file system. Unless you really need the features that this provides this is probably not a good idea if your code is performance critical.</p>

<ul>
<li>If you just need that your data is stored somewhere, use a plain file
system that doesn't need much of a translation.</li>
<li>If you don't need that it is stored, use anonymous mappings.</li>
<li>If you need it to be stored, but you can afford that it is only
writen to real disk at the very end, use an in-memory file system
(<code>tmpfs</code> or similar) and just copy it to a real disk once your
computation is finished.</li>
</ul>
"
"<p>Try using an AVL instead of a heap. In my experience AVL is usually faster in practice, unless you're making heavy use of the heap features.</p>
"
"<p>Well, it's a warning, a debugging feature. Your kernel has CONFIG_DETECT_HUNG_TASK feature enabled. As per CONFIG_DETECT_HUNG_TASK description (took from kernel config option help section  <a href=""http://lxr.linux.no/linux+"" rel=""nofollow"">http://lxr.linux.no/linux+</a>*/lib/Kconfig.debug#L264):</p>

<pre><code> ""When a hung task is detected, the kernel will print the  current stack trace
 (which you should report), but the task will stay in uninterruptible state.""
</code></pre>

<p>And, this is the reason. You had few process stuck for more than 120 sec on uninterrruptible state. If you want to clean it up, just
do the followings:</p>

<pre><code>          ""echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs""
</code></pre>
"
"<p>Upgrading to a newer kernel (Debian Wheezy) magically solved this problem.</p>
"
"<p>From the last few lines of the logs you can see the kernel reports a total-vm usage 71339176kB (~71GiB) while total vm should include both your physical memory and swap space. Also your log shows resident memory about ~69GiB. </p>

<blockquote>
  <p>Is my understanding of fragmentation correct in this case?</p>
</blockquote>

<p>If your capturing system diagnostics during the time the issue occured or sosreport, check the <code>/proc/buddyinfo</code> file for any memory fragmentation. Its best to write a script and backup this info if you are planning to reproducing this.</p>

<blockquote>
  <p>How can I figure why the memory got so fragmented?
     What can I do to avoid getting into this situation.
  Sometimes applications overcommit memory which the system is unable to honour potentially leading to OOM. You may want to modify and check the other kernel tunable or try to disable memory overcommitting using <code>sysctl -a</code> for reading the set values.</p>
</blockquote>

<p><code>
    vm.overcommit_memory=2
    vm.overcommit_ratio=80
</code></p>

<p>Note: After adding the above lines in <code>/etc/sysctl.conf</code> its best to restart the system. </p>

<p>vm.overcommit: some apps require to alloc more virtual memory for the program, more then what is available on the system.
vm.overcommit take different value, 0 - a heuristic overcommit algorithm is used<br>
1 - always overcommit regardless of whether memory is available or not (most likely set on your server its set to 0 or 1).
2 - this tell the kernel to allow apps to commit all swap + %of ram, for this the below value should also be set (ex: set to 80%)
2-  using this would disallow overcommiting the memory usage (beyond the available RAM + 80% of swap space) </p>
"
"<p>Understanding of fragmentation is incorrect. The oom was issued because of memory watermarks were broken. Take a look at this:</p>

<pre><code>Node 0 Normal free:34728kB min:42952kB low:53688kB
Node 1 Normal free:33484kB min:45096kB low:56368kB
</code></pre>
"
"<p>Updating with slabinfo This is after the node was rebooted. </p>

<pre><code># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;
kvm_async_pf           0      0    136   30    1 : tunables    0    0    0 : slabdata      0      0      0
kvm_vcpu               0      0  16256    2    8 : tunables    0    0    0 : slabdata      0      0      0
kvm_mmu_page_header      0      0    168   48    2 : tunables    0    0    0 : slabdata      0      0      0
fusion_ioctx        5005   5005    296   55    4 : tunables    0    0    0 : slabdata     91     91      0
fusion_user_ll_request      0      0   3960    8    8 : tunables    0    0    0 : slabdata      0      0      0
ext4_groupinfo_4k 131670 131670    136   30    1 : tunables    0    0    0 : slabdata   4389   4389      0
ip6_dst_cache       1260   1260    384   42    4 : tunables    0    0    0 : slabdata     30     30      0
UDPLITEv6              0      0   1088   30    8 : tunables    0    0    0 : slabdata      0      0      0
UDPv6                330    330   1088   30    8 : tunables    0    0    0 : slabdata     11     11      0
tw_sock_TCPv6        128    128    256   32    2 : tunables    0    0    0 : slabdata      4      4      0
TCPv6                288    288   1984   16    8 : tunables    0    0    0 : slabdata     18     18      0
kcopyd_job             0      0   3312    9    8 : tunables    0    0    0 : slabdata      0      0      0
dm_uevent              0      0   2632   12    8 : tunables    0    0    0 : slabdata      0      0      0
cfq_queue              0      0    232   35    2 : tunables    0    0    0 : slabdata      0      0      0
bsg_cmd                0      0    312   52    4 : tunables    0    0    0 : slabdata      0      0      0
mqueue_inode_cache     36     36    896   36    8 : tunables    0    0    0 : slabdata      1      1      0
fuse_request           0      0    416   39    4 : tunables    0    0    0 : slabdata      0      0      0
fuse_inode             0      0    768   42    8 : tunables    0    0    0 : slabdata      0      0      0
ecryptfs_key_record_cache      0      0    576   28    4 : tunables    0    0    0 : slabdata      0      0      0
ecryptfs_inode_cache      0      0   1024   32    8 : tunables    0    0    0 : slabdata      0      0      0
fat_inode_cache        0      0    712   46    8 : tunables    0    0    0 : slabdata      0      0      0
fat_cache              0      0     40  102    1 : tunables    0    0    0 : slabdata      0      0      0
hugetlbfs_inode_cache     54     54    600   54    8 : tunables    0    0    0 : slabdata      1      1      0
jbd2_journal_handle   2040   2040     48   85    1 : tunables    0    0    0 : slabdata     24     24      0
jbd2_journal_head   5071   5364    112   36    1 : tunables    0    0    0 : slabdata    149    149      0
jbd2_revoke_table_s   1792   1792     16  256    1 : tunables    0    0    0 : slabdata      7      7      0
jbd2_revoke_record_s   1536   1536     32  128    1 : tunables    0    0    0 : slabdata     12     12      0
ext4_inode_cache   75129  78771    984   33    8 : tunables    0    0    0 : slabdata   2387   2387      0
ext4_free_data      5952   6656     64   64    1 : tunables    0    0    0 : slabdata    104    104      0
ext4_allocation_context    768    768    128   32    1 : tunables    0    0    0 : slabdata     24     24      0
ext4_io_end         1344   1344     72   56    1 : tunables    0    0    0 : slabdata     24     24      0
ext4_extent_status  37921  38352     40  102    1 : tunables    0    0    0 : slabdata    376    376      0
dquot                768    768    256   32    2 : tunables    0    0    0 : slabdata     24     24      0
dnotify_mark         782    782    120   34    1 : tunables    0    0    0 : slabdata     23     23      0
pid_namespace          0      0   2192   14    8 : tunables    0    0    0 : slabdata      0      0      0
posix_timers_cache      0      0    248   33    2 : tunables    0    0    0 : slabdata      0      0      0
UDP-Lite               0      0    896   36    8 : tunables    0    0    0 : slabdata      0      0      0
xfrm_dst_cache         0      0    448   36    4 : tunables    0    0    0 : slabdata      0      0      0
ip_fib_trie          146    146     56   73    1 : tunables    0    0    0 : slabdata      2      2      0
UDP                  828    828    896   36    8 : tunables    0    0    0 : slabdata     23     23      0
tw_sock_TCP          992   1152    256   32    2 : tunables    0    0    0 : slabdata     36     36      0
TCP                  450    450   1792   18    8 : tunables    0    0    0 : slabdata     25     25      0
blkdev_queue         120    136   1896   17    8 : tunables    0    0    0 : slabdata      8      8      0
blkdev_requests     3358   3569    376   43    4 : tunables    0    0    0 : slabdata     83     83      0
blkdev_ioc           964   1287    104   39    1 : tunables    0    0    0 : slabdata     33     33      0
user_namespace         0      0    264   31    2 : tunables    0    0    0 : slabdata      0      0      0
sock_inode_cache    1377   1377    640   51    8 : tunables    0    0    0 : slabdata     27     27      0
net_namespace          0      0   4736    6    8 : tunables    0    0    0 : slabdata      0      0      0
shmem_inode_cache   2112   2112    672   48    8 : tunables    0    0    0 : slabdata     44     44      0
ftrace_event_file   1196   1196     88   46    1 : tunables    0    0    0 : slabdata     26     26      0
taskstats            196    196    328   49    4 : tunables    0    0    0 : slabdata      4      4      0
proc_inode_cache   63037  63250    648   50    8 : tunables    0    0    0 : slabdata   1265   1265      0
sigqueue            1224   1224    160   51    2 : tunables    0    0    0 : slabdata     24     24      0
bdev_cache           819    819    832   39    8 : tunables    0    0    0 : slabdata     21     21      0
kernfs_node_cache  54360  54360    112   36    1 : tunables    0    0    0 : slabdata   1510   1510      0
mnt_cache            510    510    320   51    4 : tunables    0    0    0 : slabdata     10     10      0
inode_cache        16813  19712    584   28    4 : tunables    0    0    0 : slabdata    704    704      0
dentry            144206 144606    192   42    2 : tunables    0    0    0 : slabdata   3443   3443      0
iint_cache             0      0     72   56    1 : tunables    0    0    0 : slabdata      0      0      0
buffer_head       6905641 6922305    104   39    1 : tunables    0    0    0 : slabdata 177495 177495      0
vm_area_struct     16764  16764    184   44    2 : tunables    0    0    0 : slabdata    381    381      0
mm_struct           1008   1008    896   36    8 : tunables    0    0    0 : slabdata     28     28      0
files_cache         1377   1377    640   51    8 : tunables    0    0    0 : slabdata     27     27      0
signal_cache        1380   1380   1088   30    8 : tunables    0    0    0 : slabdata     46     46      0
sighand_cache       1020   1020   2112   15    8 : tunables    0    0    0 : slabdata     68     68      0
task_xstate         1638   1638    832   39    8 : tunables    0    0    0 : slabdata     42     42      0
task_struct          837    855   6480    5    8 : tunables    0    0    0 : slabdata    171    171      0
Acpi-ParseExt       2968   2968     72   56    1 : tunables    0    0    0 : slabdata     53     53      0
Acpi-State           561    561     80   51    1 : tunables    0    0    0 : slabdata     11     11      0
Acpi-Namespace      3162   3162     40  102    1 : tunables    0    0    0 : slabdata     31     31      0
anon_vma           19313  19584     64   64    1 : tunables    0    0    0 : slabdata    306    306      0
shared_policy_node   7735   7735     48   85    1 : tunables    0    0    0 : slabdata     91     91      0
numa_policy          170    170     24  170    1 : tunables    0    0    0 : slabdata      1      1      0
radix_tree_node   2870899 2871624    584   28    4 : tunables    0    0    0 : slabdata 102558 102558      0
idr_layer_cache      555    555   2112   15    8 : tunables    0    0    0 : slabdata     37     37      0
dma-kmalloc-8192       0      0   8192    4    8 : tunables    0    0    0 : slabdata      0      0      0
dma-kmalloc-4096       0      0   4096    8    8 : tunables    0    0    0 : slabdata      0      0      0
dma-kmalloc-2048       0      0   2048   16    8 : tunables    0    0    0 : slabdata      0      0      0
dma-kmalloc-1024       0      0   1024   32    8 : tunables    0    0    0 : slabdata      0      0      0
dma-kmalloc-512        0      0    512   32    4 : tunables    0    0    0 : slabdata      0      0      0
dma-kmalloc-256        0      0    256   32    2 : tunables    0    0    0 : slabdata      0      0      0
dma-kmalloc-128        0      0    128   32    1 : tunables    0    0    0 : slabdata      0      0      0
dma-kmalloc-64         0      0     64   64    1 : tunables    0    0    0 : slabdata      0      0      0
dma-kmalloc-32         0      0     32  128    1 : tunables    0    0    0 : slabdata      0      0      0
dma-kmalloc-16         0      0     16  256    1 : tunables    0    0    0 : slabdata      0      0      0
dma-kmalloc-8          0      0      8  512    1 : tunables    0    0    0 : slabdata      0      0      0
dma-kmalloc-192        0      0    192   42    2 : tunables    0    0    0 : slabdata      0      0      0
dma-kmalloc-96         0      0     96   42    1 : tunables    0    0    0 : slabdata      0      0      0
kmalloc-8192         180    180   8192    4    8 : tunables    0    0    0 : slabdata     45     45      0
kmalloc-4096         636    720   4096    8    8 : tunables    0    0    0 : slabdata     90     90      0
kmalloc-2048        6498   6688   2048   16    8 : tunables    0    0    0 : slabdata    418    418      0
kmalloc-1024        4677   4800   1024   32    8 : tunables    0    0    0 : slabdata    150    150      0
kmalloc-512         9029   9056    512   32    4 : tunables    0    0    0 : slabdata    283    283      0
kmalloc-256        31542  31840    256   32    2 : tunables    0    0    0 : slabdata    995    995      0
kmalloc-192        16548  16548    192   42    2 : tunables    0    0    0 : slabdata    394    394      0
kmalloc-128         8449   8544    128   32    1 : tunables    0    0    0 : slabdata    267    267      0
kmalloc-96         20607  21462     96   42    1 : tunables    0    0    0 : slabdata    511    511      0
kmalloc-64         71408  75968     64   64    1 : tunables    0    0    0 : slabdata   1187   1187      0
kmalloc-32          5760   5760     32  128    1 : tunables    0    0    0 : slabdata     45     45      0
kmalloc-16         13824  13824     16  256    1 : tunables    0    0    0 : slabdata     54     54      0
kmalloc-8          45056  45056      8  512    1 : tunables    0    0    0 : slabdata     88     88      0
kmem_cache_node      551    576     64   64    1 : tunables    0    0    0 : slabdata      9      9      0
kmem_cache           256    256    256   32    2 : tunables    0    0    0 : slabdata      8      8      0
</code></pre>
"
"<p>Because of this as far as i can see: block_start &lt; from || block_end > to (respecting other conditions of course, buffer_uptodate() etc.) .
i.e. bio will write a whole block so if a region to be updated smaller than submited block you obviously need a fresh copy.</p>
"
"<p>In essence you're bypassing the kernels IO scheduler completely.</p>

<p>If you look at the ext2 implementation you'll see it never (well ok, once) calls <code>write_one_page()</code>. For large-scale data transfers it uses <code>mpage_writepages()</code> instead.</p>

<p>This uses the Block I/O interface, rather than immediately accessing the hardware. This means it passes through the IO scheduler. Large operations will not block the entire systems, as the scheduler will automatically ensure that other operations are interleaved with the large writes.</p>
"
"<p>First of all. You have no error checking. You have only coded your happy path.
Check that your mallocs dont return NULL!!!</p>

<pre><code>if (malloc returned NULL){
          free memory
          exit(error_code)
}
</code></pre>

<p>Then</p>

<pre><code> I-&gt;nodes[i] = new_inode( next_n );
 I-&gt;nodes[i] = gen_itree( I-&gt;nodes[i], next_level );
</code></pre>

<p>This part is quite unclear. You could do this</p>

<pre><code> I-&gt;nodes[i] = gen_itree( new_inode( next_n ), next_level );
</code></pre>

<p>Same goes here</p>

<pre><code>I = new_inode( 2 );
I = gen_itree(I,3);
</code></pre>

<p>could be </p>

<pre><code> I = gen_itree(new_inode( 2 ),3);
</code></pre>

<p>Also, dont forget to free your allocated memory.</p>

<p>As for (d)</p>

<pre><code>unsigned int get_node_count(inode* i){
    unsigned int counter =0;

    if (!i-&gt;nodes) return 0;

     //pseudocode
     for each inode* node in i-&gt;nodes{
        counter++
        counter+= get_node_count(node);//accumulate node count in child node
     }

      return counter;
</code></pre>
"
"<p>Everything looks pretty good. I wouldn't put printf's inside the function unless its for debugging purposes.</p>

<pre><code>#define RANGE 3 // this eliminates 'magic constants'

//Generating tree with random-number of nodes:
inode *gen_itree( inode *I, int nlevels ){
        int i, next_level, next_n;

    if ( nlevels ) { // if nlevels != 0
        next_level = nlevels - 1;
        for ( i = 0; i &lt; I-&gt;n; i++ ) {
            next_n = rand( ) % RANGE; // no need for a zero
            I-&gt;nodes[i] = new_inode( next_n );
            I-&gt;nodes[i] = gen_itree( I-&gt;nodes[i], next_level );
        }
    }

    return I;
}
</code></pre>

<p>That looks better, but I would even go one step further and eliminate some unnecessary local variables, since they are only used once (except for int i). </p>

<p>For (c), this should work:</p>

<pre><code>//This computes the C's for all nodes under this, including this node
int computeAllCs( inode *I ){
        int i;
        I-&gt;c = 0;
        for ( i = 0; i &lt; I-&gt;n; i++ )
            I-&gt;c += computeAllCs(I-&gt;nodes[i]) + 1;
}
</code></pre>

<p>Mind you that ""all recursive functions can be written iteratively (aka loop)"", so you might want to consider the iterative solutions.</p>
"
"<p>I won't directly answer your question, so I apologize in advance for that.</p>

<p>The tmpfs idea is good, but I wouldn't have my program depend on a more or less obscure implementation detail for generating keys. Why don't you try another method, such as combining the inode number with some other information? Maybe modification date: it's impossible two files get the same inode number AND modification date at the time of key-generation, unless system date changes.</p>

<p>Cheers!</p>
"
"<p>The bulk of the tmpfs code is in <code>mm/shmem.c</code>.  New inodes are created by</p>

<pre><code>static struct inode *shmem_get_inode(struct super_block *sb, const struct inode *dir,
                                 int mode, dev_t dev, unsigned long flags)
</code></pre>

<p>but it delegates almost everything to the generic filesystem code.  </p>

<p>In particular, the field <code>i_ino</code> is filled in in <code>fs/inode.c</code>:</p>

<pre><code>/**
 *      new_inode       - obtain an inode
 *      @sb: superblock
 *
 *      Allocates a new inode for given superblock. The default gfp_mask
 *      for allocations related to inode-&gt;i_mapping is GFP_HIGHUSER_MOVABLE.
 *      If HIGHMEM pages are unsuitable or it is known that pages allocated
 *      for the page cache are not reclaimable or migratable,
 *      mapping_set_gfp_mask() must be called with suitable flags on the
 *      newly created inode's mapping
 *
 */
struct inode *new_inode(struct super_block *sb)
{
        /*
         * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW
         * error if st_ino won't fit in target struct field. Use 32bit counter
         * here to attempt to avoid that.
         */
        static unsigned int last_ino;
        struct inode *inode;

        spin_lock_prefetch(&amp;inode_lock);

        inode = alloc_inode(sb);
        if (inode) {
                spin_lock(&amp;inode_lock);
                __inode_add_to_lists(sb, NULL, inode);
                inode-&gt;i_ino = ++last_ino;
                inode-&gt;i_state = 0;
                spin_unlock(&amp;inode_lock);
        }
        return inode;
}
</code></pre>

<p>And it does indeed just use an incrementing counter (last_ino).</p>

<p>Most other filesystems use information from the on-disk files to later override the <code>i_ino</code> field.</p>

<p>Note that it's perfectly possible for this to wrap all the way around.  The kernel also has a ""generation"" field that gets filled in various ways.  <code>mm/shmem.c</code> uses the current time.</p>
"
"<p><a href=""http://www.nongnu.org/ext2-doc/ext2.html#AEN1729"" rel=""nofollow"">Dave Poirier - The Second Extended File System: Internal Layout - 3.6. Locating an Inode</a> says:</p>

<blockquote>
  <p>Knowing that inode 1 is the first inode defined in the inode table,
  one can use the following formulaes:</p>

  <p><code>block group = (inode - 1) / s_inodes_per_group</code></p>
</blockquote>

<p>Here we could say with Joachim Pileborg <code>- 1</code> is there to ""make it zero-based"".</p>

<p>But then, the <code>- 1</code> in</p>

<pre><code>desc = block_group &amp; (EXT2_DESC_PER_BLOCK(inode-&gt;i_sb) - 1);
</code></pre>

<p>has nothing to do with making something zero-based; it's another way of writing</p>

<pre><code>desc = block_group % EXT2_DESC_PER_BLOCK(inode-&gt;i_sb);
</code></pre>

<p>since the number of block group descriptors per block of storage is a power of 2.</p>
"
"<p>To make it zero-based. As you can see, the <code>i_ino</code> field in <code>fs/inode.c</code> is incremented with <code>++last_ino</code>. <br>It makes the first <code>i_ino</code> equal to 1. </p>

<pre><code>/**
 *      new_inode       - obtain an inode
 *      @sb: superblock
 *
 *      Allocates a new inode for given superblock. The default gfp_mask
 *      for allocations related to inode-&gt;i_mapping is GFP_HIGHUSER_MOVABLE.
 *      If HIGHMEM pages are unsuitable or it is known that pages allocated
 *      for the page cache are not reclaimable or migratable,
 *      mapping_set_gfp_mask() must be called with suitable flags on the
 *      newly created inode's mapping
 *
 */
struct inode *new_inode(struct super_block *sb)
{
    /*
     * On a 32bit, non LFS stat() call, glibc will generate an EOVERFLOW
     * error if st_ino won't fit in target struct field. Use 32bit counter
     * here to attempt to avoid that.
     */
    static unsigned int last_ino;
    struct inode *inode;

    spin_lock_prefetch(&amp;inode_lock);

    inode = alloc_inode(sb);
    if (inode) {
            spin_lock(&amp;inode_lock);
            __inode_add_to_lists(sb, NULL, inode);
            inode-&gt;i_ino = ++last_ino;
            inode-&gt;i_state = 0;
            spin_unlock(&amp;inode_lock);
    }
    return inode;
}
</code></pre>
"
"<p>path_get sounds fine. Check out an example here <a href=""http://tomoyo.sourceforge.jp/cgi-bin/lxr/source/fs/pipe.c#L1046"" rel=""nofollow noreferrer"">http://tomoyo.sourceforge.jp/cgi-bin/lxr/source/fs/pipe.c#L1046</a> and you'll be able to find more refs there if you need them.</p>
"
"<p>It's a bug of Kernel's fanotify.
I posted a patch to Linux-Kernel:
When multiple threadsiterate the same direcotry, some thread will hang.
This patch let fanotify differentiate access events from different
threads, prevent fanotify from merging access events from different
threads.</p>

<p><a href=""http://marc.info/?l=linux-kernel&amp;m=131822913806350&amp;w=2"" rel=""nofollow"">http://marc.info/?l=linux-kernel&amp;m=131822913806350&amp;w=2</a></p>

<pre><code>    -------------------------------

    diff -r -u linux-3.1-rc4_orig/fs/notify/fanotify/fanotify.c
    linux-3.1-rc4/fs/notify/fanotify/fanotify.c
    --- linux-3.1-rc4_orig/fs/notify/fanotify/fanotify.c    2011-08-29
    12:16:01.000000000 +0800
    +++ linux-3.1-rc4/fs/notify/fanotify/fanotify.c 2011-10-10
    12:28:23.276847000 +0800
    @@ -15,7 +15,8 @@

            if (old-&gt;to_tell == new-&gt;to_tell &amp;&amp;
                old-&gt;data_type == new-&gt;data_type &amp;&amp;
    -           old-&gt;tgid == new-&gt;tgid) {
    +           old-&gt;tgid == new-&gt;tgid &amp;&amp;
    +           old-&gt;pid == new-&gt;pid) {
                    switch (old-&gt;data_type) {
                    case (FSNOTIFY_EVENT_PATH):
                            if ((old-&gt;path.mnt == new-&gt;path.mnt) &amp;&amp;
    @@ -144,11 +145,19 @@
                    return PTR_ERR(notify_event);

     #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
    -       if (event-&gt;mask &amp; FAN_ALL_PERM_EVENTS) {
    -               /* if we merged we need to wait on the new event */
    -               if (notify_event)
    -                       event = notify_event;
    -               ret = fanotify_get_response_from_access(group, event);
    +       //if overflow, do not wait for response
    +       if(fsnotify_isoverflow(event))
    +       {
    +               pr_debug(""fanotify overflow!\n"");
    +       }
    +       else
    +       {
    +               if (event-&gt;mask &amp; FAN_ALL_PERM_EVENTS) {
    +                       /* if we merged we need to wait on the new event */
    +                       if (notify_event)
    +                               event = notify_event;
    +                       ret = fanotify_get_response_from_access(group, event);
    +               }
            }
     #endif

    diff -r -u linux-3.1-rc4_orig/fs/notify/notification.c
    linux-3.1-rc4/fs/notify/notification.c
    --- linux-3.1-rc4_orig/fs/notify/notification.c 2011-08-29
    12:16:01.000000000 +0800
    +++ linux-3.1-rc4/fs/notify/notification.c      2011-10-10 12:27:09.331787000 +0800
    @@ -95,6 +95,7 @@
                    BUG_ON(!list_empty(&amp;event-&gt;private_data_list));

                    kfree(event-&gt;file_name);
    +               put_pid(event-&gt;pid);
                    put_pid(event-&gt;tgid);
                    kmem_cache_free(fsnotify_event_cachep, event);
            }
    @@ -132,6 +133,14 @@
            return priv;
     }

    +bool fsnotify_isoverflow(struct fsnotify_event *event)
    +{
    +       if(event==q_overflow_event)
    +       {
    +               return true;
    +       }
    +       return false;
    +}
     /*
      * Add an event to the group notification queue.  The group can later pull this
      * event off the queue to deal with.  If the event is successfully added to the
    @@ -374,6 +383,7 @@
                            return NULL;
                    }
            }
    +       event-&gt;pid = get_pid(old_event-&gt;pid);
            event-&gt;tgid = get_pid(old_event-&gt;tgid);
            if (event-&gt;data_type == FSNOTIFY_EVENT_PATH)
                    path_get(&amp;event-&gt;path);
    @@ -417,6 +427,7 @@
                    event-&gt;name_len = strlen(event-&gt;file_name);
            }

    +       event-&gt;pid = get_pid(task_pid(current));
            event-&gt;tgid = get_pid(task_tgid(current));
            event-&gt;sync_cookie = cookie;
            event-&gt;to_tell = to_tell;
    diff -r -u linux-3.1-rc4_orig/include/linux/fsnotify_backend.h
    linux-3.1-rc4/include/linux/fsnotify_backend.h
    --- linux-3.1-rc4_orig/include/linux/fsnotify_backend.h 2011-08-29
    12:16:01.000000000 +0800
    +++ linux-3.1-rc4/include/linux/fsnotify_backend.h      2011-10-10
    12:27:48.587369000 +0800
    @@ -238,6 +238,7 @@
            u32 sync_cookie;        /* used to corrolate events, namely inotify mv events */
            const unsigned char *file_name;
            size_t name_len;
    +       struct pid *pid;
            struct pid *tgid;

     #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
    @@ -378,6 +379,8 @@
                                                            struct fsnotify_event_private_data *priv,
                                                            struct fsnotify_event *(*merge)(struct list_head *,
                                                                                            struct fsnotify_event *));
    +/*true if the event is an overflow event*/
    +extern bool fsnotify_isoverflow(struct fsnotify_event *event);
     /* true if the group notification queue is empty */
     extern bool fsnotify_notify_queue_is_empty(struct fsnotify_group *group);
     /* return, but do not dequeue the first event on the notification queue */
</code></pre>
"
"<p><code>vfs_stat</code> takes a filename stored in userspace.  But if you trace that call in the source, you'll see (in fs/stat.c) that there are basically two parts.  Lookup the <code>struct path</code> from the userspace filename string, then call the VFS stat operation based on the contents of the path struct.  So you can do the same from kernel space.  Look into <code>kern_path()</code> to look up the <code>struct path</code> for a filename stored in kernel space.  From there, you can call <code>vfs_getattr()</code> directly.  Don't forget to <code>path_put</code> when you're done.</p>

<p>Basically, you're using the important bits of <code>vfs_fstatat()</code>.  But also consider if you can manage without the stat call.  There's an inode pointer somewhere inside the path struct, and that might be good enough for what you're trying to do.</p>
"
"<p>If you look at seq_release:</p>

<pre><code>int seq_release(struct inode *inode, struct file *file)
{
        struct seq_file *m = file-&gt;private_data;
        kvfree(m-&gt;buf);
        kfree(m);
        return 0;
}
</code></pre>

<p>It effectivly does <code>kfree(file-&gt;private_data)</code></p>

<p>Now, <code>file-&gt;private_data</code> is set up in <a href=""http://lxr.free-electrons.com/source/fs/proc_namespace.c#L222"">mounts_open_common</a> as </p>

<pre><code>file-&gt;private_data = &amp;p-&gt;m;
</code></pre>

<p>That's the  <code>p</code> which is <code>kmalloc'd</code> in your question.
The <code>m</code> member isn't a pointer, so that shouldn't be allowed to be freed. However, it's the 1. member of <code>struct proc_mounts</code></p>

<pre><code>struct proc_mounts {
        struct seq_file m;
        struct mnt_namespace *ns;
        struct path root;
        int (*show)(struct seq_file *, struct vfsmount *);
        void *cached_mount;
        u64 cached_event;
        loff_t cached_index;
};
</code></pre>

<p>So <code>seq_release()</code> performs kfree() on the address of the <code>m</code> member, that's the same address as was obtained with <code>p = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);</code></p>

<p>I guess that's not very friendly to a static analyzer. But there's no memory leak. </p>
"
"<p><code>popen</code> doesn't really give you what you want here, as it's a specialized library function. Use the system calls <code>fork</code> and <code>pipe</code> directly instead. </p>

<p>You use <code>fork</code> to create a child process and <code>pipe</code> to redirect <code>stdout</code> back to the parent process.</p>

<p>See <a href=""http://jineshkj.wordpress.com/2006/12/22/how-to-capture-stdin-stdout-and-stderr-of-child-program/"" rel=""nofollow"">this</a> example for details.</p>

<p>This is incidentally exactly what the shell does when you command it to do this:</p>

<pre><code>cat /home/image.img | md5sum &gt; result
</code></pre>
"
"<p>Thanks Henrik,
Here is the code for all of you who wonder how to do it:</p>

<pre><code>int     fd_pipe[2], nbytes, status;
char    pipe_buffer[1000];
memset(pipe_buffer,'\0',1000);

        if(pipe(fd_pipe)!=0)
            {
            perror(""fd_pipe:"");
            exit(EXIT_FAILURE);
            }
        pid = fork();
        if (pid == -1)
            {
            perror(""Fork failed"");
            exit(EXIT_FAILURE);
            }
        else
            {
            if(pid&gt;0) //The parent's part
                {
                // Parent process closes output side of the pipe
                close(fd_pipe[1]);
                //Parent wait's untill the child is done
                wait(&amp;status);
                // Read in a string from the pipe's input side
                nbytes = read(fd_pipe[0], pipe_buffer, sizeof(pipe_buffer));

                printf(""Received %d chars, string: %s \n"", nbytes, pipe_buffer);
                                    //on the end close the other side of pipe
                                    close(fd_pipe[0]);
                }
            else
                {   // The child's part
                /* Child process closes input side of the pipe */
                close(fd_pipe[0]);
                //redirect the stdout(1) to the fd_pipe and then close the sdtout
                dup2(fd_pipe[1],1);
                //Do the thing which creates the result message
                system(""/image/""IMAGE_NAME | md5sum"");

                //on the end close the other side of pipe
                close(fd_pipe[1]);
                exit(0);
                }
            }
</code></pre>
"
"<p>As I noted in my comments, the problem is in the assignment <code>pipes[pipes_count] = new_pipefd;</code> at:</p>

<pre><code>int pipes_count = 0;
int *pipes[MAXCLIENTS];
int new_pipefd[2];
int pipe_bytes;
char pipe_buffer[MAXDATASIZE];

while(1) {
    // Pipe creation
    pipe(new_pipefd);
    pipes[pipes_count] = new_pipefd;
    pipes_count++;
</code></pre>

<p>The trouble is that the variable <code>new_pipefd</code> is an array, so you're copying the address of the same array into each of the elements of <code>pipes</code>, which means that the parent only has access to the last pipe that was created.</p>

<p>I think you should be using code more like:</p>

<pre><code>int pipes_count = 0;
int pipes[MAXCLIENTS];  // Changed type!
int new_pipefd[2];
char pipe_buffer[MAXDATASIZE];

while (1)
{
    // Pipe creation
    pipe(new_pipefd);
    pipes[pipes_count++] = new_pipefd[0];  // Just the read end of the pipe

    if (fork())
    {
        // unrelated code for parent here
        close(new_pipefd[1]); // close the parent's write-end of the pipe
        // break;             // This break is not wanted
    }
    else
    {
        // unrelated code for child here
        close(new_pipefd[0]); // close the child's read-end of the pipe
        break;
    }

    if (some condition)
        break;        // The parent will stop creating pipes
}

while (condition that guarantees this is the child)
{
    write(new_pipefd[1], buffer, strlen(recv_buffer));
    close(new_pipefd[1]);
    return 0; // the child process ends
}

// This is a loop where the parent reads what the children sent
for (int i = 0; i &lt; pipes_count; i++) {
    int pipe_bytes = read(pipes[i], pipe_buffer, sizeof(pipe_buffer));
    if (pipe_bytes != 0)
        printf(""Testing: %.*s\n"", pipe_bytes, pipe_buffer); // Safe!
    close(pipes[i]);
}
</code></pre>

<p>Were it my code, I'd have a function (which I traditionally call <code>be_childish()</code>) to invoke in the 'if it is a child' block of code in the loop.  The function would never return, and would be passed whatever resources it needs (<code>new_pipefd</code> for sure, maybe other information too).  I often have a function <code>be_parental()</code> to do the parental activities.  I find this cleans up most of the code, forcing clean separation of the activities.</p>
"
"<p>I believe it's the mode of the inode...</p>

<pre><code>umode_t            i_mode;
</code></pre>

<p>To access the field see <strong>stat(2)</strong> man page:</p>

<pre><code>   The following POSIX macros are defined to check the file type using the st_mode field:

       S_ISREG(m)  is it a regular file?

       S_ISDIR(m)  directory?

       S_ISCHR(m)  character device?

       S_ISBLK(m)  block device?

       S_ISFIFO(m) FIFO (named pipe)?

       S_ISLNK(m)  symbolic link? (Not in POSIX.1-1996.)

       S_ISSOCK(m) socket? (Not in POSIX.1-1996.)
</code></pre>

<p>Here is some example code from the <a href=""http://lxr.free-electrons.com/source/fs/minix/inode.c"" rel=""nofollow"">Linux driver for minix FS</a>:</p>

<pre><code>434 void minix_set_inode(struct inode *inode, dev_t rdev)
435 {
436         if (S_ISREG(inode-&gt;i_mode)) {
437                 inode-&gt;i_op = &amp;minix_file_inode_operations;
438                 inode-&gt;i_fop = &amp;minix_file_operations;
439                 inode-&gt;i_mapping-&gt;a_ops = &amp;minix_aops;
440         } else if (S_ISDIR(inode-&gt;i_mode)) {
441                 inode-&gt;i_op = &amp;minix_dir_inode_operations;
442                 inode-&gt;i_fop = &amp;minix_dir_operations;
443                 inode-&gt;i_mapping-&gt;a_ops = &amp;minix_aops;
444         } else if (S_ISLNK(inode-&gt;i_mode)) {
445                 inode-&gt;i_op = &amp;minix_symlink_inode_operations;
446                 inode-&gt;i_mapping-&gt;a_ops = &amp;minix_aops;
447         } else
448                 init_special_inode(inode, inode-&gt;i_mode, rdev);
449 }
450
</code></pre>
"
"<p>The LDD3 book is very useful still to understand the big picture, but it won't help with details (it is for kernel 2.6.10, meanwhile we are marching towards 3.9). The <a href=""http://kernelnewbies.org/Drivers"" rel=""noreferrer"">kernelnewbies drivers page</a> is perhaps the most up-to-date, comprehensive resource. For day-to-day changes, <a href=""http://lwn.net"" rel=""noreferrer"">LWN</a> regularly comments on API changes and publishes longer overviews for new features. <a href=""http://www.h-online.com"" rel=""noreferrer"">H-online</a> carries a series of articles detailing changes from kernel version to kernel version, with links to discussions and patches.</p>
"
"<p>I had to implement my first linux driver a while back.  By far the best thing I think you can do is download the Kernel source for the version you're developing against.  Within the kernel source tree there is a directory called /Documentation.  I'd start there, last I checked this is the ""Official Documentation"" for the kernel.</p>

<p>That being said, once you have the source code there really isn't a better documentation than reading the code and seeing what it's used as.  For things like this, I'd look through /drivers/fs/ and find an example of where this struct is used and see how they're using it.</p>
"
"<p>The function pointer expects a function with return type of <code>ssize_t</code> but you've given it one of <code>int</code></p>

<p>You need a <code>ssize_t</code> there, not an <code>int</code>.</p>
"
"<p>The return type of your <code>read_proc</code> function (which throws the warning) does not match the the function that compiles cleanly.</p>

<pre><code>static ssize_t dev_read(struct file *pfil, char __user *pBuf, size_t len, loff_t *p_off)
</code></pre>

<p>vs.</p>

<pre><code>static int read_proc(struct file *pfil, char __user *pBuf, size_t len, loff_t *p_off)
</code></pre>

<p><code>ssize_t</code> and <code>int</code> may be different sizes. Your function's return type should be <code>ssize_t</code>.</p>
"
"<p>While working with file operations just follow rules according to this structure</p>

<pre><code>struct file_operations {
    struct module *owner;
    loff_t (*llseek) (struct file *, loff_t, int);
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
    ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
    ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
    ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
    ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
    int (*iterate) (struct file *, struct dir_context *);
    unsigned int (*poll) (struct file *, struct poll_table_struct *);
    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
    long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
    int (*mmap) (struct file *, struct vm_area_struct *);
    int (*open) (struct inode *, struct file *);
    int (*flush) (struct file *);
    int (*release) (struct inode *, struct file *);
    int (*fsync) (struct file *, loff_t, loff_t, int datasync);
    int (*aio_fsync) (struct kiocb *, int datasync);
    int (*fasync) (int, struct file *, int);
    int (*lock) (struct file *, int, struct file_lock *);
    ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
    unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
    int (*check_flags)(int);
    int (*flock) (struct file *, int, struct file_lock *);
    ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, size_t, unsigned int);
    ssize_t (*splice_read)(struct file *, struct pipe_inode_info *, size_t, unsigned int);
    int (*setlease)(struct file *, long arg, struct file_lock **);
    long (*fallocate)(struct file *, int mode, loff_t offset, loff_t len);
    int (*show_fdinfo)(struct seq_file *m, struct file *f); };
</code></pre>

<p>You can find this structure in Kernel Documentation Documentation/filesystems/vfs.txt or you can find it using tag vim -t file_operations from Kernel Source or you can look at header file /include/linux/fs.h.</p>

<p>Just Your mistake is return type you used static int instead of using ssize_t.</p>
"
"<p>The answer is <strong>it depends</strong>.</p>

<p>Different file systems store inode information differently.  Some will store the actual file contents in the inode structure if the size is small enough, some will store virtual or actual block numbers as a 32 or 64 bit numbers or sometimes even another encoding, some will store an offset into the disk space, most will store more complex information to handle large files spanning many many blocks...</p>

<p>You can find the details for various file systems on the Internet, it is very interesting to understand file system performance.</p>

<p>Enjoy!</p>
"
"<p>As says in <a href=""http://wiki.osdev.org/Ext2"" rel=""nofollow noreferrer"">osdev wiki</a> for <a href=""http://en.wikipedia.org/wiki/Ext2"" rel=""nofollow noreferrer"">ext2</a> inodes :</p>

<blockquote>
  <p>Like blocks, each inode has a numerical address. It is extremely important to note that unlike block addresses, inode addresses start at 1.</p>

  <p>Each inode contains 12 direct pointers, one singly indirect pointer, one doubly indirect block pointer, and one triply indirect pointer. The direct space ""overflows"" into the singly indirect space, which overflows into the doubly indirect space, which overflows into the triply indirect space.</p>

  <p>Direct Block Pointers: There are 12 direct block pointers. If valid, the value is non-zero. Each pointer is the block address of a block containing data for this inode.</p>

  <p>Singly Indirect Block Pointer: If a file needs more than 12 blocks, a separate block is allocated to store the block addresses of the remaining data blocks needed to store its contents. This separate block is called an indirect block because it adds an extra step (a level of indirection) between an inode and its data. The block addresses stored in the block are all 32-bit, and the capacity of stored addresses in this block is a function of the block size. The address of this indirect block is stored in the inode in the ""Singly Indirect Block Pointer"" field.</p>

  <p>Doubly Indirect Block Pointer: If a file has more blocks than can fit in the 12 direct pointers and the indirect block, a double indirect block is used. A double indirect block is an extension of the indirect block described above only now we have two intermediate blocks between the inode and data blocks. The inode structure has a ""Doubly Indirect Block Pointer"" field that points to this block if necessary.</p>

  <p>Triply Indirect Block Pointer: Lastly, if a file needs still more space, it can use a triple indirect block. Again, this is an extension of the double indirect block. So, a triple indirect block contains addresses of double indirect blocks, which contain addresses of single indirect blocks, which contain address of data blocks. The inode structure has a ""Triply Indirect Block Pointer"" field that points to this block if present. </p>
</blockquote>

<p><img src=""https://i.stack.imgur.com/u7fe5.gif"" alt=""inode relations""></p>

<p>as you may know there is a logical inode in linux wich used in VFS.<br>
The VFS inode data structure holds information about a file or directory on disk. </p>

<pre><code>struct inode {
    kdev_t                       i_dev;
    unsigned long                i_ino;
    umode_t                      i_mode;
    nlink_t                      i_nlink;
    uid_t                        i_uid;
    gid_t                        i_gid;
    kdev_t                       i_rdev;
    off_t                        i_size;
    time_t                       i_atime;
    time_t                       i_mtime;
    time_t                       i_ctime;
    unsigned long                i_blksize;
    unsigned long                i_blocks;
    unsigned long                i_version;
    unsigned long                i_nrpages;
    struct semaphore             i_sem;
    struct inode_operations      *i_op;
    struct super_block           *i_sb;
    struct wait_queue            *i_wait;
    struct file_lock             *i_flock;
    struct vm_area_struct        *i_mmap;
    struct page                  *i_pages;
    struct dquot                 *i_dquot[MAXQUOTAS];
    struct inode                 *i_next, *i_prev;
    struct inode                 *i_hash_next, *i_hash_prev;
    struct inode                 *i_bound_to, *i_bound_by;
    struct inode                 *i_mount;
    unsigned short               i_count;
    unsigned short               i_flags;
    unsigned char                i_lock;
    unsigned char                i_dirt;
    unsigned char                i_pipe;
    unsigned char                i_sock;
    unsigned char                i_seek;
    unsigned char                i_update;
    unsigned short               i_writecount;
    union {
        struct pipe_inode_info   pipe_i;
        struct minix_inode_info  minix_i;
        struct ext_inode_info    ext_i;
        struct ext2_inode_info   ext2_i;
        struct hpfs_inode_info   hpfs_i;
        struct msdos_inode_info  msdos_i;
        struct umsdos_inode_info umsdos_i;
        struct iso_inode_info    isofs_i;
        struct nfs_inode_info    nfs_i;
        struct xiafs_inode_info  xiafs_i;
        struct sysv_inode_info   sysv_i;
        struct affs_inode_info   affs_i;
        struct ufs_inode_info    ufs_i;
        struct socket            socket_i;
        void                     *generic_ip;
    } u;
};
</code></pre>
"
"<p>For ext4 fs, please
Refer <a href=""https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout"" rel=""nofollow"">https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout</a></p>

<p>As per my understanding for ext4, Disk is divided into multiple blocks. Address stored in inode is basically block number. so, the actual address would be block_number*block_size.</p>

<p>""Generally, the block size will be 4KiB (the same size as pages on x86 and the block layer's default block size), though the actual size is calculated as 2 ^ (10 + sb.s_log_block_size) bytes""</p>

<p>Thanks</p>
"
"<p><code>mmap</code> the memory region, then use a regular <code>write</code> or <code>vmsplice</code></p>
"
"<blockquote>
  <p>Does anyone know what is the meaning of these constant and what is the difference between them?</p>
</blockquote>

<p>Actually, you should look at several lines bellow in uio.h:</p>

<pre><code>struct iov_iter {
    int type;
    size_t iov_offset;
    size_t count;
    union {
        const struct iovec *iov;
        const struct kvec *kvec;
        const struct bio_vec *bvec;
        struct pipe_inode_info *pipe;
    };
    union {
        unsigned long nr_segs;
        int idx;
    };
};
</code></pre>

<p>Theses constant allow to use different iterators for processing <code>a buffer of data possibly in several chunks</code>. </p>

<p><code>ITER_IOVEC</code> used to iterate over buffers supplied by <code>writev/readv</code> functions,
<code>ITER_KVEC</code> do almost the same, but with data in kernel space, and <code>ITER_BVEC</code> to work with parts of memory mapped pages.</p>

<p>You can find details on <a href=""https://lwn.net/Articles/625077/"" rel=""nofollow noreferrer"">lwn</a>, do not miss comments.</p>
"
"<p>After some playing around and reading the guide posted by Ctx (<a href=""http://lwn.net/Articles/625077"" rel=""nofollow noreferrer"">lwn.net/Articles/625077</a>), I figured it out.</p>

<pre><code>unsigned long nr_segments = 1;
size_t count = 1;
struct msghdr msg = {};
struct iovec iov = {};

iov.iov_base = data;
iov.iov_len = dataLen;

iov_iter_init(&amp;msg.msg_iter, READ, &amp;iov, nr_segments, count);
</code></pre>
"
"<p>MadWiFi is deprecated.  ath5k and ath9k are supposedly the replacements, and ship with the kernel.  The errors you are getting are due to changes in the kernel API, and the only way to use your module with your current kernel would be to update the module as necessary, which is not a trivial task.  Stick with the new drivers unless you have a really good reason.</p>
"
"<p>MadWifi is currently maintained at <a href=""https://github.com/proski/madwifi"" rel=""nofollow"">https://github.com/proski/madwifi</a>.  It should support all Linux kernels from 2.6.13 to the latest released kernel (currently 3.12).  MadWifi is in maintenance-only mode.  No new features are accepted, only fixes.  No formal releases are planned.  Use ath5k or ath9k that come with your Linux kernel unless you have a reason not to.</p>

<p>Messages about modification time in the future mean that your computer clock is not set correctly or was incorrect when you unpacked the source.</p>
"
"<p>You're looking at the wrong code. <code>/proc/sys/kernel/printk</code> is provided by <code>kernel/sysctl.c</code>. The definition for <code>printk</code> <a href=""http://lxr.free-electrons.com/source/kernel/sysctl.c?v=3.18#L773"" rel=""nofollow"">looks like this</a>:</p>

<pre><code>{
    .procname       = ""printk"",
    .data           = &amp;console_loglevel,
    .maxlen         = 4*sizeof(int),
    .mode           = 0644,
    .proc_handler   = proc_dointvec,
},
</code></pre>

<p>This defines a file called <code>printk</code> which controls an int array of 4 elements. Crucially, <code>proc_dointvec</code>, the handler function, is a generic function that operates on an array of integers, and <em>it doesn't validate its arguments</em>.</p>

<p>As root, you can therefore write whatever garbage numbers you want to <code>/proc/sys/kernel/printk</code> and the kernel will happily accept them. Demo:</p>

<pre><code>root@ubuntu:/proc/sys/kernel# echo '-989897 42 -2147483648 0' &gt; printk
root@ubuntu:/proc/sys/kernel# cat printk
-989897 42  -18446744071562067968   0
</code></pre>

<p>(That 3rd one is actually an amusing and <em>probably</em> harmless bug I've just discovered...)</p>

<p>From <a href=""http://lxr.free-electrons.com/source/include/linux/printk.h?v=3.18#L47"" rel=""nofollow""><code>printk.h</code></a> you can see that the four log level parameters are derived straight from this four-element array:</p>

<pre><code>extern int console_printk[];

#define console_loglevel (console_printk[0])
#define default_message_loglevel (console_printk[1])
#define minimum_console_loglevel (console_printk[2])
#define default_console_loglevel (console_printk[3])
</code></pre>

<hr>

<p>So, then, what does the code you posted do then? It implements the <code>syslog</code> syscall, as noted by the name of the function (<code>do_syslog</code>). As noted by <a href=""http://man7.org/linux/man-pages/man2/syslog.2.html"" rel=""nofollow"">the man page</a>:</p>

<pre><code>   SYSLOG_ACTION_CONSOLE_LEVEL (8)
          The call sets console_loglevel to the value given in len,
          which must be an integer between 1 and 8 (inclusive).  The
          kernel silently enforces a minimum value of
          minimum_console_loglevel for len.  See the log level section
          for details.  The bufp argument is ignored.
</code></pre>

<p>We can see that the <code>syslog</code> system call also lets you set the console log level, but it actually checks that the values are valid. Let's test with a simple test program (note that glibc calls the function <code>klogctl</code> instead of <code>syslog</code>, since the user-space <code>syslog</code> function does something else):</p>

<pre><code>#include &lt;sys/klog.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define SYSLOG_ACTION_CONSOLE_LEVEL 8

int main(int argc, char **argv) {
    if(klogctl(SYSLOG_ACTION_CONSOLE_LEVEL, NULL, atoi(argv[1])) &lt; 0) {
        perror(""klogctl"");
    } else {
        printf(""klogctl succeeded\n"");
    }
    return 0;
}
</code></pre>

<p>Run it (after resetting <code>printk</code> back to <code>7 4 1 7</code>):</p>

<pre><code>root@ubuntu:/tmp# ./test 1 ; cat /proc/sys/kernel/printk
klogctl succeeded
1   4   1   7
root@ubuntu:/tmp# ./test 0 ; cat /proc/sys/kernel/printk
klogctl: Invalid argument
1   4   1   7
</code></pre>

<p>and so you can see that <code>syslog</code> (called via <code>klogctl</code>) does actually check the validity of your parameters.</p>
"
"<p>Kernel has no mechanism for detect changes in variables. Instead, you should perform corresponded actions before/after <em>your</em> code changes <em>your</em> variable.</p>

<p>When you add sysctl entry, you also set handler for it(<code>ctl_table-&gt;proc_handler</code>). This handler defines actions, which are executed when read/write method for entry is called. Standard <code>proc_do*</code> functions only set/get value of variable, so you should define your handler. Something like this:</p>

<pre><code>int my_handler(struct ctl_table *table, int write,
     void __user *buffer, size_t *lenp, loff_t *ppos)
{
    // Call standard helper..
    int res = proc_dointvec(table, write, buffer, lenp, ppos);
    if(write &amp;&amp; !res) {
       // Additional actions on successfull write.
    }
    return res;
}
</code></pre>

<p>Modification of the timer's timeout can be performed using <code>mod_timer</code> function.</p>
"
"<p>Linux kernel is built with old C standard (C89), where <code>struct ctl_table</code> and <code>ctl_table</code> are <strong>different types</strong>.</p>

<p>In other words, <strong><em>struct</em> keyword cannot be ommitted</strong> when refer to the <em>structure</em> type.</p>

<p>Right:</p>

<blockquote>
  <p>static <strong>struct</strong> ctl_table tcp_h_receive[] = {</p>
</blockquote>
"
"<p>use sysctl command <code>sudo sysctl -w net.ipv6.route.gc_interval=20</code> </p>

<p>If you want to make this value permenant append <code>net.ipv6.route.gc_interval=20</code> to <code>/etc/sysctl.conf</code> file</p>
"
"<p>The proc entry <code>sys/net/ipv6/route/gc_interval</code> is defined in <code>net/ipv6/route.c</code>:</p>

<pre><code>{
    .procname   =   ""gc_interval"",
    .data       =   &amp;init_net.ipv6.sysctl.ip6_rt_gc_interval,
    .maxlen     =   sizeof(int),
    .mode       =   0644,
    .proc_handler   =   proc_dointvec_jiffies,
}
</code></pre>

<p>So the <code>gc_interval</code> file is a user-land representation of the integer variable  <code>init_net.ipv6.sysctl.ip6_rt_gc_interval</code> with a jiffies-to-seconds conversion (the variable is stored in jiffies while the proc entry handle the value in seconds)</p>

<p>If you need to programmatically alter that value in the kernel, you only need to alter that variable:</p>

<pre><code>...
init_net.ipv6.sysctl.ip6_rt_gc_interval = new_gc_interval_sec * HZ;
...
</code></pre>

<p><em>Notes:</em></p>

<ul>
<li><em>the kernel references are based on Linux 3.4.5 sources</em></li>
<li><code>&lt;net/net_namespace.h&gt;</code> <em>should be included to access</em> <code>init_net</code> <em>structure</em></li>
</ul>
"
"<p>Or just:</p>

<pre><code>echo 20 &gt; /proc/sys/net/ipv6/route/gc_interval
</code></pre>

<p>/etc/sysctl.conf allow do that's at the start up of the system.</p>
"
"<p>There are no functions for changing sysctl tables in <a href=""http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/sysctl.h"" rel=""nofollow"">sysctl.h</a>.</p>

<p>You have to list all entries that you might need <em>before</em> calling <code>register_sysctl_table</code>.</p>

<p>If you really need to change the table afterwards, you have to call <code>unregister_sysctl_table</code> before doing your modifications, and then register it again.</p>
"
"<p>Yes, you can, just look into the linux kernel's drivers directory for many examples.   Essentially, you just need to call register_sysctl_table() multiple times, for for each call you make, you will be creating a branch off an existing branch.</p>

<p>The details are covered here:</p>

<p><a href=""https://tthtlc.wordpress.com/2016/05/26/how-to-add-new-entries-to-sysctl-with-the-same-root/"" rel=""nofollow"">https://tthtlc.wordpress.com/2016/05/26/how-to-add-new-entries-to-sysctl-with-the-same-root/</a></p>
"
"<p>You should use ctl_table in tree hierarchy and handle it in your module.</p>

<pre><code>static struct ctl_table sample_child_table1[] = {
{
        .ctl_name = CTL_UNNUMBERED1,
        .procname = ""sample"",
        .maxlen = sizeof(int),
        .mode = 0444,
        .data = &amp;global_var,
        .proc_handler = &amp;proc_dointvec_minmax,
        .extra1 = &amp;min_val,
        .extra2 = &amp;max_val,
},
{}
};

static struct ctl_table sample_parent_table[] = {
{
.ctl_name = CTL_KERN,
.procname = ""kernel"",
.mode = 0777,
.child = sample_child_table,
{}
},

register_sysctl_table(sample_parent_table)
</code></pre>
"
"<p>It's done dynamically. For example, when you read the <code>/proc</code> directory, the running tasks are enumerated and an entry for each process is dynamically constructed if it doesn't already exist (see proc_root_readdir => proc_pid_readdir).</p>

<p>Likewise, if you attempt to read or traverse a <code>/proc/&lt;PID&gt;</code> directory, it's created on the fly if it doesn't already exist and the entries it needs are created on the fly as well (see proc_pid_lookup => proc_pid_instantiate).</p>

<p>When a process exits, the entries are generally removed via proc_flush_task (though actual removal can be delayed due to references being held by other processes).</p>
"
"<p>The reason you can't find it is because, for the most part, it's not in the kernel -- it's in the userspace <code>mount</code> utility, which is in the <code>util-linux</code> package. If you don't give it a filesystem type, or if you give it a type of ""any"", <code>mount</code> merely goes through the list of all of the filesystems the kernel knows about, and tries each one in order until one of them mounts successfully (or returns an error if none of them do).</p>

<p>How does it find out what filesystem types the kernel knows about? It reads the <code>/proc/filesystems</code> file, which walks the <code>file_systems</code> linked list in <code>fs/filesystems.c</code>. When a filesystem driver is loaded, it calls <code>register_filesystem</code> in that same file to add itself to that list. For example, there's a call to <code>register_filesystem</code> in <code>init_ext2_fs</code> in <code>fs/ext2/super.c</code> ? <code>init_ext2_fs</code> is the module-init function for the ext2 module.</p>

<p>Some filesystems are noisy and print errors to the kernel debug log when someone tries to mount a device with the wrong filesystem, which is why, for instance, you might see errors about ""invalid XFS filesystem"" when <em>successfully</em> mounting an ext4 filesystem, if <code>mount</code> happened to try xfs first.</p>
"
"<p>From <a href=""http://linux.die.net/man/8/mount"" rel=""noreferrer"">mount</a> man page:</p>

<blockquote>
  <p>If no -t option is given, or if the auto type is specified, mount will try to guess the desired type. If mount was compiled with the blkid library, the guessing is done by this library. Otherwise, mount guesses itself by probing the superblock; if that does not turn up anything that looks familiar, mount will try to read the file /etc/filesystems, or, if that does not exist, /proc/filesystems. All of the filesystem types listed there will be tried, except for those that are labeled ""nodev"" (e.g., devpts, proc, nfs, and nfs4). If /etc/filesystems ends in a line with a single * only, mount will read /proc/filesystems afterwards.</p>
</blockquote>

<p>Also, my ubuntu box has this is mount man page (mentions <code>volume_id</code> library)</p>

<blockquote>
  <p>If no -t option is given, or if the auto type is specified, mount will try to guess the desired type.  Mount uses
                the  blkid  or  volume_id  library for guessing the filesystem type; if that does not turn up anything that looks
                familiar, mount will try to read the file /etc/filesystems, or, if that does not exist,  /proc/filesystems.   All
                of the filesystem types listed there will be tried, except for those that are labeled ""nodev"" (e.g., devpts, proc
                and nfs).  If /etc/filesystems ends in a line with a single * only, mount will read /proc/filesystems afterwards.</p>
</blockquote>
"
"<p><code>blkid -o value -s TYPE /dev/path/to/device</code></p>
"
"<p>You can only have <code>mount</code> do something for you if you develop your own filesystem.</p>

<p>In that case, when you call <code>register_filesystem</code> you need to give it a <code>file_system_type</code> which contains a <code>.mount</code> field. Mount is a function with this prototype:</p>

<pre><code>struct dentry *some_mount(struct file_system_type *fs_type,
    int flags, const char *dev_name, void *data);
</code></pre>

<p>You can access data passed with <code>-o</code> to mount via the <code>data</code> parameter.</p>

<hr>

<p>If all you want to do is pass some data from userland to your module, a far simpler way would be to use <code>module_param</code>:</p>

<pre><code>static char *abc = """";
module_param(abc, charp, 0000);
MODULE_PARM_DESC(abc, ""Some string that you give to insmod"");
</code></pre>
"
"<pre><code>Queue = blk_init_queue(sbd_request, &amp;Device.lock);
</code></pre>
"
"<p>I share the solution to the bug that led me to post this question. Though it does not actually answer the question of how to identify the device request queue. </p>

<p>In the code above is the following:</p>

<pre><code>if (test_bit(NDAS_FLAG_QUEUE_SUSPENDED,
       &amp;(NDAS_GET_SLOT_DEV(SLOT_R(req))-&gt;queue_flags)))
</code></pre>

<p>Well, that ""SLOT_R(req)""  was causing the trouble. That is defined else where to return the gendisk device.</p>

<pre><code>#define SLOT_R(_request_) SLOT((_request_)-&gt;rq_disk)
</code></pre>

<p>This returned the disk, but not the proper value for various operations later on. So as the extra block devices were loaded, this function basically kept returning 1. (I think it was processing as a boolean.) Therefore, all requests were piled on the to the request queue for disk 1. </p>

<p>The fix was to access the correct disk identification value that was already stored in the disk's private_data when the it was added to the system.</p>

<pre><code>Correct identifier definition:
   #define SLOT_R(_request_) ( (int) _request_-&gt;rq_disk-&gt;private_data )

How the correct disk number was stored.
   slot-&gt;disk-&gt;queue = slot-&gt;queue;
   slot-&gt;disk-&gt;private_data = (void*) (long) s;  &lt;-- 's' is the disk id
   slot-&gt;queue_flags = 0;
</code></pre>

<p>Now the correct disk id is returned from private data, so all requests to the correct queue. </p>

<p>As mentioned, this does not show how to identify the queue though. An un-educated guess might be:</p>

<pre><code> x = (int) _request_-&gt;rq_disk-&gt;queue-&gt;id;
</code></pre>

<p>Ref. the request_queue function in linux
<a href=""http://lxr.free-electrons.com/source/include/linux/blkdev.h#L270"" rel=""nofollow"">http://lxr.free-electrons.com/source/include/linux/blkdev.h#L270</a> &amp; 321</p>

<p>Thanks everyone for helping!</p>
"
"<p>It would probably help to stop thinking of a device driver as a program. They're completely different. A program has a specific starting point, does some stuff, and has one or more fairly well defined (well, they should, anyway) exit point. Drivers have some stuff to do when the first get loaded (e.g. <code>MODULE_INIT()</code> and other stuff), and may or may not ever do anything ever again (you can forcibly load a driver for hardware your system doesn't actually have), and may have some stuff that needs to be done if the driver is ever unloaded. Aside from that, a driver generally provides some specific entry points (system calls, ioctls, etc.) that user-land applications can access to request the driver to do something.</p>

<p>Horrible analogy, but think of a program kind of like a car - you get in, start it up, drive somewhere, and get out. A driver is more like a vending machine - you plug it in and make sure it's stocked, but then people just come along occasionaly and push buttons to make it do something.</p>
"
"<p>""Linux Device Driver"" is a good book but it's old!</p>

<p>Basic example:</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/version.h&gt;
#include &lt;linux/kernel.h&gt;

MODULE_LICENSE(""GPL"");
MODULE_AUTHOR(""Name and e-mail"");
MODULE_DESCRIPTION(""my_first_driver"");

static int __init insert_mod(void)
{
    printk(KERN_INFO ""Module constructor"");
    return 0;
}

static void __exit remove_mod(void)
{
    printk(KERN_INFO ""Module destructor"");
}

module_init(insert_mod);
module_exit(remove_mod);
</code></pre>

<p>An up-to-date tutorial, really well written, is ""<a href=""http://www.linuxforu.com/tag/linux-device-drivers-series/"" rel=""nofollow"">Linux Device Drivers Series</a>"" </p>
"
"<p>A device driver is not a ""program"" that has a <code>main {}</code> with a start point and exit point.  It's more like an API or a library or a collection of routines. In this case, it's a set of <em>entry points</em> declared by <code>MODULE_INIT()</code>, <code>MODULE_EXIT()</code>, perhaps <code>EXPORT_SYMBOL()</code> and structures that list entry points for <em>operations</em>.</p>

<p>For <em>block devices</em>, the driver is expected to provide the list of operations it can perform by declaring its functions for those operations in (from <code>include/linux/blkdev.h</code>):</p>

<pre><code>struct block_device_operations {
        int (*open) ();
        int (*release) ();
        int (*ioctl) ();
        int (*compat_ioctl) ();
        int (*direct_access) ();
        unsigned int (*check_events) ();
        /* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */
        int (*media_changed) ();
        void (*unlock_native_capacity) ();
        int (*revalidate_disk) ();
        int (*getgeo)();
        /* this callback is with swap_lock and sometimes page table lock held */
        void (*swap_slot_free_notify) ();
        struct module *owner;
};
</code></pre>

<p>For <em>char devices</em>, the driver is expected to provide the list of operations it can perform by declaring its functions for those operations in (from <code>include/linux/fs.h</code>):</p>

<pre><code>struct file_operations {
        struct module *owner;
        loff_t (*llseek) ();
        ssize_t (*read) ();
        ssize_t (*write) ();
        ssize_t (*aio_read) ();
        ssize_t (*aio_write) ();
        int (*readdir) ();
        unsigned int (*poll) ();
        long (*unlocked_ioctl) ();
        long (*compat_ioctl) ();
        int (*mmap) ();
        int (*open) ();
        int (*flush) ();
        int (*release) ();
        int (*fsync) ();
        int (*aio_fsync) ();
        int (*fasync) ();
        int (*lock) ();
        ssize_t (*sendpage) ();
        unsigned long (*get_unmapped_area)();
        int (*check_flags)();
        int (*flock) ();
        ssize_t (*splice_write)();
        ssize_t (*splice_read)();
        int (*setlease)();
        long (*fallocate)();
};
</code></pre>

<p>For <em>platform devices</em>, the driver is expected to provide the list of operations it can perform by declaring its functions for those operations in (from <code>include/linux/platform_device.h</code>):    </p>

<pre><code>struct platform_driver {
        int (*probe)();
        int (*remove)();
        void (*shutdown)();
        int (*suspend)();
        int (*resume)();
        struct device_driver driver;
        const struct platform_device_id *id_table;
};
</code></pre>

<p>The driver, especially char drivers, does not have to support every operation listed.    Note that there are macros to facilitate the coding of these structures by naming the structure entries.</p>

<blockquote>
  <p>Does the driver program starts at the MOUDLUE_INIT() macro? </p>
</blockquote>

<p>The driver's <em>init()</em> routine specified in <code>MODULE_INIT()</code> will be called during boot (when statically linked in) or when the module is dynamically loaded.  The driver passes its structure of operations to the device's subsystem when it <em>registers</em> itself during its <em>init()</em>.</p>

<p>These device driver entry points, e.g. <em>open()</em> or <em>read()</em>, are typically executed when the user app invokes a C library call (in user space) and after a switch to kernel space.  Note that the i2c driver you're looking at is a <a href=""http://www.kernel.org/doc/Documentation/driver-model/platform.txt"" rel=""noreferrer"">platform driver</a> for a bus that is used by <em>leaf</em> devices, and its functions exposed by <code>EXPORT_SYMBOL()</code> would be called by other drivers.</p>

<p>Only the driver's <em>init()</em> routine specified in <code>MODULE_INIT()</code> is guaranteed to be called. The driver's <em>exit()</em> routine specified in <code>MODULE_EXIT()</code> would only be executed if/when the module is dynamically unloaded.  The driver's op routines will be called asynchronously (just like its interrupt service routine) in unknown order.  Hopefully user programs will invoke an <em>open()</em> before issuing a <em>read()</em> or an <em>ioctl()</em> operation, and invoke other operations in a sensible fashion.  A well-written and robust driver should accommodate any order or sequence of operations, and produce sane results to ensure system integrity. </p>
"
"<p>Actually you are taking about (I2C) platform (Native)driver first you need to understand how MOUDULE_INIT() of platform driver got called versus  other loadable modules.</p>

<pre><code>/*
* module_init() - driver initialization entry point
* @x: function to be run at kernel boot time or module insertion
* module_init() will either be called during do_initcalls() (if
* builtin) or at module insertion time (if a module).  There can only
* be one per module.*/
</code></pre>

<p>and for i2c driver you can refer this link <a href=""http://www.linuxjournal.com/article/7136"" rel=""nofollow"">http://www.linuxjournal.com/article/7136</a> and
<a href=""http://www.embedded-bits.co.uk/2009/i2c-in-the-2632-linux-kernel/"" rel=""nofollow"">http://www.embedded-bits.co.uk/2009/i2c-in-the-2632-linux-kernel/</a></p>
"
"<p>Begin of a kernel module is starting from initialization function, which mainly addressed with macro <strong>__init</strong> just infront of the function name.</p>

<p>The __init macro indicate to linux kernel that the following function is an initialization function and the resource that will use for this initialization function will be free once the code of initialization function is executed. </p>

<p>There are other marcos, used for detect initialization and release function, named module_init() and module_exit() [as described above]. </p>

<p>These two macro are used, if the device driver is targeted to operate as loadable and removeable kernel module at run time [i.e. using insmod or rmmod command]</p>
"
"<p>IN short and crisp way : It starts from .probe and go all the way to init as soon you do insmod .This also registers the driver with the driver subsystem and also initiates the init.
Everytime the driver functionalities are called from the user application , functions are invoked using the call back.</p>
"
"<p>The <code>ioctl</code> dispatching is handled by the <code>blkdev_ioctl</code> function, which will process some of the ioctls directly, without calling into your driver's specific routine.</p>

<p>For <code>HDIO_GETGEO</code>, it calls your driver's <code>getgeo</code> function directly (from kernel 3.13.6, doesn't appear to have changed much since 2.6.32):</p>

<pre><code>[...]
/*
 * We need to set the startsect first, the driver may
 * want to override it.
 */
memset(&amp;geo, 0, sizeof(geo));
geo.start = get_start_sect(bdev);
ret = disk-&gt;fops-&gt;getgeo(bdev, &amp;geo); /* &lt;- here */
[...]
</code></pre>

<p>For <code>BLKBSZGET</code>, it calls <code>block_size(bdev))</code>, which simply returns <code>bdev-&gt;bd_block_size</code>.</p>

<p>You'll find <code>blkdev_ioctl</code> in <code>block/ioctl.c</code> if you need to know what happens for other ioctls.</p>
"
"<p><code>struct file_operations</code> has many more members. Per C99, members not listed are initialized to <code>NULL</code> which means they're not specially implemented. That's normal for <em>filter</em> drivers; they replace only some operations.</p>
"
"<p>The exact sequence of function calls will depend on various situations like whether I/O is direct or not, whether I/O is synchronous or asynchronous etc. Depending on these situations, at the end make_request() method of MD layer is called and this method is registered by MD layer itself at the time of RAID device creation by blk_queue_make_request() call as shown below in md.c file:</p>

<pre><code>blk_queue_make_request(mddev-&gt;queue, md_make_request);
</code></pre>

<p>This md_make_request() function will internally calls make_request() method specific to that RAID device personality as shown below:</p>

<pre><code>mddev-&gt;pers-&gt;make_request(mddev, bio);
</code></pre>

<p>You can find specific make_request() method in the list of RAID personality methods given in individual RAID files in source code, i.e., for raid0 personality, here is list of methods where make_request is initialized with raid0_make_request() in raid0.c file. </p>

<pre><code>static struct md_personality raid0_personality=
{
         .name           = ""raid0"",
         .level          = 0,
         .owner          = THIS_MODULE,
         .make_request   = raid0_make_request,
         .run            = raid0_run,
         .free           = raid0_free,
         .status         = raid0_status,
         .size           = raid0_size,
         .takeover       = raid0_takeover,
         .quiesce        = raid0_quiesce,
         .congested      = raid0_congested,
};
</code></pre>

<p>This raid0_make_request() function will perform read or write on raid0 device.</p>
"
"<p>You might try <code>lsof</code> or <code>fuser</code>.</p>
"
"<p>All you get are a list of which modules depend on which other modules (the <code>Used by</code> column in lsmod).  You can't  write a program to tell why the module was loaded, if it is still needed for anything, or what might break if you unload it and everything that depends on it.</p>
"
"<p>It says on the <a href=""http://www.linuxtopia.org/online_books/Linux_Kernel_Module_Programming_Guide/x573.html#AEN655"" rel=""noreferrer"">Linux Kernel Module Programming Guide</a> that the use count of a module is controlled by the functions <code>try_module_get</code> and <code>try_module_put</code>. Perhaps you can find where these functions are called for your module.</p>
"
"<p>Actually, there seems to be a way to list processes that claim a module/driver - however, I haven't seen it advertised (outside of Linux kernel documentation), so I'll jot down my notes here:</p>

<p>First of all, many thanks for <a href=""https://stackoverflow.com/a/449856/277826"">@haggai_e</a>'s answer; the pointer to the functions <code>try_module_get</code> and <code>try_module_put</code> as those responsible for managing the use count (refcount) was the key that allowed me to track down the procedure. </p>

<p>Looking further for this online, I somehow stumbled upon the post <a href=""http://lkml.indiana.edu/hypermail/linux/kernel/1003.3/00570.html"" rel=""nofollow noreferrer"">Linux-Kernel Archive: [PATCH 1/2] tracing: Reduce overhead of module tracepoints</a>; which finally pointed to a facility present in the kernel, known as (I guess) ""tracing""; the documentation for this is in the directory <a href=""http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/trace"" rel=""nofollow noreferrer"">Documentation/trace - Linux kernel source tree</a>. In particular, two files explain the tracing facility, <a href=""http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/trace/events.txt"" rel=""nofollow noreferrer"">events.txt</a> and <a href=""http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/trace/ftrace.txt"" rel=""nofollow noreferrer"">ftrace.txt</a>.</p>

<p>But, there is also a short ""tracing mini-HOWTO"" on a running Linux system in <code>/sys/kernel/debug/tracing/README</code> (see also <a href=""https://plus.google.com/111049168280159033135/posts/4njRkH5jCa5"" rel=""nofollow noreferrer"">I'm really really tired of people saying that there's no documentation?</a>); note that in the kernel source tree, this file is actually generated by the file <a href=""https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/kernel/trace/trace.c#n2971"" rel=""nofollow noreferrer"">kernel/trace/trace.c</a>. I've tested this on Ubuntu <code>natty</code>, and note that since <code>/sys</code> is owned by root, you have to use <code>sudo</code> to read this file, as in <code>sudo cat</code> or </p>

<pre><code>sudo less /sys/kernel/debug/tracing/README
</code></pre>

<p>... and that goes for pretty much all other operations under <code>/sys</code> which will be described here. </p>

<hr>

<p>First of all, here is a simple minimal module/driver code (which I put together from the referred resources), which simply creates a <code>/proc/testmod-sample</code> file node, which returns the string ""This is testmod."" when it is being read; this is <strong><code>testmod.c</code></strong>:</p>

<pre class=""lang-c++ prettyprint-override""><code>/*
https://github.com/spotify/linux/blob/master/samples/tracepoints/tracepoint-sample.c
https://www.linux.com/learn/linux-training/37985-the-kernel-newbie-corner-kernel-debugging-using-proc-qsequenceq-files-part-1
*/

#include &lt;linux/module.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/seq_file.h&gt; // for sequence files

struct proc_dir_entry *pentry_sample;

char *defaultOutput = ""This is testmod."";


static int my_show(struct seq_file *m, void *v)
{
  seq_printf(m, ""%s\n"", defaultOutput);
  return 0;
}

static int my_open(struct inode *inode, struct file *file)
{
  return single_open(file, my_show, NULL);
}

static const struct file_operations mark_ops = {
  .owner    = THIS_MODULE,
  .open = my_open,
  .read = seq_read,
  .llseek   = seq_lseek,
  .release  = single_release,
};


static int __init sample_init(void)
{
  printk(KERN_ALERT ""sample init\n"");
  pentry_sample = proc_create(
    ""testmod-sample"", 0444, NULL, &amp;mark_ops);
  if (!pentry_sample)
    return -EPERM;
  return 0;
}

static void __exit sample_exit(void)
{
    printk(KERN_ALERT ""sample exit\n"");
    remove_proc_entry(""testmod-sample"", NULL);
}

module_init(sample_init);
module_exit(sample_exit);

MODULE_LICENSE(""GPL"");
MODULE_AUTHOR(""Mathieu Desnoyers et al."");
MODULE_DESCRIPTION(""based on Tracepoint sample"");
</code></pre>

<p>This module can be built with the following <strong><code>Makefile</code></strong> (just have it placed in the same directory as <code>testmod.c</code>, and then run <code>make</code> in that same directory):</p>

<pre><code>CONFIG_MODULE_FORCE_UNLOAD=y
# for oprofile
DEBUG_INFO=y
EXTRA_CFLAGS=-g -O0

obj-m += testmod.o

# mind the tab characters needed at start here:
all:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
</code></pre>

<p>When this module/driver is built, the output is a kernel object file, <code>testmod.ko</code>. </p>

<hr>

<p>At this point, we can prepare the event tracing related to <code>try_module_get</code> and <code>try_module_put</code>; those are in <code>/sys/kernel/debug/tracing/events/module</code>:</p>

<pre><code>$ sudo ls /sys/kernel/debug/tracing/events/module
enable  filter  module_free  module_get  module_load  module_put  module_request
</code></pre>

<p>Note that on my system, tracing is by default enabled:</p>

<pre><code>$ sudo cat /sys/kernel/debug/tracing/tracing_enabled
1
</code></pre>

<p>... however, the module tracing (specifically) is not: </p>

<pre><code>$ sudo cat /sys/kernel/debug/tracing/events/module/enable
0
</code></pre>

<p>Now, we should first make a filter, that will react on the <code>module_get</code>, <code>module_put</code> etc events, but only for the <code>testmod</code> module. To do that, we should first check the format of the event: </p>

<pre><code>$ sudo cat /sys/kernel/debug/tracing/events/module/module_put/format
name: module_put
ID: 312
format:
...
    field:__data_loc char[] name;   offset:20;  size:4; signed:1;

print fmt: ""%s call_site=%pf refcnt=%d"", __get_str(name), (void *)REC-&gt;ip, REC-&gt;refcnt
</code></pre>

<p>Here we can see that there is a field called <code>name</code>, which holds the driver name, which we can filter against. To create a filter, we simply <code>echo</code> the filter string into the corresponding file: </p>

<pre><code>sudo bash -c ""echo name == testmod &gt; /sys/kernel/debug/tracing/events/module/filter""
</code></pre>

<p>Here, first note that since we have to call <code>sudo</code>, we have to wrap the whole <code>echo</code> redirection as an argument command of a <code>sudo</code>-ed <code>bash</code>. Second, note that since we wrote to the ""parent"" <code>module/filter</code>, not the specific events (which would be <code>module/module_put/filter</code> etc), this filter will be applied to all events listed as ""children"" of <code>module</code> directory. </p>

<p>Finally, we enable tracing for module: </p>

<pre><code>sudo bash -c ""echo 1 &gt; /sys/kernel/debug/tracing/events/module/enable""
</code></pre>

<p>From this point on, we can read the trace log file; for me, reading the blocking,
""piped"" version of the trace file worked - like this: </p>

<pre><code>sudo cat /sys/kernel/debug/tracing/trace_pipe | tee tracelog.txt
</code></pre>

<p>At this point, we will not see anything in the log - so it is time to load (and utilize, and remove) the driver (in a different terminal from where <code>trace_pipe</code> is being read):</p>

<pre><code>$ sudo insmod ./testmod.ko
$ cat /proc/testmod-sample
This is testmod.
$ sudo rmmod testmod
</code></pre>

<p>If we go back to the terminal where <code>trace_pipe</code> is being read, we should see something like:</p>

<pre><code># tracer: nop
#
#           TASK-PID    CPU#    TIMESTAMP  FUNCTION
#              | |       |          |         |
          insmod-21137 [001] 28038.101509: module_load: testmod
          insmod-21137 [001] 28038.103904: module_put: testmod call_site=sys_init_module refcnt=2
           rmmod-21354 [000] 28080.244448: module_free: testmod
</code></pre>

<p>That is pretty much all we will obtain for our <code>testmod</code> driver - the refcount changes only when the driver is loaded (<code>insmod</code>) or unloaded (<code>rmmod</code>), not when we do a read through <code>cat</code>. So we can simply interrupt the read from <code>trace_pipe</code> with <kbd>CTRL</kbd>+<kbd>C</kbd> in that terminal; and to stop the tracing altogether:</p>

<pre><code>sudo bash -c ""echo 0 &gt; /sys/kernel/debug/tracing/tracing_enabled""
</code></pre>

<p>Here, note that most examples refer to reading the file <code>/sys/kernel/debug/tracing/trace</code> instead of <code>trace_pipe</code> as here. However, one problem is that this file is not meant to be ""piped"" (so you shouldn't run a <code>tail -f</code> on this <code>trace</code> file); but instead you should re-read the <code>trace</code> after each operation. After the first <code>insmod</code>, we would obtain the same output from <code>cat</code>-ing both <code>trace</code> and <code>trace_pipe</code>; however, after the <code>rmmod</code>, reading the <code>trace</code> file would give:</p>

<pre><code>   &lt;...&gt;-21137 [001] 28038.101509: module_load: testmod
   &lt;...&gt;-21137 [001] 28038.103904: module_put: testmod call_site=sys_init_module refcnt=2
   rmmod-21354 [000] 28080.244448: module_free: testmod
</code></pre>

<p>... that is: at this point, the <code>insmod</code> had already been exited for long, and so it doesn't exist anymore in the process list - and therefore cannot be found via the recorded process ID (PID) at the time - thus we get a blank <code>&lt;...&gt;</code> as process name. Therefore, it is better to log (via <code>tee</code>) a running output from <code>trace_pipe</code> in this case. Also, note that in order to clear/reset/erase the <code>trace</code> file, one simply writes a 0 to it: </p>

<pre><code>sudo bash -c ""echo 0 &gt; /sys/kernel/debug/tracing/trace""
</code></pre>

<p>If this seems counterintuitive, note that <code>trace</code> is a special file, and will always report a file size of zero anyways: </p>

<pre><code>$ sudo ls -la /sys/kernel/debug/tracing/trace
-rw-r--r-- 1 root root 0 2013-03-19 06:39 /sys/kernel/debug/tracing/trace
</code></pre>

<p>... even if it is ""full"". </p>

<p>Finally, note that if we didn't implement a filter, we would have obtained a log of <em>all</em> module calls on the running system - which would log any call (also background) to <code>grep</code> and such, as those use the <code>binfmt_misc</code> module: </p>

<pre><code>...
  tr-6232  [001] 25149.815373: module_put: binfmt_misc call_site=search_binary_handler refcnt=133194
..
  grep-6231  [001] 25149.816923: module_put: binfmt_misc call_site=search_binary_handler refcnt=133196
..
  cut-6233  [000] 25149.817842: module_put: binfmt_misc call_site=search_binary_handler refcnt=129669
..
  sudo-6234  [001] 25150.289519: module_put: binfmt_misc call_site=search_binary_handler refcnt=133198
..
  tail-6235  [000] 25150.316002: module_put: binfmt_misc call_site=search_binary_handler refcnt=129671
</code></pre>

<p>... which adds quite a bit of overhead (in both log data ammount, and processing time required to generate it).</p>

<hr>

<p>While looking this up, I stumbled upon <a href=""http://www.ckernel.org/news/downloads/2010file/Acelan_dirty-throttling.pdf"" rel=""nofollow noreferrer"">Debugging Linux Kernel by Ftrace PDF</a>, which refers to a tool <a href=""http://git.kernel.org/cgit/linux/kernel/git/rostedt/trace-cmd.git/tree/"" rel=""nofollow noreferrer"">trace-cmd</a>, which pretty much does the similar as above - but through an easier command line interface. There is also a ""front-end reader"" GUI for <code>trace-cmd</code> called <a href=""http://people.redhat.com/srostedt/kernelshark/HTML/"" rel=""nofollow noreferrer"">KernelShark</a>; both of these are also in Debian/Ubuntu repositories via <code>sudo apt-get install trace-cmd kernelshark</code>. These tools could be an alternative to the procedure described above. </p>

<p>Finally, I'd just note that, while the above <code>testmod</code> example doesn't really show use in context of multiple claims, I have used the same tracing procedure to discover that an USB module I'm coding, was repeatedly claimed by <code>pulseaudio</code> as soon as the USB device was plugged in - so the procedure seems to work for such use cases.  </p>
"
"<p>If you use rmmod WITHOUT the --force option, it will tell you what is using a module. Example:</p>

<pre><code>$ lsmod | grep firewire
firewire_ohci          24695  0
firewire_core          50151  1 firewire_ohci
crc_itu_t               1717  1 firewire_core

$ sudo modprobe -r firewire-core
FATAL: Module firewire_core is in use.

$ sudo rmmod firewire_core
ERROR: Module firewire_core is in use by firewire_ohci

$ sudo modprobe -r firewire-ohci
$ sudo modprobe -r firewire-core
$ lsmod | grep firewire
$
</code></pre>
"
"<p>For anyone desperate to figure out why they can't reload modules, I was able to work around this problem by </p>

<ul>
<li>Getting the path of the currently used module using ""modinfo""</li>
<li>rm -rfing it</li>
<li>Copying the new module I wanted to load to the path it was in</li>
<li>Typing ""modprobe DRIVER_NAME.ko"".</li>
</ul>
"
"<p>try kgdb and set breakpoint to your module</p>
"
"<p>That example is out of date.  Under the current kernel API, pass <code>NULL</code> for the root of procfs.</p>

<p>Also, instead of <code>create_proc_entry</code>, you should use <code>proc_create()</code> with a proper <code>const struct file_operations *</code>.</p>
"
"<p>There has been a change in the interface to create an entry in the proc file system. You can have a look at <a href=""http://pointer-overloading.blogspot.in/2013/09/linux-creating-entry-in-proc-file.html"">http://pointer-overloading.blogspot.in/2013/09/linux-creating-entry-in-proc-file.html</a> for details</p>

<p>Here is a 'hello_proc' example with the new interface:</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/seq_file.h&gt;

static int hello_proc_show(struct seq_file *m, void *v) {
  seq_printf(m, ""Hello proc!\n"");
  return 0;
}

static int hello_proc_open(struct inode *inode, struct  file *file) {
  return single_open(file, hello_proc_show, NULL);
}

static const struct file_operations hello_proc_fops = {
  .owner = THIS_MODULE,
  .open = hello_proc_open,
  .read = seq_read,
  .llseek = seq_lseek,
  .release = single_release,
};

static int __init hello_proc_init(void) {
  proc_create(""hello_proc"", 0, NULL, &amp;hello_proc_fops);
  return 0;
}

static void __exit hello_proc_exit(void) {
  remove_proc_entry(""hello_proc"", NULL);
}

MODULE_LICENSE(""GPL"");
module_init(hello_proc_init);
module_exit(hello_proc_exit);
</code></pre>
"
"<p>This ought to do the trick:</p>

<pre><code>#include &lt;linux/netdevice.h&gt;

struct net_device *dev;

read_lock(&amp;dev_base_lock);

dev = first_net_device(&amp;init_net);
while (dev) {
    printk(KERN_INFO ""found [%s]\n"", dev-&gt;name);
    dev = next_net_device(dev);
}

read_unlock(&amp;dev_base_lock);
</code></pre>
"
"<p>Given a <code>struct net *net</code> identifying the net namespace that you are interested in, you should grab the <code>dev_base_lock</code> and use <code>for_each_netdev()</code>:</p>

<pre><code>read_lock(&amp;dev_base_lock);
for_each_netdev(net, dev) {
   /* Inspect dev */
}
read_unlock(&amp;dev_base_lock);
</code></pre>

<p>(In newer kernels, you can use RCU instead, but that is probably an overcomplication in this case).</p>

<hr>

<p>To obtain the <code>net</code> namespace to use, you should be registering your <code>proc</code> file with <code>register_pernet_subsys()</code>:</p>

<pre><code>static const struct file_operations foostats_seq_fops = {
    .owner   = THIS_MODULE,
    .open    = foostats_seq_open,
    .read    = seq_read,
    .llseek  = seq_lseek,
    .release = foostats_seq_release,
};

static int foo_proc_init_net(struct net *net)
{
    if (!proc_net_fops_create(net, ""foostats"", S_IRUGO,
            &amp;foostats_seq_fops))
        return -ENOMEM;
    return 0;
}

static void foo_proc_exit_net(struct net *net)
{
    proc_net_remove(net, ""foostats"");
}


static struct pernet_operations foo_proc_ops = {
    .init = foo_proc_init_net,
    .exit = foo_proc_exit_net,
};

register_pernet_subsys(&amp;foo_proc_ops)
</code></pre>

<p>In your <code>foostats_seq_open()</code> function, you take a reference on the <code>net</code> namespace, and drop it in the release function:</p>

<pre><code>static int foostats_seq_open(struct inode *inode, struct file *file)
{
    int err;
    struct net *net;

    err = -ENXIO;
    net = get_proc_net(inode);
    if (net == NULL)
        goto err_net;

    err = single_open(file, foostats_seq_show, net);
    if (err &lt; 0)
        goto err_open;

    return 0;

err_open:
    put_net(net);
err_net:
    return err;
}

static int foostats_seq_release(struct inode *inode, struct file *file)
{
    struct net *net = ((struct seq_file *)file-&gt;private_data)-&gt;private;

    put_net(net);
    return single_release(inode, file);
}
</code></pre>

<p>The <code>foostats_seq_show()</code> function can then obtain the <code>net</code>, walk the devices, gather the statistics and produce the output:</p>

<pre><code>static int sockstat6_seq_show(struct seq_file *seq, void *v)
{
    struct net *net = seq-&gt;private;
    struct net_device *dev;

    int foostat, barstat;

    read_lock(&amp;dev_base_lock);
    for_each_netdev(net, dev) {
       /* Inspect dev */
    }
    read_unlock(&amp;dev_base_lock);

    seq_printf(seq, ""Foo: %d\n"", foostat);
    seq_printf(seq, ""Bar: %d\n"", barstat);

    return 0;
}
</code></pre>
"
"<p>To have more control over the device numbers and the device creation you could do the following steps (instead of <code>register_chrdev()</code>):</p>

<ol>
<li>Call <code>alloc_chrdev_region()</code> to get a major number and a range of minor numbers to work with.</li>
<li>Create device class for your devices with <code>class_create()</code>.</li>
<li>For each device, call <code>cdev_init()</code> and <code>cdev_add()</code> to add the character device to the system.</li>
<li>For each device, call <code>device_create()</code>. As a result, among other things, <a href=""http://en.wikipedia.org/wiki/Udev"" rel=""noreferrer"">Udev</a> will create device nodes for your devices. No need for <code>mknod</code> or the like. <code>device_create()</code> also allows you to control the names of the devices.</li>
</ol>

<p>There are probably many examples of this on the Net, <a href=""https://github.com/euspectre/kedr/blob/master/sources/examples/sample_target/cfake.c"" rel=""noreferrer"">one of them is here</a>.</p>
"
"<pre><code>static int __init ofcd_init(void) /* Constructor */
{
    printk(KERN_INFO ""Welcome!"");
    if (alloc_chrdev_region(&amp;first, 0, 1, ""char_dev"") &lt; 0)  //$cat /proc/devices
    {
        return -1;
    }
    if ((cl = class_create(THIS_MODULE, ""chardrv"")) == NULL)    //$ls /sys/class
    {
        unregister_chrdev_region(first, 1);
        return -1;
    }
    if (device_create(cl, NULL, first, NULL, ""mynull"") == NULL) //$ls /dev/
    {
        class_destroy(cl);
        unregister_chrdev_region(first, 1);
        return -1;
    }
    cdev_init(&amp;c_dev, &amp;fops);
    if (cdev_add(&amp;c_dev, first, 1) == -1)
    {
        device_destroy(cl, first);
        class_destroy(cl);
        unregister_chrdev_region(first, 1);
        return -1;
    }
    return 0;
}
</code></pre>
"
"<p><strong>Minimal runnable example</strong></p>

<p>Minimized from other answers. <a href=""https://github.com/cirosantilli/linux-kernel-module-cheat/blob/68af3477cce1cd22566edce2651f54cf8c184a91/kernel_module/character_device_create.c"" rel=""nofollow noreferrer"">GitHub upstream</a> with test setup.</p>

<pre><code>#include &lt;linux/cdev.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/fs.h&gt; /* register_chrdev, unregister_chrdev */
#include &lt;linux/module.h&gt;
#include &lt;linux/seq_file.h&gt; /* seq_read, seq_lseek, single_release */

#define NAME ""lkmc_character_device_create""

static int major = -1;
static struct cdev mycdev;
static struct class *myclass = NULL;

static int show(struct seq_file *m, void *v)
{
    seq_printf(m, ""abcd"");
    return 0;
}

static int open(struct inode *inode, struct file *file)
{
    return single_open(file, show, NULL);
}

static const struct file_operations fops = {
    .llseek = seq_lseek,
    .open = open,
    .owner = THIS_MODULE,
    .read = seq_read,
    .release = single_release,
};

static void cleanup(int device_created)
{
    if (device_created) {
        device_destroy(myclass, major);
        cdev_del(&amp;mycdev);
    }
    if (myclass)
        class_destroy(myclass);
    if (major != -1)
        unregister_chrdev_region(major, 1);
}

static int myinit(void)
{
    int device_created = 0;

    /* cat /proc/devices */
    if (alloc_chrdev_region(&amp;major, 0, 1, NAME ""_proc"") &lt; 0)
        goto error;
    /* ls /sys/class */
    if ((myclass = class_create(THIS_MODULE, NAME ""_sys"")) == NULL)
        goto error;
    /* ls /dev/ */
    if (device_create(myclass, NULL, major, NULL, NAME ""_dev"") == NULL)
        goto error;
    device_created = 1;
    cdev_init(&amp;mycdev, &amp;fops);
    if (cdev_add(&amp;mycdev, major, 1) == -1)
        goto error;
    return 0;
error:
    cleanup(device_created);
    return -1;
}

static void myexit(void)
{
    cleanup(1);
}

module_init(myinit)
module_exit(myexit)
MODULE_LICENSE(""GPL"");
</code></pre>
"
"<p>This example will create a proc entry which enables reading access. I think you can enable other kinds of access by changing the <code>mode</code> argument passed to the function. I haven't passed a parent directory because there is no need to. The structure <code>file_operations</code> is where you setup your reading and writing callbacks.</p>

<pre><code>struct proc_dir_entry *proc_file_entry;

static const struct file_operations proc_file_fops = {
 .owner = THIS_MODULE,
 .open  = open_callback,
 .read  = read_callback,
};

int __init init_module(void){
  proc_file_entry = proc_create(""proc_file_name"", 0, NULL, &amp;proc_file_fops);
  if(proc_file_entry == NULL)
   return -ENOMEM;
  return 0;
}
</code></pre>

<p>You can check this example for more details: <a href=""https://www.linux.com/learn/linux-training/37985-the-kernel-newbie-corner-kernel-debugging-using-proc-qsequenceq-files-part-1"" rel=""nofollow noreferrer"">https://www.linux.com/learn/linux-training/37985-the-kernel-newbie-corner-kernel-debugging-using-proc-qsequenceq-files-part-1</a></p>
"
"<p>Here is a 'hello_proc' code, which makes use of the newer 'proc_create()' interface.</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/seq_file.h&gt;

static int hello_proc_show(struct seq_file *m, void *v) {
  seq_printf(m, ""Hello proc!\n"");
  return 0;
}

static int hello_proc_open(struct inode *inode, struct  file *file) {
  return single_open(file, hello_proc_show, NULL);
}

static const struct file_operations hello_proc_fops = {
  .owner = THIS_MODULE,
  .open = hello_proc_open,
  .read = seq_read,
  .llseek = seq_lseek,
  .release = single_release,
};

static int __init hello_proc_init(void) {
  proc_create(""hello_proc"", 0, NULL, &amp;hello_proc_fops);
  return 0;
}

static void __exit hello_proc_exit(void) {
  remove_proc_entry(""hello_proc"", NULL);
}

MODULE_LICENSE(""GPL"");
module_init(hello_proc_init);
module_exit(hello_proc_exit);
</code></pre>

<p>This code has been taken from <a href=""http://pointer-overloading.blogspot.in/2013/09/linux-creating-entry-in-proc-file.html"">http://pointer-overloading.blogspot.in/2013/09/linux-creating-entry-in-proc-file.html</a></p>
"
"<p>If you ever played with object-oriented languages like C++, think of <code>file_operations</code> as a base class, and your functions as being implementations of its virtual methods.</p>
"
"<p>Pointers to functions are a very powerful tool in the C language that allows for real-time redirect of function calls. Most if not all operating systems have a similar mechanism, like for example the infamous INT 21 functions 25/35 in the old MS-DOS that allowed TSR programs to exist.</p>

<p>In C, you can assign the pointer to a function to a variable and then call that function through that variable. The function can be changed either at init time based on some parameters or at runtime based on some behavior.</p>

<p>Here is an example:</p>

<pre><code>int fn(int a)
{
   ...
   return a;
}

...

int (*dynamic_fn)(int);
...
dynanic_fn = &amp;fn;
...
int i = dynamic_fn(0);
</code></pre>

<p>When the pointer ""lives"" in a structure that can be passed to system calls, this is a very powerful feature that allows hooks into system functions.</p>

<p>In object oriented languages, the same kind of behavior can be achieved by using reflection to instantiate classes dynamically.</p>
"
"<p>The functions <code>seq_read</code>, <code>seq_lseek</code> and <code>single_release</code> are declared in the kernel source file <code>linux-3.1.6/include/linux/seq_file.h</code> and defined in the kernel source file <code>linux-3.1.6/fs/seq_file.c</code>. They are probably common to many file operations.</p>
"
"<p>I'm not exactly sure what you mean when you say ""There is no function call for the above function with those arguments.""  </p>

<p>The prototype for these functions is defined in the <a href=""http://lxr.linux.no/linux+v3.10/include/linux/fs.h#L1517"" rel=""noreferrer"">declaration for <code>struct file_operations</code> itself</a>.</p>

<p>Here is the first few lines from the struct declaration:</p>

<pre><code>struct file_operations {
    struct module *owner;
    loff_t (*llseek) (struct file *, loff_t, int);
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
    ...
</code></pre>

<p>While the arguments are not named in the declaration, you can clearly see that the <code>write()</code> function is declared with 4 parameters matching the types that you mention in your question.</p>

<p>When you assign the function to its appropriate field (<code>proc_myled_operations.write = proc_myled_write</code>) you are simply passing a pointer to the write function declared and defined in your module.  Pointers to functions themselves do not need parameters.</p>

<hr>

<p>Ok, so you're question really is: ""How does the user space system call eventually call the write function in your module?""  Good question!  I recommend editing your question to make that clearer for future readers.</p>

<p>Well, let's see if I can follow the paper trail.  I discovered <a href=""http://docs.cs.up.ac.za/programming/asm/derick_tut/syscalls.html"" rel=""noreferrer"">this document</a> to give me the starting location to look in the code for the <code>write()</code> system call. It's very <strong>very</strong> old, but hey, not everything changes in the kernel!  We start our journey at the <code>write()</code> system call declaration in <a href=""http://lxr.linux.no/linux+v3.10/fs/read_write.c#L486"" rel=""noreferrer"">fs/read_write.c</a>:</p>

<pre><code>SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,
            size_t, count)
</code></pre>

<p>It uses the file descriptor <code>fd</code> to get the <code>struct file</code> created when you registered your character driver.  Then it gets the current position in the file and calls <a href=""http://lxr.linux.no/linux+v3.10/fs/read_write.c#L430"" rel=""noreferrer""><code>vfs_write()</code></a>.</p>

<pre><code>ssize_t vfs_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)
</code></pre>

<p>And it is in this function see <a href=""http://lxr.linux.no/linux+v3.10/fs/read_write.c#L446"" rel=""noreferrer"">the following line</a>:</p>

<pre><code>ret = file-&gt;f_op-&gt;write(file, buf, count, pos);
</code></pre>

<p>There it is!</p>

<p>To allay any doubts as to the type of <code>file-&gt;f_op</code>, we take a look at <a href=""http://lxr.linux.no/linux+v3.10/include/linux/fs.h#L763"" rel=""noreferrer"">the definition of <code>struct file</code></a> and see <a href=""http://lxr.linux.no/linux+v3.10/include/linux/fs.h#L775"" rel=""noreferrer"">the following definition for the <code>f_op</code> field</a>:</p>

<pre><code>    const struct file_operations    *f_op;
</code></pre>

<p>So it must be the <code>struct file_operations</code> you passed in when you registered your driver.  Phew!</p>

<p>Hopefully all of these links will show you how to follow the trail for other system calls if you are curious.</p>
"
"<p>@Maverick, write prototype or signature in kernel is <strong>ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *)</strong>. From user space application you will be issuing <strong>open</strong>, <strong>write</strong> system call to turn on/off the LED. Write system call signature in user space is <strong>int write(int fd, const char *buf, size_t count)</strong>. So when you call write from user space, fd (file descriptor) passed reaches the <strong>virtual file system(vfs)</strong>, maintains linked list of the <strong>open file descriptor table(OFDT)</strong>, thus according to the <strong>fd</strong>, OFDT has an pointer <strong>filp (file pointer)</strong> which point to the file opened for <strong>ex: device node ""/dev/xxx"" or any other file for that matter</strong>. The rest <strong>buf and count</strong> are same arguments passed from the user space to the kernel space. Last <strong>loff_t *fpos</strong> comes into picture if you want to seek the file for <strong>ex: using lseek or fseek on the file opened</strong>, if seek then the file pointer(<strong>loff_t fpos</strong>) position gets changed accordingly. Hope I cleared your doubt :-)</p>
"
"<p>You need hardware support for this. The CPU need to sense when a certain memory address gets written to and call some code - an interrupt or exception handler. In my experience, I've seen this on the PowerPC platform but not on the x86. It's called a hardware watchpoint.</p>

<p>Theoretically, if you run in an emulator, you could simulate this behaviour, but I am completely unfamiliar with the currently existing emulators.</p>

<p>EDIT: I've dug a little more and it seems there is a general purpose hw breakpoint interface in Linux and that x86 has such a register. It's called DR7.
Look at function in 'include/linux/hw_breakpoint.h'. It looks like ptrace and/or perf use these interfaces. Good luck debugging it!</p>
"
"<p>Many thanks for the replies by <a href=""https://stackoverflow.com/a/19734787/277826"">@CosminRatiu</a> and <a href=""https://stackoverflow.com/questions/19725900/watch-a-variable-memory-address-change-in-linux-kernel-and-print-stack-trace#comment29352526_19734787"">Eugene</a>; thanks to those, I found:</p>

<ul>
<li><a href=""https://stackoverflow.com/questions/16362063/linux-kernel-hardware-break-points/16377522#16377522"">debugging - Linux kernel hardware break points - Stack Overflow</a></li>
<li><a href=""https://www.kernel.org/doc/ols/2009/ols2009-pages-149-158.pdf"" rel=""nofollow noreferrer"">Hardware Breakpoint (or watchpoint) - The Linux Kernel Archives</a></li>
</ul>

<p>... with which I could develop the example I'm posting here, the <code>testhrarr.c</code> kernel module/driver and the <code>Makefile</code> (below). It demonstrates that the hardware watchpoint tracing can be achieved in two ways: either using the <code>perf</code> program, which can probe the driver unchanged; or by adding some hardware breakpoint code to the driver (in the example, enveloped by the <code>HWDEBUG_STACK</code> define variable). </p>

<p>Essentially, debugging contents of standard atomic variable types like ints (like the <code>runcount</code> variable) are straightforward, as long as they are defined as a global variable in the kernel module, so they end up showing as a kernel symbol globally. Because of that, the code below adds the <code>testhrarr_</code> as prefix to the variables (so as to avoid naming conflicts). However, debugging contents of arrays may be a bit trickier, due to the need for dereferencing - so that is what this post demonstrates, debug of the first byte of the <code>testhrarr_arr</code> array. It was done on:</p>

<pre><code>$ echo `cat /etc/lsb-release`
DISTRIB_ID=Ubuntu DISTRIB_RELEASE=11.04 DISTRIB_CODENAME=natty DISTRIB_DESCRIPTION=""Ubuntu 11.04""
$ uname -a
Linux mypc 2.6.38-16-generic #67-Ubuntu SMP Thu Sep 6 18:00:43 UTC 2012 i686 i686 i386 GNU/Linux
$ cat /proc/cpuinfo | grep ""model name""
model name  : Intel(R) Atom(TM) CPU N450   @ 1.66GHz
model name  : Intel(R) Atom(TM) CPU N450   @ 1.66GHz
</code></pre>

<p>The <code>testhrarr</code> module basically allocates memory for a small array upon module initialization, sets up a timer function, and exposes a <code>/proc/testhrarr_proc</code> file (using the newer <code>proc_create</code> interface). Then, attempting to read from the <code>/proc/testhrarr_proc</code> file (say, using <code>cat</code>) will trigger the timer function, which will modify the <code>testhrarr_arr</code> array values, and dump messages to <code>/var/log/syslog</code>. We expect that <code>testhrarr_arr[0]</code> will change three times during the operation; once in <code>testhrarr_startup</code>, and twice in <code>testhrarr_timer_function</code> (due to wrapping).  </p>

<h2>using <code>perf</code></h2>

<p>After building the module with <code>make</code>, you can load it with:</p>

<pre><code>sudo insmod ./testhrarr.ko
</code></pre>

<p>At that point, <code>/var/log/syslog</code> would contain:</p>

<pre><code>kernel: [40277.199913] Init testhrarr: 0 ; HZ: 250 ; 1/HZ (ms): 4 ; hrres: 0.000000001
kernel: [40277.199930]  Addresses: _runcount 0xf84be22c ; _arr 0xf84be2a0 ; _arr[0] 0xed182a80 (0xed182a80) ; _timer_function 0xf84bc1c3 ; my_hrtimer 0xf84be260; my_hrt.f 0xf84be27c
kernel: [40277.220329] HW Breakpoint for testhrarr_arr write installed (0xf84be2a0)
</code></pre>

<p>Note that just passing <code>testhrarr_arr</code> as symbol for hardware watchpoint scans the address of that variable (<code>0xf84be2a0</code>), not the address of the first element of the array (<code>0xed182a80</code>)! Because of this, the hardware breakpoint is <em>not</em> going to trigger - so the behavior will be as if the hardware breakpoint code is not present at all (which can be achieved by undefining <code>HWDEBUG_STACK</code>)!</p>

<p>So, even without a hardware breakpoint set through kernel module code, we can still use <code>perf</code> to observe a change of a memory address - in <code>perf</code>, we specify both the address we want to watch (here the address of the first element of <code>testhrarr_arr</code>, <code>0xed182a80</code>), and the process which should be ran: here we run <code>bash</code>, so we can execute a <code>cat /proc/testhrarr_proc</code> which will trigger the kernel module timer, followed by a <code>sleep 0.5</code> which will allow the timer to complete. The <code>-a</code> parameter is also needed, otherwise some events may be missed:</p>

<pre><code>$ sudo perf record -a --call-graph --event=mem:0xed182a80:w bash -c 'cat /proc/testhrarr_proc ; sleep 0.5'
testhrarr proc: startup
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.485 MB perf.data (~21172 samples) ]
</code></pre>

<p>At this point, <code>/var/log/syslog</code> would also contain something like:</p>

<pre><sup>
[40822.114964]  testhrarr_timer_function: testhrarr_runcount 0
[40822.114980]  testhrarr jiffies 10130528 ; ret: 1 ; ktnsec: 40822114975062
[40822.118956]  testhrarr_timer_function: testhrarr_runcount 1
[40822.118977]  testhrarr jiffies 10130529 ; ret: 1 ; ktnsec: 40822118973195
[40822.122940]  testhrarr_timer_function: testhrarr_runcount 2
[40822.122956]  testhrarr jiffies 10130530 ; ret: 1 ; ktnsec: 40822122951143
[40822.126962]  testhrarr_timer_function: testhrarr_runcount 3
[40822.126978]  testhrarr jiffies 10130531 ; ret: 1 ; ktnsec: 40822126973583
[40822.130941]  testhrarr_timer_function: testhrarr_runcount 4
[40822.130961]  testhrarr jiffies 10130532 ; ret: 1 ; ktnsec: 40822130955167
[40822.134940]  testhrarr_timer_function: testhrarr_runcount 5
[40822.134962]  testhrarr jiffies 10130533 ; ret: 1 ; ktnsec: 40822134958888
[40822.138936]  testhrarr_timer_function: testhrarr_runcount 6
[40822.138958]  testhrarr jiffies 10130534 ; ret: 1 ; ktnsec: 40822138955693
[40822.142940]  testhrarr_timer_function: testhrarr_runcount 7
[40822.142962]  testhrarr jiffies 10130535 ; ret: 1 ; ktnsec: 40822142959345
[40822.146936]  testhrarr_timer_function: testhrarr_runcount 8
[40822.146957]  testhrarr jiffies 10130536 ; ret: 1 ; ktnsec: 40822146954479
[40822.150949]  testhrarr_timer_function: testhrarr_runcount 9
[40822.150970]  testhrarr jiffies 10130537 ; ret: 1 ; ktnsec: 40822150963438
[40822.154974]  testhrarr_timer_function: testhrarr_runcount 10
[40822.154988] testhrarr [ 5, 7, 9, 11, 13, ]
</sup></pre>

<p>To read the capture of <code>perf</code> (a file called <code>perf.data</code>) we can use:</p>

<pre>$ sudo perf report --call-graph flat --stdio
<sup>No kallsyms or vmlinux with build-id 5031df4d8668bcc45a7bdb4023909c6f8e2d3d34 was found
[testhrarr] with build id 5031df4d8668bcc45a7bdb4023909c6f8e2d3d34 not found, continuing without symbols
Failed to open /bin/cat, continuing without symbols
Failed to open /usr/lib/libpixman-1.so.0.20.2, continuing without symbols
Failed to open /usr/lib/xorg/modules/drivers/intel_drv.so, continuing without symbols
Failed to open /usr/bin/Xorg, continuing without symbols
# Events: 5  unknown
#
# Overhead  Command  Shared Object                                Symbol
# ........  .......  .............  ....................................
#
    87.50%     Xorg  [testhrarr]    [k] testhrarr_timer_function
            87.50%
                testhrarr_timer_function
                __run_hrtimer
                hrtimer_interrupt
                smp_apic_timer_interrupt
                apic_timer_interrupt
                0x30185d
                0x2ed701
                0x2ed8cc
                0x2edba0
                0x9d0386
                0x8126fc8
                0x81217a1
                0x811bdd3
                0x8070aa7
                0x806281c
                __libc_start_main
                0x8062411

     6.25%      cat  [testhrarr]    [k] testhrarr_timer_function
             6.25%
                testhrarr_timer_function
                testhrarr_proc_show
                seq_read
                proc_reg_read
                vfs_read
                sys_read
                syscall_call
                0xaa2416
                0x8049f4d
                __libc_start_main
                0x8049081

     3.12%  swapper  [testhrarr]    [k] testhrarr_timer_function
             3.12%
                testhrarr_timer_function
                __run_hrtimer
                hrtimer_interrupt
                smp_apic_timer_interrupt
                apic_timer_interrupt
                cpuidle_idle_call
                cpu_idle
                start_secondary

     3.12%      cat  [testhrarr]    [k] 0x356
             3.12%
                0xf84bc356
                0xf84bc3a7
                seq_read
                proc_reg_read
                vfs_read
                sys_read
                syscall_call
                0xaa2416
                0x8049f4d
                __libc_start_main
                0x8049081



#
# (For a higher level overview, try: perf report --sort comm,dso)
#
</sup></pre>

<p>So, since we're building the kernel module with debugging on (<code>-g</code> in the <code>Makefile</code>), it is not a problem for <code>perf</code> to find this module's symbols, even if the live kernel is not a debug kernel. So it correctly interprets <code>testhrarr_timer_function</code> as the setter most of the time, although it doesn't report <code>testhrarr_startup</code> (but it does report <code>testhrarr_proc_show</code> which calls it). There are also references to <code>0xf84bc3a7</code> and <code>0xf84bc356</code> which it couldn't resolve; however, note that the module is loaded at <code>0xf84bc000</code>:</p>

<pre><code>$ sudo cat /proc/modules | grep testhr
testhrarr 13433 0 - Live 0xf84bc000
</code></pre>

<p>... and that entry also starts with <code>...[k] 0x356</code>; and if we look in the <code>objdump</code> of the kernel module:</p>

<pre>$ objdump -S testhrarr.ko | less
<sup>...
00000323 :

static void testhrarr_startup(void)
{
...
    testhrarr_arr[0] = 0; //just the first element
 34b:   a1 80 00 00 00          mov    0x80,%eax
 350:   c7 00 00 00 00 00       movl   $0x0,(%eax)
    hrtimer_start(&my_hrtimer, ktime_period_ns, HRTIMER_MODE_REL);
 356:   c7 04 24 01 00 00 00    movl   $0x1,(%esp)                     **********
 35d:   8b 15 1c 00 00 00       mov    0x1c,%edx
...
00000375 :


static int testhrarr_proc_show(struct seq_file *m, void *v) {
...
    seq_printf(m, ""testhrarr proc: startup\n"");
 38f:   c7 44 24 04 79 00 00    movl   $0x79,0x4(%esp)
 396:   00
 397:   8b 45 fc                mov    -0x4(%ebp),%eax
 39a:   89 04 24                mov    %eax,(%esp)
 39d:   e8 fc ff ff ff          call   39e
    testhrarr_startup();
 3a2:   e8 7c ff ff ff          call   323
 3a7:   eb 1c                   jmp    3c5   **********
  } else {
    seq_printf(m, ""testhrarr proc: (is running, %d)\n"", testhrarr_runcount);
 3a9:   a1 0c 00 00 00          mov    0xc,%eax
...
</sup></pre>

<p>... so <code>0xf84bc356</code> apparently refers to <code>hrtimer_start</code>; and <code>0xf84bc3a7</code> -> <code>3a7</code> refers to its calling <code>testhrarr_proc_show</code> function; which thankfully makes sense. (Note that I've experienced with different versions of the driver, that the <code>_start</code> could show, and the <code>timer_function</code> to be expressed by sheer addresses; not sure what this is due). </p>

<p>One problem with <code>perf</code>, though, is that it gives me a statistical ""Overhead"" of these functions occurring (not sure what that refers to - probably time spent between entry and exit of a function?) - but what I want, really, is a log of stack traces which is sequential. Not sure if <code>perf</code> can be set up for that - but it definitely be done with kernel module code for hardware breakpoints.  </p>

<h2>using kernel module HW breakpoint</h2>

<p>The code which is in the <code>HWDEBUG_STACK</code> implements the HW breakpoint setup and handling. As noted, the default set up for the symbol <code>ksym_name</code> (if unspecified), is <code>testhrarr_arr</code>, which doesn't trigger the hardware breakpoint at all. The <code>ksym_name</code> parameter can be specified on the command line during <code>insmod</code>; here we can note that:</p>

<pre><code>$ sudo rmmod testhrarr    # remove module if still loaded
$ sudo insmod ./testhrarr.ko ksym=testhrarr_arr[0]
</code></pre>

<p>... results with a <code>HW Breakpoint for testhrarr_arr[0] write installed (0x  (null))</code> in <code>/var/log/syslog</code>; - which means we cannot use symbols with bracket notation for array access; thankfully a null pointer here simply means that HW breakpoint will again not fire; it doesn't crash the OS completely <code>:)</code></p>

<p>There is, however, a global variable made to refer to the first element of the <code>testhrarr_arr</code> array, called <code>testhrarr_arr_first</code> - note how this global variable is specially handled in the code, and needs to be dereferenced, so that the correct address is obtained. So we do:</p>

<pre><code>$ sudo rmmod testhrarr    # remove module if still loaded
$ sudo insmod ./testhrarr.ko ksym=testhrarr_arr_first
</code></pre>

<p>... and the syslog informs:</p>

<pre><code>kernel: [43910.509726] Init testhrarr: 0 ; HZ: 250 ; 1/HZ (ms): 4 ; hrres: 0.000000001
kernel: [43910.509765]  Addresses: _runcount 0xf84be22c ; _arr 0xf84be2a0 ; _arr[0] 0xedf6c5c0 (0xedf6c5c0) ; _timer_function 0xf84bc1c3 ; my_hrtimer 0xf84be260; my_hrt.f 0xf84be27c
kernel: [43910.538535] HW Breakpoint for testhrarr_arr_first write installed (0xedf6c5c0)
</code></pre>

<p>... and we can see that the HW breakpoint is set at <code>0xedf6c5c0</code>, which is the address of <code>testhrarr_arr[0]</code>. Now if we trigger the driver via the <code>/proc</code> file:</p>

<pre><code>$ cat /proc/testhrarr_proc
testhrarr proc: startup
</code></pre>

<p>... we obtain in <code>syslog</code>:</p>

<pre><sup>kernel: [44069.735695] testhrarr_arr_first value is changed
[44069.735711] Pid: 29320, comm: cat Not tainted 2.6.38-16-generic #67-Ubuntu
[44069.735719] Call Trace:
[44069.735737]  [] ? sample_hbp_handler+0x2d/0x3b [testhrarr]
[44069.735755]  [] ? __perf_event_overflow+0x90/0x240
[44069.735768]  [] ? proc_alloc_inode+0x23/0x90
[44069.735778]  [] ? proc_alloc_inode+0x23/0x90
[44069.735790]  [] ? perf_swevent_event+0x136/0x140
[44069.735801]  [] ? perf_bp_event+0x70/0x80
[44069.735812]  [] ? prep_new_page+0x110/0x1a0
[44069.735824]  [] ? get_page_from_freelist+0x12e/0x320
[44069.735836]  [] ? seq_open+0x3d/0xa0
[44069.735848]  [] ? hw_breakpoint_handler.clone.0+0x102/0x130
[44069.735861]  [] ? hw_breakpoint_exceptions_notify+0x22/0x30
[44069.735872]  [] ? notifier_call_chain+0x45/0x60
[44069.735883]  [] ? atomic_notifier_call_chain+0x22/0x30
[44069.735894]  [] ? notify_die+0x2d/0x30
[44069.735904]  [] ? do_debug+0x88/0x180
[44069.735915]  [] ? debug_stack_correct+0x30/0x38
[44069.735928]  [] ? testhrarr_startup+0x33/0x52 [testhrarr]
[44069.735940]  [] ? testhrarr_proc_show+0x32/0x57 [testhrarr]
[44069.735952]  [] ? seq_read+0x145/0x390
[44069.735963]  [] ? seq_read+0x0/0x390
[44069.735973]  [] ? proc_reg_read+0x64/0xa0
[44069.735985]  [] ? vfs_read+0x9f/0x160
[44069.735995]  [] ? proc_reg_read+0x0/0xa0
[44069.736003]  [] ? sys_read+0x42/0x70
[44069.736013]  [] ? syscall_call+0x7/0xb
[44069.736019] Dump stack from sample_hbp_handler
[44069.740132]  testhrarr_timer_function: testhrarr_runcount 0
[44069.740146]  testhrarr jiffies 10942435 ; ret: 1 ; ktnsec: 44069740142485
[44069.740159] testhrarr_arr_first value is changed
[44069.740169] Pid: 4302, comm: gnome-terminal Not tainted 2.6.38-16-generic #67-Ubuntu
[44069.740176] Call Trace:
[44069.740195]  [] ? sample_hbp_handler+0x2d/0x3b [testhrarr]
[44069.740213]  [] ? __perf_event_overflow+0x90/0x240
[44069.740227]  [] ? perf_swevent_event+0x136/0x140
[44069.740239]  [] ? perf_bp_event+0x70/0x80
[44069.740253]  [] ? sched_clock_local+0xd3/0x1c0
[44069.740267]  [] ? format_decode+0x323/0x380
[44069.740280]  [] ? hw_breakpoint_handler.clone.0+0x102/0x130
[44069.740292]  [] ? hw_breakpoint_exceptions_notify+0x22/0x30
[44069.740302]  [] ? notifier_call_chain+0x45/0x60
[44069.740313]  [] ? atomic_notifier_call_chain+0x22/0x30
[44069.740324]  [] ? notify_die+0x2d/0x30
[44069.740335]  [] ? do_debug+0x88/0x180
[44069.740345]  [] ? debug_stack_correct+0x30/0x38
[44069.740364]  [] ? init_intel_cacheinfo+0x103/0x394
[44069.740379]  [] ? testhrarr_timer_function+0xed/0x160 [testhrarr]
[44069.740391]  [] ? __run_hrtimer+0x6f/0x190
[44069.740404]  [] ? testhrarr_timer_function+0x0/0x160 [testhrarr]
[44069.740416]  [] ? hrtimer_interrupt+0x108/0x240
[44069.740430]  [] ? smp_apic_timer_interrupt+0x56/0x8a
[44069.740441]  [] ? apic_timer_interrupt+0x31/0x38
[44069.740453]  [] ? _raw_spin_unlock_irqrestore+0x15/0x20
[44069.740465]  [] ? try_to_del_timer_sync+0x67/0xb0
[44069.740476]  [] ? del_timer_sync+0x29/0x50
[44069.740486]  [] ? flush_delayed_work+0x13/0x40
[44069.740500]  [] ? tty_flush_to_ldisc+0x12/0x20
[44069.740510]  [] ? n_tty_poll+0x4f/0x190
[44069.740523]  [] ? tty_poll+0x6d/0x90
[44069.740531]  [] ? n_tty_poll+0x0/0x190
[44069.740542]  [] ? do_poll.clone.3+0xd0/0x210
[44069.740553]  [] ? do_sys_poll+0x134/0x1e0
[44069.740563]  [] ? __pollwait+0x0/0xd0
[44069.740572]  [] ? pollwake+0x0/0x60
...
[44069.740742]  [] ? pollwake+0x0/0x60
[44069.740757]  [] ? rw_verify_area+0x6c/0x130
[44069.740770]  [] ? ktime_get_ts+0xf8/0x120
[44069.740781]  [] ? poll_select_set_timeout+0x64/0x70
[44069.740793]  [] ? sys_poll+0x5a/0xd0
[44069.740804]  [] ? syscall_call+0x7/0xb
[44069.740815]  [] ? init_intel_cacheinfo+0x23/0x394
[44069.740822] Dump stack from sample_hbp_handler
[44069.744130]  testhrarr_timer_function: testhrarr_runcount 1
[44069.744143]  testhrarr jiffies 10942436 ; ret: 1 ; ktnsec: 44069744140055
[44069.748132]  testhrarr_timer_function: testhrarr_runcount 2
[44069.748145]  testhrarr jiffies 10942437 ; ret: 1 ; ktnsec: 44069748141271
[44069.752131]  testhrarr_timer_function: testhrarr_runcount 3
[44069.752145]  testhrarr jiffies 10942438 ; ret: 1 ; ktnsec: 44069752141164
[44069.756131]  testhrarr_timer_function: testhrarr_runcount 4
[44069.756141]  testhrarr jiffies 10942439 ; ret: 1 ; ktnsec: 44069756138318
[44069.760130]  testhrarr_timer_function: testhrarr_runcount 5
[44069.760141]  testhrarr jiffies 10942440 ; ret: 1 ; ktnsec: 44069760138469
[44069.760154] testhrarr_arr_first value is changed
[44069.760164] Pid: 4302, comm: gnome-terminal Not tainted 2.6.38-16-generic #67-Ubuntu
[44069.760170] Call Trace:
[44069.760187]  [] ? sample_hbp_handler+0x2d/0x3b [testhrarr]
[44069.760202]  [] ? __perf_event_overflow+0x90/0x240
[44069.760213]  [] ? perf_swevent_event+0x136/0x140
[44069.760224]  [] ? perf_bp_event+0x70/0x80
[44069.760235]  [] ? sched_clock_local+0xd3/0x1c0
[44069.760247]  [] ? format_decode+0x323/0x380
[44069.760258]  [] ? hw_breakpoint_handler.clone.0+0x102/0x130
[44069.760269]  [] ? hw_breakpoint_exceptions_notify+0x22/0x30
[44069.760279]  [] ? notifier_call_chain+0x45/0x60
[44069.760289]  [] ? atomic_notifier_call_chain+0x22/0x30
[44069.760299]  [] ? notify_die+0x2d/0x30
[44069.760308]  [] ? do_debug+0x88/0x180
[44069.760318]  [] ? debug_stack_correct+0x30/0x38
[44069.760334]  [] ? init_intel_cacheinfo+0x103/0x394
[44069.760345]  [] ? testhrarr_timer_function+0xed/0x160 [testhrarr]
[44069.760356]  [] ? __run_hrtimer+0x6f/0x190
[44069.760366]  [] ? send_to_group.clone.1+0xf8/0x150
[44069.760376]  [] ? testhrarr_timer_function+0x0/0x160 [testhrarr]
[44069.760387]  [] ? hrtimer_interrupt+0x108/0x240
[44069.760396]  [] ? fsnotify+0x1a5/0x290
[44069.760407]  [] ? smp_apic_timer_interrupt+0x56/0x8a
[44069.760416]  [] ? apic_timer_interrupt+0x31/0x38
[44069.760428]  [] ? mem_cgroup_resize_limit+0x108/0x1c0
[44069.760437]  [] ? fput+0x0/0x30
[44069.760446]  [] ? sys_write+0x67/0x70
[44069.760455]  [] ? syscall_call+0x7/0xb
[44069.760464]  [] ? init_intel_cacheinfo+0x23/0x394
[44069.760470] Dump stack from sample_hbp_handler
[44069.764134]  testhrarr_timer_function: testhrarr_runcount 6
[44069.764147]  testhrarr jiffies 10942441 ; ret: 1 ; ktnsec: 44069764144141
[44069.768133]  testhrarr_timer_function: testhrarr_runcount 7
[44069.768146]  testhrarr jiffies 10942442 ; ret: 1 ; ktnsec: 44069768142976
[44069.772134]  testhrarr_timer_function: testhrarr_runcount 8
[44069.772148]  testhrarr jiffies 10942443 ; ret: 1 ; ktnsec: 44069772144121
[44069.776132]  testhrarr_timer_function: testhrarr_runcount 9
[44069.776145]  testhrarr jiffies 10942444 ; ret: 1 ; ktnsec: 44069776141971
[44069.780133]  testhrarr_timer_function: testhrarr_runcount 10
[44069.780141] testhrarr [ 5, 7, 9, 11, 13, ]</sup></pre>

<p>... we get a stack trace exactly three times - once during <code>testhrarr_startup</code>, and twice in <code>testhrarr_timer_function</code>: once for <code>runcount==0</code> and once for <code>runcount==5</code>, as expected. </p>

<p>Well, hope this helps someone,<br>
Cheers!</p>

<hr>

<p><strong><code>Makefile</code></strong></p>

<pre><code>CONFIG_MODULE_FORCE_UNLOAD=y

# debug build:
# ""CFLAGS was changed ... Fix it to use EXTRA_CFLAGS.""
override EXTRA_CFLAGS+=-g -O0

obj-m += testhrarr.o
#testhrarr-objs  := testhrarr.o

all:
    @echo EXTRA_CFLAGS = $(EXTRA_CFLAGS)
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
    make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
</code></pre>

<p><strong><code>testhrarr.c</code></strong></p>

<pre><code>/*
 * [http://www.tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN189 The Linux Kernel Module Programming Guide]
 * https://stackoverflow.com/questions/16920238/reliability-of-linux-kernel-add-timer-at-resolution-of-one-jiffy/17055867#17055867
 * https://stackoverflow.com/questions/8516021/proc-create-example-for-kernel-module/18924359#18924359
 * http://lxr.free-electrons.com/source/samples/hw_breakpoint/data_breakpoint.c
 */


#include &lt;linux/module.h&gt;   /* Needed by all modules */
#include &lt;linux/kernel.h&gt;   /* Needed for KERN_INFO */
#include &lt;linux/init.h&gt;     /* Needed for the macros */
#include &lt;linux/jiffies.h&gt;
#include &lt;linux/time.h&gt;
#include &lt;linux/proc_fs.h&gt;  /* /proc entry */
#include &lt;linux/seq_file.h&gt; /* /proc entry */
#define ARRSIZE 5
#define MAXRUNS 2*ARRSIZE

#include &lt;linux/hrtimer.h&gt;

#define HWDEBUG_STACK 1

#if (HWDEBUG_STACK == 1)
#include &lt;linux/perf_event.h&gt;
#include &lt;linux/hw_breakpoint.h&gt;

struct perf_event * __percpu *sample_hbp;
static char ksym_name[KSYM_NAME_LEN] = ""testhrarr_arr"";
module_param_string(ksym, ksym_name, KSYM_NAME_LEN, S_IRUGO);
MODULE_PARM_DESC(ksym, ""Kernel symbol to monitor; this module will report any""
      "" write operations on the kernel symbol"");
#endif

static volatile int testhrarr_runcount = 0;
static volatile int testhrarr_isRunning = 0;

static unsigned long period_ms;
static unsigned long period_ns;
static ktime_t ktime_period_ns;
static struct hrtimer my_hrtimer;

static int* testhrarr_arr;
static int* testhrarr_arr_first;

static enum hrtimer_restart testhrarr_timer_function(struct hrtimer *timer)
{
  unsigned long tjnow;
  ktime_t kt_now;
  int ret_overrun;

  printk(KERN_INFO
    "" %s: testhrarr_runcount %d \n"",
    __func__, testhrarr_runcount);

  if (testhrarr_runcount &lt; MAXRUNS) {
    tjnow = jiffies;
    kt_now = hrtimer_cb_get_time(&amp;my_hrtimer);
    ret_overrun = hrtimer_forward(&amp;my_hrtimer, kt_now, ktime_period_ns);
    printk(KERN_INFO
      "" testhrarr jiffies %lu ; ret: %d ; ktnsec: %lld\n"",
      tjnow, ret_overrun, ktime_to_ns(kt_now));
    testhrarr_arr[(testhrarr_runcount % ARRSIZE)] += testhrarr_runcount;
    testhrarr_runcount++;
    return HRTIMER_RESTART;
  }
  else {
    int i;
    testhrarr_isRunning = 0;
    // do not use KERN_DEBUG etc, if printk buffering until newline is desired!
    printk(""testhrarr_arr [ "");
    for(i=0; i&lt;ARRSIZE; i++) {
      printk(""%d, "", testhrarr_arr[i]);
    }
    printk(""]\n"");
    return HRTIMER_NORESTART;
  }
}

static void testhrarr_startup(void)
{
  if (testhrarr_isRunning == 0) {
    testhrarr_isRunning = 1;
    testhrarr_runcount = 0;
    testhrarr_arr[0] = 0; //just the first element
    hrtimer_start(&amp;my_hrtimer, ktime_period_ns, HRTIMER_MODE_REL);
  }
}


static int testhrarr_proc_show(struct seq_file *m, void *v) {
  if (testhrarr_isRunning == 0) {
    seq_printf(m, ""testhrarr proc: startup\n"");
    testhrarr_startup();
  } else {
    seq_printf(m, ""testhrarr proc: (is running, %d)\n"", testhrarr_runcount);
  }
  return 0;
}

static int testhrarr_proc_open(struct inode *inode, struct  file *file) {
  return single_open(file, testhrarr_proc_show, NULL);
}

static const struct file_operations testhrarr_proc_fops = {
  .owner = THIS_MODULE,
  .open = testhrarr_proc_open,
  .read = seq_read,
  .llseek = seq_lseek,
  .release = single_release,
};


#if (HWDEBUG_STACK == 1)
static void sample_hbp_handler(struct perf_event *bp,
             struct perf_sample_data *data,
             struct pt_regs *regs)
{
  printk(KERN_INFO ""%s value is changed\n"", ksym_name);
  dump_stack();
  printk(KERN_INFO ""Dump stack from sample_hbp_handler\n"");
}
#endif

static int __init testhrarr_init(void)
{
  struct timespec tp_hr_res;
  #if (HWDEBUG_STACK == 1)
  struct perf_event_attr attr;
  #endif

  period_ms = 1000/HZ;
  hrtimer_get_res(CLOCK_MONOTONIC, &amp;tp_hr_res);
  printk(KERN_INFO
    ""Init testhrarr: %d ; HZ: %d ; 1/HZ (ms): %ld ; hrres: %lld.%.9ld\n"",
               testhrarr_runcount,      HZ,        period_ms, (long long)tp_hr_res.tv_sec, tp_hr_res.tv_nsec );

  testhrarr_arr = (int*)kcalloc(ARRSIZE, sizeof(int), GFP_ATOMIC);
  testhrarr_arr_first = &amp;testhrarr_arr[0];

  hrtimer_init(&amp;my_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
  my_hrtimer.function = &amp;testhrarr_timer_function;
  period_ns = period_ms*( (unsigned long)1E6L );
  ktime_period_ns = ktime_set(0,period_ns);

  printk(KERN_INFO
    "" Addresses: _runcount 0x%p ; _arr 0x%p ; _arr[0] 0x%p (0x%p) ; _timer_function 0x%p ; my_hrtimer 0x%p; my_hrt.f 0x%p\n"",
    &amp;testhrarr_runcount, &amp;testhrarr_arr, &amp;(testhrarr_arr[0]), testhrarr_arr_first, &amp;testhrarr_timer_function, &amp;my_hrtimer, &amp;my_hrtimer.function);


  proc_create(""testhrarr_proc"", 0, NULL, &amp;testhrarr_proc_fops);


  #if (HWDEBUG_STACK == 1)
  hw_breakpoint_init(&amp;attr);
  if (strcmp(ksym_name, ""testhrarr_arr_first"") == 0) {
    // just for testhrarr_arr_first - interpret the found symbol address
    // as int*, and dereference it to get the ""real"" address it points to
    attr.bp_addr = *((int*)kallsyms_lookup_name(ksym_name));
  } else {
    // the usual - address is kallsyms_lookup_name result
    attr.bp_addr = kallsyms_lookup_name(ksym_name);
  }
  attr.bp_len = HW_BREAKPOINT_LEN_1;
  attr.bp_type = HW_BREAKPOINT_W ; //| HW_BREAKPOINT_R;

  sample_hbp = register_wide_hw_breakpoint(&amp;attr, (perf_overflow_handler_t)sample_hbp_handler);
  if (IS_ERR((void __force *)sample_hbp)) {
    int ret = PTR_ERR((void __force *)sample_hbp);
    printk(KERN_INFO ""Breakpoint registration failed\n"");
    return ret;
  }

  // explicit cast needed to show 64-bit bp_addr as 32-bit address
  // https://stackoverflow.com/questions/11796909/how-to-resolve-cast-to-pointer-from-integer-of-different-size-warning-in-c-co/11797103#11797103
  printk(KERN_INFO ""HW Breakpoint for %s write installed (0x%p)\n"", ksym_name, (void*)(uintptr_t)attr.bp_addr);
  #endif

  return 0;
}

static void __exit testhrarr_exit(void)
{
  int ret_cancel = 0;
  kfree(testhrarr_arr);
  while( hrtimer_callback_running(&amp;my_hrtimer) ) {
    ret_cancel++;
  }
  if (ret_cancel != 0) {
    printk(KERN_INFO "" testhrarr Waited for hrtimer callback to finish (%d)\n"", ret_cancel);
  }
  if (hrtimer_active(&amp;my_hrtimer) != 0) {
    ret_cancel = hrtimer_cancel(&amp;my_hrtimer);
    printk(KERN_INFO "" testhrarr active hrtimer cancelled: %d (%d)\n"", ret_cancel, testhrarr_runcount);
  }
  if (hrtimer_is_queued(&amp;my_hrtimer) != 0) {
    ret_cancel = hrtimer_cancel(&amp;my_hrtimer);
    printk(KERN_INFO "" testhrarr queued hrtimer cancelled: %d (%d)\n"", ret_cancel, testhrarr_runcount);
  }
  remove_proc_entry(""testhrarr_proc"", NULL);
  #if (HWDEBUG_STACK == 1)
  unregister_wide_hw_breakpoint(sample_hbp);
  printk(KERN_INFO ""HW Breakpoint for %s write uninstalled\n"", ksym_name);
  #endif
  printk(KERN_INFO ""Exit testhrarr\n"");
}

module_init(testhrarr_init);
module_exit(testhrarr_exit);

MODULE_LICENSE(""GPL"");
</code></pre>
"
"<p>I guess you have added this line <code>interrupt_time = skb -&gt; timestamp</code>. If yes, then</p>

<ol>
<li>Open proc file in kernel space (check fs/proc/ and add an entry for timestamp)</li>
<li>Register your open/read calls.</li>
<li>Whenever user tries to read a file Linux Kernel calls registered read call, in your case it is dev_read. </li>
</ol>

<p>Check <a href=""http://www.ibm.com/developerworks/library/l-proc/"" rel=""nofollow"">this link</a> for how proc fs is used</p>
"
"<pre><code>There is sample proc code and its output


Sample proc code
===============

[root@localhost p]# cat test.c

#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/jiffies.h&gt;
#include &lt;linux/seq_file.h&gt;

//extern uint64_t interrupt_time;

static struct proc_dir_entry *test_dir;

static int my_proc_show(struct seq_file *m, void *v)
{
    seq_printf(m, ""%lu\n"", jiffies);
    //seq_printf(m, ""%lu"", interrupt_time);
    return 0;
}

static int my_proc_open(struct inode *inode, struct file *file)
{
    return single_open(file, my_proc_show, NULL);
}

static const struct file_operations tst_fops = {
    .open       = my_proc_open,
    .read       = seq_read,
    .llseek     = seq_lseek,
    .release    = single_release,
};

static int __init test_init(void)
{
    test_dir = proc_mkdir(""myproc"", NULL);

    if (test_dir)
            proc_create(""jiffies"", 0, test_dir, &amp;tst_fops);

    return 0;
}
static void __exit test_exit(void)
{
    remove_proc_entry (""jiffies"", test_dir);
    proc_remove (test_dir);
}
module_init(test_init);
module_exit(test_exit);

MODULE_LICENSE(""GPL"");
MODULE_AUTHOR(""Test"");

    Output
   ======
    [root@localhost p]# cat /proc/myproc/jiffies
    4325737301
</code></pre>
"
"<p>I'm not sure if your issue is how to create and populate entries in <code>/proc</code> or how to read from an existing one. Regarding the latter:</p>

<blockquote>
  <p>how to read it to the user application </p>
</blockquote>

<p>From the user program open <code>/proc/foo/bar</code> and read from it, as from any other file.</p>
"
"<p>It is crashing becasue of this return( ( *pos &lt; NUM_MSG_HIST_ENTRIES ) ? pos : NULL );</p>
"
"<p>Sorry, I got the fix.</p>

<p>Erroneous code</p>

<pre><code>static const struct file_operations basic_proc_fops =
{

  .owner = THIS_MODULE,
  .open = basicProcOpen,
  .read = seq_read,
  .llseek = seq_lseek,
  .release = single_release,

};
</code></pre>

<p>Right code-</p>

<pre><code> static const struct file_operations basic_proc_fops =
    {

      .owner = THIS_MODULE,
      .open = basicProcOpen,
      .read = seq_read,
      .llseek = seq_lseek,
      .release = seq_release,

    };
</code></pre>

<p>I would appreciate, if someone can explain why it makes the difference.</p>
"
"<p>(I do not have enough reputation to comment, so adding it as an answer) Regarding your question on why seq_release and not single_release, 'release' functions should compliment 'open' functions. Your open function here 'basicProcOpen' calls 'seq_open' so you should be calling seq_release.</p>

<p>If you look at single_release, in addition to seq_release, there is a kfree(op) which causes your crash.</p>

<pre><code>623 int single_release(struct inode *inode, struct file *file)
624 {
625         const struct seq_operations *op = ((struct seq_file *)file-&gt;private_data)-&gt;op;
626         int res = seq_release(inode, file);
627         kfree(op);
628         return res;
629 }
630 EXPORT_SYMBOL(single_release);
</code></pre>
"
"<p>There are 2 problems with your code:</p>

<ol>
<li><p>Use Linux kernel macro for your code. <a href=""http://makelinux.com/ldd3/chp-11-sect-5"" rel=""nofollow"">http://makelinux.com/ldd3/chp-11-sect-5</a> . Just add <code>struct list_head</code> as element to your <code>struct values_list</code> and use <code>list_entry</code>, <code>list_add</code> and other</p></li>
<li><p>Netfilter hools are run in softirq context, so you <strong>must</strong> use <code>spin_lock_irqsave</code> and <code>spin_unlock_irqrestore</code>. This is most likely reason why your system crashes with softlockup. Read carefully <a href=""http://makelinux.com/ldd3/chp-5-sect-5"" rel=""nofollow"">http://makelinux.com/ldd3/chp-5-sect-5</a></p></li>
</ol>
"
"<p><code>seq_file</code> is a helper for implementing a read-only file.
The buffer of the <code>show</code> callback is a kernel buffer where you are supposed to write the data that is to be returned to user space.</p>

<p>You can choose to use <code>seq_file</code>, or not; but it would not make sense here.</p>

<p>But in any case, procfs operations are defined with <code>struct file_operations</code>;
to implement a write callback, just implement <code>write</code> in <code>fops</code>.</p>
"
"<p>Assuming you are maintaining an array of <code>struct data</code> and count is the no of such structures. The below functions should help you to read the structures from userspace. The below code assumes that the log buffer or the array is not modified when you are reading it (It's a simple example). You can modify the below to suit your needs. Make sure to synchronize your data structures such as the log buffer to make sure what you read is what is present.</p>

<p>And Yes! you can use globally declare the structure and use it within seq_show.</p>

<pre><code>static void *seq_start(struct seq_file *s, loff_t *pos)
{
    if (*pos &gt; count)
        return NULL;
    return pos;
}

static int seq_show(struct seq_file *s, void *v)
{
    loff_t *pos = (loff_t *)v;

    if (*pos == 0) {
        seq_printk(s, ""Address\t\t\tPID\tInfo\n"");
    }
    seq_printk(s, ""0x%p\t%u\t%u\n"", drv_data[*pos].address, drv_data[*pos].pid,
                     drv_data[*pos].info);
    return 0;
}

static void *seq_next(struct seq_file *s, void *v, loff_t *pos)
{
    (*pos)++;
    if (*pos &gt;= count)
        return NULL;
    return pos;
}
</code></pre>
"
"<p>As far, as I know, you can't create and write file in <code>/proc</code> that easily. Most likely, call to <code>filp_open()</code> has failed and you don't check it's return value properly. You have to check return value with <code>IS_ERR()</code> function.</p>

<p>But I should mention again that this idea seems wrong for me. If you want create an entry in <code>/proc</code> directory, consider using <a href=""http://tuxthink.blogspot.com/2011/02/creating-readwrite-proc-entry.html"" rel=""nofollow"">standard way</a>.</p>
"
"<p>You cannot change <code>do_fork</code>, it is a constant at run time. It is the address of <code>do_fork()</code> function.</p>

<p>You cannot assign anything to a function. It is because name of a function is not a variable. It is a <em>constant</em> pointer.</p>

<p>It is the same as </p>

<pre><code>5 = 2 + 2;
</code></pre>

<p>You would get the same error message.</p>

<p>I assume you want your function to be called every time <code>do_fork()</code> is called. It it going to be more complicated to implement. I would start for example with <a href=""http://lwn.net/Articles/128076/"" rel=""nofollow"">this link</a>.</p>
"
"<p>Firstly to resolve that <code>Permission Denied Error</code></p>

<ol>
<li>Login as <strong><code>root (su)</code></strong></li>
<li><p>Run the command </p>

<pre><code>$ ls -l -t /proc | head -21 &gt; /proc/hello_proc
</code></pre></li>
</ol>

<p>Now you will face another issue as below.</p>

<blockquote>
  <p>head: write error: Input/output error<br>
  head: write error</p>
</blockquote>

<p>The reason being that you not have written the write file operations <code>fops</code> for the proc file. In the code you have commented out the write operation.</p>
"
"<p><code>seq_write</code> doesn't do what you might think. It's actually like <code>seq_printf</code> except it just writes a fixed number of bytes (rather than formatted outpuut). The seq_xxx API doesn't support writing to the device. You have to implement that separately. </p>

<p>For a fairly simple model of how to create a writable device using single_open on the read side, take a look at <code>proc_pid_set_comm_operations</code>, which implements <code>/proc/&lt;pid&gt;/comm</code> and also supports writing.</p>

<p>Also, note that <code>create_proc_entry</code> was deprecated but it's pretty straight-forward to change <code>create_proc_entry</code> to <code>proc_create</code>. As described in Documentation/filesystems/seq_file.txt:</p>

<pre><code>-       entry = create_proc_entry(""sequence"", 0, NULL);
-       if (entry)
-               entry-&gt;proc_fops = &amp;ct_file_ops;
+       entry = proc_create(""sequence"", 0, NULL, &amp;ct_file_ops);
</code></pre>
"
"<p>It's the <code>show_pid_map()</code> function in <code>fs/proc/task_mmu.c</code> (provided your system uses an MMU, which is the case of most non-embedded systems).</p>

<p>In general, the code for files under <code>/proc/</code> can be cause under <code>fs/procfs</code>.</p>
"
"<p>The procfs code can be found in <code>fs/proc/</code> subdirectory. If you open <code>fs/proc/base.c</code>, you can find two very similar arrays - <code>tgid_base_stuff</code> and <code>tid_base_stuff</code>. They both register file operations functions for files inside of <code>/proc/PID/</code> and <code>/proc/PID/TID/</code> respectivly. So you're more interested in the first one. Find the one that registers <code>""maps""</code> file, it looks like this:</p>

<pre><code>REG(""maps"",       S_IRUGO, proc_pid_maps_operations),
</code></pre>

<p>So the structure describing file operations on this file is called <code>proc_pid_maps_operations</code>. This function is defined in two places - <code>fs/proc/task_mmu.c</code> and <code>fs/proc/task_nommu.c</code>. Which one is actually used depends on your kernel configuration but it's most likely the first one.</p>

<p>Inside of <code>task_mmu.c</code>, you can find the structure definition:</p>

<pre><code>const struct file_operations proc_pid_maps_operations =
{
    .open       = pid_maps_open,
    .read       = seq_read,
    .llseek     = seq_lseek,
    .release    = proc_map_release,
};
</code></pre>

<p>So when <code>/proc/PID/maps</code> is opened, the kernel will use <code>pid_maps_open</code> function, which registers another set of operations:</p>

<pre><code>static const struct seq_operations proc_pid_maps_op = {
    .start  = m_start,
    .next   = m_next,
    .stop   = m_stop,
    .show   = show_pid_map
};
</code></pre>

<p>So you're interested in <code>show_pid_map</code> function, which only calls <code>show_map</code> function which in turn calls <code>show_map_vma</code> (all in the same file).</p>
"
"<p>Warning at linker stage like</p>

<pre><code>WARNING: ""mem_map"" [/home/babak/code/module/mem_map.ko] undefined!
</code></pre>

<p>means that <code>mem_map</code> is declared, but its definition is not accessible for modules.</p>

<p>So you need search statements like <code>EXPORT_SYMBOL(mem_map)</code> or <code>EXPORT_SYMBOL_GPL(mem_map)</code> in sources (<code>.c</code> files).</p>

<p>Found that for kernel 3.19 (<code>mm/memory.c</code>):</p>

<pre><code>#ifndef CONFIG_NEED_MULTIPLE_NODES
/* use the per-pgdat data instead for discontigmem - mbligh */
unsigned long max_mapnr;
struct page *mem_map;

EXPORT_SYMBOL(max_mapnr);
EXPORT_SYMBOL(mem_map);
#endif
</code></pre>

<p>Probably, you haven't CONFIG_NEED_MULTIPLE_NODES kernel's configuration set, so symbol <code>mem_map</code> is not exported(and even not defined).</p>
"
"<p>The best I've been able to do on my own:</p>

<ul>
<li>In this problem, I want to write <code>sk_buff</code> to shared memory and read it from user space.</li>
<li>Here, I use netfilter hook <code>PRE_ROUTING</code>, and in my hook I can get the skb.</li>
<li>On the question of how to write to shared memory, as suggested by user Tsyvarev I can write the memory I malloc directly.
</li>
</ul>

<p>First malloc shared memory:</p>

<pre class=""lang-c prettyprint-override""><code>kernel_memaddr = __get_free_pages(GFP_KERNEL, PAGE_ORDER);  //or use kmalloc vmalloc
SetPageReserved(virt_to_page(kernel_memaddr));
</code></pre>

<p>Userspace needs to know the memory physical address (proc read):</p>

<pre class=""lang-c prettyprint-override""><code>static int proc_show_meminfo(struct seq_file *m, void *v) {
    seq_printf(m, ""%08lx %lu\n"",__pa(kernel_memaddr), kernel_memsize);
    return 0;
}
</code></pre>

<p>In <code>proc_mmap()</code>, we need to <code>remap_pfn_range</code> the memory:</p>

<pre class=""lang-c prettyprint-override""><code>int proc_mmap(struct file *filp, struct vm_area_struct *vma)
{
    unsigned long page;
    page = virt_to_phys((void *)kernel_memaddr) &gt;&gt; PAGE_SHIFT;

    if( remap_pfn_range(vma, vma-&gt;vm_start, page, (vma-&gt;vm_end - vma-&gt;vm_start),
         vma-&gt;vm_page_prot) )
    {
        printk(""remap failed..."");
        return -1;
    }
    vma-&gt;vm_flags |= (VM_DONTDUMP|VM_DONTEXPAND);
    printk(""remap_pfn_rang page:[%lu] ok.\n"", page);
    return 0;
}
</code></pre>

<p>When we want to write data to shared memory, just copy it:</p>

<pre class=""lang-c prettyprint-override""><code>memcpy((void *)(memaddr + offset),data, dataLen);   //data is what you want to write
</code></pre>

<p>And in user space, after we get kernel_memaddr, we use <code>mmap()</code> to get address</p>

<pre class=""lang-c prettyprint-override""><code>map_addr = mmap(NULL, phymem_size, PROT_READ|PROT_WRITE, MAP_SHARED, map_fd, phymem_addr);
memcpy(str,map_addr,256);
</code></pre>
"
"<p>In the <code>readAccelerator</code> function, you are reading 10 chars into the buffer, but buffer is defined as an array of pointer to char, not an array of char, try this:</p>

<pre><code>// char * buffer[10]; &lt;-- problem here
char buffer[10];
</code></pre>

<p>Problems in kernel code:</p>

<pre><code>// char *output;
// you are writing to output without initialize it, this produce UB, which may be a crash, try this:
char output[1024];
sprintf(output, ""0x%02x, 0x%02x"", out_lo, out_hi); // length = 10
printk(""OUTPUT = %s\n"",output);


// if(copy_to_user(buf, &amp;output, len))
// here you are copying from the address of output, not output the buffer, try
if(copy_to_user(buf, output, len)) ...
</code></pre>
"
"<p>So it is now working.</p>

<p>You were right @fluter needed to allocate the <code>output [11] = {0}</code>. Here is the final function and call for reference.</p>

<p>Driver Function for read:</p>

<pre><code>static ssize_t proc_accelerator_read(struct file *file, const char __user * buf,
                  size_t count, loff_t * ppos)
  {
     printk(""READ: "");
     u32 out_lo;
     char output[11] = {0};
     u32 out_hi;
     int OUTLO_ADDR = 4;
     int OUTHI_ADDR = 5;
     u32 len = 11;

     out_lo = ioread32(base_addr+OUTLO_ADDR);
     out_hi = ioread32(base_addr+OUTHI_ADDR);
     sprintf(output, ""0x%02x, 0x%02x"", out_lo, out_hi); // length = 10
     printk(""OUTPUT = %s\n"",output);
     if(copy_to_user(buf, output, len))
        return -EFAULT;
     // returning total length of 11!!!
     printk(""exiting read...\n"");
     return count;
 }
</code></pre>

<p>Userland function for call:</p>

<pre><code>void readAccelerator(unsigned int * outlo, unsigned int * outhi)
{
    char buffer[11];
    size_t size = 1;
    size_t nitems = 11;
    FILE* fp;

    fp = fopen(""/proc/accelerator"",""r"");
    if (fp == NULL)
    {
        printf(""Cannot open for read\n"");
        return -1;
    }
    /*
    Expect return format:
    0x00, 0x00
    */
    fread(buffer, size, nitems, fp);
//  read(fp, buffer, nitems);
    fclose(fp);
    printf(""%s\n"",buffer);
    return;
}
</code></pre>
"
"<p>It's because there is no <code>struct seq_operation</code> but <code>struct seq_operations</code></p>
"
"<p>If procfs is not the strict requirement then make use of '<em>kobject</em>' to create the <code>sysfs</code> entry. Refer below example and modify <code>foo_show</code> function as per your requirement. Otherwise, the comment from @mali will do the trick.</p>

<p><a href=""https://github.com/saiyamd/linux/blob/master/samples/kobject/kobject-example.c"" rel=""nofollow noreferrer"">https://github.com/saiyamd/linux/blob/master/samples/kobject/kobject-example.c</a></p>
"
"<p>If I understand correctly, you want to print the address of the <em>global</em> <code>mem_map</code> array, right from your kernel module. The pointer that you're looking for is global ,therefore <a href=""http://elixir.free-electrons.com/linux/v3.13/source/mm/memory.c#L82"" rel=""nofollow noreferrer"">it has already been exported</a> for you to use in your kernel module. All you have to do is find its' symbol.</p>

<p>Finding an exported symbol is easy, by including <code>&lt;linux/kallsyms.h&gt;</code> you'll have the power of using <code>kallsyms_lookup_name()</code> which takes a <code>char *</code> and returns the address of the symbol it represents. All you have to do now, is assigning the address to the empty pointer, possibly in your <code>init</code> function.</p>

<pre><code>mem_map = (struct page *) kallsyms_lookup_name(""mem_map"");
</code></pre>

<p>Now your <code>mem_map</code> pointer actually points to the <code>mem_map</code> array that you're after. Cool.</p>

<p>Next, you're declaring <code>virt_to_phy()</code> and using <code>__pa()</code> inside it. Why? You can simply use <code>virt_to_phys()</code> that is already declared (and doing exactly the same in your case) in <code>asm/io.h</code>. Please not that you're trying to print an address, therefore the right <code>printf</code> format would be <code>%lx</code> instead of <code>%lu</code>.</p>

<p>Last but not least, ridiculous the number of pages you're examining is actually the decimal value of the address of <code>get_num_physpages</code>, which is a function. If you wish to print the return value of <code>get_num_physpages</code> you should call it as a function, <code>get_num_physpages()</code> because now your code prints the value of the pointer to <code>get_num_physpages</code>. </p>

<p>This is how I think your code should have looked like:</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/seq_file.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;linux/kallsyms.h&gt;
#include &lt;asm/io.h&gt;

#define ERROR -1

MODULE_LICENSE(""Dual BSD/GPL"");

static struct proc_dir_entry* proc_file;
struct page *mem_map;

int mem_map_show(struct seq_file *m, void *v)
{
    int ret_val = 0;

    printk(KERN_INFO ""Proc file read\n"");
    ret_val =  seq_printf(m, ""mem_map virt addr:\t0x%p\n"", mem_map);
    ret_val += seq_printf(m, ""mem_map phys addr:\t0x%016llx\n"", ((unsigned long long) virt_to_phys((volatile void *) mem_map)));
    ret_val += seq_printf(m, ""mem_map phys pages:\t%lu\n"", (long unsigned int) get_num_physpages());
    return ret_val;
}

static int mem_map_open(struct inode *inode, struct file *file)
{
    return single_open(file, mem_map_show, NULL);
}

struct file_operations mem_map_fops = {
    .owner = THIS_MODULE,
    .open = mem_map_open,
    .read = seq_read,
    .llseek = seq_lseek,
    .release = single_release,
};

static int __init mem_map_init(void)
{
    printk(KERN_INFO ""Loaded mem_map module\n"");
    mem_map = (struct page *) kallsyms_lookup_name(""mem_map"");
    if (!mem_map) {
        printk(KERN_ALERT ""Error: Unable to find address of global 'mem_map'\n"");
                return ERROR;
        }
    proc_file = proc_create(""mem_map"", 0, NULL, &amp;mem_map_fops);
    if (!proc_file) {
        printk(KERN_ALERT ""Error: Could not initialize /proc/mem_map\n"");
        return -ENOMEM;
    }
    return 0;
}

static void __exit mem_map_exit(void)
{
    remove_proc_entry(""mem_map"",NULL);
    printk(KERN_INFO ""Proc file unloaded\n"");
}


/* Declaration of the init and exit functions */
module_init(mem_map_init);
module_exit(mem_map_exit);
</code></pre>

<p>and more specifically, if you want to comply with how values in <code>procfs</code> are printed, I would implement <code>mem_map_show</code> somewhat like this:</p>

<pre><code>int mem_map_show(struct seq_file *m, void *v)
{
    int ret_val = 0;

    ret_val =  seq_printf(m, ""0x%p 0x%016llx %lu\n"",
            mem_map,
            ((unsigned long long) virt_to_phys((volatile void *) mem_map)),
            (long unsigned int) get_num_physpages());
    return ret_val;
}
</code></pre>
"
"<p>Don't you think : </p>

<pre><code>static int counter_seq_show(struct seq_file *s, void *bookmark) {
    unsigned long *bpos = (unsigned long *) bookmark;
    seq_printf(s, ""value: %Ld\n"", *bpos);
    return 0;
}
</code></pre>

<p>Or even </p>

<pre><code>static int counter_seq_show(struct seq_file *s, void *bookmark) {
    seq_printf(s, ""value: %lu\n"", *((unsigned long *)bpos));
    return 0;
}
</code></pre>

<p>I haven't fully understood your program but I saw two different ways you cast 'bookmark'. In one function you cast it to be 'unsigned long *' and other you do 'loff_t *' (long int). Ideally they should be the same, but are you doing it this way for some reason ?</p>

<p>HTH </p>
"
"<p>You can't use <code>fopen</code> as this is a libc function. The example bellow shows how to read a file from the kernel.</p>

<p><a href=""http://www.wasm.ru/forum/viewtopic.php?pid=467952#p467952"" rel=""nofollow"">http://www.wasm.ru/forum/viewtopic.php?pid=467952#p467952</a></p>
"
"<p>Probably you don't need to read a /proc file within kernel, because a /proc interface is used by kernel to export some information to user-space, the information definitely already exists in kernel, either in some list of struct's or other global containers. So the proper way is probably just getting the global list/container by calling some kernel API or using them directly, if they are exported.</p>
"
"<p>This information from BIOS + Hardware DB. You can get info direct by dmidecode, for example (if you need more info - try to check dmidecode source code)</p>

<pre><code>sudo dmidecode -t processor
</code></pre>
"
"<p><em>Short answer</em></p>

<p>Kernel uses special CPU instruction <a href=""http://en.wikipedia.org/wiki/CPUID"" rel=""nofollow""><code>cpuid</code></a> and saves results in internal structure - <a href=""http://lxr.free-electrons.com/source/arch/x86/include/asm/processor.h?v=3.12#L83"" rel=""nofollow""><code>cpuinfo_x86</code></a> for x86</p>

<p><em>Long answer</em></p>

<p>Kernel source is your best friend.
Start from entry point - file <code>/proc/cpuinfo</code>.
As any proc file it has to be cretaed somewhere in kernel and declared with some file_operations. This is done at <a href=""http://lxr.free-electrons.com/source/fs/proc/cpuinfo.c?v=3.12"" rel=""nofollow"">fs/proc/cpuinfo.c</a>. Interesting piece is <code>seq_open</code> that uses reference to some <code>cpuinfo_op</code>. This ops are declared in <a href=""http://lxr.free-electrons.com/source/arch/x86/kernel/cpu/proc.c?v=3.12#L152"" rel=""nofollow"">arch/x86/kernel/cpu/proc.c</a> where we see some <code>show_cpuinfo</code> function. This function is in the same file on <a href=""http://lxr.free-electrons.com/source/arch/x86/kernel/cpu/proc.c?v=3.12#L57"" rel=""nofollow"">line 57</a>. </p>

<p>Here you can see</p>

<pre class=""lang-c prettyprint-override""><code> 64         seq_printf(m, ""processor\t: %u\n""
 65                    ""vendor_id\t: %s\n""
 66                    ""cpu family\t: %d\n""
 67                    ""model\t\t: %u\n""
 68                    ""model name\t: %s\n"",
 69                    cpu,
 70                    c-&gt;x86_vendor_id[0] ? c-&gt;x86_vendor_id : ""unknown"",
 71                    c-&gt;x86,
 72                    c-&gt;x86_model,
 73                    c-&gt;x86_model_id[0] ? c-&gt;x86_model_id : ""unknown"");
</code></pre>

<p>Structure <code>c</code> declared on the first line as <code>struct cpuinfo_x86</code>. This structure is declared in <a href=""http://lxr.free-electrons.com/source/arch/x86/include/asm/processor.h?v=3.12#L83"" rel=""nofollow"">arch/x86/include/asm/processor.h</a>. And if you search for references on that structure you will find function <a href=""http://lxr.free-electrons.com/source/arch/x86/kernel/cpu/common.c?v=3.12#L574"" rel=""nofollow""><code>cpu_detect</code></a> and that function calls function <code>cpuid</code> which is finally resolved to <a href=""http://lxr.free-electrons.com/source/arch/x86/include/asm/processor.h?v=3.12#L189"" rel=""nofollow""><code>native_cpuid</code></a> that looks like this:</p>

<pre class=""lang-c prettyprint-override""><code>189 static inline void native_cpuid(unsigned int *eax, unsigned int *ebx,
190                                 unsigned int *ecx, unsigned int *edx)
191 {
192         /* ecx is often an input as well as an output. */
193         asm volatile(""cpuid""
194             : ""=a"" (*eax),
195               ""=b"" (*ebx),
196               ""=c"" (*ecx),
197               ""=d"" (*edx)
198             : """" (*eax), ""2"" (*ecx)
199             : ""memory"");
200 }
</code></pre>

<p>And here you see assembler instruction <a href=""http://en.wikipedia.org/wiki/CPUID"" rel=""nofollow""><code>cpuid</code></a>. And this little thing does real work.</p>
"
"<p>Your forget to update <code>*pos</code> parameter in your <code>_next</code> handler. Usually, it is incremented by 1 every <code>_next</code> call.
UPDATE: Also your <code>_start</code> handler should navigate to given position.</p>

<p>Infinite loop is actually a consequence of <code>cat</code> implementation: it call <em>read(2)</em> until it returns 0 or -1. Because of your implementation do not update position, every <em>read(2)</em> call reads from the beginning and return positive value(non-zero bytes has been read).</p>

<p>BTW, C standard, used in the kernel, allows implicit conversion between <code>void*</code> and other pointer types. So you can safetly declare <code>tmp</code> variable in your <code>_next</code> handler as <code>struct store_node *tmp;</code>. For example, see <code>seq_list_*</code> handlers in <code>fs/seq_file.c</code> kernel source.</p>
"
"<p>Linux kernel provides <a href=""https://www.kernel.org/doc/Documentation/filesystems/seq_file.txt"" rel=""nofollow noreferrer"">seq_file</a> interface for easily implement files represented enumeration of things, like lists are.</p>

<p>All you need is to provide up to 4 functions which encapsulate enumeration:</p>

<pre><code>// Assume this is the head of your list.
static struct my_list;

// Start iteration
static void *my_start (struct seq_file *m, loff_t *pos)
{
    // Use ready-made helper for lists.
    return seq_list_start(&amp;my_list, *pos);
}

// Next iteration
static void * my_next(struct seq_file *m, void *v, loff_t *pos)
{
    // Use ready-made helper for lists.
    return seq_list_next(v, &amp;my_list, pos);
}

// Output on single iteration
static int my_show (struct seq_file *m, void *v)
{
    // Get original structure
    struct node* node = list_entry(v, struct node, list);
    // E.g., print content of 'x' field
    seq_printf(m, ""%u,"", node-&gt;x);

    return 0; // Success
}

static struct seq_operations my_seq_ops = {
    .start = &amp;my_start,
    .stop = NULL, // Not needed in this case
    .next = &amp;my_next,
    .show = &amp;my_show
};
</code></pre>

<p>Structure with these functions should be passed to <code>seq_open()</code> when opening the file:</p>

<pre><code>static int my_open(struct inode* inode, struct file* filp)
{
    return seq_open(filp, &amp;my_seq_ops);
}
</code></pre>

<p>And use <code>seq_read</code> as a <code>.read</code> function in file operations:</p>

<pre><code>static struct file_operations my_file_ops = {
    .open = &amp;my_open,
    .read = &amp;seq_read,
};
</code></pre>

<hr>

<p>Note, that <em>writing</em> into such file you should implement <strong>manually</strong>, <code>seq_lock</code> doesn't help with this.</p>
"
"<p>You can read list using function similar to this one:</p>

<pre><code>struct k_list {
        struct list_head links;
        int data;
};

struct k_list my_list;

static ssize_t pop_queue(struct file * file,
                                char *buf,
                                size_t count,
                                loff_t *ppos)
{
        struct list_head *pos, *q;
        struct k_list *tmp;

        printk(KERN_INFO ""--Listing inserted numbers--"");
        list_for_each_safe(pos, q, &amp;my_list.links) {
                tmp = list_entry(pos, struct k_list, links);
                printk(KERN_INFO ""object: %d "", tmp-&gt;data);
        }
        printk(KERN_INFO ""--End of list--"");

        return count;
}
</code></pre>
"
"<p>Your main issue is with the following line :</p>

<pre><code> writer = SequenceFile.createWriter(fs, conf, seq_path, key.getClass(), value.getClass());
</code></pre>

<p>which is inside the <code>for</code>, creating a new <code>writer</code> in each pass. It replaces previous file at the path <code>seq_path</code>. Thus only last image is available. </p>

<p>Pull it out of the loop, and the problem should vanish. </p>
"
"<p>Dunno, I suppose language designers have their priorities.  Charitably, the swift code could lose a line and still read well:</p>

<pre><code>let file_manager = NSFileManager.defaultManager()
let data: NSData = file_manager.contentsAtPath(""/some/local/file-path/on/computer.txt"")!
let seq_file = NSString(data: data, encoding: NSUTF8StringEncoding)
print(seq_file)
</code></pre>

<p>This is more or less what it took to read a file with java 1.4:</p>

<pre><code>try
{
    String line;
    File file = new File((""manifest.mf"");
    BufferedReader inFile = new BufferedReader(new FileReader(file));
    while((line = inFile.readLine()) != null)
    {
            System.out.println(line)
    }
    inFile.close();
}
catch (IOException e)
{
    System.out.println(""problem with file"");
}
</code></pre>

<p>In java 8, you can do something like this:</p>

<pre><code>    Files.lines(Paths.get(""manifest.mf"")).forEach(System.out::println);
</code></pre>

<p>Things change. Swift is at 1.2. It does seem a bit old fashioned though.</p>
"
"<blockquote>
  <p>I've read about the advantages of Swift...If it's so new and powerful,
  why would they make such a simple task so complicated?</p>
</blockquote>

<p>Well, in Swift you can do this: </p>

<pre><code>let string = try? NSString(contentsOfFile: ""name.txt"", encoding: NSASCIIStringEncoding)
print(string)
</code></pre>

<p>The question is if you really want to, because the longer versions give you more flexibility and better error handling...</p>
"
"<p>/proc is a virtual file system : in fact, it just gives a convenient view of the kernel internals. It's definitely safe to read it (that's why it's here) but it's risky on the long term, as the internal of these virtual files may evolve with newer version of kernel. </p>

<p><strong>EDIT</strong></p>

<p>More information available in <a href=""http://www.kernel.org/doc/Documentation/filesystems/proc.txt"" rel=""nofollow"">proc documentation in Linux kernel doc</a>, chapter 1.4 Networking
I can't find if the information how the information evolve over time. I thought it was frozen on open, but can't have a definite answer.</p>

<p><strong>EDIT2</strong></p>

<p>According to <a href=""http://uw714doc.sco.com/en/man/html.4/proc.4.html"" rel=""nofollow"">Sco doc</a> (not linux, but I'm pretty sure all flavours of *nix behave like that)</p>

<blockquote>
  <p>Although process state and
  consequently the contents of /proc
  files can change from instant to
  instant, a single read(2) of a /proc
  file is guaranteed to return a
  ``sane'' representation of state, that
  is, the read will be an atomic
  snapshot of the state of the process.
  No such guarantee applies to
  successive reads applied to a /proc
  file for a running process. In
  addition, atomicity is specifically
  not guaranteed for any I/O applied to
  the as (address-space) file; the
  contents of any process's address
  space might be concurrently modified
  by an LWP of that process or any other
  process in the system.</p>
</blockquote>
"
"<p>The procfs API in the Linux kernel provides an interface to make sure that reads return consistent data. Read the comments in <a href=""http://lxr.linux.no/linux+v2.6.38/fs/proc/generic.c#L41"" rel=""noreferrer""><code>__proc_file_read</code></a>. Item 1) in the big comment block explains this interface.</p>

<p>That being said, it is of course up to the implementation of a specific proc file to use this interface correctly to make sure its returned data is consistent. So, to answer your question: no, the kernel does not guarantee consistency of the proc files during a read but it provides the means for the implementations of those files to provide consistency.</p>
"
"<p>Although the files in <code>/proc</code> appear as regular files in userspace, they are not really files but rather entities that support the standard file operations from userspace (<code>open</code>, <code>read</code>, <code>close</code>). <strong>Note that this is quite different than having an ordinary file on disk that is being changed by the kernel.</strong></p>

<p>All the kernel does is print its internal state into its own memory using a <code>sprintf</code>-like function, and that memory is copied into userspace whenever you issue a <code>read(2)</code> system call.</p>

<p>The kernel handles these calls in an entirely different way than for regular files, which could mean that the entire snapshot of the data you will read could be ready at the time you <code>open(2)</code> it, while the kernel makes sure that concurrent calls are consistent and atomic. I haven't read that anywhere, but it doesn't really make sense to be otherwise.</p>

<p>My advice is to take a look at the implementation of a proc file in your particular Unix flavour. This is really an implementation issue (as is the format and the contents of the output) that is not governed by a standard.</p>

<p>The simplest example would be the implementation of the <a href=""http://lxr.free-electrons.com/source/fs/proc/uptime.c"" rel=""nofollow""><code>uptime</code></a> proc file in Linux. Note how the entire buffer is produced in the callback function supplied to <code>single_open</code>.</p>
"
"<p>Short of unknown bugs, there are no race conditions in <code>/proc</code> that would lead to reading corrupted data or a mix of old and new data. In this sense, it's safe. However there's still the race condition that much of the data you read from <code>/proc</code> is potentially-outdated as soon as it's generated, and even moreso by the time you get to reading/processing it. For instance processes can die at any time and a new process can be assigned the same pid; the only process ids you can ever use without race conditions are your own child processes'. Same goes for network information (open ports, etc.) and really most of the information in <code>/proc</code>. I would consider it bad and dangerous practice to rely on any data in <code>/proc</code> being accurate, except data about your own process and potentially its child processes. Of course it may still be useful to present other information from <code>/proc</code> to the user/admin for informative/logging/etc. purposes.</p>
"
"<p>I have the source for Linux 2.6.27.8 handy since I'm doing driver development at the moment on an embedded ARM target.</p>

<p>The file ...<code>linux-2.6.27.8-lpc32xx/net/ipv4/raw.c</code> at line 934 contains, for example</p>

<pre><code>    seq_printf(seq, ""%4d: %08X:%04X %08X:%04X""
            "" %02X %08X:%08X %02X:%08lX %08X %5d %8d %lu %d %p %d\n"",
            i, src, srcp, dest, destp, sp-&gt;sk_state,
            atomic_read(&amp;sp-&gt;sk_wmem_alloc),
            atomic_read(&amp;sp-&gt;sk_rmem_alloc),
            0, 0L, 0, sock_i_uid(sp), 0, sock_i_ino(sp),
            atomic_read(&amp;sp-&gt;sk_refcnt), sp, atomic_read(&amp;sp-&gt;sk_drops));
</code></pre>

<p>which outputs</p>

<pre><code>[wally@zenetfedora ~]$ cat /proc/net/tcp
  sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode
   0: 017AA8C0:0035 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 15160 1 f552de00 299
   1: 00000000:C775 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 13237 1 f552ca00 299
...
</code></pre>

<p>in function <code>raw_sock_seq_show()</code> which is part of a hierarchy of <em>procfs</em> handling functions.  The text is not generated until a <code>read()</code> request is made of the <code>/proc/net/tcp</code> file, a reasonable mechanism since <em>procfs</em> reads are surely much less common than updating the information.</p>

<p>Some drivers (such as mine) implement the proc_read function with a single <code>sprintf()</code>.  The extra complication in the core drivers implementation is to handle potentially very long output which may not fit in the intermediate, kernel-space buffer during a single read.</p>

<p>I tested that with a program using a 64K read buffer but it results in a kernel space buffer of 3072 bytes in my system for proc_read to return data.  Multiple calls with advancing pointers are needed to get more than that much text returned.  I don't know what the right way to make the returned data consistent when more than one i/o is needed.  Certainly each entry in <code>/proc/net/tcp</code> is self-consistent.  There is some likelihood that lines side-by-side are snapshot at different times.</p>
"
"<p>When you read from a /proc file, the kernel is calling a function which has been registered in advance to be the ""read"" function for that proc file.  See the <code>__proc_file_read</code> function in fs/proc/generic.c .  </p>

<p>Therefore, the safety of the proc read is only as safe as the function the kernel calls to satisfy the read request.  If that function properly locks all data it touches and returns to you in a buffer, then it is completely safe to read using that function.  Since proc files like the one used for satisfying read requests to /proc/net/tcp have been around for a while and have undergone scrupulous review, they are about as safe as you could ask for.  In fact, many common Linux utilities rely on reading from the proc filesystem and formatting the output in a different way.  (Off the top of my head, I think 'ps' and 'netstat' do this).</p>

<p>As always, you don't have to take my word for it; you can look at the source to calm your fears.  The following documentation from proc_net_tcp.txt tells you where the ""read"" functions for /proc/net/tcp live, so you can look at the actual code that is run when you read from that proc file and verify for yourself that there are no locking hazards.</p>

<blockquote>
  <p>This document describes the interfaces
  /proc/net/tcp and /proc/net/tcp6.<br>
  Note that these interfaces are
  deprecated in favor of tcp_diag.
         These /proc interfaces provide information about currently active TCP
  connections, and are implemented by
  tcp4_seq_show() in net/ipv4/tcp_ipv4.c
  and tcp6_seq_show() in
  net/ipv6/tcp_ipv6.c, respectively.</p>
</blockquote>
"
"<p><strong>In general, no.</strong> (So most of the answers here are wrong.) It <em>might</em> be safe, depending on what property you want. But it's easy to end up with bugs in your code if you assume too much about the consistency of a file in <code>/proc</code>. For example, see <a href=""http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=593516"" rel=""noreferrer"">this bug which came from assuming that <code>/proc/mounts</code> was a consistent snapshot</a>.</p>

<p>For example:</p>

<ul>
<li><p><strong><code>/proc/uptime</code></strong> is <strong>totally atomic</strong>, as someone mentioned in another answer -- but <em>only since Linux 2.6.30</em>, which is less than two years old.  So even this tiny, trivial file was subject to a race condition until then, and still is in most enterprise kernels.  See <a href=""http://lxr.linux.no/linux+v2.6.38/fs/proc/uptime.c"" rel=""noreferrer""><code>fs/proc/uptime.c</code></a> for the current source, or <a href=""http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=a9caa3de249a6c43bc9c6aec87881f09276677e3"" rel=""noreferrer"">the commit that made it atomic</a>.  On a pre-2.6.30 kernel, you can <code>open</code> the file, <code>read</code> a bit of it, then if you later come back and <code>read</code> again, the piece you get will be inconsistent with the first piece. (I just demonstrated this -- try it yourself for fun.)</p></li>
<li><p><strong><code>/proc/mounts</code></strong> is <strong>atomic within a single <code>read</code> system call.</strong> So if you <code>read</code> the whole file all at once, you get a single consistent snapshot of the mount points on the system. However, if you use several <code>read</code> system calls -- and if the file is big, this is exactly what will happen if you use normal I/O libraries and don't pay special attention to this issue -- you will be subject to a race condition. Not only will you not get a consistent snapshot, but mount points which were present before you started and never stopped being present might go missing in what you see. To see that it's atomic for one <code>read()</code>, look at <a href=""http://lxr.linux.no/linux+v2.6.38/fs/namespace.c#L889"" rel=""noreferrer""><code>m_start()</code> in <code>fs/namespace.c</code></a> and see it grab a semaphore that guards the list of mountpoints, which it keeps until <code>m_stop()</code>, which is called when the <code>read()</code> is done.  To see what can go wrong, see <a href=""http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=593516"" rel=""noreferrer"">this bug from last year</a> (same one I linked above) in otherwise high-quality software that blithely read <code>/proc/mounts</code>.</p></li>
<li><p><strong><code>/proc/net/tcp</code></strong>, which is the one you're actually asking about, is even less consistent than that.  It's <strong>atomic only within each row of the table</strong>.  To see this, look at <a href=""http://lxr.linux.no/linux+v2.6.38/net/ipv4/tcp_ipv4.c#L1964"" rel=""noreferrer""><code>listening_get_next()</code> in <code>net/ipv4/tcp_ipv4.c</code></a> and <code>established_get_next()</code> just below in the same file, and see the locks they take out on each entry in turn.  I don't have repro code handy to demonstrate the lack of consistency from row to row, but there are no locks there (or anything else) that would make it consistent.  Which makes sense if you think about it -- networking is often a super-busy part of the system, so it's not worth the overhead to present a consistent view in this diagnostic tool.</p></li>
</ul>

<p>The other piece that keeps <code>/proc/net/tcp</code> atomic within each row is the buffering in <code>seq_read()</code>, which you can read <a href=""http://lxr.linux.no/linux+v2.6.38/fs/seq_file.c#L132"" rel=""noreferrer"">in <code>fs/seq_file.c</code></a>. This ensures that once you <code>read()</code> part of one row, the text of the whole row is kept in a buffer so that the next <code>read()</code> will get the rest of that row before starting a new one. The same mechanism is used in <code>/proc/mounts</code> to keep each row atomic even if you do multiple <code>read()</code> calls, and it's also the mechanism that <code>/proc/uptime</code> in newer kernels uses to stay atomic. That mechanism does <em>not</em> buffer the whole file, because the kernel is cautious about memory use.</p>

<p>Most files in <code>/proc</code> will be at least as consistent as <code>/proc/net/tcp</code>, with each row a consistent picture of one entry in whatever information they're providing, because most of them use the same <code>seq_file</code> abstraction.  As the <code>/proc/uptime</code> example illustrates, though, some files were still being migrated to use <code>seq_file</code> as recently as 2009; I bet there are still some that use older mechanisms and don't have even that level of atomicity. These caveats are rarely documented. For a given file, your only guarantee is to read the source.</p>

<p>In the case of <code>/proc/net/tcp</code>, you can read it and parse each line without fear. But if you try to draw any conclusions from multiple lines at once -- beware, other processes and the kernel <em>are</em> changing it while you read it, and you are probably creating a bug.</p>
"
"<p>I think the main idea would be to parse the main file line by line, while generating a result XML. And every time it gets large enough, to feed it to Sphinx. Rinse and repeat.</p>
"
"<p>What parsing do you need to do? If the transformations are restricted to just one line in the input at once and not too complicated, I would use <a href=""http://en.wikipedia.org/wiki/AWK"" rel=""nofollow"">awk</a> instead of Ruby...</p>
"
"<p>I hate guys who doesn't write solution after a question. So I'll try to don't be one of them, hopefully it will help somebody.</p>

<p>I added a simple reader method to the File class then used it to loop on the file based on a chunk size of my choice. Quite simple actually, working like a charm with Sphinx.</p>

<pre><code>class File

  # New static method
  def self.seq_read(file_path,chunk_size=nil)
    open(file_path,""rb"") do |f|
      f.each_chunk(chunk_size) do |chunk|
        yield chunk
      end
    end
  end

  # New instance method
  def each_chunk(chunk_size=1.kilobyte)
    yield read(chunk_size) until eof?
  end

end
</code></pre>

<p>Then just use it like this:</p>

<pre><code>source_path = ""./my_very_big_file.txt""
CHUNK_SIZE  = 10.megabytes
File.seq_read(source_path, CHUNK_SIZE) do |chunk|
  chunk.each_line do |line|
    ...
  end
end
</code></pre>
"
"<p>This bug was fixed by Konstantin Khlebnikov, details can be found in <a href=""https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=1b15ec7a7427d4188ba91b9bbac696250a059d22"" rel=""nofollow"">git commit log</a>.</p>
"
"<p>You can check the Makefile. </p>

<p>Thus the definitions in this Makefile turn to:</p>

<pre><code>obj-m := terminal.o
terminal-objs := syscall.o primarymodule.o
</code></pre>

<p>or view this:</p>

<p><a href=""http://www.linuxchix.org/content/courses/kernel_hacking/lesson8"" rel=""nofollow"">http://www.linuxchix.org/content/courses/kernel_hacking/lesson8</a></p>
"
"<p>You can't use not exported symbols from modules. Use EXPORT_SYMBOL.</p>
"
"<p>I think the interface you are now using is obsolete, <a href=""http://www.makelinux.net/ldd3/"" rel=""nofollow"">this</a> may help you.</p>

<p>I also have a small example of <code>/proc</code> filesystem:</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;

#include &lt;linux/proc_fs.h&gt;

static int proc_read (char *page, char **start, off_t offset, int count, int *eof, void *data);


static int proc_read (char *page, char **start, off_t offset, int count, int *eof, void *data) {
    int reval = 0;

    reval = sprintf(page, ""Hello world\n"");
    *eof = 1;

    return reval;
}

static int __init proc_init(void) {
    struct proc_dir_entry * proc_entry;

    printk(KERN_INFO ""Hello Proc\n"");

    proc_entry = create_proc_read_entry(""test_proc"", 0, NULL, proc_read, NULL);


    return 0;
}


static void __exit proc_exit(void) {
    remove_proc_entry(""test_proc"", NULL);

}

module_init(proc_init);
module_exit(proc_exit);

MODULE_LICENSE(""GPL"");
MODULE_AUTHOR(""Douglas"");
</code></pre>

<p>you can execute <code>cat /proc/test_proc</code> to test this program.</p>
"
"<p>I figured out how to do what I needed to do. (Didn't exactly need to set the EOF indicator, but just needed to increase the position so cat did not endlessly read from my procfile.)</p>

<p>The loff_t *data argument should actually be named offset or position. (I think this fits it's purpose better, data is ambigious) I looked at this page for an example definition: <a href=""http://lxr.free-electrons.com/source/fs/seq_file.c#L165"" rel=""nofollow"">http://lxr.free-electrons.com/source/fs/seq_file.c#L165</a></p>

<pre>156 /**
157  *      seq_read -      -&gt;read() method for sequential files.
158  *      @file: the file to read from
159  *      @buf: the buffer to read to
160  *      @size: the maximum number of bytes to read
161  *      @ppos: the current position in the file
162  *
163  *      Ready-made -&gt;f_op-&gt;read()
164  */
165 ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)</pre>

<p>Anyways working code example:
You need to increase the value of *data before you return (To let the user program know it's new position). Then you can check if it's &gt;0 during the next call.</p>

<pre>static ssize_t proc_read(struct file *file, char __user *buffer, size_t count, loff_t * data){

    if((int)*data&gt;0){
        return 0;
    }

    char * ret_str;
    ret_str= ""Test\n"";

    *data += 6;
    memcpy(buffer, ret_str, 6);
    return 6;
}</pre>

<p><b><i> </i></b></p>
"
"<h2>Root cause</h2>

<p>Probably examples you found are intended for some different kernel version (other than you use). Internal kernel API varies from version to version. See
<a href=""https://www.kernel.org/doc/Documentation/stable_api_nonsense.txt"" rel=""nofollow"">Documentation/stable_api_nonsense.txt</a> for details. The general advice is to look into exactly your kernel sources for code examples. For example see how proc API implemented in <a href=""http://lxr.free-electrons.com/source/kernel/time/timer_stats.c"" rel=""nofollow"">kernel/time/timer_stats.c</a> (in your kernel code, of course).</p>

<h2>Why warnings</h2>

<p>Your signatures of <code>procfile_read()</code> and <code>procfile_write()</code> functions must be the same as in <code>struct file_operations</code>:</p>

<pre class=""lang-c prettyprint-override""><code>ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
</code></pre>

<p>But you have next signatures instead:</p>

<pre class=""lang-c prettyprint-override""><code>int procfile_read(char *buffer, char **buffer_location, off_t offset,
                  int buffer_length, int *eof, void *data)
int procfile_write(struct file *file, const char *buffer,
                   unsigned long count, void *data)
</code></pre>

<p>You probably need to double check the actual signatures in <code>struct file_operations</code> for your kernel version.</p>

<h2>Example code insights</h2>

<p>Also you may notice that <code>.read</code> callback need to be set like that (in new kernel versions):</p>

<pre><code>.read = seq_read,
</code></pre>

<p>And actual reading should be done via <code>.open</code> callback:</p>

<pre><code>.open = tstats_open,
</code></pre>

<p>In open function you need to call your actual show function, like this:</p>

<pre><code>static int tstats_open(struct inode *inode, struct file *filp)
{
    return single_open(filp, tstats_show, NULL);
}
</code></pre>

<p>And show function should have signature like this:</p>

<pre><code>static int tstats_show(struct seq_file *m, void *v)
</code></pre>

<p>For complete example see <a href=""http://lxr.free-electrons.com/source/kernel/time/timer_stats.c"" rel=""nofollow"">kernel/time/timer_stats.c</a> in your kernel.</p>
"
"<p><code>seq_file</code> is useful for files, which <strong>content</strong> is not stored somewhere, but is <strong>generated on the fly</strong> when user needs it. It can be generation using single <em>format</em> string (like <code>%s\n</code> in the question post), or combining chunks of different or same types.</p>

<p>When use <code>seq_file</code> functionality, code writer doesn't bother about size of the buffer to read in, current file's offset and accessing to <code>__user</code> data with <code>copy_to_user()</code>. Instead, <strong>he concentrates on generating file's content</strong>, as if it is some stream of unlimited size. Everything else is processed by <code>seq_file</code> mechanism automatically.</p>

<p>E.g., given example can be implememted using <code>seq_file</code> as follows:</p>

<pre class=""lang-c prettyprint-override""><code>int param_show(struct seq_file *m, void *v)
{
    (void)v; /* Unused */
    seq_printf(m, ""%s\n"", param); /* Just generate content of the ""file"" */
    return 0;
}

int my_proc_open(struct inode *inode, struct file *filp)
{
    return single_open(filp, &amp;param_show, NULL);
}

const struct file_operations my_proc_ops = {
    .owner = THIS_MODULE,
    .open = &amp;my_proc_open,
    .read = &amp;seq_read
};
</code></pre>

<p>For comparison, the same read functionality implemented directly:</p>

<pre class=""lang-c prettyprint-override""><code>ssize_t my_proc_read(struct file *file, char __user *buffer, size_t count, loff_t *offset)
{
    ssize_t ret;
    size_t param_len = strlen(param);

    /* Write to buffer everything except terminating '\n' */
    ret = simple_read_from_buffer(buffer, count, offset, param, param_len);
    /* But processing of additional '\n' is much more complex */
    if (ret &gt;= 0 &amp;&amp; ret &lt; (ssize_t)count &amp;&amp; *offset == param_len) {
        char ch = '\n';
        int err = put_user(buffer + ret, &amp;ch); /* Try to append '\n' */

        if (!err) {
            /* Success */
            ++ret;
            ++(*offset);
        } else if (!ret) {
            /* Fail and nothing has been read before */
            ret = err;
        }
    }

    return ret;
}

const struct file_operations my_proc_ops = {
    .owner = THIS_MODULE,
    .read = &amp;my_proc_read
};
</code></pre>

<p>As one can see, while reading ready content of <code>params</code> is single-line (uses helper <code>simple_read_from_buffer</code>), additional <code>\n</code>, which should be <em>generated</em>, makes implementation much more difficult.</p>

<p>Disadvantage of <code>seq_file</code> is its perfomance: content, generated in <code>.show</code> function doesn't cached, so every subsequent <code>read()</code> syscall requires <code>.show</code> to be called again. Also, for generating file's content internal buffer is used, and this buffer should be allocated in the heap.</p>

<p>But in most cases, files generated on the fly are small and/or are read  rarely and/or are not performance critical. So <code>seq_file</code> is suitable for such files in almost all cases.</p>
"
"<p><code>seq_file</code> provides helpers only for reading file. There is no similar helpers for write, but it is not difficult to implement <code>.write</code> callback for iterable data by hands:</p>

<p>Unlike to the reading, you can drop file's position handling in the .write callback, assuming that user always write to the beginning, or, optionally, to the end (using O_APPEND file's control flag).
Second, again unlike to the reading, you can assume that user writes at once content of 1,2 or more elements, but not a half element.</p>

<p>The simplest way is allow to write by single element:</p>

<pre><code>size_t write(struct file* file, const char __user* buf, size_t size, loff_t* pos)
{
    copy_from_user(str, buf, size); // Copy string from user space
    my_elem = my_parse(str, size); // Parse string
    if(file-&gt;f_flags &amp; O_APPEND) {
         list_add_tail(my_elem, &amp;my_list);//Append element to the end of list
    }
    else {
         clear_my_list(); // Clear old content of the list
         list_add_tail(my_elem, &amp;my_list);// Add single element to it.
    }

    (void)pos; //Do not use file position at all
    return count; // Return number of bytes passed by the user
}
</code></pre>

<p>If user wants to write several elements, e.g., from a file on hard disk, any shell is able to split this file by, e.g., new lines, and feed lines to the your proc file one by one.</p>
"
"<p>After I tied a lot. I found there is actually no <code>seq</code> version write function. However, you can treat <code>/proc</code> file as a normal device file which can be operated by methods defined in <code>file_operations</code>.</p>
"
"<p>You need to use <a href=""http://www.cplusplus.com/reference/cstdlib/realloc/"" rel=""nofollow noreferrer""><code>realloc()</code></a>, not <code>malloc()</code>, like this:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

typedef struct {
    int len;
    int *arr;
} seq;

void write_seq(seq *q)
{
    q-&gt;arr = realloc (q-&gt;arr, (q-&gt;len + 1) *  sizeof(int));
    q-&gt;arr[q-&gt;len] = q-&gt;len;
    q-&gt;len++;
}

int main(void)
{
    seq q;
    q.len = 0;
    q.arr = NULL;

    for(int i = 0; i &lt; 10; ++i)
        write_seq(&amp;q);


    printf(""length is %d\n"", q.len);
    for (int i = 0; i &lt; q.len; i++) {
        printf(""%d\n"", q.arr[i]);
    }

    free(q.arr);

    return 0;
}
</code></pre>

<p>Output:</p>

<pre><code>length is 10
0
1
2
3
4
5
6
7
8
9
</code></pre>
"
"<p>To add members to the array when you don't know in advance the size of that array, you'd need to use <code>realloc()</code> to increase the size on demand.   However it's inefficient to do that for <em>every</em> change to the array size, so it would be more usual to allow for a certain amount of headroom (whether that be a fixed increment or a percentage based amount) in the buffer.</p>

<p>The corollary of that is you need to store the current <em>capacity</em> of the buffer as well as the offset to the amount <em>currently</em> used.</p>

<p>This also means that there'll be a certain amount of memory wastage, but that's the trade off you have to make.</p>

<p>My approach would look something like this, abstracting the operations that you might want to perform on a <code>seq</code>.</p>

<pre><code>typedef struct {
    size_t    capacity;
    size_t    offset;
    uint16_t *arr;
} seq;

static const size_t SEQ_INITIAL = 8;
static const size_t SEQ_INCREMENT = 8;

int seq_init(seq *seq) {
    assert(seq != NULL);         /* catch null seq */
    assert(seq-&gt;arr == NULL);    /* error to call on already init'd seq */
    seq-&gt;capacity = SEQ_INITIAL;
    seq-&gt;offset = 0;
    seq-&gt;arr = malloc(seq-&gt;capacity * sizeof(seq-&gt;arr[0]));
    return seq-&gt;arr == NULL ? -1 : 0;
}

static int seq_grow(seq *seq) {  /* private implementation detail */
    size_t new_capacity = seq-&gt;capacity + SEQ_INCREMENT;
    void *p = realloc(seq-&gt;arr, new_capacity * sizeof(seq-&gt;arr[0]));
    if (p == NULL) {             /* realloc failed, seq unmodified */
        return -1;
    }
    seq-&gt;arr = p;
    seq-&gt;capacity = new_capacity;
    return 0;
}

int seq_write(seq *seq, uint16_t value) {
    assert(seq != NULL);         /* catch null seq */
    if ((seq-&gt;offset == seq-&gt;capacity) &amp;&amp; seq_grow(seq) &lt; 0) {
        return -1;               /* write failed */
    }
    assert(seq-&gt;arr != NULL);    /* catch bad seq */
    assert(seq-&gt;offset &lt; seq-&gt;capacity); /* ensure seq really has room */
    seq-&gt;arr[seq-&gt;offset++] = value;
    return 0;
}

void seq_free(seq *seq) {
    if (seq != NULL) {
        free(seq-&gt;arr);
        seq-&gt;arr = NULL;
    }
}
</code></pre>
"
"<p>The solution to your issue is to forward declare the overlapping classes in the header files, and then to include their actual .h files from your .cpp implementation files.</p>

<p>For instance, to get around <code>Gateway</code>'s dependencies on <code>ResultSet</code>,</p>

<pre><code>// Gateway.h
class ResultSet;

class Gateway {
    ResultSet exec(string params);
};
</code></pre>

<p>This forward declares the class <code>ResultSet</code>. </p>

<p>Now in <code>Gateway.cpp</code>, we have to provide the actual interface to the compiler. So now we include <code>ResultSet.h</code>.</p>

<pre><code>// Gateway.cpp
#include ""ResultSet.h""

ResultSet Gateway::exec(string p) { ... }
</code></pre>

<p>We do this for your other cyclic relationships, and you will then have source you can compile and build.</p>

<p>For <code>ResultSet</code>, we will forward declare <code>Member</code>.</p>

<pre><code>// ResultSet.h
class Member;

class ResultSet {
    ResultSet();    // ctor
    int     index;
    bool    next();
    string  getCurrent(Member member);
};
</code></pre>

<p>And in its implementation file, we will finally include <code>Member</code>'s header.</p>

<pre><code>// ResultSet.cpp
#include ""Member.h""

ResultSet::ResultSet() { index = 0; }
bool    ResultSet::next() { ++index &lt; length; }
string  ResultSet::getCurrent(Member member) { member.fetch(index) }
</code></pre>

<p>And finally, <code>Member</code>...</p>

<pre><code>// Member.h
class Gateway;

class Member {
    Gateway gateway;
    string  fetch(int i);
};
</code></pre>

<p>And of course, <code>Member.cpp</code> must then include Gateway's information.</p>

<pre><code>// Member.cpp
#include ""Gateway.h""
string Member::fetch(int i) { return gateway.sGet(i); }
</code></pre>

<p>Now there are no cyclic dependencies.</p>
"
"<p>To figure out how many times your function gets called, increment a static counter every time the function is entered and the print out the value after the call. For instance:</p>

<pre><code>int counter;
void get (int n) {
    ++counter; /* increment counter before first return */
    if (n&lt;1) return;
    get (n-1) ;
    get (n-3) ;
    printf (""%d"", n) ;
}

int main()
{
    counter = 0; /* reset counter before each use */
    get(6);
    printf(""get() was called %d times\n"", counter);
}
</code></pre>
"
"<p>Considering this is certainly an academic exercise, it may behoove you to understand how the recursion is working.</p>

<p>We can modify your code to print out a call tree, showing each invocation:</p>

<pre><code>#include &lt;stdio.h&gt;

void get(int n, int depth)
{
    static int call = 1;
    printf(""%3d: %*sget(%d)\n"", call++, 2*depth, """", n);
    if (n&lt;1)
        return;
    get(n-1, depth+1);
    get(n-3, depth+1);
}

int main(void)
{
    get(6, 0);
    return 0;
}
</code></pre>

<p><strong>Output:</strong></p>

<pre class=""lang-none prettyprint-override""><code>  1: get(6)
  2:   get(5)
  3:     get(4)
  4:       get(3)
  5:         get(2)
  6:           get(1)
  7:             get(0)
  8:             get(-2)
  9:           get(-1)
 10:         get(0)
 11:       get(1)
 12:         get(0)
 13:         get(-2)
 14:     get(2)
 15:       get(1)
 16:         get(0)
 17:         get(-2)
 18:       get(-1)
 19:   get(3)
 20:     get(2)
 21:       get(1)
 22:         get(0)
 23:         get(-2)
 24:       get(-1)
 25:     get(0)
</code></pre>

<p>Note that I am assuming your assignment states <code>if (n&lt;1)</code> (""one""), not <code>if (n&lt;l)</code> (""ell"").  Also, notice that I added a <code>depth</code> parameter. This allowed me to indent each call appropriately.</p>
"
"<p>You don't need to call <code>std::vector::clear</code> or do something else, the destructor will get called when you delete it via <code>delete ptr_s;</code>.</p>

<p>The <code>still reachable</code> matter is explained in Valgrind <a href=""http://valgrind.org/docs/manual/faq.html#faq.reports"" rel=""nofollow"">FAQ</a>.</p>

<blockquote>
  <p>My program uses the C++ STL and string classes. Valgrind reports
  'still reachable' memory leaks involving these classes at the exit of
  the program, but there should be none.</p>

  <p>First of all: relax, it's probably not a bug, but a feature. Many
  implementations of the C++ standard libraries use their own memory
  pool allocators. Memory for quite a number of destructed objects is
  not immediately freed and given back to the OS, but kept in the
  pool(s) for later re-use. The fact that the pools are not freed at the
  exit of the program cause Valgrind to report this memory as still
  reachable. The behaviour not to free pools at the exit could be called
  a bug of the library though.</p>
</blockquote>

<p><strong>Update:</strong></p>

<p>Briefly, don't copy classes with <code>memcpy</code>, if you use <code>memcpy</code> to copy a class object whose destructor deletes a pointer within itself (std::vector member in your case), you will end up with double delete when the second instance of the object is destroyed.</p>

<p>The right way is copy/move constructor and/or assignment operator for classes.</p>
"
"<p>I am a Cppcheck developer.</p>

<p>You can perhaps use the --rule and --rule-file options to add such rules. Maybe you can use a regular expression such as:</p>

<pre><code>\sget[A-Za-z]+\(\)\s+{\s+return
</code></pre>

<p>It depends on your code base.</p>

<p>If you can write a regular expression then this is the most direct and simple way to create a custom rule.</p>

<p>For more information, read the ""Writing rules"" articles here:
<a href=""http://sourceforge.net/projects/cppcheck/files/Articles/"" rel=""noreferrer"">http://sourceforge.net/projects/cppcheck/files/Articles/</a></p>

<p>But maybe you want to write more sophisticated rules that search for such getter methods by using the Cppcheck SymbolDatabase, tokenlist and syntax tree. You can't use --rule and --rule-file then. You have these choices then:</p>

<ul>
<li>Use --dump and write your own custom scripts that read the output data (xml). </li>
<li>Write C++ code and compile it into Cppcheck. This is relatively straightforward imho but requires that you compile Cppcheck yourself.</li>
</ul>
"
"<p>Read <a href=""http://man7.org/linux/man-pages/man3/system.3.html"" rel=""nofollow"">system(3)</a>. That C function (which you probably should avoid, prefer explicit <a href=""http://man7.org/linux/man-pages/man2/syscalls.2.html"" rel=""nofollow"">syscalls(2)</a> like <code>fork</code> &amp; <code>execve</code>) is running the POSIX <code>/bin/sh -c</code> ; read also <a href=""http://man7.org/linux/man-pages/man3/popen.3.html"" rel=""nofollow"">popen(3)</a>.</p>

<p>But your interactive shell is probably <code>bash</code> which behaves differently than POSIX <code>sh</code>, notably for redirections like <code>&lt;(amixer sget Master)</code></p>

<p>To make things more complex, the <code>/bin/bash</code> <em>program</em>, when invoked as <code>sh</code>, changes it behavior to POSIX <code>sh</code>, so on many systems, <code>/bin/sh</code> is a symlink to <code>/bin/bash</code> ...</p>

<p>So read also the documentation of <a href=""http://www.gnu.org/software/bash/"" rel=""nofollow"">GNU <code>bash</code></a>,  and <a href=""http://www.makelinux.net/alp/"" rel=""nofollow"">Advanced Linux Programming</a>, and <a href=""http://www.tldp.org/LDP/abs/html/"" rel=""nofollow"">Advanced Bash Scripting Guide</a> ...</p>

<p>Then, either set up your pipelines and redirections with explicit <a href=""http://man7.org/linux/man-pages/man2/syscalls.2.html"" rel=""nofollow"">syscalls(2)</a>, or code some <code>bash</code> or <code>zsh</code> script (but probably not a POSIX <code>/bin/sh</code> one!) to do the work.</p>

<p>I don't know what <code>amixer sget Master</code>  does, but perhaps you might consider a pipeline like</p>

<pre><code> amixer sget Master | awk -F '[][]' '/dB/ { print $2 }'
</code></pre>

<p><sup>(and the above pipeline is POSIX <code>sh</code> compatible, so callable from <a href=""http://man7.org/linux/man-pages/man3/popen.3.html"" rel=""nofollow"">popen(3)</a>...)</sup></p>

<p>I am surprised you need to do all that. I guess that the sound volume could be queried by some pseudo file from <code>/sys/</code></p>

<p>Learn more about <a href=""http://www.alsa-project.org/"" rel=""nofollow"">ALSA</a> and read some <a href=""http://0pointer.de/blog/projects/guide-to-sound-apis.html"" rel=""nofollow""><em>Guide thru the Linux sound API</em></a></p>
"
"<p>Sorry, but you have to do case switching since the compiler has to generate different CPU instructions for different types. The kind of operation is defined by the choice of the variable.</p>
"
"<p>You should make expr structure. This mean one node of AST (Abstruct Syntax Tree). And it have op. This mean +,-,*,/ for the lhs, rhs. do_expr caluculate expression. Finally, dump_any print the value.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

typedef enum any_type{
  ANY_TYPE_CHAR,
  ANY_TYPE_UCHAR,
  ANY_TYPE_SHORT,
  ANY_TYPE_USHORT,
  ANY_TYPE_INT,
  ANY_TYPE_UINT,
  ANY_TYPE_LONG,
  ANY_TYPE_ULONG,
  ANY_TYPE_FLOAT,
  ANY_TYPE_DOUBLE,
} any_type;

typedef struct any{
  any_type type;
  union{
    char as_char;
    unsigned char as_uchar;
    short as_short;
    unsigned short as_ushort;
    int as_int;
    unsigned int as_uint;
    long as_long;
    unsigned long as_ulong;
    float as_float;
    double as_double;
  };
} any;

typedef enum op_type{
  OP_PLUS,
  OP_MINUS,
  OP_MULT,
  OP_DIVID,
} op_type;

typedef struct {
  int op;
  any lhs;
  any rhs;
} expr;

int
do_expr(expr* e, any *r) {
  switch (e-&gt;op) {
    case OP_PLUS:
      r-&gt;type = e-&gt;lhs.type;
      r-&gt;as_int = e-&gt;lhs.as_int + e-&gt;rhs.as_int;
      return 0;
      break;
    default:
      fprintf(stderr, ""unknown operation\n"");
      break;
  }
  return 1;
}

void
dump_any(any* a) {
  switch (a-&gt;type) {
    case ANY_TYPE_INT:
      printf(""%d\n"", a-&gt;as_int);
      break;
    default:
      assert(!""unknown type"");
      break;
  }
}

int
main(int argc, char* argv[]) {
  expr e1 = {
    .op = OP_PLUS,
    .lhs = { .type = ANY_TYPE_INT, as_int: 1, },
    .rhs = { .type = ANY_TYPE_INT, as_int: 2, },
  };

  any ret;
  if (do_expr(&amp;e1, &amp;ret) == 0) {
    dump_any(&amp;ret);
  }

  return 0;
}
</code></pre>
"
"<p>This is going to require a lot of code, because <a href=""https://en.wikipedia.org/wiki/Combinatorial_explosion"" rel=""nofollow noreferrer"">combinatorial explosion</a> is part of the problem.</p>

<p>Use a table-driven approach: define two tables, one for converting between types, and one for performing operations on them.</p>

<p>For conversion make a function pointer type</p>

<pre><code>typedef any (*convert_any)(any val, any_type target);
</code></pre>

<p>and make a table of conversions keyed on <code>any_type</code>:</p>

<p>convert_any conversion[] = {
    convert_char,
    convert_uchar,
    convert_short,
    ...
};</p>

<p>with implementations like this for each type (you'll need ten of these):</p>

<pre><code>static any convert_char(any val, any_type target) {
    any res = { .type = target };
    switch (target) {
        case ANY_TYPE_CHAR: res.as_char = val.as_char; break;
        case ANY_TYPE_INT: res.as_int = (int)val.as_char; break;
        ...
    }
    return res;
}
</code></pre>

<p>For operations make another  function pointer type:</p>

<pre><code>typedef any (*operation_any)(any left, any right);
</code></pre>

<p>You will need to make a 3D array of such pointers - one for each triple of operation, the type of its left operand, and the type of its right operand.</p>

<p>Implementations would look like this:</p>

<pre><code>static any add_int(any left, any right) {
    any lhs = conversion[left.type](left, ANY_TYPE_INT);
    any rhs = conversion[right.type](right, ANY_TYPE_INT);
    any res {.type = ANY_TYPE_INT, .as_int = lhs.as_int + rhs.as_int};
    return res;
}
static any add_double(any left, any right) {
    any lhs = conversion[left.type](left, ANY_TYPE_DOUBLE);
    any rhs = conversion[right.type](right, ANY_TYPE_DOUBLE);
    any res {.type = ANY_TYPE_DOUBLE, .as_double = lhs.as_double + rhs.as_double };
    return res;
}
</code></pre>

<p>There will be forty such implementations - one for each result type and operation pair. The 3D table will contain 400 entries, depending on the type of the result the operation needs to produce. The call will look up into 3D array, find <code>operation_any</code> pointer, pass two arguments, and get a result like this:</p>

<pre><code>any res = operations[PLUS_OP][left.type][right.type](left, right);
</code></pre>
"
"<p>To avoid a combinational nightmare, consider that there are 3 groups of types, <em>unsigned integers</em>, <em>signed integers</em>, <em>floating point</em>. </p>

<p>A goal is to determine which of the 3 groups the operation is to use.  Then get the value of the operand per its type and the target group.  Do the math per that group.  Then save per the group and the highest ranking type.</p>

<hr>

<p>For each of the 10 types, create 10 functions to fetch the data and return as the widest <em>unsigned integer</em>.  Another 10 for <em>signed integer</em> and lastly 10 for <em>floating point</em>.</p>

<p>For each for the 10 types, do the same to create functions to set the data.   So far 60 small functions.</p>

<p>To access the correct function, use a table look up in a function.  3 more functions for getting, 3 more for setting.</p>

<p>An example addition function is at the end.  It looks for the highest ranking type and gets/adds/sets based on the one of 3 groups.  </p>

<p>Now add 3 more functions for <code>-,/,*</code>.  Total about 60 + 6 + 4 functions.  </p>

<p>Bonus: To add a new function like <code>%</code>, only takes 1 more function to write.</p>

<pre><code>#include&lt;assert.h&gt;

typedef enum any_type{
    // Insure these are in rank order
    // ANY_TYPE_CHAR left out for now
    ANY_TYPE_SCHAR,
    ANY_TYPE_UCHAR,
    ANY_TYPE_SHORT,
    ANY_TYPE_USHORT,
    ANY_TYPE_INT,
    ANY_TYPE_UINT,
    ANY_TYPE_LONG,
    ANY_TYPE_ULONG,
    ANY_TYPE_FLOAT,
    ANY_TYPE_DOUBLE,
    ANY_TYPE_N,
} any_type;

typedef struct any{
    any_type type;
    union{
        signed char as_schar;
        unsigned char as_uchar;
        short as_short;
        unsigned short as_ushort;
        int as_int;
        unsigned int as_uint;
        long as_long;
        unsigned long as_ulong;
        float as_float;
        double as_double;
    };
} any;

/////////////////////////////////////
unsigned long any_uget_schar(const any *x) {
  return (unsigned long) x-&gt;as_schar;
}
unsigned long any_uget_uchar(const any *x) {
  return x-&gt;as_uchar;
}
/* 8 more */

unsigned long any_get_unsigned(const any *x) {
  static unsigned long (*uget[ANY_TYPE_N])(const any *x) = {
    any_uget_schar, any_uget_uchar, /* 8 others */ };
  assert(x-&gt;type &lt;  ANY_TYPE_N);
  return (uget[x-&gt;type])(x);
}

/////////////////////////////////////
signed long any_sget_schar(const any *x) {
  return x-&gt;as_schar;
}
signed long any_sget_uchar(const any *x) {
  return x-&gt;as_uchar;
}
/* 8 more */

signed long any_get_signed(const any *x) {
  static signed long (*sget[ANY_TYPE_N])(const any *x) = {
      any_sget_schar, any_sget_uchar, /* 8 others */ };
  assert(x-&gt;type &lt;  ANY_TYPE_N);
  return sget[x-&gt;type](x);
}
/////////////////////////////////////

double any_get_fp(const any *x); // similar for floating point

/////////////////////////////////////

void any_uset_schar(any *x, unsigned long y) {
  x-&gt;as_schar = (signed char) y;
}

void any_uset_uchar(any *x, unsigned long y) {
  x-&gt;as_uchar = (unsigned char) y;
}

/* 8 more */

void any_set_unsigned(any *x, unsigned long y) {
  static void (*uset[ANY_TYPE_N])(any *x, unsigned long y) = {
    any_uset_schar, any_uset_uchar, /* 8 others */ };
  assert(x-&gt;type &lt;  ANY_TYPE_N);
  uset[x-&gt;type](x,y);
}

/* 10 more for any_sset_... */

/* 10 more for any_fset_... */

///////////////////////////////////////////////

static const char classify[] = ""susususuff"";


any any_get_add(any a, any b) {
  any sum;
  sum.type = max(a.type, b.type);
  assert(sum.type &lt;  ANY_TYPE_N);
  switch (classify[sum.type]) {
    case 's':
      any_set_signed(&amp;sum, any_get_signed(&amp;a) + any_get_signed(&amp;b));
      break;
    case 'u':
      any_set_unsigned(&amp;sum, any_get_unsigned(&amp;a) + any_get_unsigned(&amp;b));
      break;
    case 'f':
      any_set_fp(&amp;sum, any_get_signed(&amp;a) + any_get_signed(&amp;b));
      break;
    default:
      assert(0);
  }
  return sum;
}
</code></pre>
"
"<p>EEPROM:</p>

<p>It's part of setting the MAC and serial number, but the only way to know if the EEPROM is working is to read its content.
$ cat /sys/bus/i2c/devices/2-0057/eeprom | hexdump -C</p>
"
"<p>Line</p>

<pre><code>stuct bin_attribute *battr = (void*)attr;
</code></pre>

<p>correctly obtains pointer to the <code>bin_attribute</code> structure from the pointer to its <strong>first field</strong> <code>attr</code> of type <code>struct attribute</code>.</p>

<hr>

<p>Normally, Linux kernel developers tend to use <code>container_of</code> macro for obtaining pointer to the structure type knowing pointer to its field. More ""canonical"" way for the transformation above would be:</p>

<pre><code>stuct bin_attribute *battr = container_of(attr, struct device_attribute, attr);
</code></pre>

<p>(In this call the first <code>attr</code> argument refers to the <em>pointer</em>, and the third <code>attr</code> argument refers to the <em>field's name</em>).</p>
"
"<p>Are your drivers sitting on the specific bus? If no, what purpose of the specific class?</p>

<p>Anyway, for starter</p>

<pre><code>struct class devclass = {?}

probe()
{
  struct device *dev = ?

  dev-&gt;class = &amp;devclass;
}

init()
{
  class_register(&amp;devclass);
}
</code></pre>
"
"<p>First, you should know that there is already a kernel driver for the tmp102 that has a sysfs interface. Have a look at <a href=""http://elixir.free-electrons.com/linux/v4.13/source/drivers/hwmon/tmp102.c"" rel=""nofollow noreferrer"">drivers/hwmon/tmp102.c</a>.</p>

<p>Now, for your issue, you have a <code>struct kobject</code> that is passed to you sysfs callback. You can call <code>kobj_to_dev()</code> to get a pointer to the device. Then, for example, you could use <code>dev_get_drvdata()</code> to get a pointer to your own private structure that would contain a pointer to the i2c client. Don't forget to set it first with <code>dev_set_drvdata()</code> in your probe.</p>

<p>You have can find an example in <a href=""http://elixir.free-electrons.com/linux/v4.13/source/drivers/rtc/rtc-ds1343.c#L156"" rel=""nofollow noreferrer"">drivers/rtc/rtc-ds1343.c</a> but it is using an spi_driver.</p>
"
"<p>If while removing the module (rmmod) you are getting the error, there must be a problem in your __exit(). Based on your __init(), you are registering the driver first and then adding the device. So, you must unregister the device first before unregistering the driver.'</p>

<pre><code>platform_device_unregister(dev);
platform_driver_unregister(&amp;my_driver);
</code></pre>
"
"<p>Two correction in your code.</p>

<p>1) In my_init() you should add return function here to avoid calling platform_device_put() in case of success of device adding.</p>

<p><strong>return ret; // if device is added succesfully then return.</strong></p>

<pre><code>    ret = platform_device_add(dev);
    if (ret != 0) {
        printk(""&lt;1&gt;"" ""platform driver could not be added\n"");
        goto undo_malloc;
    }
    printk(""&lt;1&gt;"" ""platform driver installed\n"");

    return ret; // if device is added succesfully then return.

undo_malloc:
    platform_device_put(dev);
    return ret;
</code></pre>

<p>2) in my_cleanup() always unregistered all devices first and then unregistered your driver...</p>
"
"<p>You <strong>don't want</strong> to do that.</p>

<p>Kernel people always say that ""policy does not belong to kernel"". The kernel should do as userland tells it, but should never decide what to do and should never do complex things that the userland can easily compose of more basic operations. This sounds awful lot like policy.</p>

<p>The only part of kernel that works with inodes and dentries are implementations of the respective system calls and very special modules like ecryptfs and kernel nfsd. For anything that is not directly filesystem-related, you should not assume filesystem even exists!</p>

<p>Unless you are doing anything filesystem-related that really can't be done elsewhere, you should have userland tool manipulate files and feed the data in/read from kernel via device nodes or <code>/proc</code> or <code>/sys</code> special files (they are really just like devices, except identified by name rather than device numbers).</p>

<p>Now if you are really doing something filesystem related, you can easily look up the uses of <a href=""http://lxr.free-electrons.com/ident?i=vfs_link"" rel=""nofollow""><code>vfs_link</code> on  lxr.free-electrons.com</a> (or <a href=""http://lxr.linux.no/linux+v3.13.5/+ident=61695501"" rel=""nofollow"">lxr.linux.no</a>). There are 3 uses in total. They are most likely <strong>the only three uses in the whole universe</strong>.</p>

<p>That is however <strong>not the correct way to do rename</strong>. There <strong>is</strong> a similar function <a href=""http://lxr.free-electrons.com/ident?i=vfs_rename"" rel=""nofollow""><code>vfs_rename</code></a>. The semantics is different, because rename replaces target while link does not and also because it is allowed to rename directories but not to link them. <code>vfs_rename</code> has whopping <strong>four</strong> uses <strong>in the whole universe</strong>.</p>

<p>As for the arguments, if you <em>don't</em> have a <code>struct file*</code>. That would be a handle to <em>open</em> file, but you are linking one <em>path</em> to another <em>path</em>. <code>old_dentry</code> is the old filename, <code>new_dentry</code> is the new filename, <code>new_dir</code>/<code>dir</code> is the directory into which <code>new_dentry</code> should be placed, <code>old_dir</code> is the inode in which <code>old_dentry</code> lived (. I don't really know what <code>delegated_inode</code> is, but it has something to do with the nfsd (which is one of those three users of this function).</p>
"
"<p>If you want to configure something for your kernel module, you can do that in a wrapper script which inserts your kernel module using <code>insmod</code> command.</p>

<p>And have a look at <a href=""http://kernelnewbies.org/FAQ/WhyWritingFilesFromKernelIsBad"" rel=""nofollow"">this</a> article where it tell ""Why it is bad to write files from Kernel""</p>
"
"<p>There is just no way to implement it properly. If you want to do it anyway, and also
understand the reason why it is a Bad Idea (tm), see this <a href=""http://www.linuxjournal.com/article/8110"" rel=""nofollow"">article</a></p>
"
"<p>Wrong wrong wrong. <code>sysfs</code> is an interface <em>to userspace</em>, you should not be using it inside the kernel.</p>

<p>If your module wants to change the block scheduler then you should work out how to do that inside the kernel, ie. when a user writes to <code>/sys/block/sda/queue/scheduler</code> some kernel code is run, you should be calling that code directly.</p>

<p>Having said that this seems like a Bad Idea, how will you handle multiple block devices for example?</p>
"
"<p>On current kernel versions you can achieve the same using vfs_path_lookup() (<a href=""http://lxr.linux.no/linux+"" rel=""nofollow"">http://lxr.linux.no/linux+</a>*/fs/namei.c#L2051).</p>
"
"<p>Firstly, you can't use user space system calls(<code>readlinkat()</code> or <code>readlink()</code>) directly in your kernel module. Rather you need to use exported function / symbol within the kernel space. </p>

<p>Next, may want to look into the <a href=""http://lxr.free-electrons.com/source/include/linux/fs.h#L1515"" rel=""nofollow"">struct inode_operations</a> specific to the file system which you are using. Also look into <a href=""http://lxr.free-electrons.com/ident?i=generic_readlink"" rel=""nofollow""><code>generic_readlink()</code></a> which internally call <code>vfs_readlink()</code>.</p>
"
"<p><code>current-&gt;uid</code> and <code>current-&gt;euid</code> can substitute for the first two.</p>

<p><code>schedule()</code> should work for the last one.</p>

<p>The filesystem operations look more complicated: you might try and see if <code>sys_chown()</code>, <code>sys_mknod()</code>, and <code>sys_unlink()</code> are exported (available for use by any module).  If they work, great.  There are some <a href=""http://www.linuxjournal.com/article/8110"" rel=""nofollow noreferrer"">useful tips here</a>.  Otherwise, you have to dig a little deeper:</p>

<p>The <code>chown</code> syscall is defined in <code>fs/open.c</code>.  At a glance I don't see why you couldn't copy that code into your own ""kernel_chown"" function and give it a try.</p>

<p>The <code>mknodat</code> and <code>unlink</code> syscalls are in <code>fs/namei.c</code>; they eventually wind up calling <code>vfs_mknod()</code> and <code>vfs_unlink()</code>, respectively.  Maybe you can duplicate that code or figure out how it's done from there.</p>
"
"<p>The sem is acquired when holding spinlock. Once the order is swapped, the problem goes away. The problem has been fixed in late kernels.</p>

<pre><code>#2: (&amp;(&amp;c-&gt;erase_completion_lock)-&gt;rlock), jffs2_garbage_collect_pass+0x1fc/0x790
#3: (&amp;c-&gt;alloc_sem), jffs2_garbage_collect_pass+0x208/0x790
</code></pre>

<p>The code is in fs/jffs2/gc.c. Swap line 228 and 229 to solve the problem.</p>

<pre><code>227         D1(printk(KERN_DEBUG ""No progress from erasing blocks; doing GC     anyway\n""));
228         spin_lock(&amp;c-&gt;erase_completion_lock);
229         mutex_lock(&amp;c-&gt;alloc_sem);
230 }
</code></pre>
"
"<p>Seriously, try something newer. 2.6.18 is >7 years old.</p>
"
"<p>Looks like CPU#1 and CPU#3 are spinning in a spinlock on a inode structure.</p>
"
