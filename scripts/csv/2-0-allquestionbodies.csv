"body"
"<p>I'm working on a project about Linux kernel mm(memory management)
and with a page, I need to find the process which the page belongs to.</p>

<p>However, I could not find any way without modifying the kernel.
So, I'm really wondering whether it is possible to do that without modifying kernel.</p>

<p>In detail, when I have a VMA then, it is also possible to convert the VMA into the corresponding page, I want to know what process the VMA or page belongs to.</p>

<p>for example, in mm/page_io.c (of linux kernel source tree):</p>

<pre><code>    int __swap_writepage(struct page *page, struct writeback_control *wbc,
        void (*end_write_func)(struct bio *, int))
{
        struct bio *bio;
        int ret, rw = WRITE;
        struct swap_info_struct *sis = page_swap_info(page);
...
        ret = bdev_write_page(sis-&gt;bdev, swap_page_sector(page), page, wbc);
        if (!ret) {
                count_vm_event(PSWPOUT);

                /* I should figure out what process is having the page above.
                 * But it is hard to know, because page is managed in LRU and
                 * it is not directly related to its process. What hints I have
                 * are page struct and some data structures which I could
                 * infer from the page only.
                 */
                // here!
</code></pre>

<p>In where I mark ""here!"", I should do that work what I said above.
I'm waiting for your great answer.
Thank you!</p>
"
"<p>I am new to Linux kernel debugging.</p>

<p>I have came across the tools like ftrace and gdb. I want to see all the relevant function calls made when a module is loaded by the kernel when it loads such as the function calls made by the graphics driver (drm, kms, setting up of buffers etc.) and initializing of the GPU.</p>

<p>I tried to set up the grub by adding</p>

<blockquote>
  <p>stacktrace trace_event=sched:<em>,timer:</em>,irq:* trace_buf_size=40M</p>
</blockquote>

<p>and I got the following output</p>

<pre><code>       Depth    Size   Location    (58 entries)
        -----    ----   --------
  0)     4096      68   ftrace_call+0x5/0xb
  1)     4028       8   mempool_alloc_slab+0x13/0x20
  2)     4020      56   mempool_alloc+0x4e/0x140
  3)     3964      12   scsi_sg_alloc+0x48/0x60
  4)     3952      44   __sg_alloc_table+0xd6/0x130
  5)     3908      32   scsi_alloc_sgtable+0x81/0xe0
  6)     3876      20   scsi_init_sgtable+0x27/0x70
  7)     3856      36   scsi_init_io+0x3c/0x1c0
  8)     3820     140   sd_setup_read_write_cmnd+0x3c/0xb70
  9)     3680       8   sd_init_command+0x2d/0xc0
 10)     3672      16   scsi_setup_cmnd+0xe1/0x170
 11)     3656      24   scsi_prep_fn+0xc4/0x170
 12)     3632      36   blk_peek_request+0x13b/0x280
 13)     3596      68   scsi_request_fn+0x38/0x5f0
 14)     3528      12   __blk_run_queue+0x2e/0x40
 15)     3516      40   blk_queue_bio+0x38c/0x3a0
 16)     3476      40   generic_make_request+0xd0/0x1b0
 17)     3436      96   submit_bio+0x67/0x180
 18)     3340      28   submit_bh_wbc+0x115/0x170
 19)     3312      16   bh_submit_read+0x3c/0xb0
 20)     3296      64   __read_extent_tree_block+0x180/0x210
 21)     3232      76   ext4_find_extent+0x11e/0x2f0
 22)     3156     184   ext4_ext_map_blocks+0x63/0xec0
 23)     2972      96   ext4_map_blocks+0x87/0x540
 24)     2876      60   ext4_getblk+0x52/0x1b0
 25)     2816      24   ext4_bread+0x23/0xa0
 26)     2792      76   __ext4_read_dirblock+0x27/0x3f0
 27)     2716      72   dx_probe+0x36/0x5e0
 28)     2644     160   ext4_find_entry+0x457/0x610
 29)     2484      60   ext4_lookup+0x5c/0x230
 30)     2424      16   lookup_real+0x17/0x50
 31)     2408      28   __lookup_hash+0x40/0x60
 32)     2380      52   walk_component+0x218/0x2f0
 33)     2328      52   link_path_walk+0x149/0x530
 34)     2276     120   path_openat+0x7f/0x1120
 35)     2156     152   do_filp_open+0x68/0xe0
 36)     2004      40   file_open_name+0xf5/0x180
 37)     1964      20   filp_open+0x27/0x50
</code></pre>

<p>which didn't help me much.</p>

<p>How should I proceed? Any help would be appreciated.</p>

<p>Thanks</p>
"
"<p>I am trying to understand the code for a kernel module that makes some function calls from the kernel source. The code is in <a href=""https://elixir.free-electrons.com/linux/latest/source/include/linux/device-mapper.h"" rel=""nofollow noreferrer"">device-mapper.h</a>.</p>

<pre><code>struct dm_target_io {
    struct dm_io *io;
    struct dm_target *ti;
    unsigned target_bio_nr;
    unsigned *len_ptr;
    struct bio clone;
};

static inline void *dm_per_bio_data(struct bio *bio, size_t data_size)
{
    return (char *)bio - offsetof(struct dm_target_io, clone) - data_size;
}
</code></pre>

<p>We are told elsewhere, in a comment in device_mapper.h, that ""dm_per_bio_data returns the data location."" I am not sure why this is the case.</p>

<p>First, dm_per_bio_data takes a struct bio* and subtracts it by offsetof(struct dm_target_io, clone), which should give the start of the enclosing dm_target_io struct. Then, it subtracts data_size, which takes the pointer to--where?</p>

<p>I've been looking to see where dm_target_io is declared inside another struct to see where subtracting by data_size might take me. No such luck so far.</p>
"
"<p>How do I create my own bio request to read a sector from the disk drive ?</p>

<p>I am trying the following but it freezes the system.</p>

<pre><code>static void read_bio()
{
    struct bio *b;
    struct page *p;

    b = bio_alloc(GFP_KERNEL, 1);
    if (!b) {
        printk(KERN_INFO ""bio allocation failed\n"");
    }
    bio_init(b);

    b-&gt;bi_sector = 10000;
    b-&gt;bi_bdev = bd;    /* ""/dev/sda1"" */
    b-&gt;bi_end_io = bio_end_clone;

    p = alloc_page(GFP_KERNEL);
    if (!p) {
        printk(KERN_INFO ""page allocation failed\n"");
    }
    bio_add_page(b, p, PAGE_SIZE, 0);
    b-&gt;bi_private = p;

    bio_get(b);
    submit_bio(READ, b);
    printk(KERN_DEBUG ""submit read request\n"");
}
</code></pre>
"
"<p>I have created block device in kernel module. When some I/O happens I read/write all data from/to another existing device (let's say <code>/dev/sdb</code>).</p>

<p>It opens OK, but read/write operations return 14 error(<code>EFAULT</code>,Bad Address). After some research I found that I need map address to user space(probably <code>buffer</code> or <code>filp</code> variables), but <code>copy_to_user</code> function does not help. Also I looked to <code>mmap()</code> and <code>remap_pfn_range()</code> functions, but I can not get how to use them in my code, especially where to get correct <code>vm_area_struct</code> structure. All examples that I found, used char devices and <code>file_operations</code> structure, not block device.</p>

<p>Any hints? Thanks for help.</p>

<p>Here is my code for reading:</p>

<pre><code>mm_segment_t old_fs;
old_fs = get_fs();
set_fs(KERNEL_DS);
filp = filp_open(""/dev/sdb"",  O_RDONLY | O_DIRECT | O_SYNC, 00644);
if(IS_ERR(filp))
{
    set_fs(old_fs);
    int err = PTR_ERR(filp);
    printk(KERN_ALERT""Can not open file - %d"", err);
    return;
}
else
{
    bytesRead = vfs_read(filp, buffer, nbytes, &amp;offset);  //It gives 14 error
    filp_close(filp, NULL);
}
set_fs(old_fs);
</code></pre>
"
"<p>I am trying to implement device mapper target by referring to the already existing ones dm-linear, dm-snapshot, dm-cache etc. In my implementation, I need to perform a read/modify/write operation on a certain sector range. Since the device mapper directly talks to the block layer, I am not sure what data structures/functions to use to read the sectors in the memory, modify the buffer and write it back to another sector range.
At the application level, we have syscalls and below we have vfs_read/vfs_write. Is there anything similar for device mapper layer?
I have been stuck here for very long. Any help will be appreciated.</p>
"
"<p>I want to read only one sector from hard disk to a specific page in memory, this page is reserved and is not mapped to any address mapping. I found <a href=""https://stackoverflow.com/questions/12720420/how-to-read-a-sector-using-a-bio-request-in-linux-kernel"">this solution</a> but I don't know how to translate a file to a block device and a sector. For example, in function <code>do_generic_file_read</code> in file <code>mm/filemap.c</code> there is this line:</p>

<pre><code>error = mapping-&gt;a_ops-&gt;readpage(filp, page);
</code></pre>

<p>since the target page is not of any mapping I cannot use the same function, but I need to translate the filp to a device and a sector to be able to generate my own bio request. how can I do this?</p>

<p><strong>Edit 1</strong> </p>

<p>I tried this as a possible solution, by adding this, It first calculates the sector, then directly calls <code>ext2_get_block</code> to get the device, It then adds the desired page location and submits the bio request:</p>

<pre><code>struct page *myPage;
int myRet;
struct buffer_head bh;
struct bio *bio = bio_alloc(GFP_NOIO,1);
myPage = pfn_to_page(Some_Location);
bio_init(bio);
bio-&gt;bi_sector = (sector_t)page_offset &lt;&lt; (PAGE_CACHE_SHIFT - mapping-&gt;host-&gt;i_blkbits);
myRet = ext2_get_block(mapping-&gt;host, bio-&gt;bi_sector, &amp;bh, 0);
bio-&gt;bi_bdev = bh.b_bdev;
bio-&gt;bi_next = NULL;
bio-&gt;bi_size = PAGE_SIZE;
bio_add_page(bio, myPage, PAGE_SIZE, 0);
submit_bio(READ, bio);
</code></pre>

<p>This uses the existing address mapping in the function to create the bio request, since the desired page does not have an address mapping. It only has one problem, the <code>submit_bio</code> line causes this:</p>

<pre><code>[    4.792142] ------------[ cut here ]------------
[    4.792892] WARNING: at arch/x86/kernel/pci-nommu.c:63 nommu_map_sg+0xd9/0x100()
[    4.793674] Hardware name: Standard PC (i440FX + PIIX, 1996)
[    4.794149] Modules linked in:
[    4.794607] Pid: 153, comm: kblockd/0 Not tainted 2.6.32.65 #308
[    4.795077] Call Trace:
[    4.795545]  [&lt;ffffffff81056875&gt;] ? warn_slowpath_common+0x65/0xa0
[    4.796024]  [&lt;ffffffff810380a9&gt;] ? nommu_map_sg+0xd9/0x100
[    4.796446]  [&lt;ffffffff8121ef4a&gt;] ? ide_dma_prepare+0xda/0x180
[    4.796900]  [&lt;ffffffff81219923&gt;] ? do_rw_taskfile+0x253/0x330
[    4.797532]  [&lt;ffffffff8122311c&gt;] ? ide_do_rw_disk+0x22c/0x320
[    4.797983]  [&lt;ffffffff81215c3a&gt;] ? do_ide_request+0x11a/0x600
[    4.798416]  [&lt;ffffffff81051450&gt;] ? __dequeue_entity+0x30/0x40
[    4.798854]  [&lt;ffffffff810519a1&gt;] ? finish_task_switch.constprop.110+0x31/0xc0
[    4.799391]  [&lt;ffffffff8141fdd6&gt;] ? thread_return+0x2a/0x1d4
[    4.799816]  [&lt;ffffffff81052116&gt;] ? check_preempt_wakeup+0x76/0xe0
[    4.800279]  [&lt;ffffffff811a3be0&gt;] ? blk_unplug_work+0x0/0x20
[    4.800754]  [&lt;ffffffff811a5b2a&gt;] ? generic_unplug_device+0x1a/0x30
[    4.801218]  [&lt;ffffffff810661dc&gt;] ? worker_thread+0x13c/0x210
[    4.802710]  [&lt;ffffffff81069cb0&gt;] ? autoremove_wake_function+0x0/0x30
[    4.804130]  [&lt;ffffffff810660a0&gt;] ? worker_thread+0x0/0x210
[    4.805357]  [&lt;ffffffff810660a0&gt;] ? worker_thread+0x0/0x210
[    4.806356]  [&lt;ffffffff81069907&gt;] ? kthread+0x77/0x80
[    4.807302]  [&lt;ffffffff81033eaa&gt;] ? child_rip+0xa/0x20
[    4.808500]  [&lt;ffffffff81069890&gt;] ? kthread+0x0/0x80
[    4.809060]  [&lt;ffffffff81033ea0&gt;] ? child_rip+0x0/0x20
[    4.809620] ---[ end trace 61d7e1478dbb58eb ]---
</code></pre>

<p>and later causes this:</p>

<pre><code>[    4.871857] hda: task_pio_intr: status=0x58 { DriveReady SeekComplete DataRequest }
[    4.872553] hda: possibly failed opcode: 0x29
[    4.873346] hda: DMA disabled
[    4.885478] Clocksource tsc unstable (delta = 115822911 ns)
[    4.886364] Switching to clocksource jiffies
[    4.919051] ide0: reset: success
</code></pre>

<p>and this:</p>

<pre><code>[   48.957807] hda: lost interrupt
</code></pre>

<p>I added this to function <code>__do_page_cache_readahead</code> in <code>mm/readahead.c</code> but it can be added similarly to <code>mm/filemap.c</code> or similar functions. maybe someone can fix that problem!</p>
"
"<p>I want to read the first(s) chunks of my disk.
I'm currently developing a driver and i want to stock (and retrieve) some meta data (the number of time each chunks is consulted) in the firsts chunk of my disk</p>

<p>I've see  <a href=""https://stackoverflow.com/questions/12720420/how-to-read-a-sector-using-a-bio-request-in-linux-kernel"">How to read a sector using a bio request in Linux kernel</a>
and then i start writing the code for the read part :</p>

<pre><code>struct bio *bio = bio_alloc(GFP_NOIO, 1);
struct page *page =  alloc_page(GFP_KERNEL)
struct completion event;
bio-&gt;bi_bdev = conf-&gt;disks[0].rdev;
bio-&gt;bi_sector = (sector_t) 0;
bio_add_page(bio, page, (sizeof(struct nuda_table)) * conf-&gt;nbr_chunk, 0);
init_completion(&amp;event);
bio-&gt;bi_private = &amp;event;
bio-&gt;bi_end_io = readComplete;

submit_bio(READ | REQ_SYNC, bio);
wait_for_completion(&amp;event);
bio_put(bio);
</code></pre>

<p>But then i don't know where the data that i have read are stored.
In the <code>struct page</code> ?
Little other question : there is a parameter length in <code>bio_add_page()</code> is this suppose to be bytes ? or chunks ? or other things ?</p>

<p>Thank you in advance</p>
"
"<p>I am trying to do the following thing:</p>

<p>I have a kernel module that hooks into the make_request_fn function of a device-mapper device. In my kernel module I dispatch the bio to either the same device's make_request function, or to another device (that coincidentally happens to be the target device of the mapping, maybe this is important)</p>

<p>For certain bios whose sector range overlap an imaginary line, I need to split the bio request into two parts, first part to device 1, second part to device 2.</p>

<p>I tried to mimic what dm does for splitting bio, at high level overview this is what I did:</p>

<ol>
<li>Call bio_clone() on original bio</li>
<li>Adjust bi_size for first clone to match size of first part</li>
<li>Replace bi_end_io of cloned bio with my own completion function so that I have control when cloned bio completes</li>
<li>submit cloned bio to first device with its make_request_fn(first_dev_queue, cloned_bio)</li>
<li>Wait until completion</li>
<li>Call bio_clone again on original bio, to create second clone</li>
<li>Call bio_advance() to adjust bi_sector, bi_size and bi_idx accordingly to the second part of the request. Also replace bi_end_io with my own completion function.</li>
<li>Manually fix clone's bi_bdev to correct device (device 2)</li>
<li>submit second bio clone to second device with its make_request_fn(second_dev_queue, cloned_bio)</li>
<li>Wait for completion</li>
<li>call bio_endio() on original IO</li>
</ol>

<p>My problem is that the kernel thread hangs in __split_and_process_bio() at step 5) when I am waiting for the completion of the first cloned IO. Interestingly enough this seems to happen only on the second iteration, meaning I seem to have logs indicating that the first IO that I split this way succeeds, but then this happens on the second. This makes me think I don't properly complete something in the first iteration.</p>

<p>Any help in an explanation of the end to end process of splitting and returning back a bio to the caller would be appreciated.</p>
"
"<p>My gstreamer program for dm368 which does streaming + DVI o/p + recording on demand always crashes with the error unable to handle kernel paging request at some virtual address. Can somebosy shed some light on how to debug the issue.</p>

<pre><code>Unable to handle kernel paging request at virtual address 0c0c9ca0
pgd = c0004000
[0c0c9ca0] *pgd=00000000
Internal error: Oops: 5 [#1] PREEMPT
last sysfs file: /sys/devices/virtual/irqk/irqk/dev
Modules linked in: cmemk dm365mmap edmak irqk
CPU: 0    Not tainted  (2.6.32-17-ridgerun #22)
PC is at blk_rq_map_sg+0x70/0x2c0
LR is at mmc_queue_map_sg+0x2c/0xa4
pc : [&lt;c01751ac&gt;]    lr : [&lt;c025a42c&gt;]    psr: 80000013
sp : c23e1db0  ip : c3cf8848  fp : c23e1df4
r10: c3cf6258  r9 : 00001000  r8 : c23d2e40
r7 : 83c1e000  r6 : c3cf8880  r5 : 0c0c9c9c  r4 : c20f1400
r3 : 00000001  r2 : 00000c0d  r1 : 00000c0c  r0 : 00000000
Flags: Nzcv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
Control: 0005317f  Table: 818f4000  DAC: 00000017
Process mmcqd (pid: 978, stack limit = 0xc23e0270)
Stack: (0xc23e1db0 to 0xc23e2000)
1da0:                                     c20f1400 00000c0c 00005000 00000001
1dc0: 00000001 00000000 c23e1e14 c20e3604 c3cf6258 c23e0000 c21ae600 c3cf6258
1de0: c20e3604 00000001 c23e1e14 c23e1df8 c025a42c c017514c c23e1e94 c3cf6258
1e00: c23e0000 c21ae600 c23e1f9c c23e1e18 c0259cc8 c025a410 00000001 00000000
1e20: c23e1e3c 00000000 c23e1e3c c23e1e94 c23e1e68 00000000 00000000 00000019
1e40: 00037f36 00000000 00000000 00000000 00000000 000000b5 00000000 00000000
1e60: 00000000 00000000 0000000c 00000000 00000000 00000000 00000000 00000000
1e80: 0000049d 00000000 00000000 00000000 00000000 11e1a300 00000000 00000200
1ea0: 00000080 00000000 00000100 00000000 00000000 00000000 00000000 c20f1400
1ec0: c20f1300 00000000 c23e1eec c23e1ed8 c016ec50 c01821bc c3cf6258 c20f1318
1ee0: c23e1f0c c23e1ef0 c016d5bc c016d43c c20f1300 c3cf6258 00000000 00000000
1f00: c23e1f34 c23e1f10 c017a154 c016d5a4 00000000 00000000 c20f1300 c3cf6258
1f20: 00000000 00000001 c23e1f5c c23e1f38 c017a6ac c017a058 c23e0000 c23d2e40
1f40: c23e0000 c23d2e40 c3cf6258 c23d2e40 c23e1f84 c23e1f60 c3cf6258 00000000
1f60: c23e1f84 c23e1f70 c016fa6c c0175594 c3cf6258 c23e0000 c3cf6258 c20e3604
1f80: c20e360c c23d2e40 00000000 c23d2fa0 c23e1fc4 c23e1fa0 c025a998 c0259b74
1fa0: c23e1fcc c207fd98 c20e3604 c025a884 00000000 00000000 c23e1ff4 c23e1fc8
1fc0: c0054a80 c025a894 00000000 00000000 c23e1fd0 c23e1fd0 00000000 00000000
1fe0: 00000000 00000000 00000000 c23e1ff8 c0041520 c0054a08 625f746e 646e756f
Backtrace:
[&lt;c017513c&gt;] (blk_rq_map_sg+0x0/0x2c0) from [&lt;c025a42c&gt;] (mmc_queue_map_sg+0x2c/0xa4)
[&lt;c025a400&gt;] (mmc_queue_map_sg+0x0/0xa4) from [&lt;c0259cc8&gt;] (mmc_blk_issue_rq+0x164/0x7cc)
 r7:c21ae600 r6:c23e0000 r5:c3cf6258 r4:c23e1e94
[&lt;c0259b64&gt;] (mmc_blk_issue_rq+0x0/0x7cc) from [&lt;c025a998&gt;] (mmc_queue_thread+0x114/0x118)
[&lt;c025a884&gt;] (mmc_queue_thread+0x0/0x118) from [&lt;c0054a80&gt;] (kthread+0x88/0x90)
[&lt;c00549f8&gt;] (kthread+0x0/0x90) from [&lt;c0041520&gt;] (do_exit+0x0/0x67c)
 r7:00000000 r6:00000000 r5:00000000 r4:00000000
Code: e0252593 e50b1030 ea000043 e51b3034 (e5959004)
---[ end trace c3f2f2bb3920d771 ]---
time: 1770
time123: 1770
Unable to handle kernel paging request at virtual address b6b8b8bc
pgd = c04d4000
[b6b8b8bc] *pgd=00000000
Internal error: Oops: 5 [#2] PREEMPT
last sysfs file: /sys/devices/virtual/irqk/irqk/dev
Modules linked in: cmemk dm365mmap edmak irqk
CPU: 0    Tainted: G      D     (2.6.32-17-ridgerun #22)
PC is at kmem_cache_alloc+0x38/0xa8
LR is at load_elf_binary+0x24/0x11c8
pc : [&lt;c0098528&gt;]    lr : [&lt;c00da614&gt;]    psr: a0000093
sp : c3831e38  ip : c3831e60  fp : c3831e5c
r10: 00000000  r9 : c2d28800  r8 : 00000000
r7 : 00000080  r6 : 000000d0  r5 : 60000013  r4 : b6b8b8bc
r3 : 00000000  r2 : 0000457f  r1 : 000000d0  r0 : c03f840c
Flags: NzCv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment user
Control: 0005317f  Table: 804d4000  DAC: 00000015
Process video_capture_a (pid: 1537, stack limit = 0xc3830270)
Stack: (0xc3831e38 to 0xc3832000)
1e20:                                                       c0087044 c007b2d4
1e40: c3830000 c04060cc c2d28800 00000001 c3831f0c c3831e60 c00da614 c0098500
1e60: 00000001 00000000 c1325780 c20b6000 c3831fb0 00000020 00000000 c20b6000
1e80: c3831ee4 00000001 00000000 00000000 00000000 41675d70 c3831ecc c3831ea8
1ea0: c0088304 c0087ff0 00000017 c3831ee4 00000000 c3831ec0 c3830000 c2d28800
1ec0: c3831f04 c3831ed0 c00a0fc4 c00882bc 00000001 00000001 c3831ee4 c3831e5c
1ee0: 00000000 c3830000 c04060cc c2d28800 00000001 00000000 c00da5f0 00000000
1f00: c3831f4c c3831f10 c00a1510 c00da600 c0503000 c3831fb0 c2d28802 fffffff8
1f20: c3831fb0 00000000 c2d28800 c3830000 00000001 beec1e7c c3831fb0 41675d70
1f40: c3831f84 c3831f50 c00a2944 c00a1400 4065b714 00000000 c00a64d0 c2015000
1f60: 41675d70 beec1e7c c3831fb0 c002b0e4 c3830000 00000e20 c3831fa4 c3831f88
1f80: c002df60 c00a27e4 40673e20 00000000 40673000 0000000b 00000000 c3831fa8
1fa0: c002af60 c002df34 40673e20 00000000 4065b714 41675d70 beec1e7c 00000164
1fc0: 40673e20 00000000 40673000 0000000b 41675c64 41675cf0 00000e20 0000cc60
1fe0: 41675c48 41675c58 40584940 405de30c 00000010 4065b714 00000000 00000000
Backtrace:
[&lt;c00984f0&gt;] (kmem_cache_alloc+0x0/0xa8) from [&lt;c00da614&gt;] (load_elf_binary+0x24/0x11c8)
 r7:00000001 r6:c2d28800 r5:c04060cc r4:c3830000
[&lt;c00da5f0&gt;] (load_elf_binary+0x0/0x11c8) from [&lt;c00a1510&gt;] (search_binary_handler+0x120/0x330)
[&lt;c00a13f0&gt;] (search_binary_handler+0x0/0x330) from [&lt;c00a2944&gt;] (do_execve+0x170/0x270)
[&lt;c00a27d4&gt;] (do_execve+0x0/0x270) from [&lt;c002df60&gt;] (sys_execve+0x3c/0x5c)
[&lt;c002df24&gt;] (sys_execve+0x0/0x5c) from [&lt;c002af60&gt;] (ret_fast_syscall+0x0/0x28)
 r7:0000000b r6:40673000 r5:00000000 r4:40673e20
Code: e5904080 e5907090 e3540000 1590308c (17943103)
---[ end trace c3f2f2bb3920d772 ]---
Unable to handle kernel paging request at virtual address b8cec4cd
pgd = c04d4000
[b8cec4cd] *pgd=00000000
Internal error: Oops: 1 [#3] PREEMPT
last sysfs file: /sys/devices/virtual/irqk/irqk/dev
Modules linked in: cmemk dm365mmap edmak irqk
CPU: 0    Tainted: G      D     (2.6.32-17-ridgerun #22)
PC is at unmap_vmas+0x5d0/0x634
LR is at free_hot_cold_page+0x1ec/0x24c
pc : [&lt;c00893c4&gt;]    lr : [&lt;c0077de0&gt;]    psr: a0000013
sp : c3831bb8  ip : 40e78000  fp : c3831c24
r10: c03faa70  r9 : 00000000  r8 : c3ab39dc
r7 : c3830000  r6 : b8cec4c9  r5 : eaa3a0a6  r4 : c0449fe0
r3 : ffffffff  r2 : c7d1d4f0  r1 : eaa3a0a6  r0 : 00000002
Flags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
Control: 0005317f  Table: 804d4000  DAC: 00000015
Process video_capture_a (pid: 1537, stack limit = 0xc3830270)
Stack: (0xc3831bb8 to 0xc3832000)
1ba0:                                                       ffffffff 00000000
1bc0: c3831c34 00000001 00007fff 00000000 40e78000 c04d5038 804ff3cf 00000000
1be0: 00000000 c1325600 00000000 40e78000 40e78000 c04d5038 00000001 c3830000
1c00: 00000000 c12dddc0 c1325600 00000005 00000001 c1325634 c3831c54 c3831c28
1c20: c008c0c0 c0088e04 c3831c30 00000000 000009bc c03faa70 c1325600 00000000
1c40: c1325600 c1325634 c3831c6c c3831c58 c003bb4c c008c00c c3830000 c20b6000
1c60: c3831c94 c3831c70 c003fc8c c003bb1c c20b6000 c3831df0 0000000b c20b6000
1c80: c3831df0 c0396040 c3831cac c3831c98 c00416bc c003fb4c c003de48 c003dcac
1ca0: c3831cc4 c3831cb0 c002ec0c c0041530 c3830270 00000005 c3831ce4 c3831cc8
1cc0: c00306b0 c002ea80 00010000 c20b6000 b6b8b8bc c1325600 c3831d1c c3831ce8
1ce0: c0030890 c0030654 00000000 c2d99f40 c049cfa0 c03fa5fc c3831e24 c3831df0
1d00: 00000005 b6b8b8bc 20000093 00000000 c3831d3c c3831d20 c0030954 c00306d0
1d20: c03fa5fc c3831e24 00000005 c3831df0 c3831dec c3831d40 c002a334 c0030940
1d40: 00000000 c04d4000 c20b6000 00000000 c12dddc0 0000c000 c3cf7830 00000000
1d60: c3831dd4 c3831d70 c0087680 c0086884 00000004 00000000 00000000 c04df8f0
1d80: 0000000c c04d4000 00000000 c1325600 00000030 c00309e4 c3831db4 c3831da8
1da0: c007b8a8 c007b640 c3831dc4 c12dddc0 00000200 c20b6000 c3831dd4 c3831dc8
1dc0: c00594c0 c0182ad0 c3831e0c ffffffff c3831e24 000000d0 00000080 00000000
1de0: c3831e5c c3831df0 c002ab0c c002a308 c03f840c 000000d0 0000457f 00000000
1e00: b6b8b8bc 60000013 000000d0 00000080 00000000 c2d28800 00000000 c3831e5c
1e20: c3831e60 c3831e38 c00da614 c0098528 a0000093 ffffffff c0087044 c007b2d4
1e40: c3830000 c04060cc c2d28800 00000001 c3831f0c c3831e60 c00da614 c0098500
1e60: 00000001 00000000 c1325780 c20b6000 c3831fb0 00000020 00000000 c20b6000
1e80: c3831ee4 00000001 00000000 00000000 00000000 41675d70 c3831ecc c3831ea8
1ea0: c0088304 c0087ff0 00000017 c3831ee4 00000000 c3831ec0 c3830000 c2d28800
1ec0: c3831f04 c3831ed0 c00a0fc4 c00882bc 00000001 00000001 c3831ee4 c3831e5c
1ee0: 00000000 c3830000 c04060cc c2d28800 00000001 00000000 c00da5f0 00000000
1f00: c3831f4c c3831f10 c00a1510 c00da600 c0503000 c3831fb0 c2d28802 fffffff8
1f20: c3831fb0 00000000 c2d28800 c3830000 00000001 beec1e7c c3831fb0 41675d70
1f40: c3831f84 c3831f50 c00a2944 c00a1400 4065b714 00000000 c00a64d0 c2015000
1f60: 41675d70 beec1e7c c3831fb0 c002b0e4 c3830000 00000e20 c3831fa4 c3831f88
1f80: c002df60 c00a27e4 40673e20 00000000 40673000 0000000b 00000000 c3831fa8
1fa0: c002af60 c002df34 40673e20 00000000 4065b714 41675d70 beec1e7c 00000164
1fc0: 40673e20 00000000 40673000 0000000b 41675c64 41675cf0 00000e20 0000cc60
1fe0: 41675c48 41675c58 40584940 405de30c 00000010 4065b714 00000000 00000000
Backtrace:
[&lt;c0088df4&gt;] (unmap_vmas+0x0/0x634) from [&lt;c008c0c0&gt;] (exit_mmap+0xc4/0x1f0)
[&lt;c008bffc&gt;] (exit_mmap+0x0/0x1f0) from [&lt;c003bb4c&gt;] (mmput+0x40/0xfc)
 r7:c1325634 r6:c1325600 r5:00000000 r4:c1325600
[&lt;c003bb0c&gt;] (mmput+0x0/0xfc) from [&lt;c003fc8c&gt;] (exit_mm+0x150/0x158)
 r5:c20b6000 r4:c3830000
[&lt;c003fb3c&gt;] (exit_mm+0x0/0x158) from [&lt;c00416bc&gt;] (do_exit+0x19c/0x67c)
 r7:c0396040 r6:c3831df0 r5:c20b6000 r4:0000000b
[&lt;c0041520&gt;] (do_exit+0x0/0x67c) from [&lt;c002ec0c&gt;] (die+0x19c/0x1c0)
[&lt;c002ea70&gt;] (die+0x0/0x1c0) from [&lt;c00306b0&gt;] (__do_kernel_fault+0x6c/0x7c)
[&lt;c0030644&gt;] (__do_kernel_fault+0x0/0x7c) from [&lt;c0030890&gt;] (do_page_fault+0x1d0/0x1e8)
 r7:c1325600 r6:b6b8b8bc r5:c20b6000 r4:00010000
[&lt;c00306c0&gt;] (do_page_fault+0x0/0x1e8) from [&lt;c0030954&gt;] (do_translation_fault+0x24/0xa4)
[&lt;c0030930&gt;] (do_translation_fault+0x0/0xa4) from [&lt;c002a334&gt;] (do_DataAbort+0x3c/0x9c)
 r7:c3831df0 r6:00000005 r5:c3831e24 r4:c03fa5fc
[&lt;c002a2f8&gt;] (do_DataAbort+0x0/0x9c) from [&lt;c002ab0c&gt;] (__dabt_svc+0x4c/0x60)
Exception stack(0xc3831df0 to 0xc3831e38)
1de0:                                     c03f840c 000000d0 0000457f 00000000
1e00: b6b8b8bc 60000013 000000d0 00000080 00000000 c2d28800 00000000 c3831e5c
1e20: c3831e60 c3831e38 c00da614 c0098528 a0000093 ffffffff
 r8:00000000 r7:00000080 r6:000000d0 r5:c3831e24 r4:ffffffff
[&lt;c00984f0&gt;] (kmem_cache_alloc+0x0/0xa8) from [&lt;c00da614&gt;] (load_elf_binary+0x24/0x11c8)
 r7:00000001 r6:c2d28800 r5:c04060cc r4:c3830000
[&lt;c00da5f0&gt;] (load_elf_binary+0x0/0x11c8) from [&lt;c00a1510&gt;] (search_binary_handler+0x120/0x330)
[&lt;c00a13f0&gt;] (search_binary_handler+0x0/0x330) from [&lt;c00a2944&gt;] (do_execve+0x170/0x270)
[&lt;c00a27d4&gt;] (do_execve+0x0/0x270) from [&lt;c002df60&gt;] (sys_execve+0x3c/0x5c)
[&lt;c002df24&gt;] (sys_execve+0x0/0x5c) from [&lt;c002af60&gt;] (ret_fast_syscall+0x0/0x28)
 r7:0000000b r6:40673000 r5:00000000 r4:40673e20
Code: 1afffebd e596600c e3560000 0a000003 (e5961004)
---[ end trace c3f2f2bb3920d773 ]---
Fixing recursive fault but reboot is needed!
BUG: scheduling while atomic: video_capture_a/1537/0x00000002
Modules linked in: cmemk dm365mmap edmak irqk
Backtrace:
[&lt;c002e6a0&gt;] (dump_backtrace+0x0/0x114) from [&lt;c0304928&gt;] (dump_stack+0x18/0x1c)
 r7:c3830000 r6:c20b6000 r5:c20b6000 r4:00000000
[&lt;c0304910&gt;] (dump_stack+0x0/0x1c) from [&lt;c0037acc&gt;] (__schedule_bug+0x54/0x60)
[&lt;c0037a78&gt;] (__schedule_bug+0x0/0x60) from [&lt;c0304c34&gt;] (schedule+0x84/0x390)
 r5:c20b6000 r4:0000000b
[&lt;c0304bb0&gt;] (schedule+0x0/0x390) from [&lt;c00415ec&gt;] (do_exit+0xcc/0x67c)
[&lt;c0041520&gt;] (do_exit+0x0/0x67c) from [&lt;c002ec0c&gt;] (die+0x19c/0x1c0)
[&lt;c002ea70&gt;] (die+0x0/0x1c0) from [&lt;c00306b0&gt;] (__do_kernel_fault+0x6c/0x7c)
[&lt;c0030644&gt;] (__do_kernel_fault+0x0/0x7c) from [&lt;c003090c&gt;] (do_bad_area+0x64/0x70)
 r7:00000000 r6:00000000 r5:00000004 r4:e5961004
[&lt;c00308a8&gt;] (do_bad_area+0x0/0x70) from [&lt;c00325e0&gt;] (do_alignment+0x5ac/0x700)
[&lt;c0032034&gt;] (do_alignment+0x0/0x700) from [&lt;c002a334&gt;] (do_DataAbort+0x3c/0x9c)
[&lt;c002a2f8&gt;] (do_DataAbort+0x0/0x9c) from [&lt;c002ab0c&gt;] (__dabt_svc+0x4c/0x60)
Exception stack(0xc3831b70 to 0xc3831bb8)
1b60:                                     00000002 eaa3a0a6 c7d1d4f0 ffffffff
1b80: c0449fe0 eaa3a0a6 b8cec4c9 c3830000 c3ab39dc 00000000 c03faa70 c3831c24
1ba0: 40e78000 c3831bb8 c0077de0 c00893c4 a0000013 ffffffff
 r8:c3ab39dc r7:c3830000 r6:b8cec4c9 r5:c3831ba4 r4:ffffffff
[&lt;c0088df4&gt;] (unmap_vmas+0x0/0x634) from [&lt;c008c0c0&gt;] (exit_mmap+0xc4/0x1f0)
[&lt;c008bffc&gt;] (exit_mmap+0x0/0x1f0) from [&lt;c003bb4c&gt;] (mmput+0x40/0xfc)
 r7:c1325634 r6:c1325600 r5:00000000 r4:c1325600
[&lt;c003bb0c&gt;] (mmput+0x0/0xfc) from [&lt;c003fc8c&gt;] (exit_mm+0x150/0x158)
 r5:c20b6000 r4:c3830000
[&lt;c003fb3c&gt;] (exit_mm+0x0/0x158) from [&lt;c00416bc&gt;] (do_exit+0x19c/0x67c)
 r7:c0396040 r6:c3831df0 r5:c20b6000 r4:0000000b
[&lt;c0041520&gt;] (do_exit+0x0/0x67c) from [&lt;c002ec0c&gt;] (die+0x19c/0x1c0)
[&lt;c002ea70&gt;] (die+0x0/0x1c0) from [&lt;c00306b0&gt;] (__do_kernel_fault+0x6c/0x7c)
[&lt;c0030644&gt;] (__do_kernel_fault+0x0/0x7c) from [&lt;c0030890&gt;] (do_page_fault+0x1d0/0x1e8)
 r7:c1325600 r6:b6b8b8bc r5:c20b6000 r4:00010000
[&lt;c00306c0&gt;] (do_page_fault+0x0/0x1e8) from [&lt;c0030954&gt;] (do_translation_fault+0x24/0xa4)
[&lt;c0030930&gt;] (do_translation_fault+0x0/0xa4) from [&lt;c002a334&gt;] (do_DataAbort+0x3c/0x9c)
 r7:c3831df0 r6:00000005 r5:c3831e24 r4:c03fa5fc
[&lt;c002a2f8&gt;] (do_DataAbort+0x0/0x9c) from [&lt;c002ab0c&gt;] (__dabt_svc+0x4c/0x60)
Exception stack(0xc3831df0 to 0xc3831e38)
1de0:                                     c03f840c 000000d0 0000457f 00000000
1e00: b6b8b8bc 60000013 000000d0 00000080 00000000 c2d28800 00000000 c3831e5c
1e20: c3831e60 c3831e38 c00da614 c0098528 a0000093 ffffffff
 r8:00000000 r7:00000080 r6:000000d0 r5:c3831e24 r4:ffffffff
[&lt;c00984f0&gt;] (kmem_cache_alloc+0x0/0xa8) from [&lt;c00da614&gt;] (load_elf_binary+0x24/0x11c8)
 r7:00000001 r6:c2d28800 r5:c04060cc r4:c3830000
[&lt;c00da5f0&gt;] (load_elf_binary+0x0/0x11c8) from [&lt;c00a1510&gt;] (search_binary_handler+0x120/0x330)
[&lt;c00a13f0&gt;] (search_binary_handler+0x0/0x330) from [&lt;c00a2944&gt;] (do_execve+0x170/0x270)
[&lt;c00a27d4&gt;] (do_execve+0x0/0x270) from [&lt;c002df60&gt;] (sys_execve+0x3c/0x5c)
[&lt;c002df24&gt;] (sys_execve+0x0/0x5c) from [&lt;c002af60&gt;] (ret_fast_syscall+0x0/0x28)
 r7:0000000b r6:40673000 r5:00000000 r4:40673e20
^C^C^CUnable to handle kernel paging request at virtual address b6b8b8bc
pgd = c0004000
[b6b8b8bc] *pgd=00000000
Internal error: Oops: 5 [#4] PREEMPT
last sysfs file: /sys/devices/virtual/irqk/irqk/dev
Modules linked in: cmemk dm365mmap edmak irqk
CPU: 0    Tainted: G      D     (2.6.32-17-ridgerun #22)
PC is at kmem_cache_alloc+0x38/0xa8
LR is at mempool_alloc_slab+0x1c/0x20
pc : [&lt;c0098528&gt;]    lr : [&lt;c0074944&gt;]    psr: a0000093
sp : c2675d80  ip : c2675da8  fp : c2675da4
r10: c2675e9c  r9 : c2073578  r8 : 00011210
r7 : 00000080  r6 : 00011200  r5 : 00000013  r4 : b6b8b8bc
r3 : 00000000  r2 : c2675db8  r1 : 00011200  r0 : c03f840c
Flags: NzCv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
Control: 0005317f  Table: 818f4000  DAC: 00000017
Process kjournald (pid: 984, stack limit = 0xc2674270)
Stack: (0xc2675d80 to 0xc2676000)
5d80: c2675dac c2675d90 00000001 c2674000 00000010 c2073560 c2675db4 c2675da8
5da0: c0074944 c0098500 c2675dfc c2675db8 c0074ab4 c0074938 c201c1a0 c201c1a0
5dc0: 00000000 00010259 c0405db8 c21fed80 c2675e24 00000001 00000000 00000010
5de0: 00000000 c2073520 00000001 c2675e9c c2675e2c c2675e00 c00c5c5c c0074a88
5e00: c20fb000 0000000f c20fb000 c21fed80 00000000 00000001 00000000 00000001
5e20: c2675e3c c2675e30 c00c5d64 c00c5c3c c2675e64 c2675e40 c00c0434 c00c5d5c
5e40: c21fed80 00000000 00000003 00000000 00000001 00000001 c2675e94 c2675e68
5e60: c00c2688 c00c0378 0003002b 00000001 c210b7f8 00000014 c20fb000 00000100
5e80: c25d2000 c28252c0 c2675eb4 c2675e98 c0103d08 c00c2564 c00feb64 c21fed80
5ea0: c25d2020 c28252c0 c2675ef4 c2675eb8 c0103e80 c0103c5c c20fb058 00000001
5ec0: c2bf8f00 c210b7f8 c2675ef4 c2674000 c2674000 00000000 c20fb058 c2bf8f00
5ee0: 00000000 c20fb000 c2675f7c c2675ef8 c0101818 c0103d24 c20b6000 000006ed
5f00: 0003a773 c20fb094 c005a274 c21c8000 00000000 c20b6030 00000001 c21c8000
5f20: 0003a773 000006ed c005a2c0 c005a250 00000000 c0021780 c2675f7c c2675f48
5f40: c0304eb8 c0037ae8 c20b7658 c20b777c c2675f7c c2675f90 c2674000 c20fb000
5f60: c20b75e0 c20fb040 c20fb050 c20fb0c4 c2675fc4 c2675f80 c0105bdc c0100ef8
5f80: c2675fc4 00000000 c20b75e0 c0054ce8 c2675f90 c2675f90 c2675fc4 c2675fcc
5fa0: c2029ca8 c20fb000 c0105b08 00000000 00000000 00000000 c2675ff4 c2675fc8
5fc0: c0054a80 c0105b18 00000000 00000000 c2675fd0 c2675fd0 00000000 00000000
5fe0: 00000000 00000000 00000000 c2675ff8 c0041520 c0054a08 00000000 00000000
Backtrace:
[&lt;c00984f0&gt;] (kmem_cache_alloc+0x0/0xa8) from [&lt;c0074944&gt;] (mempool_alloc_slab+0x1c/0x20)
 r7:c2073560 r6:00000010 r5:c2674000 r4:00000001
[&lt;c0074928&gt;] (mempool_alloc_slab+0x0/0x20) from [&lt;c0074ab4&gt;] (mempool_alloc+0x3c/0x158)
[&lt;c0074a78&gt;] (mempool_alloc+0x0/0x158) from [&lt;c00c5c5c&gt;] (bio_alloc_bioset+0x30/0xd4)
[&lt;c00c5c2c&gt;] (bio_alloc_bioset+0x0/0xd4) from [&lt;c00c5d64&gt;] (bio_alloc+0x18/0x30)
 r8:00000001 r7:00000000 r6:00000001 r5:00000000 r4:c21fed80
[&lt;c00c5d4c&gt;] (bio_alloc+0x0/0x30) from [&lt;c00c0434&gt;] (submit_bh+0xcc/0x194)
[&lt;c00c0368&gt;] (submit_bh+0x0/0x194) from [&lt;c00c2688&gt;] (ll_rw_block+0x134/0x1a0)
 r9:00000001 r8:00000001 r7:00000000 r6:00000003 r5:00000000
r4:c21fed80
[&lt;c00c2554&gt;] (ll_rw_block+0x0/0x1a0) from [&lt;c0103d08&gt;] (flush_descriptor+0xbc/0xc8)
[&lt;c0103c4c&gt;] (flush_descriptor+0x0/0xc8) from [&lt;c0103e80&gt;] (journal_write_revoke_records+0x16c/0x184)
 r4:c28252c0
[&lt;c0103d14&gt;] (journal_write_revoke_records+0x0/0x184) from [&lt;c0101818&gt;] (journal_commit_transaction+0x930/0x14e4)
[&lt;c0100ee8&gt;] (journal_commit_transaction+0x0/0x14e4) from [&lt;c0105bdc&gt;] (kjournald+0xd4/0x28c)
[&lt;c0105b08&gt;] (kjournald+0x0/0x28c) from [&lt;c0054a80&gt;] (kthread+0x88/0x90)
[&lt;c00549f8&gt;] (kthread+0x0/0x90) from [&lt;c0041520&gt;] (do_exit+0x0/0x67c)
 r7:00000000 r6:00000000 r5:00000000 r4:00000000
Code: e5904080 e5907090 e3540000 1590308c (17943103)
---[ end trace c3f2f2bb3920d774 ]---
Recvd 2
in 2
^C^C^C^C^C^CUnable to handle kernel paging request at virtual address b6b8b8bc
pgd = c0004000
[b6b8b8bc] *pgd=00000000
Internal error: Oops: 5 [#5] PREEMPT
last sysfs file: /sys/devices/virtual/irqk/irqk/dev
Modules linked in: cmemk dm365mmap edmak irqk
CPU: 0    Tainted: G      D     (2.6.32-17-ridgerun #22)
PC is at kmem_cache_alloc+0x38/0xa8
LR is at mempool_alloc_slab+0x1c/0x20
pc : [&lt;c0098528&gt;]    lr : [&lt;c0074944&gt;]    psr: a0000093
sp : c2e5dbe8  ip : c2e5dc10  fp : c2e5dc0c
r10: c201c208  r9 : c2073578  r8 : 00011210
r7 : 00000080  r6 : 00011200  r5 : 00000013  r4 : b6b8b8bc
r3 : 00000000  r2 : c2e5dc20  r1 : 00011200  r0 : c03f840c
Flags: NzCv  IRQs off  FIQs on  Mode SVC_32  ISA ARM  Segment kernel
Control: 0005317f  Table: 818f4000  DAC: 00000017
Process flush-179:0 (pid: 1120, stack limit = 0xc2e5c270)
Stack: (0xc2e5dbe8 to 0xc2e5e000)
dbe0:                   c2e5dc4c c2e5dbf8 00000001 c2e5c000 00000010 c2073560
dc00: c2e5dc1c c2e5dc10 c0074944 c0098500 c2e5dc64 c2e5dc20 c0074ab4 c0074938
dc20: 00000000 c13a6708 00000000 00000001 c2114940 00000000 c21146f0 00000001
dc40: c0469c20 00000010 00000000 c2073520 c00c2090 c201c208 c2e5dc94 c2e5dc68
dc60: c00c5c5c c0074a88 c0180c20 0000000f c2e5c000 c3367b88 c0469c20 00000001
dc80: 00000000 c3367b88 c2e5dca4 c2e5dc98 c00c5d64 c00c5c3c c2e5dccc c2e5dca8
dca0: c00c0434 c00c5d5c 00000001 c0469c20 c3367b88 00000000 c3367b88 c00c2090
dcc0: c2e5dd1c c2e5dcd0 c00c3e9c c00c0378 c2114940 0003ffff 00000000 0003ccaf
dce0: c2e5ded8 c00c6c30 00001000 00000001 c0181834 3ccaf800 c0469c20 c201c208
dd00: 00000000 c00c6c30 c00c2090 c2e5ded8 c2e5dd54 c2e5dd20 c00c4150 c00c3b6c
dd20: c00c2090 c2e5dd30 c0071df4 c201c2a4 c2e5ded8 00000000 00000000 000003ff
dd40: 00000001 ffffffff c2e5dd64 c2e5dd58 c00c4170 c00c4040 c2e5dd74 c2e5dd68
dd60: c00c7d10 c00c416c c2e5dd8c c2e5dd78 c0078cb8 c00c7d08 c0469c20 c2e5ded8
dd80: c2e5de34 c2e5dd90 c007971c c0078cac 0000000e 00000000 00000000 c201c2a4
dda0: c0078c9c c201c2a4 c23d2ee0 00000002 0000008d 00003e49 00000000 c2e5ddc8
ddc0: 00000000 00000002 00000000 c047b680 c0469c20 c048cb00 c047b620 c048cb20
dde0: c04a7f60 c048cca0 c04a7e80 c0465140 00000000 00000000 00000000 00000000
de00: 00000000 00003e49 00000000 c201c208 00000004 c201c208 00000000 c2e5ded8
de20: c23d2f68 c201c2a4 c2e5de44 c2e5de38 c007987c c00794e0 c2e5de54 c2e5de48
de40: c00798b8 c007985c c2e5de7c c2e5de58 c00ba440 c0079894 00000000 c2e5c000
de60: c201c208 c23d2f40 c2001640 c2e5ded8 c2e5ded4 c2e5de80 c00bb218 c00ba36c
de80: c2e5c000 c2e5df14 00000000 00000000 0002486e c23d2f60 c1cf8350 c201c210
dea0: c201c210 c2001600 00000015 c2e5c000 00000000 c23d2f68 00000000 00000000
dec0: c23d2f40 c2e5df48 c2e5df44 c2e5ded8 c00bb44c c00bae40 c23d2ee0 00000000
dee0: 00000000 c2e5df14 00000400 00000000 00000000 00000000 00000000 00000000
df00: 00000014 00000000 c20b0fa0 c042a240 0002486e 00023cb6 c23d2f40 c2e5df48
df20: 00000000 c23d2f40 000015da 00000000 00000000 c23d2f80 c2e5df84 c2e5df48
df40: c00bb7b0 c00bb300 000015da 00000000 00000000 00000003 c03fe048 000001f4
df60: c2e5c000 00023882 c23d2f40 00000000 00000000 00000000 c2e5dfa4 c2e5df88
df80: c00bb804 c00bb604 c2e5c000 c23d2ee0 c23d2f40 c008577c c2e5dfc4 c2e5dfa8
dfa0: c0085810 c00bb7e4 c2e5dfcc c20a5f18 c23d2f40 c008577c c2e5dff4 c2e5dfc8
dfc0: c0054a80 c008578c 00000000 00000000 c2e5dfd0 c2e5dfd0 00000000 00000000
dfe0: 00000000 00000000 00000000 c2e5dff8 c0041520 c0054a08 00000000 00000000
Backtrace:
[&lt;c00984f0&gt;] (kmem_cache_alloc+0x0/0xa8) from [&lt;c0074944&gt;] (mempool_alloc_slab+0x1c/0x20)
 r7:c2073560 r6:00000010 r5:c2e5c000 r4:00000001
[&lt;c0074928&gt;] (mempool_alloc_slab+0x0/0x20) from [&lt;c0074ab4&gt;] (mempool_alloc+0x3c/0x158)
[&lt;c0074a78&gt;] (mempool_alloc+0x0/0x158) from [&lt;c00c5c5c&gt;] (bio_alloc_bioset+0x30/0xd4)
[&lt;c00c5c2c&gt;] (bio_alloc_bioset+0x0/0xd4) from [&lt;c00c5d64&gt;] (bio_alloc+0x18/0x30)
 r8:c3367b88 r7:00000000 r6:00000001 r5:c0469c20 r4:c3367b88
[&lt;c00c5d4c&gt;] (bio_alloc+0x0/0x30) from [&lt;c00c0434&gt;] (submit_bh+0xcc/0x194)
[&lt;c00c0368&gt;] (submit_bh+0x0/0x194) from [&lt;c00c3e9c&gt;] (__block_write_full_page+0x340/0x4d4)
 r9:c00c2090 r8:c3367b88 r7:00000000 r6:c3367b88 r5:c0469c20
r4:00000001
[&lt;c00c3b5c&gt;] (__block_write_full_page+0x0/0x4d4) from [&lt;c00c4150&gt;] (block_write_full_page_endio+0x120/0x12c)
[&lt;c00c4030&gt;] (block_write_full_page_endio+0x0/0x12c) from [&lt;c00c4170&gt;] (block_write_full_page+0x14/0x1c)
[&lt;c00c415c&gt;] (block_write_full_page+0x0/0x1c) from [&lt;c00c7d10&gt;] (blkdev_writepage+0x18/0x20)
[&lt;c00c7cf8&gt;] (blkdev_writepage+0x0/0x20) from [&lt;c0078cb8&gt;] (__writepage+0x1c/0x6c)
[&lt;c0078c9c&gt;] (__writepage+0x0/0x6c) from [&lt;c007971c&gt;] (write_cache_pages+0x24c/0x37c)
 r5:c2e5ded8 r4:c0469c20
[&lt;c00794d0&gt;] (write_cache_pages+0x0/0x37c) from [&lt;c007987c&gt;] (generic_writepages+0x30/0x38)
[&lt;c007984c&gt;] (generic_writepages+0x0/0x38) from [&lt;c00798b8&gt;] (do_writepages+0x34/0x40)
[&lt;c0079884&gt;] (do_writepages+0x0/0x40) from [&lt;c00ba440&gt;] (writeback_single_inode+0xe4/0x24c)
[&lt;c00ba35c&gt;] (writeback_single_inode+0x0/0x24c) from [&lt;c00bb218&gt;] (writeback_inodes_wb+0x3e8/0x4c0)
[&lt;c00bae30&gt;] (writeback_inodes_wb+0x0/0x4c0) from [&lt;c00bb44c&gt;] (wb_writeback+0x15c/0x1f0)
[&lt;c00bb2f0&gt;] (wb_writeback+0x0/0x1f0) from [&lt;c00bb7b0&gt;] (wb_do_writeback+0x1bc/0x1e0)
[&lt;c00bb5f4&gt;] (wb_do_writeback+0x0/0x1e0) from [&lt;c00bb804&gt;] (bdi_writeback_task+0x30/0xd4)
[&lt;c00bb7d4&gt;] (bdi_writeback_task+0x0/0xd4) from [&lt;c0085810&gt;] (bdi_start_fn+0x94/0x10c)
 r7:c008577c r6:c23d2f40 r5:c23d2ee0 r4:c2e5c000
[&lt;c008577c&gt;] (bdi_start_fn+0x0/0x10c) from [&lt;c0054a80&gt;] (kthread+0x88/0x90)
 r7:c008577c r6:c23d2f40 r5:c20a5f18 r4:c2e5dfcc
[&lt;c00549f8&gt;] (kthread+0x0/0x90) from [&lt;c0041520&gt;] (do_exit+0x0/0x67c)
 r7:00000000 r6:00000000 r5:00000000 r4:00000000
Code: e5904080 e5907090 e3540000 1590308c (17943103)
---[ end trace c3f2f2bb3920d775 ]---
</code></pre>
"
"<p>I am trying to squeeze the most performance out of a Linux block driver for a high-end storage device.  One problem that has me a bit stumped at the moment is this: if a user task starts an I/O operation (read or write) on one CPU, and the device interrupt occurs on another CPU, I incur about 80 microseconds of delay before the task resumes execution.</p>

<p>I can see this using O_DIRECT against the raw block device, so this is not page cache or filesystem- related.  The driver uses <code>make_request</code> to receive operations, so it has no request queue and does not utilize any kernel I/O scheduler (you'll have to trust me, it's way faster this way).</p>

<p>I can demonstrate to myself that the problem occurs between calling <code>bio_endio</code> on one CPU and the task being rescheduled on another CPU.  If the task is on the same CPU, it starts very quickly, and if the task is on another physical CPU, it takes a lot longer -- usually about 80 microseconds longer on my current test system (x86_64 on Intel 5520 [NUMA] chipset).</p>

<p>I can instantly double my performance by setting the process and IRQ cpu affinity to the same physical CPU, but that's not a good long-term solution-- I'd rather be able to get good performance no matter where the I/Os originate.  And I only have one IRQ so I can only steer it to one CPU at a time -- no good if many threads are running on many CPUs.</p>

<p>I can see this problem on kernels from Centos 5.4's 2.6.18 to the mainline 2.6.32.</p>

<p>So the question is: why does it take longer for the user process to resume, if I called <code>bio_endio</code> from another CPU?  Is this a scheduler issue?  And is there any way to eliminate or lower the delay?</p>
"
"<p>I am interested in developing kernel module that binds two block devices into a new block device in such manner that first block device contains data at mount time, and the other is considered empty. Every write is being made to second partition, so on next mount the base filesystem remains unchanged. I know of solutions like UnionFS, but those are filesystem-based, while i want to develop it a layer lower, block-based.</p>

<p>Can anyone tell me how could i open ad read/write block device from kernel module? Possibly without using userspace program for reading/writing merged block devices. I found similar topic <a href=""https://stackoverflow.com/questions/1695678/reading-from-a-block-device-in-kernel-space"">here</a>, but the answer was rather unsatysfying because filp_* functions are rather for reading small config files, not for (large) block device I/O.</p>

<p>Since interface for creating block devices is standarized i was thinking of direct (or almost direct) acces to functions implementing source devices, as i will be requested to export similar functions anyway. If i could do that i would simply create some proxy-functions calling appropriate functions on source devices. Can i somehow obtain pointer to a gendisk structure that belongs to different driver?</p>

<p>This serves only my own purposes (satisfying quriosity being main of them) so i am not worried about messing my kernel up seriously.</p>

<p>Or does somebody know if module like that already exists?</p>
"
"<p>I'm working on Linux kernel version 2.6.39.1, and am developing a block device driver. In this regard, I want to combine multiple <code>struct bio</code>s into a single <code>struct request</code>, which is then added to the <code>request_queue</code> for processing by the device driver, namely -- <code>scsi_request_fn()</code>.</p>

<p>I tried using the <code>-&gt;bi_next</code> field of <code>struct bio</code> to link multiple <code>struct bio</code>s that I have composed, thereby creating a linked list of <code>struct bio</code>s. When I call <code>submit_bio()</code> to submit a bio to the block device layer for I/O, <a href=""http://lxr.linux.no/linux+v2.6.39/block/blk-core.c#L1611"" rel=""nofollow"">this</a> <code>BUG_ON()</code> is triggered because the code expects <code>bio-&gt;bi_next</code> to be <code>NULL</code>.</p>

<p>Is there a way to link several <code>struct bio</code>s into a single <code>struct request</code> before sending it to lower layers for servicing?</p>
"
"<p>i have two threads that asynchronously act on a ""PG_uptodate"" bit on a page. First thread calls wait_event_interruptible() on on PG_uptodate and waits for the page to get updated from disk io. The second thread sets the page's PG_uptodate bit and calls wake_up_interruptible() so that the threads sleeping for the page to be updated gets woken up. and i am experiencing a kernel crash with below dump: </p>

<pre><code>  41.192000] Unable to handle kernel NULL pointer dereference at virtual address 00000000

 [   41.192000] [&lt;c008efdc&gt;] (wake_bit_function+0x0/0xcc) from [&lt;c0063c38&gt;]
                wake_up_common+0xb0/0xf8)
 [   41.192000]  r7:c0da350c r6:c05919b8 r5:c0da3518 r4:e7f5fb04
 [   41.192000] [&lt;c0063b88&gt;] (__wake_up_common+0x0/0xf8) from [&lt;c0063e74&gt;]
                (__wake_up+0x48/0x5c)

 [   41.192000] [&lt;c0063e2c&gt;] (__wake_up+0x0/0x5c) from [&lt;c018a1ac&gt;]
                (bio_end_io_read+0x88/0xdc)
 [   41.192000]  r8:00000000 r7:54602a40 r6:00000001 r5:e85bc0b4 r4:e867e700
 [   41.192000] [&lt;c018a124&gt;] (bio_end_io_read+0x0/0xdc) from [&lt;c0164324&gt;]
                (bio_endio+0x70/0x74)
 [   41.192000]  r7:00000088 r6:e8ff5b60 r5:00000000 r4:e867e700
 [   41.192000] [&lt;c01642b4&gt;] (bio_endio+0x0/0x74) from [&lt;c0245080&gt;]
                (req_bio_endio+0xc8/0xec)
 [   41.192000]  r5:00000000 r4:e867e700
 [   41.192000] [&lt;c0244fb8&gt;] (req_bio_endio+0x0/0xec) from [&lt;c02452e0&gt;]
                (blk_update_request+0x23c/0x524)

         ..........
         ..........
</code></pre>

<p>can any body please point me how can i   resolve this.</p>

<p>Thanks,
Kapil</p>
"
"<p>I have a block device driver which is working, after a fashion. It is for a PCIe device, and I am handling the bios directly with a make_request_fn rather than use a request queue, as the device has no seek time. However, it still has transaction overhead.</p>

<p>When I read consecutively from the device, I get bios with many segments (generally my maximum of 32), each consisting of 2 hardware sectors (so 2 * 2k) and this is then handled as one scatter-gather transaction to the device, saving a lot of signaling overhead. However on a write, the bios each have just one segment of 2 sectors and therefore the operations take a lot longer in total. What I would like to happen is to somehow cause the incoming bios to consist of many segments, or to merge bios sensibly together myself. What is the right approach here?</p>

<p>The current content of the <code>make_request_fn</code> is something along the lines of:</p>

<ul>
<li>Determine read/write of the bio</li>
<li>For each segment in the bio, make an entry in a <code>scatterlist*</code> with <code>sg_set_page</code></li>
<li>Map this scatterlist to PCI with <code>pci_map_sg</code></li>
<li>For every segment in the scatterlist, add to a device-specific structure defining a multiple-segment DMA scatter-gather operation</li>
<li>Map that structure to DMA</li>
<li>Carry out transaction</li>
<li>Unmap structure and SG DMA</li>
<li>Call <code>bio_endio</code> with <code>-EIO</code> if failed and <code>0</code> if succeeded.</li>
</ul>

<p>The request queue is set up like:</p>

<pre><code>#define MYDEV_BLOCK_MAX_SEGS 32
#define MYDEV_SECTOR_SIZE 2048

blk_queue_make_request(mydev-&gt;queue, mydev_make_req);

set_bit(QUEUE_FLAG_NONROT, &amp;mydev-&gt;queue-&gt;queue_flags);
blk_queue_max_segments(mydev-&gt;queue, MYDEV_BLOCK_MAX_SEGS);
blk_queue_physical_block_size(mydev-&gt;queue, MYDEV_SECTOR_SIZE);
blk_queue_logical_block_size(mydev-&gt;queue, MYDEV_SECTOR_SIZE);

blk_queue_flush(mydev-&gt;queue, 0);

blk_queue_segment_boundary(mydev-&gt;queue, -1UL);
blk_queue_max_segments(mydev-&gt;queue, MYDEV_BLOCK_MAX_SEGS);
blk_queue_dma_alignment(mydev-&gt;queue, 0x7);
</code></pre>
"
"<p>I'm creating a very very simple block RAM disk based on sbull.</p>

<p>So far it works fine if I read/write blocks of data using dd, but whenever I try mounting a filesystem on it (and sometimes creating a file system) my driver crashes.</p>

<p>After long weeks of debugging, I finally found out what is wrong, even though I can't really find a way to solve the problem. Hence my question here :)</p>

<p>Whenever a user space application creates a request to the device WITH AN OFFSET, the driver won't work! Let me show you the source code in order to clarify:</p>

<p>First of all, I'm handling requests using mk_request (not using a request_queue):</p>

<pre><code>static void escsi_mk_request(struct request_queue *q, struct bio *bio)
{
        struct block_device *bdev = bio-&gt;bi_bdev;
        struct escsi_dev *esd = bdev-&gt;bd_disk-&gt;private_data;
        int rw;
        struct bio_vec *bvec;
        sector_t sector;
        int i;
        int err = -EIO;

        printk(""request received nr. sectors = %lu\n"",bio_sectors(bio));

        sector = bio-&gt;bi_sector;
        if (bio_end_sector(bio) &gt; get_capacity(bdev-&gt;bd_disk))
                goto out;

        if (unlikely(bio-&gt;bi_rw &amp; REQ_DISCARD)) {
                err = 0;
                goto out;
        }

        rw = bio_rw(bio);
        if (rw == READA)
            rw = READ;

        bio_for_each_segment(bvec, bio, i) {
                unsigned int len = bvec-&gt;bv_len;
                err = esd_do_bvec(esd, bvec-&gt;bv_page, len, bvec-&gt;bv_offset, rw, sector);
                if (err) {
                        printk(""err!\n"");
                        break;
                }
                sector += len &gt;&gt; SECTOR_SHIFT;
        }

out:
        bio_endio(bio, err);
}
</code></pre>

<p>The esd_do_bvec function:</p>

<pre><code>static int esd_do_bvec(struct escsi_dev *esd, struct page *page,
                         unsigned int len, unsigned int off, int rw,
                         sector_t sector)
 {
            void *mem;
            int err = 0;
            unsigned int offset;
            int i;

        offset = off + sector * 512;

        printk(""ESD RW=%d, len=%d, off=%d, offset=%d, sector=%lu\n"",rw,len,off,offset,sector);

        mem = kmap_atomic(page);
        if (rw == READ) {
                memcpy(mem,esd-&gt;data+offset,len);
        } else {
                memcpy(esd-&gt;data+offset,mem,len);
        }
        kunmap_atomic(mem);

out:
        return err;
}
</code></pre>

<p>OK, so basically when I read or write data using dd, the variable ""off"" in esd_do_bvec() is always 0, regardless of where and how many bytes I want to write. The file system obviously always performs I/O in 4KB chunks and will write a full block even when only one byte needs to be replaced. </p>

<p>I am sure that reads and writes are working correctly when there's no offset because I created a file that is the same size as my block RAM disk and dumped the entire file into my device using dd, then got the output of the device (also using dd), and the input and output files are exactly the same. I also wrote the same file into a brd (Linux kernel original block RAM disk driver) and the outputs are the same comparing my device and the brd device.</p>

<p>BUT -- in some specific situations I try to mount or create a new file system on my device and somehow it gets I/O requests with an offset, and at that point my driver fails. I assume that I'm not handling the offset properly. For example, when I try ""mount -t ext2 /dev/esda"":</p>

<pre><code>linux-xjwl:/home/phil/escsi # mount /dev/esda -t ext2 /mnt/esda1/
mount: wrong fs type, bad option, bad superblock on /dev/esda,
       missing codepage or helper program, or other error
       In some cases useful info is found in syslog - try
       dmesg | tail or so
linux-xjwl:/home/phil/escsi # dmesg|tail -n 10
[ 2239.275901] ESD RW=0, len=4096, off=0, offset=16384, sector=32
[ 2239.275947] request received nr. sectors = 8
[ 2239.275959] ESD RW=0, len=4096, off=0, offset=4096, sector=8
[ 2239.276516] request received nr. sectors = 8
[ 2239.276537] ESD RW=0, len=4096, off=0, offset=2097152, sector=4096
[ 2239.276606] request received nr. sectors = 8
[ 2239.276626] ESD RW=0, len=4096, off=0, offset=28672, sector=56
[ 2239.277535] request received nr. sectors = 2
[ 2239.277535] ESD RW=0, len=1024, off=1024, offset=2048, sector=2
[ 2239.277535] EXT4-fs (esda): VFS: Can't find ext4 filesystem
</code></pre>

<p>(p.s.: the output shows ""EXT4"" but I am running with ""-t ext2"")</p>

<p>I have checked the contents of sector n. 2 in my device and it does contain the ext2 metadata (since I ran mkfs.ext2 prior to trying to mount, of course). So I believe there's a problem with the offset. So far I can't really debug my driver because I wasn't able to come up with a request which would cause an I/O request with an offset (e.g., if I try writing a single byte into my device, Linux will read the whole block and rewrite it with only one different byte).</p>

<p>Hope it's not a too simple question for you.</p>

<p>Thanks in advance,
Phil</p>

<hr>

<hr>

<hr>

<p>Please see the answer provided by Peter below.</p>

<p>If you're wondering what the esd_do_bvec() function looks like now, here it comes:</p>

<pre><code>static int esd_do_bvec(struct escsi_dev *esd, char *buf,
                        unsigned int len, int rw, sector_t sector)
{
        int err = 0;
        unsigned int offset;

        // Please notice that we STILL have an offset to deal with, but
        // this offset comes in sectors and needs to be converted to a
        // a byte offset.
        offset = sector &lt;&lt; SECTOR_SHIFT; // or multiply by 512

        //printk(""ESD RW=%d, len=%d, off=%d, offset=%d, sector=%lu\n"",rw,len,off,offset,sector);

        if (rw == READ) {
                memcpy(buf,esd-&gt;data+offset,len);
        } else {
                memcpy(esd-&gt;data+offset,buf,len);
        }
        return err;
}
</code></pre>
"
"<p>I'm developing a block driver using?the make_request?method,?effectively bypassing existing scsi?or request?stack in block layer. ?So?that means im directly?working with?bios. ?As prescribed in linux?documentation and from referring?to similar?drivers in kernel, you?close a session with a?bio with the?bio_endio function.</p>

<p>I usually invoke bio_endio during?successful?I/O completion, meaning?with an error code?of zero. ?But?there are cases that this is not?fulfilled or there are error cases. ?My?question?is, what are the valid error?codes that can be?used with it? ?My?initial impression is that?other than?zero as error code, bio_endio will?fail. ?I've read somewhere that -EBUSY is not?recognized, and I tried?-EIO but my driver?crashed. ?I got a?panic in some dio_xxx function?leading from bio_endio(bio,-EIO) and I have no idea why it happened. I?would?like to block subsequent bios?sent to me after?reaching my queue?depth and with no tags left,?and so I?want to use bio_endio with an error?code.</p>

<p>What are those error codes, and will?they work?for my intended function? ?Or is there a better?way aside from bio_endio??Thanks!</p>
"
"<p>I'm writing a Linux block device driver for some custom hardware. </p>

<p>I've gone back and forth whether to the <em>make_request()</em> interface or the <em>request_fn()</em> interface and in either case I cannot find a clear answer as to whether or not the requested data needs to be resolved in the thread context where the data was requested.</p>

<p>For instance, some data is requested of my driver by the kernel, by which my make_request() callback is invoked. Am I <em>required</em> to deliver that data (e.g. using bio_endio() ) before I return from that callback, or could I perhaps call that bio_endio() in a different thread/task (e.g. if I was waiting on an IRQ from a DMA to tell me that data is locally available, I could return in the BH.)</p>

<p>In my testing, if I <em>don't</em> call bio_endio() before the end of the callback's scope, the kernel and the calling process hang, as would be expected--but they eventually panic... which would lead me to believe that either a) the panic is more to warn the driver developer that he should have returned <em>SOMETHING</em> within a ""reasonable"" amount of time (irrespective of the thread context) or that I shouldn't have returned at all without providing either the data or an error code.</p>
"
"<p>I am trying to build my own Linux derivative to run on an TI-AR7 board. I took the board from an old Telekom Speedport W 501V router. To understand how firmware is flashed onto the device I have downloaded the most recent <a href=""https://www.telekom.de/hilfe/geraete-zubehoer/router/weitere-router/speedport-w-5xx-serie/speedport-w-501v?samChecked=true"" rel=""nofollow"">official firmware</a>. Using the Linux <code>file</code> command I determined the image is a tar archive, which can be extracted easily.</p>

<pre><code>ubuntu@ip-172-31-23-210:~/reverse$ ls
fw_speedport_w501v_v_28.04.38.image
ubuntu@ip-172-31-23-210:~/reverse$ file fw*
fw_speedport_w501v_v_28.04.38.image: POSIX tar archive (GNU)
ubuntu@ip-172-31-23-210:~/reverse$ tar -xvf fw*
./var/
./var/tmp/
./var/tmp/kernel.image
./var/tmp/filesystem.image
./var/flash_update.ko
./var/flash_update.o
./var/info.txt
./var/install
./var/chksum
./var/regelex
./var/signature
ubuntu@ip-172-31-23-210:~/reverse$
</code></pre>

<p>According to a <a href=""http://www.wehavemorefun.de/fritzbox/Firmware-Image"" rel=""nofollow"">wiki (Firmware-Image)</a> that I have found, <code>./var/tmp/kernel.image</code> contains the actual firmware. During the update process this image is written to the <code>mtd1</code> device. As stated in the <a href=""http://www.wehavemorefun.de/fritzbox/LZMA-Kernel"" rel=""nofollow"">wiki (LZMA-Kernel)</a> the lzma compressed kernel starts with the magic number <code>0xfeed1281</code>. A hexdump of  <code>kernel.image</code> contains that number at its beginning.</p>

<pre><code>ubuntu@ip-172-31-23-210:~/reverse/var/tmp$ hexdump -n 4 kernel.image
0000000 1281 feed
0000004
ubuntu@ip-172-31-23-210:~/reverse/var/tmp$
</code></pre>

<p>The following script given on the last wiki entry should decompress the kernel.</p>

<pre><code>#! /usr/bin/perl

use Compress::unLZMA;
use Archive::Zip;

open INPUT, ""&lt;$ARGV[0]"" or die ""can't open $ARGV[0]: $!"";

read INPUT, $buf, 4;
$magic = unpack(""V"", $buf);
if ($magic != 0xfeed1281) {
  die ""bad magic"";
}

read INPUT, $buf, 4;
$len = unpack(""V"", $buf);

read INPUT, $buf, 4*2; # address, unknown

read INPUT, $buf, 4;
$clen = unpack(""V"", $buf);
read INPUT, $buf, 4;
$dlen = unpack(""V"", $buf);
read INPUT, $buf, 4;
$cksum = unpack(""V"", $buf);
printf ""Archive checksum: 0x%08x\n"", $cksum;

read INPUT, $buf, 1+4; # properties, dictionary size
read INPUT, $dummy, 3; # alignment
$buf .= pack('VV', $dlen, 0); # 8 bytes of real size
#$buf .= pack('VV', -1, -1); # 8 bytes of real size
read INPUT, $buf2, $clen;

$crc = Archive::Zip::computeCRC32($buf2);
printf ""Input CRC32: 0x%08x\n"", $crc;
if ($cksum != $crc) {
  die ""wrong checksum"";
}
$buf .= $buf2;

$data = Compress::unLZMA::uncompress($buf);
unless (defined $data) {
  die ""uncompress: $@"";
}

open OUTPUT, ""&gt;$ARGV[1]"" or die ""can't write $ARGV[1]"";
print OUTPUT $data;
#truncate OUTPUT, $dlen;
</code></pre>

<p>To use the script you may need to install <a href=""http://search.cpan.org/~ferreira/Compress-unLZMA-0.04/lib/Compress/unLZMA.pm"" rel=""nofollow"">Compress::unLZMA</a> and <a href=""http://search.cpan.org/~phred/Archive-Zip-1.56/lib/Archive/Zip.pm"" rel=""nofollow"">Archive::Zip</a> perl modules.</p>

<pre><code>ubuntu@ip-172-31-23-210:~/reverse/var/tmp$ tar -xvf Compress*
Compress-unLZMA-0.04/
Compress-unLZMA-0.04/Makefile.PL
Compress-unLZMA-0.04/ppport.h
Compress-unLZMA-0.04/Changes
Compress-unLZMA-0.04/lzma_sdk/
[...]
ubuntu@ip-172-31-23-210:~/reverse/var/tmp$ cd Compress*
ubuntu@ip-172-31-23-210:~/reverse/var/tmp/Compress-unLZMA-0.04$ perl Makefile.PL
Checking if your kit is complete...
Looks good
Writing Makefile for Compress::unLZMA
Writing MYMETA.yml and MYMETA.json
ubuntu@ip-172-31-23-210:~/reverse/var/tmp/Compress-unLZMA-0.04$ make
cp lib/Compress/unLZMA.pm blib/lib/Compress/unLZMA.pm
/usr/bin/perl /usr/share/perl/5.18/ExtUtils/xsubpp  -typemap /usr/share/perl/5.18/ExtUtils/typemap  unLZMA.xs &gt; unLZMA.xsc &amp;&amp; mv unLZMA.xsc unLZMA.c
cc -c  -I. -Ilzma_sdk/Source -D_REENTRANT -D_GNU_SOURCE
[...]
ubuntu@ip-172-31-23-210:~/reverse/var/tmp/Compress-unLZMA-0.04$ sudo make install
Files found in blib/arch: installing files in blib/lib into architecture dependent library tree
Installing /usr/local/lib/perl/5.18.2/auto/Compress/unLZMA/unLZMA.bs
Installing /usr/local/lib/perl/5.18.2/auto/Compress/unLZMA/unLZMA.so
Installing /usr/local/lib/perl/5.18.2/Compress/unLZMA.pm
Installing /usr/local/man/man3/Compress::unLZMA.3pm
Appending installation info to /usr/local/lib/perl/5.18.2/perllocal.pod
ubuntu@ip-172-31-23-210:~/reverse/var/tmp/Compress-unLZMA-0.04$ # same for Archive::Zip module
</code></pre>

<p>After installing these dependencies the script decompressed the kernel successfully.</p>

<pre><code>ubuntu@ip-172-31-23-210:~/reverse/var/tmp$ ./decompress.pl kernel.image kernel.decompressed
Archive checksum: 0x29176e12
Input CRC32: 0x29176e12
ubuntu@ip-172-31-23-210:~/reverse/var/tmp$
</code></pre>

<p>But what kind of file is <code>kernel.decompressed</code> and how do I generate a similar file from my Linux kernel source? I continued analyzing it using <code>file</code> and <a href=""https://github.com/devttys0/binwalk"" rel=""nofollow"">binwalk</a>.</p>

<pre><code>ubuntu@ip-172-31-23-210:~/reverse/var/tmp$ file kernel.decompressed
kernel.decompressed: data
ubuntu@ip-172-31-23-210:~/reverse/var/tmp$ binwalk kernel.decompressed

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
1509632       0x170900        Linux kernel version ""2.6.13.1-ohio (686) (gcc version 3.4.6) #9 Wed Apr 4 13:48:08 CEST 2007""
1516240       0x1722D0        CRC32 polynomial table, little endian
1517535       0x1727DF        Copyright string: ""Copyright 1995-1998 Mark Adler ""
1549488       0x17A4B0        Unix path: /usr/gnemul/irix/
1550920       0x17AA48        Unix path: /usr/lib/libc.so.1
1618031       0x18B06F        Neighborly text, ""neighbor %.2x%.2x.%.2x:%.2x:%.2x:%.2x:%.2x:%.2x lost on port %d(%s)(%s)""
1966080       0x1E0000        gzip compressed data, maximum compression, from Unix, last modified: 2007-04-04 11:45:13

ubuntu@ip-172-31-23-210:~/reverse/var/tmp$
</code></pre>

<p>So the Linux kernel starts at <code>1509632</code> and ends at <code>1516240</code>. What kind of data is stored in front the Linux kernel (<code>0</code> to <code>1509632</code>)? I extracted the kernel and that piece of unknown data using <code>dd</code>.</p>

<pre><code>ubuntu@ip-172-31-23-210:~/reverse/var/tmp$ dd if=kernel.decompressed of=unknown.data bs=1 count=1509632
1509632+0 records in
1509632+0 records out
1509632 bytes (1.5 MB) copied, 1.62137 s, 931 kB/s
ubuntu@ip-172-31-23-210:~/reverse/var/tmp$ dd if=kernel.decompressed of=kernel bs=1 skip=1509632 count=6608
6608+0 records in
6608+0 records out
6608 bytes (6.6 kB) copied, 0.0072771 s, 908 kB/s
ubuntu@ip-172-31-23-210:~/reverse/var/tmp$
</code></pre>

<p>I need to ask again: What kind of file is <code>kernel</code> and how do I generate a similar file from my Linux kernel source? I used <code>xxd</code> and <code>strings</code> to look at the file more closely.</p>

<pre><code>ubuntu@ip-172-31-23-210:~/reverse/var/tmp$ xxd -l 100 kernel
0000000: 4c69 6e75 7820 7665 7273 696f 6e20 322e  Linux version 2.
0000010: 362e 3133 2e31 2d6f 6869 6f20 2836 3836  6.13.1-ohio (686
0000020: 2920 2867 6363 2076 6572 7369 6f6e 2033  ) (gcc version 3
0000030: 2e34 2e36 2920 2339 2057 6564 2041 7072  .4.6) #9 Wed Apr
0000040: 2034 2031 333a 3438 3a30 3820 4345 5354   4 13:48:08 CEST
0000050: 2032 3030 370a 0000 0000 0000 0000 0000   2007...........
0000060: 0000 0000                                ....
ubuntu@ip-172-31-23-210:~/reverse/var/tmp$ strings kernel
Linux version 2.6.13.1-ohio (686) (gcc version 3.4.6) #9 Wed Apr 4 13:48:08 CEST 2007
do_be
do_bp
do_tr
do_ri
do_cpu
nmi_exception_handler
do_ade
emulate_load_store_insn
do_page_fault
context_switch
__put_task_struct
do_exit
local_bh_enable
run_workqueue
2.6.13.1-ohio gcc-3.4
enable_irq
__free_pages_ok
free_hot_cold_page
prep_new_page
kmem_cache_destroy
kmem_cache_create
pageout
vunmap_pte_range
vmap_pte_range
__vunmap
__brelse
sync_dirty_buffer
bio_endio
queue_kicked_iocb
proc_get_inode
remove_proc_entry
sysfs_get
sysfs_fill_super
kref_get
kref_put
0123456789abcdefghijklmnopqrstuvwxyz
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
vsnprintf
{zt^f
pw0Gm
0cIZ-
68BG+
QC]S%
v,;Zk
ubuntu@ip-172-31-23-210:~/reverse/var/tmp$
</code></pre>

<p>This Github <a href=""https://github.com/leon1101/laughing-parakeet"" rel=""nofollow"">repository</a> contains the extracted files to use for further analysis.</p>
"
"<p>I want to draw latency information for each struct bio that passes through the block layer. I have a module that overrides make_request_fn. I would want to find out how long did that bio took from there to reach request queue and from there to driver and so on.</p>

<p>I tried to attach a custom struct to the bio I receive at make_request_fn but since I did not create those, I cant use the bi_private field. Is there any way to work around this?</p>

<p>One option I have is to make a bio wrapper structure and copy bio structs into it before passing it to the lower functions so that I could use container_of to record times.</p>

<p>I have read about tools like blktrace and btt but I need that information inside my module. Is there any way to achieve this?</p>

<p>Thank you.</p>
"
"<p>I am trying to improve functionality of scsi_debug linux device driver. It is included in the kernel source code. This adapter driver simulates a variable number of SCSI disks, each sharing a common amount of RAM allocated by the driver to act as (volatile) storage. With one SCSI disk simulated, the scsi_debug driver is functionally equivalent to a RAM disk. More info here: <a href=""http://sg.danny.cz/sg/sdebug26.html"" rel=""nofollow noreferrer"">http://sg.danny.cz/sg/sdebug26.html</a></p>

<p>So, I am trying to give extra functionality. Instead to use ramdisk, I wanted to use loop devices, by using losetup, and the loop device should look like a SCSI disk connected to the virtual scsi_debug adapter for the user. However I am passing through difficult times sending IO to the loopback device. </p>

<p>When I create a virtual disk, I open the loop device, and read/write to it with no issues, by creating bio structures and sending the request to the block device using submit_bio(). All here looks fantastic and work really fine. </p>

<p>Once I figured out how to use bios, I tried to plug into the existing data IO code. scsi_debug does this by getting the data from the SCSI commands (struct scsi_cmmd) using scsi_sg_copy_to_buffer() and sg_copy_from_buffer(), both part of the kernel API. A simple memcpy() is enough to have a functional ramdisk. </p>

<p>However I need to do more than that. I though that just to clone the bios and send out to the block device would work, so I tried this:</p>

<pre><code>static int do_disk_IO( struct scsi_cmnd *scmd, struct block_device *device){
    struct bio *pending_bio;
    struct bio *cloned_bio;
    TRC(""start"");

    pending_bio = scmd-&gt;request-&gt;bio; /* IS THIS CORRECT? */
    if( pending_bio  != NULL ){
        cloned_bio = bio_clone( pending_bio, GFP_NOIO);
        cloned_bio-&gt;bi_bdev = device; /* loop block device ref */
        cloned_bio-&gt;bi_end_io = disk_IO_end_cloned; /* this func show error
                                                       and run bio_put() */
        cloned_bio-&gt;bi_next = NULL;   /* Is this OK? */
        blk_partition_remap( cloned_bio); /* remap bio to disk partition*/
        generic_make_request( cloned_bio); /* fly lil bird! */
    }
    TRC(""end"");
    return 0;
}
</code></pre>

<p>Got errors like this: kernel:BUG: soft lockup - CPU#0 stuck for 22s!</p>

<p>One single bio pass thru this with no issues. My problem is when a list of bios comes (mean, when I have more bios in the bi_next field). I even tried by cloning the entire bio list and sending that to the device queue. Got the same error anyway. </p>

<p>Questions: </p>

<ol>
<li>Is correct the way to get the bios from the scsi command like this? scmd->request->bio. I am almost sure this is correct, but I would like somebody to confirm </li>
<li>Why the CPU is in a soft lock up when more bios in the list are received? </li>
<li>Is there a way to link several struct bios into a single struct request before sending it to lower layers for servicing?</li>
<li>What is the best way to mark the original bio structures once the IO is done? </li>
<li>Related to the last point: is required to inform the upper layers that we're done with some particular bio -maybe using bio_endio()?</li>
</ol>

<p>Thanks in advance!!!</p>
"
"<p>Hello stackoverflow.</p>

<p>Wondering what I got wrong trying to access a block-device directly from a kernel module. (Kernel 3.7 on amd64)</p>

<p>I get the (struct gendisk*) of the device using get_gendisk(). Next, create a bio with bio_map_kern(), add the block_device to it using bdget_disk(), and send it using submit_bio(). (see code below)</p>

<p>When doing this on 'sdb', it works fine. When doing it on 'loop0' or a ramdisk device, it fails with segfault.
The fault boils down to generic_make_request_checks() calls inline-function bdev_get_queue(), which is trying to access the 'bd_disk' field in the block_device struct.</p>

<p>RIP: 0010:[]  [] generic_make_request_checks+0x3e/0x2b1</p>

<p>When getting the block_device from 'sdb', the bd_disk is linked back to the device's gendisk struct (on any partition of it). When trying the same on the 'loop0' device, this pointer is zero. But loop0 is properly set up as I can mkfs, mount or dd with it.</p>

<p>Any hints on how to set up a simple data read? The clean and proper way? adding the gendisk pointer to the block_device cannot be a nice solution as I don't 'own' the structures.</p>

<p>Maybe this approach is all wrong and there is some easy read() function I missed... :-)</p>

<p>callstack (kernel 3.7, amd64):</p>

<pre><code>[&lt;ffffffff812796f5&gt;] generic_make_request_checks+0x3e/0x2b1
[&lt;ffffffff8103c2b8&gt;] ? console_trylock+0xf/0x47
[&lt;ffffffff8103dad0&gt;] ? vprintk_emit+0x3aa/0x3d0
[&lt;ffffffff81279976&gt;] ? generic_make_request+0xe/0xd5
[&lt;ffffffff8127a75c&gt;] ? submit_bio+0x10a/0x13b
[&lt;ffffffffa02ad191&gt;] ? init_tryKM2+0x16e/0x221 [tryKM2]
[&lt;ffffffffa02ad023&gt;] ? endFunc_tryKM2+0x23/0x23 [tryKM2]
[&lt;ffffffff810020b6&gt;] ? do_one_initcall+0x75/0x12b
[&lt;ffffffff8107c9a3&gt;] ? sys_init_module+0x105/0x251
[&lt;ffffffff8145f1e9&gt;] ? system_call_fastpath+0x16/0x1b
</code></pre>

<p>My test code for trying this:</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/blkdev.h&gt;
#include &lt;linux/genhd.h&gt;
#include &lt;linux/bio.h&gt;
#include &lt;linux/completion.h&gt;

typedef struct _drvDat
{
    dev_t di;
    struct gendisk *gd;
} drvDat;

#define printf(...) printk(KERN_ALERT ""tryKM2: "" __VA_ARGS__)
#define DEVNAME ""loop0""
#define PARTITIONNO 0

static int init_tryKM2(void)
{
  int dummy;
    // init self
    memset(&amp;self,0,sizeof(self));

    self.di = blk_lookup_devt(DEVNAME,0);    // use partition zero here. gendisk handle is same anyway.
    if(self.di==0)
        return -1;
    self.gd = get_gendisk(self.di,&amp;dummy);        // get_gendisk always gets the 'disk', even if dev_t points to a partition.
    if(self.gd==0)
        return -1;

    // check if have partitions  (this array always has at least one entry. That is same as &amp;(self.gd-&gt;part0)
    if(self.gd-&gt;part_tbl-&gt;len&lt;1+PARTITIONNO)
        {put_disk(self.gd);self.gd=0;return -1;}

    readbytes_tryKM2(&amp;self);

    return 0;
}

static void endFunc_tryKM2(struct bio *bb, int err)
{
    if(bb-&gt;bi_private)
        complete( (struct completion*)(bb-&gt;bi_private) );
}

static void readbytes_tryKM2(drvDat *self)
{
  struct bio *bb;
  DECLARE_COMPLETION_ONSTACK(waithandle);
  unsigned char *buf;
  unsigned int i,j;

    printf(""readbytes_tryKM2\n"");
    buf = (unsigned char*)vmalloc(0x800);
    memset( buf , 0xFE , 0x800 );


    bb = bio_map_kern( self-&gt;gd-&gt;queue , buf , 0x400 , GFP_KERNEL );
    if( IS_ERR(bb) )
        {vfree(buf);return;}

    bb-&gt;bi_sector = 0;

    bb-&gt;bi_bdev = bdget_disk(self-&gt;gd,PARTITIONNO);
    printf(""   bi_bdev = %016lX\n"",(unsigned long)(bb-&gt;bi_bdev));
    printf(""   bi_bdev-&gt;bd_disk = %016lX\n"",(unsigned long)(bb-&gt;bi_bdev-&gt;bd_disk));

    bb-&gt;bi_end_io = endFunc_tryKM2;
    bb-&gt;bi_private = &amp;waithandle;

    printf(""  send...\n"");
    submit_bio( 0 , bb );
    printf(""  wait...\n"");
    wait_for_completion(&amp;waithandle);

    printf(""  done. flags=0x%X\n"",(unsigned int)(bb-&gt;bi_flags));

    if(!( bb-&gt;bi_flags &amp; (1&lt;&lt;BIO_UPTODATE) ))
        {bio_put(bb);vfree(buf);return;}

    // just dump data... (misusing upper half of buffer)
    for(i=0;i&lt;0x400;i+=0x20)
    {
        for(j=0;j&lt;0x20;j++)
            snprintf( (char*)(buf+0x400+3*j) , 8 , ""%02X "" , (unsigned int)buf[i+j] );
        buf[3*0x20-1]=0;
        printf(""   %s\n"",buf+0x400);
    }

    bio_put(bb);

    vfree(buf);
}

module_init(init_tryKM2);
module_exit(cleanup_tryKM2);
</code></pre>
"
"<p>The documentation for Openssl memory BIO sinks is <a href=""http://www.openssl.org/docs/crypto/BIO_s_mem.html#"" rel=""nofollow noreferrer"">here</a>.</p>

<p>I am creating a BIO chain to turn binary strings into base64 strings. The source/sink is always a memory location, and this enables me to just keep the same chain arround. However the data (should) go into a memory buffer managed by OpenSSL when I write to it, and it should come from a user supplied memory buffer when read from the chain.</p>

<p>BIO_set_mem_buf() is the function used to set a user supplied buffer, and I will set the BIO_NOCLOSE property as I manage my memory using new. Now in order to use the same chain for writing I need to change the memory bio into managing its own memory. My question is:
<strong>"" Will BIO_reset() change it back to managing its own memory after a user has supplied a custom buffer ? Are there any performance consequences of using a single chain for what I want to do ?""</strong></p>
"
"<p>I want to work with XML file format of RSA public and private keys.
Now i found how to save these keys in PEM and binary (DER) formats (for example, PEM_write_RSAPrivateKey())</p>

<p>I have a string with xml-format RSA keys and i need to load them into EVP_PKEY or RSA  OpenSSL structures.</p>

<p>XML format is like this:</p>

<pre><code>&lt;RSAKeyPair&gt;
  &lt;Modulus&gt;...&lt;/Modulus&gt;
  &lt;Exponent&gt;...&lt;/Exponent&gt;
  &lt;P&gt;...&lt;/P&gt;
  &lt;Q&gt;...&lt;/Q&gt;
  &lt;DP&gt;...&lt;/DP&gt;
  &lt;DQ&gt;...&lt;/DQ&gt;
  &lt;InverseQ&gt;
    ...
  &lt;/InverseQ&gt;
  &lt;D&gt;...&lt;/D&gt;
&lt;/RSAKeyPair&gt;
</code></pre>

<p>Thanks!</p>
"
"<p>How to properly print RSA* as string in C++?</p>

<p>I am using <code>OpenSSL</code>. It doesn't seem to have a <code>.c_str()</code> method, right?</p>
"
"<p>I want to encrypt and decrypt using <code>PKCS7_encrypt()</code> and <code>PKCS7_decrypt()</code> functions in openSSL. I have used the example in openSSL Demo. What I want to do is to encrypt a message in the format of <code>char*</code> and decrypt using that <code>char*</code>. I don't want to read and write into file. Here is the code to encrypt, which perfectly works and has no problem:</p>

<pre><code>in = BIO_new_file(""encr.txt"", ""r"");
if (!in)
    return 0;

/* encrypt content */
p7 = PKCS7_encrypt(recips, in, EVP_des_ede3_cbc(), flags);
if (!p7)
    return 0;

char* chEnc = new char[1000];

BIO* memorybio = BIO_new(BIO_s_mem());
BIO* base64bio = BIO_new(BIO_f_base64());
BIO* outbio = BIO_push(base64bio, memorybio);

/* Copy PKCS#7 */
long ll = i2d_PKCS7_bio(outbio, p7);
BIO_flush(outbio);
BIO_set_flags(memorybio, BIO_FLAGS_MEM_RDONLY);
BIO_get_mem_data(memorybio, &amp;chEnc);
cout &lt;&lt; chEnc &lt;&lt; ""\n"";
</code></pre>

<p>Now, when I want to do the reverse and decrypt the <code>char*</code> chEnc, I did as below:</p>

<pre><code>BIO *in = NULL, *out = NULL, *tbio = NULL;
X509 *rcert = NULL;
EVP_PKEY *rkey = NULL;
PKCS7 *p7 = NULL;
int ret = 1;

OpenSSL_add_all_algorithms();
ERR_load_crypto_strings();

/* Read in recipient certificate and private key */
tbio = BIO_new_file(""signer.pem"", ""r"");

if (!tbio)
    return 0;

rcert = PEM_read_bio_X509(tbio, NULL, 0, NULL);
BIO_reset(tbio);
rkey = PEM_read_bio_PrivateKey(tbio, NULL, 0, NULL);
if (!rcert || !rkey)
    return 0;

BIO* memorybio = BIO_new(BIO_s_mem());
int iLength = BIO_puts(memorybio, chEnc);

BIO* base64bio = BIO_new(BIO_f_base64());
BIO* inbio = BIO_push(base64bio, memorybio);

/* Copy PKCS#7 */
BIO_flush(inbio);
BIO_set_flags(inbio, BIO_FLAGS_MEM_RDONLY);
p7 = d2i_PKCS7_bio(inbio, &amp;p7);
if (!PKCS7_decrypt(p7, rkey, rcert, out, 0))
    return 0;

ret = 0;

if (ret) {
    fprintf(stderr, ""Error Signing Data\n"");
    ERR_print_errors_fp(stderr);
}

if (p7)
    PKCS7_free(p7);
if (rcert)
    X509_free(rcert);
if (rkey)
    EVP_PKEY_free(rkey);

if (in)
    BIO_free(in);
if (out)
    BIO_free(out);
if (tbio)
    BIO_free(tbio);

return ret;
</code></pre>

<p>The problem is that the <code>PKCS7_decrypt</code> does not work and it does not decrypt into <code>out</code> variable. After the line <code>if (!PKCS7_decrypt(p7, rkey, rcert, out, 0)) return 0;</code> , it returns from the function. Is the procedure to decrypt correct? Shall I use other APIs of openSSL to convert or something? </p>

<p>Looking forward to your suggestions and comments.</p>

<p>Thanks</p>
"
"<p>I am trying out a small example program to decrypt a message that has been signed and then encrypted using openSSL. It works well in the command line. However upon trying out the code after modifying the code in the 'demos' folder of OpenSSL, the decryption fails</p>

<p>Here is the decryption code:</p>

<pre><code>   int decrypt_smime(){

        BIO *in = NULL, *out = NULL, *tbio = NULL;
        X509 *rcert = NULL;
        EVP_PKEY *rkey = NULL;
        //PKCS7 *cms = NULL;
        CMS_ContentInfo *cms = NULL;
        int ret = 1;
        int flags = CMS_STREAM;
        OpenSSL_add_all_algorithms();
        ERR_load_crypto_strings();
        printf(""decrypt...\n"");
        /* Read in recipient certificate and private key */
        tbio = BIO_new_file(""signer.pem"", ""r"");

        if (!tbio)
            goto err;

        rcert = PEM_read_bio_X509(tbio, NULL, 0, NULL);

        BIO_reset(tbio);

        rkey = PEM_read_bio_PrivateKey(tbio, NULL, 0, NULL);

        if (!rcert || !rkey)
            goto err;
        printf(""decrypt...\n"");
        /* Open S/MIME message to decrypt */

        in = BIO_new_file(""smencsign.txt"", ""r"");

        if (!in)
            goto err;
        printf(""keys read...\n"");
        /* Parse message */
        cms = SMIME_read_CMS(in, NULL); //here is the problem I think

        if (!cms)
            goto err;
        printf(""keys read...\n"");
        out = BIO_new_file(""decout.txt"", ""w"");
        if (!out)
            goto err;

        /* Decrypt S/MIME message */
        if (!CMS_decrypt(cms, rkey, rcert, NULL, out, flags))
            goto err;

        ret = 0;

        err:

        if (ret)
        {
            fprintf(stderr, ""Error Decrypting Data\n"");
            ERR_print_errors_fp(stderr);
        }

        if (cms)
            //PKCS7_free(cms);
            CMS_ContentInfo_free(cms);
        if (rcert)
            X509_free(rcert);
        if (rkey)
            EVP_PKEY_free(rkey);

        if (in)
            BIO_free(in);
        if (out)
            BIO_free(out);
        if (tbio)
            BIO_free(tbio);

        return ret;

    }
</code></pre>

<p>The error I get is:
Error Verifying Data
*3074258568:error:0D0D40D1:asn1 encoding routines:SMIME_read_ASN1:no content type:asn_mime.c:451:*</p>

<pre><code>The commands on openssl that worked:

openssl cms -sign -in encr.txt -signer signer.pem -text | openssl cms -encrypt -out smencsign.txt signer.pem

openssl smime -decrypt -in smencsign.txt -recip signer.pem -inkey signer.pem
</code></pre>

<p>So clearly openssl uses 'cms' utility to sign and encrypt but seems to use 'smime' utility for decryption. What is then the code equivalent?</p>
"
"<p>I have a DER encoded CMS file that I would like to decrypt using the openssl API.</p>

<p>I have found the <a href=""http://wiki.openssl.org/index.php/Manual:CMS_decrypt%283%29"" rel=""nofollow noreferrer"">API</a> for decrypting:</p>

<pre><code>CMS_decrypt(cms_content, pkey, cert, NULL, out, NULL);
</code></pre>

<p>I have found examples for reading the pkey and cert PEM files, and setting up the output BIO, but I can't find out how to read the cms file.</p>

<p><strong>Question</strong>: how can I read an ASN.1 DER encoded file into the <code>cms_content</code> variable that has the type <code>CMS_ContentInfo</code>?</p>

<hr>

<p>EDIT: Thanks to the <a href=""https://stackoverflow.com/a/19360293/1033422"">Camille's answer</a>, I managed to get it working with:</p>

<pre><code>#include &lt;stdio.h&gt;

#include &lt;openssl/ssl.h&gt;
#include &lt;openssl/err.h&gt;
#include &lt;openssl/cms.h&gt;

int main (int argc, char **argv)
{
    char pkeypath[] = ""recipient_prvkey.pem"";
    char certpath[] = ""sender_cert.pem"";
    char cmspath[] = ""encrypted.der"";
    char decpath[] = ""decrypted.zip"";

    BIO *in = NULL, *out = NULL, *tbio = NULL;
    CMS_ContentInfo *cms = NULL;

    EVP_PKEY *pkey;
    X509 *cert;

    OpenSSL_add_all_algorithms();
    ERR_load_crypto_strings();

    tbio = BIO_new_file(pkeypath, ""r"");
    pkey = PEM_read_bio_PrivateKey(tbio, NULL, 0, NULL);
    if (pkey == NULL) {
        printf(""error reading private key"");
        return EXIT_FAILURE;
    }
    BIO_free(tbio);

    tbio = BIO_new_file(certpath, ""r"");
    cert = PEM_read_bio_X509(tbio, NULL, 0, NULL);
    if (cert == NULL) {
        printf(""error reading private key"");
        return EXIT_FAILURE;
    }

    in = BIO_new_file(cmspath, ""r"");
    cms = d2i_CMS_bio(in, NULL);
    BIO_free(in);

    out = BIO_new_file(decpath, ""w"");

    if (!CMS_decrypt_set1_pkey(cms, pkey, cert))
    {
        fprintf(stderr, ""set1_pkey error\n"");
        return EXIT_FAILURE;
    }

    if (!CMS_decrypt(cms, NULL, NULL, NULL, out, CMS_BINARY))
    {
        int error = ERR_get_error();

        fprintf(stderr, ""error: %s :: %s :: %s\n"",
                ERR_reason_error_string(error),
                ERR_func_error_string(error),
                ERR_lib_error_string(error)
                );
    }
    BIO_free(out);

    return 0;
}
</code></pre>
"
"<p>Does the following code properly free all the allocated memory?</p>

<pre><code>void foo(){
    //set up connection
    SSL *ssl = NULL;
    SSL_METHOD *method = (SSL_METHOD *)SSLv23_client_method();
    SSL_CTX *ctx = SSL_CTX_new(method);
    BIO *bio = BIO_new_ssl_connect(ctx);
    BIO_get_ssl(bio, &ssl);
    BIO_set_conn_hostname(bio, ""facebook.com:443"");

    doConnect(ssl, ctx, bio);
    ...
    doFree(ssl, ctx, bio);
}

void doConnect(SSL *ssl, SSL_CTX *ctx, BIO *bio){
    BIO_reset(bio); //this is here in case we are trying to reconnect
    if (BIO_do_connect(connection->bio) &lt;= 0){
        while ( BIO_should_retry(connection->bio)){
            if (BIO_do_connect(connection->bio) > 0){
                break;
            }
        }
        //error handeling in case BIO_should_retry returns false omitted.
    }
    if (SSL_get_verify_result(connection->ssl) != X509_V_OK){
        // Handle the failed verification
    }
    int socket = BIO_get_fd(bio, NULL);
}

void doFree(SSL *ssl, SSL_CTX *ctx, BIO *bio){
    BIO_free_all(bio); //is this right?
}
</code></pre>

<p>The reason I'm wondering if this is the correct way of freeing the memory is because I'm currently getting the following stack trace and I dont know if I'm improperly freeing the memory or if it is some other sort of error (valgrind doesnt report any memory error, it simply halts here).</p>

<pre>(gdb) bt
#0  0x040010c2 in ?? () from /lib/ld-linux.so.2
#1  0x06a13a0b in write () at ../sysdeps/unix/syscall-template.S:82
#2  0x04153ae9 in ?? () from /lib/i386-linux-gnu/libcrypto.so.1.0.0
#3  0x041508e4 in BIO_write () from /lib/i386-linux-gnu/libcrypto.so.1.0.0
#4  0x040771f1 in ?? () from /lib/i386-linux-gnu/libssl.so.1.0.0
#5  0x040775ff in ?? () from /lib/i386-linux-gnu/libssl.so.1.0.0
#6  0x04078d2f in ?? () from /lib/i386-linux-gnu/libssl.so.1.0.0
#7  0x04077a64 in ?? () from /lib/i386-linux-gnu/libssl.so.1.0.0
#8  0x04074bde in ?? () from /lib/i386-linux-gnu/libssl.so.1.0.0
#9  0x0408eed1 in SSL_shutdown () from /lib/i386-linux-gnu/libssl.so.1.0.0
#10 0x0409b175 in ?? () from /lib/i386-linux-gnu/libssl.so.1.0.0
#11 0x04150638 in BIO_free () from /lib/i386-linux-gnu/libcrypto.so.1.0.0
#12 0x041511c4 in BIO_free_all () from /lib/i386-linux-gnu/libcrypto.so.1.0.0
</pre>
"
"<p>I am trying to sign a email message using OpenSSL. I want to perform Clear Text Signing on the email message. </p>

<p>I know I can do this using command prompt with the command: </p>

<pre><code>openssl smime -sign -in hw.txt -text -out signed.msg -signer mycert.pem
</code></pre>

<p>But how do I do this using C Code? </p>

<p>This is what I am doing right now: </p>

<pre><code>int flgs = PKCS7_DETACHED | PKCS7_TEXT;
PKCS7 * p7 = PKCS7_sign(signCert, pKey, certs, bio, flgs);
if(p7 != NULL) {
    int res = PKCS7_final(p7, bio, flags);
    __android_log_print(ANDROID_LOG_DEBUG, ""OpenSSLJni"", ""\nFinal result is: %d"", res);
    FILE *outfile = fopen(""/storage/sdcard0/sign_output.txt"", ""w"");
    BIO* out = BIO_new_fp(outfile, BIO_NOCLOSE) ;// BIO_new_file(outfile, """");
    BIO_reset(bio);
    SMIME_write_PKCS7(out, p7, bio, flags);
    return true;
}
</code></pre>

<p>But I in the output file I am only getting the signature not both the body and signature.</p>

<p>Any pointers?  </p>
"
"<p>I am having problems accessing the <code>EnvelopedData</code> within a signed <code>CMS_ContentInfo*</code> object when using a memory <code>BIO</code>.</p>

<p>Using the following code, everything works fine :</p>

<pre><code>BIO* output = BIO_new_file(""/absolute/path/test.txt"", ""r+"");
                    if (CMS_verify(cms, stack, store, dcont, output, CMS_NOINTERN)) {
    BIO_flush(output);
    BIO_reset(output);
    CMS_ContentInfo* cms2 = SMIME_read_CMS(output, nullptr);
}
</code></pre>

<p>cms2 is instantiated properly and I am able to decrypt its content. Although, I don't want the file to be written to disk so I am trying to make this work in memory like so :</p>

<pre><code>BIO* output = BIO_new(BIO_s_mem());
if (CMS_verify(cms, stack, store, dcont, output, CMS_NOINTERN)) {
    BIO_flush(output);
    BIO_seek(output, 0);
    CMS_ContentInfo* cms2 = SMIME_read_CMS(output, nullptr);
}
</code></pre>

<p>For some reason, it seems the <code>SMIME_read_CMS</code> function can never read from the <code>BIO</code>. Can anyone help me get this working?</p>
"
"<p>I'm working on a project which needs to connect to a server over a secure socket connection and send some commands, in case one of the commands fail I get an error response on that socket and then the socket closes.</p>

<p>I have tried a single-threaded approach with a non-blocking ssl socket. I connect to the server and then send a few commands, do a non-blocking read for an error status, send some more commands, read again and so on. The server is an Apple Push Notification Service in case it helps.</p>

<p>Everything seems fine until I get an error response followed by the server closing the socket. I can read the error response and see that the socket has been closed but when I free the BIO object the application crashes (unhandled SIGPIPE). In my opinion it crashes because I may be sending data even after the socket has been closed. This is the backtrace after the SIGPIPE signal was issued:</p>

<pre><code>queue = 'com.apple.main-thread', stop reason = signal SIGPIPE
frame #0: 0x94cad46a libsystem_kernel.dylib`__write + 10
frame #1: 0x0007b835 APNTest`conn_write + 69
frame #2: 0x0007957d APNTest`BIO_write + 141
frame #3: 0x00100127 APNTest`ssl3_write_pending + 215
frame #4: 0x001001f9 APNTest`do_ssl3_write + 57
frame #5: 0x00101cab APNTest`ssl3_dispatch_alert + 59
frame #6: 0x000fdb80 APNTest`ssl3_shutdown + 112
frame #7: 0x00126e43 APNTest`ssl_ctrl + 83
frame #8: 0x00005653 APNTest`APNConnection::shutdown(this=0x00300fd0) + 83 at APNConnection.cpp:136
frame #9: 0x000055e5 APNTest`APNConnection::~APNConnection(this=0x00300fd0) + 21 at APNConnection.cpp:41
frame #10: 0x00005687 APNTest`APNConnection::~APNConnection(this=0x00300fd0) + 23 at APNConnection.cpp:40
frame #11: 0x000024d6 APNTest`APNService::run(this=0xbffff7a8) + 1190 at APNService.cpp:73
frame #12: 0x00006a6a APNTest`main + 1946 at main.cpp:36
frame #13: 0x94ce46d9 libdyld.dylib`start + 1
</code></pre>

<p>Here is the code I use to create my OpenSSL secure socket</p>

<pre><code>BIO *bio;
SSL_CTX *ctx;
SSL *ssl;

ctx = SSL_CTX_new(SSLv23_client_method());
if (!SSL_CTX_load_verify_locations(ctx, strdup(trustStoreFile.c_str()), NULL)) {...}
if (SSL_CTX_use_certificate_file(ctx, strdup(clientCertFile.c_str()), SSL_FILETYPE_PEM) &lt;= 0) {...}
if (SSL_CTX_use_PrivateKey_file(ctx, strdup(clientPKFile.c_str()), SSL_FILETYPE_PEM) &lt;= 0) {...}

bio = BIO_new_ssl_connect(ctx);
BIO_get_ssl(bio, &amp; ssl);
SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);
BIO_set_nbio(bio, 1);
BIO_set_conn_hostname(bio, serverURL.c_str());
int connErr = 0;
do {
    connErr = BIO_do_connect(bio);
} while (BIO_should_retry(bio));
</code></pre>

<p>Reading and writing data is performed using <code>BIO_write(bio, data, size)</code> and <code>BIO_read(bio, data, datasize)</code></p>

<p>Cleanup code and the one that crashes is </p>

<pre><code>SSL_CTX_free(ctx);
BIO_reset(bio);
BIO_free_all(bio);
</code></pre>

<p>BIO_reset is the one that crashes right now, but if I remove it BIO_free_all will crash. What I can do to avoid the crash is send one command at a time and after each command is sent I should wait 1 second or so to see if the server sent an error for that command or not, send one more, wait again and so on. Or another thing that helped me hide the crash is installing a dummy signal handler for SIGPIPE but these are just workarounds.</p>

<p>I'm guessing that it may be crashing because of the data queued for sending after the socket was closed. What makes me believe this is that I see that ssl3_shutdown calls some ssl3_write_pending and also because the cleanup code will not crash if I am extra careful to not do any more BIO_write(s) after I get a non-zero SSL_shutdown(). </p>

<p>Am I doing something wrong with the cleanup code or is there a way to instruct OpenSSL to discard any data when freeing the BIO and SSL objects? </p>

<p>Thank you for your help!</p>
"
"<p>My program got crashed when I call close(socket_fd) after BIO_reset function. Crash log shows invalid handle passed to close() function.</p>

<pre><code>void close_ssl_stream(BIO *bio, int socket)
{
    BIO_flush(bio);
    BIO_reset(bio);
    BIO_free_all(bio);
    ERR_clear_error();
    ERR_free_strings();
    ERR_remove_state(0);
    printf(""Closing socket fd: %d\n"", socket);
    close(socket);
}
</code></pre>

<p>Program crashes at close(socket) line.</p>

<p>I have moved close(socket) line above BIO_reset function.</p>

<pre><code> {
        BIO_flush(bio);
        printf(""Closing socket fd: %d\n"", socket);
        close(socket);
        BIO_reset(bio);
        BIO_free_all(bio);
        ERR_clear_error();
        ERR_free_strings();
        ERR_remove_state(0);
    }
</code></pre>

<p>Now it crashes at BIO_reset(bio) line.
How to free the socket file descriptor in this program? Any suggestions to improve this code is also welcomed.</p>
"
"<p>I am confused whether i need to implement the OCSP myself or does openssl implicitly implements it in SSL_get_verify_result(ssl) method. If i need to do it myself then how do i do that ? There is no proper documentation or blog that i could find which clearly states how to do it.</p>

<p>My Code to connect to openssl goes like this:</p>

<pre><code>SSL_load_error_strings();
ERR_load_BIO_strings();
OpenSSL_add_all_algorithms();

BIO * bio;
int x = 0;
long error=0;

SSL_library_init();
SSL_CTX * ctx = SSL_CTX_new(TLSv1_2_client_method());
SSL * ssl;


if(! SSL_CTX_load_verify_locations(ctx, ""CA.CRT"", NULL))
{
/* Handle failed load here */
    //Failed
}



bio = BIO_new_ssl_connect(ctx);
error = BIO_get_ssl(bio, &amp;ssl);
error = SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);

if(bio == NULL){
/* Handle the failure */
    //Failed
}




BIO_set_conn_hostname(bio, ""hostname:443"");


if(error = BIO_do_connect(bio) &lt;= 0){
/* Handle failed connection */
    //Failed
    return 0;
}



if(SSL_get_verify_result(ssl) != X509_V_OK)
{
    /* Handle the failed verification */
    //Failed
}

char buff[] = ""The entire Post request in http format"";


if(BIO_write(bio, buff, strlen(buff)) &lt;= 0)
{
if(! BIO_should_retry(bio))
{
    /* Handle failed write here */
    //Failed
}

/* Do something to handle the retry */

}


USHORT entireResSize = 0;
BYTE* babuff = NULL;
while(1)
{
    BYTE buffer[10000]={0};
    USHORT currentResSize = 10000;
    currentResSize = BIO_read(bio, buffer, currentResSize);
    if(currentResSize == 0)
    {
    /* Handle closed connection */
        //Failed
        break;
    }
    else if(currentResSize &lt; 0)
    {
    if(! BIO_should_retry(bio))
    {
    /* Handle failed read here */
        //Failed
        break;
    }
    else
    {
        entireResSize += currentResSize;
        babuff = (BYTE*) realloc(babuff,entireResSize);
        strcpy(&amp;babuff[entireResSize - currentResSize], buffer);
    }

    /* Do something to handle the retry */
    }

}


/* To reuse the connection, use this line */

BIO_reset(bio);
SSL_CTX_free(ctx);

/* To free it from memory, use this line */

BIO_free_all(bio);
</code></pre>
"
"<p>I want create a block device that get a bio with request for n sector and split it into n bio with 1 sector. I used <code>bio_split</code> but it doesn't work and reaches <code>BUG_ON</code>.</p>

<p>Is there any function to do such thing?</p>

<p>If there's not can anyone help me to write a function to do that?
It's also fine to have a function that split a bio into 4k bios.</p>
"
"<p>I'm writing a driver for the Android kernel which needs to open and eventually read from the MMC block device (e.g. ""/dev/block/mmcblk0""). Right now I'm trying to open the block device using blkdev_get_by_path() and plan to read from it by constructing a bio struct for my read and using generic_make_request() to perform the read.</p>

<p>At this point I'm taking it one step at a time and only trying to open the device and then close it once it's successfully opened (with blkdev_put()). The problem that I'm facing is that even just calling blkdev_get_by_path() is sometimes causing the kernel to crash and reboot the device.</p>

<p>Here's a bit of code:</p>

<pre><code>#define MMC_DEV ""/dev/block/mmcblk0""

void open_mmc_dev()
{
     struct block_device *mmc_dev;
     mmc_dev = blkdev_get_by_path(MMC_DEV, FMODE_READ, 0);
     if (!IS_ERR(mmc_dev))
     {
          blk_dev_put(mmc_dev);
          printk(""Opened MMC Device\n"");
     }
     else
     {
          printk(""blkdev_get_by_path failed with %ld\n"", PTR_ERR(blk_dev));
     }
}
</code></pre>

<p>I should also add that this code for opening the MMC device is being run repeatedly, by scheduling an event with mod_timer(), initially scheduled within my own driver's init function. The reason for this is that the MMC device is not initially present, so I set up this event to run every 100ms. As long as blkdev_get_by_path() is returning -ENOENT I reset my event to run again 100ms later until I successfully get the block_device pointer. What I'm seeing is that 1 out of every 3 or 4 boots will either hang the phone or cause it to reboot. On the successfull boots I'm able to verify with dmesg that I was eventually able to get a pointer to the MMC block_device. I've also tried repeatedly running my event without the calls to blkdev_get_by_path() and blkdev_put() and this doesn't cause the crashes I'm seeing, so the crash appears to be related specifically to those blkdev calls.</p>

<p>What could be causing blkdev_get_by_path() to crash?
Is there some synchronization component I'm missing required for opening a block device like this?</p>
"
"<p>I have a basic linux block filter driver (taken from <a href=""https://github.com/asimkadav/block-filter"" rel=""nofollow noreferrer"">https://github.com/asimkadav/block-filter</a> ) which i want to extend to do the following:</p>

<ol>
<li>Record IO pattern on device</li>
<li>Duplicate IO to another device</li>
</ol>

<p>I am trying to add to debugging info to ""misc_request_fn"" function but the kernel keep crashing.</p>

<p>I am not sure what i am doing wrong.
further more - how can i identify write operation and duplicate it to another device ?</p>

<blockquote>
<pre><code>#include &lt;linux/pci.h&gt;
#include &lt;linux/bug.h&gt;
#include &lt;linux/kallsyms.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/rtnetlink.h&gt;
#include &lt;linux/lockdep.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/highmem.h&gt;
#include &lt;linux/swap.h&gt;
#include &lt;linux/completion.h&gt;
#include &lt;linux/kthread.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/blkdev.h&gt;

#ifndef _MISCDEVICE_H
#define _MISCDEVICE_H

// Driver number
#define MISC_MINOR      45


// Fault injection op-codes
//
#define MISC_GET 0x101
#define MISC_PUT 0x102

#endif



static struct miscdevice misc_help;
static struct block_device *blkdev;
static void (*original_request_fn) (struct request_queue*, struct bio*);


/* Sample ioctl code - not used. Can be used to trigger on/off filtering. */
static long mischelp_ioctl(/*struct inode *inode,*/ struct file *fp,
                unsigned int cmd, unsigned long arg) {

        if (cmd == MISC_GET)    {
                printk (""Can perform get ops %d.\n"", (int) arg);
        }

        if (cmd == MISC_PUT)    {
                printk (""Can perform put ops %d.\n"", (int) arg);
        }

        return 0;
}


struct file_operations misc_fops = {
        .unlocked_ioctl = mischelp_ioctl,
        .owner = THIS_MODULE,
        .mmap = NULL,
};

void misc_request_fn(struct request_queue *q, struct bio *bio) {
        //printk (""we are passing bios.\n"");
        // here is where we trace requests...
        printk (""IO size %d\n"",bio-&gt;bi_size);
        original_request_fn (q, bio);
        return;
}


void register_block_device(char *path)  {

        struct request_queue *blkdev_queue = NULL;

        if (path == NULL)       {
                printk (""Block device empty.\n"");
                return;
        }

        printk (""Will open %s.\n"", path);

        blkdev = lookup_bdev(path);

        if (IS_ERR(blkdev))     {
                printk (""No such block device.\n"");
                return;
        }

        printk (""Found block device %p with bs %d.\n"", blkdev, blkdev-&gt;bd_block_size);
        blkdev_queue = bdev_get_queue(blkdev);
        original_request_fn = blkdev_queue-&gt;request_fn;
        blkdev_queue-&gt;request_fn = misc_request_fn;
}

void unregister_block_device(void)      {
        struct request_queue *blkdev_queue = NULL;

        blkdev_queue = bdev_get_queue(blkdev);

        if ((blkdev_queue-&gt;request_fn != NULL) &amp;&amp;
                        (original_request_fn != NULL))  {

                blkdev_queue-&gt;request_fn = original_request_fn;
                printk (""Successfully unregistered block device.\n"");
        }
}



int init_module(void)   {
        int retval = 0;
        static char *mischelp_name = ""mischelp"";

        misc_help.minor = MISC_MINOR;
        misc_help.name = mischelp_name;
        misc_help.fops = &amp;misc_fops;
        retval = misc_register(&amp;misc_help);

        if (retval)
                return retval;

        register_block_device(""/dev/sdg"");

        printk (""block tracer initialized successfully.\n"");
        return 0;
}

void cleanup_module(void){
        int number = 0;

        unregister_block_device();

        number = misc_deregister(&amp;misc_help);
        if (number &lt; 0) {
                printk (""misc_deregister failed. %d\n"", number);
        }

        printk (""It's over for block tracer.. \n"");
}
</code></pre>
</blockquote>
"
"<p>I'm doing some image processing, and I'd like to individually read each pixel value in a JPEG and PNG images.</p>

<p>In my deployment scenario, it would be awkward for me to use a 3rd party library (as I have restricted access on the target computer), but I'm assuming that there's no standard C or C++ library for reading JPEG/PNG...</p>

<p>So, if you know of a way of <em>not</em> using a library then great, if not then answers are still welcome!</p>
"
"<p>See below a main() and two very simple classes.  Then per Boost serialization (and what is shown) my questions are:</p>

<p>1)  Does class B need the normal overloaded stream insertion operators '&lt;&lt;' and '>>' to be defined?  Currently in my real code it doesn't have these.</p>

<p>2)  Does class A in the store() and load() methods need to iterate through the map and multimap containers explicitely, storing/loading their key:value pairs explicitely?
e.g.  something like:</p>

<pre><code>void A::store(const char* filename){

std::ofstream ofs(filename);
boost::archive::text_oarchive oa(ofs);

std::map&lt; std::string, B &gt;::iterator it;

BMap.size();
oa &lt;&lt; BMap.size();
for( it = BMap.begin(); it != BMap.end(); it++ ){
    oa &lt;&lt;  it-&gt;first;
    oa &lt;&lt; it-&gt;second;
}

//similar for strMultimap
}
</code></pre>

<p>I assume that I don't need to do this, but am not certain.</p>

<p>3)  Assuming class B has only the two data members shown, does it need a default contructor included explicitely? (as opposed to the implicit default constructor)</p>

<p>4)  Does B need to have an overide for the comparison operator '>'?  I assume that it doesn't since this is a very simple class.</p>

<p>Finally, any other comments per anything that I've failed to cover is appreciated!</p>

<p>Example code for my above questions:</p>

<pre><code>//includes ommitted

int main() {

    std::string file(""test.dat"");

    A * pA = new A;

    pA-&gt;store(file.c_str());
    pA-&gt;fillMaps();
    //release data
    pA-&gt;load(file.c_str());

    return 0;
}

//includes ommitted

class A
{
    friend class boost::serialization::access;

public:

    std::map&lt; std::string, B &gt; BMap;
    std::multimap&lt; std::string, std::string &gt; strMultimap;

    template&lt;class Archive&gt;
    void serialize(Archive &amp; ar, const unsigned int version)
    {
        ar &amp; BMap;
        ar &amp; strMultimap;
    }

    void store(const char* filename){

    std::ofstream ofs(filename);
    boost::archive::text_oarchive oa(ofs);
    oa &lt;&lt; this;
  }

  void load(const char* filename){

    std::ifstream ifs(filename);
    boost::archive::text_iarchive ia(ifs);
    ia &gt;&gt; this;

  }

  void fillMaps(){

//code to allocate B objects and put them in BMap and fill strMultimap with whatever number of key:value pairs

}

class B
{
friend class boost::serialization::access;

public:

    std::string str;
    unsigned int num;

    B::B(void)
    : str(""a string"")
    , num(7)
    {
    }

    template&lt;class Archive&gt;
    void serialize(Archive &amp; ar, const unsigned int version)
    {
        ar &amp; str;
        ar &amp; num;
    }
}
</code></pre>
"
"<p>I would like to load a cropped version of a bitmap image into a Bitmap object, without loading the original bitmap as well.</p>

<p>Is this at all possible without writing custom loading routines to handle the raw data?</p>

<p>Thanks,
Sandor</p>
"
"<p>How to get sparse block size and check if data is present at the given offset in sparse file in reiserfs/ext3 in Linux?</p>

<p><s>I want to use it to implement simple copy-on-write block device using FUSE.</s></p>

<p>Or I should better keep a bitmap in a separate file?</p>
"
"<p>I am on Linux and need to know either of the two things:</p>

<p>1) If i have a regular file on some file system on a partition under Linux is there a way to know the set of the physical blocks that this file occupies on the drive from user space? Or at least the set of the file system's clusters?</p>

<p>2) Is there a way to get the same information about the whole free space of the given file system?</p>

<p>In both cases i understand that if there is any possible way to extract this info it will probably be totally unsafe and racy (anything could happen to these set of blocks between the time i see them and act on them somehow). I also really don't want an implementation that will have to know a lot about every filesystem.</p>
"
"<p>So I have this code that makes a series of bytes, but then zips it with bzip2. How could I unzip them? Plain(right-click) unzipping gives me corruption, probably because there are no file beginnings or ends. It needs to be done in some programming language, preferrably C#, C, C++, Java or Python. Also, I'd need to read that binary data in the unzipped stream. I'd appreciate any help. </p>

<p>This is the code, it fills an array and compresses it with BZ2_bzBuffToBuffCompress at the end:</p>

<pre><code>void *build_save(int *size, int x0, int y0, int w, int h,
         unsigned char bmap[YRES/CELL][XRES/CELL],
         float fvx[YRES/CELL][XRES/CELL],
         float fvy[YRES/CELL][XRES/CELL], sign signs[MAXSIGNS],
         void* partsptr)
{
  unsigned char *d=calloc(1,3*(XRES/CELL)*(YRES/CELL)+(XRES*YRES)*15+MAXSIGNS*262), *c;
  int i,j,x,y,p=0,*m=calloc(XRES*YRES, sizeof(int));
  int bx0=x0/CELL, by0=y0/CELL, bw=(w+CELL-1)/CELL, bh=(h+CELL-1)/CELL;
  particle *parts = partsptr;

  // normalize coordinates
  x0 = bx0*CELL;
  y0 = by0*CELL;
  w = bw *CELL;
  h = bh *CELL;

  // save the required air state
  for (y=by0; y&lt;by0+bh; y++)
    for (x=bx0; x&lt;bx0+bw; x++)
      d[p++] = bmap[y][x];
  for (y=by0; y&lt;by0+bh; y++)
    for (x=bx0; x&lt;bx0+bw; x++)
      if (bmap[y][x]==WL_FAN||bmap[y][x]==4){
    i = (int)(fvx[y][x]*64.0f+127.5f);
      if (i&lt;0) i=0;
      if (i&gt;255) i=255;
      d[p++] = i;
      }
  for (y=by0; y&lt;by0+bh; y++)
    for (x=bx0; x&lt;bx0+bw; x++)
      if (bmap[y][x]==WL_FAN||bmap[y][x]==4){
    i = (int)(fvy[y][x]*64.0f+127.5f);
    if (i&lt;0) i=0;
    if (i&gt;255) i=255;
    d[p++] = i;
      }

  // save the particle map
  for (i=0; i&lt;NPART; i++)
    if (parts[i].type) {
    x = (int)(parts[i].x+0.5f);
    y = (int)(parts[i].y+0.5f);
    if (x&gt;=x0 &amp;&amp; x&lt;x0+w &amp;&amp; y&gt;=y0 &amp;&amp; y&lt;y0+h) {
      if (!m[(x-x0)+(y-y0)*w] ||
          parts[m[(x-x0)+(y-y0)*w]-1].type == PT_PHOT ||
          parts[m[(x-x0)+(y-y0)*w]-1].type == PT_NEUT)
        m[(x-x0)+(y-y0)*w] = i+1;
    }
    }
  for (j=0; j&lt;w*h; j++) {
    i = m[j];
    if (i)
      d[p++] = parts[i-1].type;
    else
      d[p++] = 0;
  }

  // save particle properties
  for (j=0; j&lt;w*h; j++){
    i = m[j];
    if (i)
      {
    i--;
    x = (int)(parts[i].vx*16.0f+127.5f);
    y = (int)(parts[i].vy*16.0f+127.5f);
    if (x&lt;0) x=0;
    if (x&gt;255) x=255;
    if (y&lt;0) y=0;
    if (y&gt;255) y=255;
    d[p++] = x;
    d[p++] = y;
      }
  }
  for (j=0; j&lt;w*h; j++){
    i = m[j];
    if (i) {
      //Everybody loves a 16bit int
      //d[p++] = (parts[i-1].life+3)/4;
      int ttlife = (int)parts[i-1].life;
      d[p++] = ((ttlife&amp;0xFF00)&gt;&gt;8);
      d[p++] = (ttlife&amp;0x00FF);
    }
  }
  for (j=0; j&lt;w*h; j++){
    i = m[j];
    if (i) {
      //Now saving tmp!
      //d[p++] = (parts[i-1].life+3)/4;
      int tttmp = (int)parts[i-1].tmp;
      d[p++] = ((tttmp&amp;0xFF00)&gt;&gt;8);
      d[p++] = (tttmp&amp;0x00FF);
        }
  }
  for (j=0; j&lt;w*h; j++){
    i = m[j];
    if (i) {
      //Save colour (ALPHA)
      d[p++] = (parts[i-1].dcolour&amp;0xFF000000)&gt;&gt;24;
    }
  }
  for (j=0; j&lt;w*h; j++){
    i = m[j];
    if (i) {
      //Save colour (RED)
      d[p++] = (parts[i-1].dcolour&amp;0x00FF0000)&gt;&gt;16;
    }
  }
  for (j=0; j&lt;w*h; j++){
    i = m[j];
    if (i) {
      //Save colour (GREEN)
      d[p++] = (parts[i-1].dcolour&amp;0x0000FF00)&gt;&gt;8;
    }
  }
  for (j=0; j&lt;w*h; j++){
    i = m[j];
    if (i) {
      //Save colour (BLUE)
          d[p++] = (parts[i-1].dcolour&amp;0x000000FF);
    }
  }
  for (j=0; j&lt;w*h; j++){
    i = m[j];
    if (i){
      // New Temperature saving uses a 16bit unsigned int for
      // temperatures, giving a precision of 1 degree versus 36 for the old
      // format
      int tttemp = (int)parts[i-1].temp;
      d[p++] = ((tttemp&amp;0xFF00)&gt;&gt;8);
      d[p++] = (tttemp&amp;0x00FF);
    }
  }
  for (j=0; j&lt;w*h; j++) {
    i = m[j];
    if (i &amp;&amp; (parts[i-1].type==PT_CLNE || parts[i-1].type==PT_PCLN ||
          parts[i-1].type==PT_BCLN || parts[i-1].type==PT_SPRK ||
          parts[i-1].type==PT_LAVA || parts[i-1].type==PT_PIPE))
      d[p++] = parts[i-1].ctype;
  }

  j = 0;
  for (i=0; i&lt;MAXSIGNS; i++)
    if (signs[i].text[0] &amp;&amp;
    signs[i].x&gt;=x0 &amp;&amp; signs[i].x&lt;x0+w &amp;&amp;
    signs[i].y&gt;=y0 &amp;&amp; signs[i].y&lt;y0+h)
      j++;
  d[p++] = j;
  for (i=0; i&lt;MAXSIGNS; i++)
    if (signs[i].text[0] &amp;&amp;
    signs[i].x&gt;=x0 &amp;&amp; signs[i].x&lt;x0+w &amp;&amp;
    signs[i].y&gt;=y0 &amp;&amp; signs[i].y&lt;y0+h){
      d[p++] = (signs[i].x-x0);
      d[p++] = (signs[i].x-x0)&gt;&gt;8;
          d[p++] = (signs[i].y-y0);
      d[p++] = (signs[i].y-y0)&gt;&gt;8;
      d[p++] = signs[i].ju;
      x = strlen(signs[i].text);
      d[p++] = x;
      memcpy(d+p, signs[i].text, x);
      p+=x;
    }

  i = (p*101+99)/100 + 612;
  c = malloc(i);

  //New file header uses PSv, replacing fuC. This is to detect if the
  //client uses a new save format for temperatures
  //This creates a problem for old clients, that display and ""corrupt""
  //error instead of a ""newer version"" error

  c[0] = 0x50; //0x66;
  c[1] = 0x53; //0x75;
  c[2] = 0x76; //0x43;
  c[3] = legacy_enable|((sys_pause&lt;&lt;1)&amp;0x02)|((gravityMode&lt;&lt;2)&amp;0x0C)|((airMode&lt;&lt;4)&amp;0x70)|((ngrav_enable&lt;&lt;7)&amp;0x80);
  c[4] = SAVE_VERSION;
  c[5] = CELL;
  c[6] = bw;
  c[7] = bh;
  c[8] = p;
  c[9] = p &gt;&gt; 8;
  c[10] = p &gt;&gt; 16;
  c[11] = p &gt;&gt; 24;

  i -= 12;

  if (BZ2_bzBuffToBuffCompress((char *)(c+12), (unsigned *)&amp;i, (char *)d, p, 9, 0, 0) != BZ_OK){
    free(d);
    free(c);
    free(m);
    return NULL;
  }
  free(d);
  free(m);

  *size = i+12;
  return c;
}
</code></pre>
"
"<pre><code>void destroy()
{
    AList::const_iterator a;
    for(a = AList.begin(); a != AList.end();)
    {
        if(!a-&gt;second.BList.empty())
            a-&gt;second.BList.clear();//will give error if not mutable
    }
}
typedef std::map&lt;unsigned int,int&gt; bmap;
typedef std::map&lt;unsigned int,someStruct&gt; Alist;
typedef struct someStruct
{
    float x,y,z;
    bmap BList; //needs to be mutable for Blist.clear() above.
    //mutable bmap BList; //&lt;---like this
} someStruct;
</code></pre>

<p>I only chanced across mutable as an option in a similar but not the same question. My question is am I doing the right thing, or if there are any pitfalls in doing so? Thank you for your help in advance.</p>

<pre><code>//error given: (if otherwise not mutable)
// error: passing 'const AList' as 'this' argument of 'void std::map&lt;_Key, _Tp, _Compare, _Alloc&gt;::clear() [with _Key = unsigned int, _Tp = int, _Compare = std::less&lt;unsigned int&gt;, _Alloc = std::allocator&lt;std::pair&lt;const unsigned int, int&gt; &gt;]' discards qualifiers
</code></pre>
"
"<p>Hello guys i am new to android so be gentle with me :),<br>
I have gallery i need to load images i have lot's of them, the performance on image loading i have solved by using AsyncTask.
<br></p>

<p>Now i have the scrolling on gallery problem, it's skips images and it's not looking nice.</p>

<p>Now i have tried to implement my custom Gallery and no success on that, it's just won't work
<br/>
now i have one more question the </p>

<pre><code>final ScrollableGallery galleryView = (ScrollableGallery)findViewById(R.id.gallery); //always returns null
</code></pre>

<p>suddenly , can you explane why please? </p>

<p>Here's the code:
<br></p>

<pre><code>import android.content.Context;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.widget.Gallery;

public class ScrollableGallery extends Gallery {

    public ScrollableGallery(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    public ScrollableGallery(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public ScrollableGallery(Context context) {
        super(context);
    }

    @Override
    public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {

        // limit the max speed in either direction
        if (velocityX &gt; 1200.0f) {
            velocityX = 1200.0f;
        } else if (velocityX &lt; 1200.0f) {
            velocityX = -1200.0f;
        }
        return super.onFling(e1, e2, velocityX, velocityY);
    }
}
</code></pre>

<p>The XML part:<br/></p>

<pre><code>&lt;ScrollableGallery
        android:id=""@+id/gallery""
        android:layout_width=""675dp""
        android:layout_height=""492dp""
        android:layout_marginLeft=""62dp""
        android:layout_marginTop=""225dp""
        android:scaleType=""fitXY"" &gt;
    &lt;/ScrollableGallery&gt;
</code></pre>

<p><br/>
The Actvity Invocation:<br/>
The initiation</p>

<pre><code>final ScrollableGallery galleryView = (ScrollableGallery)findViewById(R.id.gallery);
</code></pre>

<p><br/></p>

<p>The adapter initiation:<br/></p>

<pre><code>galleryV.setAdapter(new BaseAdapter() {
            public int getCount() {
                return _imageList.size();
            }

            public Object getItem(int position) {
                return _imageList.get(position);
            }

            public long getItemId(int position) {
                _position = position;
                return position;
            }

            public View getView(final int position, View convertView,final ViewGroup parent) {
                if (convertView == null) {
                    convertView = new ImageView(Database.this);
                }
                ImageDispatcher dispatch = new ImageDispatcher(((ImageView) convertView));
                dispatch.execute(_imageList.get(position));
                ((ImageView) convertView).setScaleType(ImageView.ScaleType.FIT_XY);
                ((ImageView) convertView).setLayoutParams(new ScrollableGallery.LayoutParams(675, 492));

                return convertView;
            }
        });
&lt;br/&gt;
The image dispatcher:

    import java.lang.ref.WeakReference;
    import android.graphics.Bitmap;
    import android.graphics.BitmapFactory;
    import android.os.AsyncTask;
    import android.widget.ImageView;

    public class ImageDispatcher extends AsyncTask&lt;String, Void, Bitmap&gt; {

        private final WeakReference&lt;ImageView&gt; imageViewReference;

        public ImageDispatcher(ImageView imageView) {
            imageViewReference = new WeakReference&lt;ImageView&gt;(imageView);
        }

        @Override
        // Actual download method, run in the task thread
        protected Bitmap doInBackground(String... params) {

            return ShrinkBitmap(params[0], 300 ,300);
        }

        @Override
        protected void onPostExecute(Bitmap bitmap) {
            if (isCancelled()) {
                bitmap = null;
            }

            if (imageViewReference != null) {
                ImageView imageView = imageViewReference.get();
                if (imageView != null) {
                    imageView.setImageBitmap(bitmap);
                }
            }
        }

        /*********************************************************
         * PRIVATE METHODS
         *********************************************************/
        @SuppressWarnings(""unused"")
        private Bitmap ShrinkBitmap(String file, int width, int height) {
            BitmapFactory.Options bmpFactoryOptions = new BitmapFactory.Options();
            bmpFactoryOptions.inTempStorage = new byte[16 * 1024];
            bmpFactoryOptions.inJustDecodeBounds = true;
            Bitmap bitmap = BitmapFactory.decodeFile(file, bmpFactoryOptions);
            int heightRatio = (int) Math.ceil(bmpFactoryOptions.outHeight / (float) height);
            int widthRatio = (int) Math.ceil(bmpFactoryOptions.outWidth / (float) width);

            bmpFactoryOptions.inSampleSize = heightRatio &gt; 1 || widthRatio &gt; 1 ? heightRatio : widthRatio;
            bmpFactoryOptions.inJustDecodeBounds = false;
            bitmap = BitmapFactory.decodeFile(file, bmpFactoryOptions);
            return bitmap;
        }

        @SuppressWarnings(""unused"")
        private Bitmap ShrinkBitmap(String file) {
            BitmapFactory.Options bmpFactoryOptions = new BitmapFactory.Options();
            bmpFactoryOptions.inTempStorage = new byte[16 * 1024];
            bmpFactoryOptions.inJustDecodeBounds = true;

            Bitmap bMap = BitmapFactory.decodeFile(file);
            Bitmap bMapScaled = Bitmap.createScaledBitmap(bMap,150, 100, true);

            return bMapScaled;
        }
    }
</code></pre>

<p>I think it's all the code that i have for this part,
now is the question:<br/>
How do i make the scroll, one image in time, and how do i show loading indicator like i do in web when i load images ???</p>

<p>Any code fixing would be highly appreciated ! </p>

<p>Thank you in advance...</p>
"
"<p>I have a question which is confusing me and my task is to work out fragmentation.</p>

<pre><code>stat() for a file:
st_size = 10520
st_blksize = 4096
st_blocks = 24
</code></pre>

<p>I have read in some places that st_blksize is the general block size of the file system which in this case is <code>4096</code> but that file would fit into <code>3 blocks</code>, <code>10520 / 512</code> is <code>20.5</code> meaning that there are <code>3.5 blocks</code> of unused space, even though it is allocated. Does this mean that there are <code>1792</code> unused bytes in this file (fragmentation)?</p>

<p>As I have mentioned I read into this a fair bit and have read a lot of contradicting texts, would like someone to clear this up once and for all!</p>
"
"<p>How can i improve my gridView performance? Scrolling is not smooth. </p>

<p>Here's my code:</p>

<pre><code>public View getView(final int position, View convertView, ViewGroup parent) {

        View MyView;

        // Inflate the layout
        LayoutInflater li = ((Activity) MyContext).getLayoutInflater();

        MyView = li.inflate(R.layout.gallery_adapter, null);
        ImageButton imageFolders = (ImageButton) MyView.findViewById(R.id.folder);


        try {

            imageFolders.setImageBitmap(bMap);
            imageFolders.setOnClickListener(this);
            imageFolders.setId(products.get(position).getId());
        } catch (Exception e) {

        }

        MyView.setLayoutParams(70, 70);
        return MyView;
    }
</code></pre>

<p>I have something like 200 images on this gridView, but the performance is very, very bad. </p>
"
"<p>As the title suggests, i'm having trouble figuring out how the Unix kernel converts a logical file offset into a logical block number and then retrieves it from the i-node.</p>

<p>As a reference, i'm asking a more detailed explanation of the ""bmap"" algorithm described first in ""The Design of the UNIX Operating System"" by Maurice J. Bach.</p>

<p>Thank you..</p>
"
"<p>I need to get hold of the width and height values from the bmp so that I can pass those as arguments when I later create a gdk pixmap from the raw pixeldata in the bitmap.
I did some research on the BMP-format and the file header should look like this:</p>

<pre><code>struct Fileheader
{
    unsigned short Type;          // signature - 'BM'
    unsigned  long Size;          // file size in bytes
    unsigned short Reserved1;     // 0
    unsigned short Reserved2;     // 0
    unsigned long  OffBits;       // offset to bitmap
    unsigned long  StructSize;    // size of this struct (40)
    unsigned long  Width;         // bmap width in pixels
    unsigned long  Height;        // bmap height in pixels
    unsigned short Planes;        // num planes - always 1
    unsigned short BitCount;      // bits per pixel
    unsigned long  Compression;   // compression flag
    unsigned long  SizeImage;     // image size in bytes
    long           XPelsPerMeter; // horz resolution
    long           YPelsPerMeter; // vert resolution
    unsigned long  ClrUsed;       // 0 -&gt; color table size
    unsigned long  ClrImportant;  // important color count
    Fileheader()
    {
        Size=Width=Height=Planes=BitCount=Compression=SizeImage=XPelsPerMeter= YPelsPerMeter=ClrUsed=ClrImportant=Type=StructSize=Reserved1=Reserved2=OffBits=0;}
    };
}
</code></pre>

<p>after fetching the blob the standard way into row[0]</p>

<pre><code>Fileheader fh;
memcpy(&amp;fh, row[0], sizeof(Fileheader));
</code></pre>

<p>will give just gibberish values when</p>

<pre><code>cout &lt;&lt; ""width: "" &lt;&lt; fh.Width &lt;&lt; "", height: "" &lt;&lt; fh.Height &lt;&lt; endl;
</code></pre>

<p>namely: width: 65536, height: 5626121834492592128</p>

<p>Anyone see what's wrong here? I'm on a 64-bit linux box BTW.</p>
"
"<p>I'm trying to move a unordered_map of unique_ptr's into another map, but getting the compile error below.</p>

<pre><code>#include &lt;memory&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;

int main()
{
    std::unordered_map&lt;int, std::unique_ptr&lt;int&gt;&gt; aMap;
    std::unordered_map&lt;int, std::unique_ptr&lt;int&gt;&gt; bMap;

    std::unique_ptr&lt;int&gt; ptr(new int);
    *ptr = 10;
    aMap.insert(std::make_pair(0, std::move(ptr)));

    std::move(aMap.begin(), aMap.end(), bMap.end());


    return 0;
}


1&gt;------ Build started: Project: Testing, Configuration: Debug Win32 ------
1&gt;Build started 08.07.2012 23:54:16.
1&gt;InitializeBuildStatus:
1&gt;  Creating ""Debug\Testing.unsuccessfulbuild"" because ""AlwaysCreate"" was specified.
1&gt;ClCompile:
1&gt;  main.cpp
1&gt;d:\progs\visual studio 2010\vc\include\utility(260): error C2166: l-value specifies const object
1&gt;          d:\progs\visual studio 2010\vc\include\utility(259) : while compiling     class template member function 'std::pair&lt;_Ty1,_Ty2&gt; &amp;std::pair&lt;_Ty1,_Ty2&gt;::operator =(std::pair&lt;_Ty1,_Ty2&gt; &amp;&amp;)'
1&gt;          with
1&gt;          [
1&gt;              _Ty1=const int,
1&gt;              _Ty2=std::unique_ptr&lt;int&gt;
1&gt;          ]
1&gt;          d:\coding\testing\main.cpp(12) : see reference to class template instantiation 'std::pair&lt;_Ty1,_Ty2&gt;' being compiled
1&gt;          with
1&gt;          [
1&gt;              _Ty1=const int,
1&gt;              _Ty2=std::unique_ptr&lt;int&gt;
1&gt;          ]
1&gt;
1&gt;Build FAILED.
1&gt;
1&gt;Time Elapsed 00:00:00.64
========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========
</code></pre>
"
"<p>EDIT: If you're going to be doing things with GRIB files I would recommend the <a href=""http://www.gdal.org/"" rel=""nofollow"">GDAL library</a> which is backed by the <a href=""http://www.osgeo.org/"" rel=""nofollow"">Open Source Geospatial Foundation</a>. You will save yourself a lot of headache :) </p>

<p>I'm using Qt creator in Ubuntu creating a c++ app.  I am attempting to use an external lib, libgrib2c.a, that has a header grib2.h.  Everything compiles, but when it tries to link I get the error:</p>

<blockquote>
  <p>undefined reference to 'seekgb(_IO_FILE*, long, long, long*, long*)</p>
</blockquote>

<p>I have tried wrapping the header file with:</p>

<pre><code>extern ""C""{
#include ""grib2.h""
}
</code></pre>

<p>But it didn't fix anything so I figured that was not my problem. In the .pro file I have the line:</p>

<pre><code>include($${ROOT}/Shared/common/commonLibs.pri)
</code></pre>

<p>and in commonLibs.pri I have:</p>

<pre><code>INCLUDEPATH+=$${ROOT}/external_libs/g2clib/include
LIBS+=-L$${ROOT}/external_libs/g2clib/lib
LIBS+=-lgrib2c
</code></pre>

<p>I am not encountering an error finding the library.  If I do a nm command on the libgrib2c.a I get:</p>

<pre><code>nm libgrib2c.a | grep seekgb
seekgb.o:
00000000 T seekgb
</code></pre>

<p>And when I run qmake with the additional argument of LIBS+=-Wl,--verbose I can find the lib file in the output:</p>

<pre><code>attempt to open /usr/lib/libgrib2c.so failed
attempt to open /usr/lib/libgrib2c.a failed
attempt to open /mnt/sdb1/ESMF/App/ESMF_App/../external_libs/linux/qwt_6.0.2/lib/libgrib2c.so failed
attempt to open /mnt/sdb1/ESMF/App/ESMF_App/../external_libs/linux/qwt_6.0.2/lib/libgrib2c.a failed
attempt to open ..//Shared/Config/lib/libgrib2c.so failed
attempt to open ..//Shared/Config/lib/libgrib2c.a failed
attempt to open ..//external_libs/libssh2/lib/libgrib2c.so failed
attempt to open ..//external_libs/libssh2/lib/libgrib2c.a failed
attempt to open ..//external_libs/openssl/lib/libgrib2c.so failed
attempt to open ..//external_libs/openssl/lib/libgrib2c.a failed
attempt to open ..//external_libs/g2clib/lib/libgrib2c.so failed
attempt to open ..//external_libs/g2clib/lib/libgrib2c.a succeeded
</code></pre>

<p>Although it doesn't show any of the .o files in the library is this because it is a c library in my c++ app?  </p>

<p>in the .cpp file that I am trying to use the library I have:</p>

<pre><code>#include ""gribreader.h""
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;external_libs/g2clib/include/grib2.h&gt;
#include &lt;Shared/logging/Logger.hpp&gt;

//------------------------------------------------------------------------------
/// Opens a GRIB file from disk.
///
/// This function opens the grib file and searches through it for how many GRIB
/// messages are contained as well as their starting locations.
///
/// \param a_filePath. The path to the file to be opened.
/// \return True if successful, false if not.
//------------------------------------------------------------------------------
bool GRIBReader::OpenGRIB(std::string a_filePath)
{
  LOG(notification)&lt;&lt;""Attempting to open grib file: ""&lt;&lt; a_filePath;
  if(isOpen())
  {
    CloseGRIB();
  }
  m_filePath = a_filePath;
  m_filePtr = fopen(a_filePath.c_str(), ""r"");

  if(m_filePtr == NULL)
  {
    LOG(error)&lt;&lt;""Unable to open file: "" &lt;&lt; a_filePath;
    return false;
  }
  LOG(notification)&lt;&lt;""Successfully opened GRIB file"";

  g2int currentMessageSize(1);
  g2int seekPosition(0);
  g2int lengthToBeginningOfGrib(0);
  g2int seekLength(32000);
  int i(0);
  int iterationLimit(300);
  m_GRIBMessageLocations.clear();
  m_GRIBMessageSizes.clear();
  while(i &lt; iterationLimit)
  {
    seekgb(m_filePtr, seekPosition, seekLength,
           &amp;lengthToBeginningOfGrib, &amp;currentMessageSize);
    if(currentMessageSize != 0)
    {
      LOG(verbose) &lt;&lt; ""Adding GRIB message location "" &lt;&lt; lengthToBeginningOfGrib
                   &lt;&lt; "" with length "" &lt;&lt; currentMessageSize;
      m_GRIBMessageLocations.push_back(lengthToBeginningOfGrib);
      m_GRIBMessageSizes.push_back(currentMessageSize);

      seekPosition = lengthToBeginningOfGrib + currentMessageSize;
      LOG(verbose) &lt;&lt; ""GRIB seek position moved to "" &lt;&lt; seekPosition;
    }
    else
    {
      LOG(notification)&lt;&lt;""End of GRIB file found, after ""&lt;&lt; i
                      &lt;&lt; "" GRIB messages."";
      break;
    }
  }
  if(i &gt;= iterationLimit)
  {
    LOG(warning) &lt;&lt; ""The iteration limit of "" &lt;&lt; iterationLimit
                 &lt;&lt; ""was reached while searching for GRIB messages"";
  }
  return true;
}
</code></pre>

<p>And the header grib2.h is as follows:</p>

<pre><code>#ifndef _grib2_H
#define _grib2_H
#include&lt;stdio.h&gt;

#define G2_VERSION ""g2clib-1.4.0""
#ifdef __64BIT__
typedef int g2int;
typedef unsigned int g2intu;
#else
typedef long g2int;
typedef unsigned long g2intu;
#endif
typedef float g2float;

struct gtemplate {
   g2int type;           /* 3=Grid Defintion Template.                       */
                         /* 4=Product Defintion Template.                    */
                         /* 5=Data Representation Template.                  */
   g2int num;            /* template number.                                 */
   g2int maplen;         /* number of entries in the static part             */
                         /*                    of the template.              */
   g2int *map;           /* num of octets of each entry in the               */
                         /*         static part of the template.             */
   g2int needext;        /* indicates whether or not the template needs      */
                         /*     to be extended.                              */
   g2int extlen;         /* number of entries in the template extension.     */
   g2int *ext;           /* num of octets of each entry in the extension     */
                         /*                      part of the template.       */
};

typedef struct gtemplate gtemplate;

struct gribfield {
   g2int   version,discipline;
   g2int   *idsect;
   g2int   idsectlen;
   unsigned char *local;
   g2int   locallen;
   g2int   ifldnum;
   g2int   griddef,ngrdpts;
   g2int   numoct_opt,interp_opt,num_opt;
   g2int   *list_opt;
   g2int   igdtnum,igdtlen;
   g2int   *igdtmpl;
   g2int   ipdtnum,ipdtlen;
   g2int   *ipdtmpl;
   g2int   num_coord;
   g2float *coord_list;
   g2int   ndpts,idrtnum,idrtlen;
   g2int   *idrtmpl;
   g2int   unpacked;
   g2int   expanded;
   g2int   ibmap;
   g2int   *bmap;
   g2float *fld;
};

typedef struct gribfield gribfield;


/*  Prototypes for unpacking API  */
void seekgb(FILE *,g2int ,g2int ,g2int *,g2int *);
g2int g2_info(unsigned char *,g2int *,g2int *,g2int *,g2int *);
g2int g2_getfld(unsigned char *,g2int ,g2int ,g2int ,gribfield **);
void g2_free(gribfield *);

/*  Prototypes for packing API  */
g2int g2_create(unsigned char *,g2int *,g2int *);
g2int g2_addlocal(unsigned char *,unsigned char *,g2int );
g2int g2_addgrid(unsigned char *,g2int *,g2int *,g2int *,g2int );
g2int g2_addfield(unsigned char *,g2int ,g2int *,
                       g2float *,g2int ,g2int ,g2int *,
                       g2float *,g2int ,g2int ,g2int *);
g2int g2_gribend(unsigned char *);

/*  Prototypes for supporting routines  */
extern double int_power(double, g2int );
extern void mkieee(g2float *,g2int *,g2int);
void rdieee(g2int *,g2float *,g2int );
extern gtemplate *getpdstemplate(g2int);
extern gtemplate *extpdstemplate(g2int,g2int *);
extern gtemplate *getdrstemplate(g2int);
extern gtemplate *extdrstemplate(g2int,g2int *);
extern gtemplate *getgridtemplate(g2int);
extern gtemplate *extgridtemplate(g2int,g2int *);
extern void simpack(g2float *,g2int,g2int *,unsigned char *,g2int *);
extern void compack(g2float *,g2int,g2int,g2int *,unsigned char *,g2int *);
void misspack(g2float *,g2int ,g2int ,g2int *, unsigned char *, g2int *);
void gbit(unsigned char *,g2int *,g2int ,g2int );
void sbit(unsigned char *,g2int *,g2int ,g2int );
void gbits(unsigned char *,g2int *,g2int ,g2int ,g2int ,g2int );
void sbits(unsigned char *,g2int *,g2int ,g2int ,g2int ,g2int );

int pack_gp(g2int *, g2int *, g2int *,
            g2int *, g2int *, g2int *, g2int *, g2int *,
            g2int *, g2int *, g2int *, g2int *,
            g2int *, g2int *, g2int *, g2int *, g2int *,
            g2int *, g2int *, g2int *);

#endif  /*  _grib2_H  */
</code></pre>

<p>I have been scratching my head for two days on this. If anyone has an idea on what to do or can point me in some sort of direction, I'm stumped.  Also, if you have any comments on how I can improve this post I'd love to hear them, kinda new at this posting thing.  Usually I'm able to find an answer in the vast stores of knowledge already contained on the web.</p>
"
"<p>I'm working on some code that was originally made in MSVC and I'm trying to get it to compile on Clang (using Xcode). The code I've got is something like this:</p>

<pre><code>#define DO_MAPPING(x,y,z)\
    myMaps[map##x] = GetTex( #x##""Map"" );\
    myRemaps[map##x] = GetHandle( #x##""Remap"" );
</code></pre>

<p>Currently I'm getting a build error saying that pasting formed the string <code>""Height""""Map""</code>, where I really want <code>""HeightMap""</code>. This code works on MSVC, is there something about Clang's macro syntax that means this kind of thing needs to be written differently?</p>
"
"<p>I'm creating my own custom Filter class for use in boost::filtered_graph.  The WeightMap concept must have a default constructor, copy constructor, and assignment operator.</p>

<p>I've created the class below, which has a std::shared_ptr private member.  My question is how I'm supposed to write the assignment operator.  The copy constructor wasn't a problem, but the assignment operator doesn't work.</p>

<pre><code>class BFDMFilter
{
private:
const BGraph* m_battlemap;
const std::shared_ptr&lt;MoveAbility&gt; m_mv_ab;

public:
BFDMFilter() : m_battlemap(nullptr), m_mv_ab() { }
BFDMFilter(const BGraph* bmap, std::shared_ptr&lt;MoveAbility&gt; mv) : m_battlemap(bmap), m_mv_ab(mv) { }

BFDMFilter(const BFDMFilter&amp; filter) : m_battlemap(filter.m_battlemap), m_mv_ab(filter.m_mv_ab) { }
BFDMFilter&amp; operator=(const BFDMFilter&amp; filter)
{
  if(this != &amp;filter)
  {
m_battlemap = filter.m_battlemap;
m_mv_ab = filter.m_mv_ab;
  }

  return *this;
}

bool operator()(const Edge&amp; edge) const
{
  Tile::TileEdge path = (*m_battlemap)[edge];

  return m_mv_ab-&gt;CanMove(path.TerrainType()) &gt; 0.0;
}

bool operator()(const Vertex&amp; vertex) const
{
  Tile tile = (*m_battlemap)[vertex];

  return m_mv_ab-&gt;CanMove(tile.TerrainType()) &gt; 0.0;
}
};
</code></pre>

<p>Which then gives me a compile error:</p>

<pre><code>error: passing ?const std::shared_ptr&lt;momme::battle::MoveAbility&gt;? as ?this? argument of ?std::shared_ptr&lt;_Tp&gt;&amp; std::shared_ptr&lt;_Tp&gt;::operator=(std::shared_ptr&lt;_Tp&gt;&amp;&amp;) [with _Tp = momme::battle::MoveAbility, std::shared_ptr&lt;_Tp&gt; = std::shared_ptr&lt;momme::battle::MoveAbility&gt;]? discards qualifiers [-fpermissive]
</code></pre>

<p>I understand why; the assignment operator modifies the reference count of the shared_ptr when it does the assignment, so that it can keep track of how many open references there are.  But then, how do I write the assignment operator?  std::weak_ptr has the same behavior, and if I make the reference non-const, then the boost library complains that the function is deleted.</p>
"
"<p>trying to get my own filesystem working using fuse (filesystem in user space, linux) im really curious on where to get detailed up to date documentation of the operations used?</p>

<p>most time i search for other file system implementations and see what they do, but some operations seem to be not widely used like poll/ioctl or bmap.
and the documentation of the fuse api doesnt help much, cause e.g. the parameters and return values of the operations are not documented thus i have to guess how to use em</p>

<p>so the question is where do i get better information about how such exotic operations are supposed to be implemented?</p>

<p>thx</p>
"
"<p>I want to do something before writing data into hard disk. I don't known any solutions. To avoid editing kernel source code, is there any locations that I can use hook function as a loadable module?</p>

<p>UPDATE: Thanks all, LSM is good for API hooks. But I want to find other solution that provides mechanism hook read/write block of data. It can avoid re-encrypting all file after updating file.</p>

<p>I think there is something that I can modify between filesystem (ext2, ext3,...) and buffer cache.</p>
"
"<p>According to MSDN:</p>

<blockquote>
  <p>StretchBlt creates a mirror image of a bitmap if the signs of the nWidthSrc and nWidthDest parameters or if the nHeightSrc and nHeightDest parameters differ. </p>
</blockquote>

<p>So I tried creating upside-down image. I have a class looking like this:</p>

<pre><code>class Picture
{
 private:
 HBITMAP bmp; //Bitmap
 HDC pdc; //Device context
 short int w; //Weidth of bitmap
 short int h; //Heighth of bitmap

 public:
 short int x;
 short int y;
 void draw(HDC);
 void upside_down();
}
</code></pre>

<p>and I have this method:</p>

<pre><code>void Picture::upside_down()
{
 HDC dc = CreateCompatibleDC(pdc);
 HBITMAP bmap = CreateCompatibleBitmap(pdc, w, h);
 SelectObject(dc, bmap);
 BitBlt(dc, 0, 0, w, h, pdc, 0, 0, SRCCOPY);
 StretchBlt(pdc, 0, 0, w, h, dc, 0, 0, w, -h, SRCCOPY);
 DeleteDC(dc);
 DeleteObject(bmap);
}
</code></pre>

<p>but it doesn't work, nothing happens. I wonder if it's something with DC compability, I've always had problems understanding the logic behind that.</p>

<p>So, what should I do so I could get my bitmap flipped?</p>
"
"<p>I'm parsing some data from string maps to a different structs, each with their own set of member variables. The setup could be something like this:</p>

<pre><code>struct AStruct
{
    int a;
    float b;
};


map&lt;string,string&gt; aMap;
aMap[""a""] = ""3"";
aMap[""b""] = ""2.42"";

struct BStruct
{
    string a;
    char b;
};

map&lt;string,string&gt; bMap;
bMap[""a""] = ""asdf"";
bMap[""b""] = 'k';
</code></pre>

<p>As there are many structs but few contained primitives, I have created a helpful set of templated parsing functions:</p>

<pre><code>template &lt;typename T&gt;
void parse(string origin, T&amp; dest);
</code></pre>

<p>Now, in order to prevent myself from having to define a different function to assign the values to each struct, I can use a macro, something like this:</p>

<pre><code>#define ASSIGN(map, dest, param0Name, param1Name) \
    dest.param0Name = map[#param0Name]; \
    dest.param1Name = map[#param1Name]; \
</code></pre>

<p>and assign like so:</p>

<pre><code>AStruct myA;
ASSIGN(aMap, myA, a, b);
</code></pre>

<p>This is a big help. But in reality my structs all have a different number of members, requiring a new macro to be defined in each case.</p>

<p><strong>Is there a way I can pass an array of symbols to the macro and iterate through those?</strong></p>

<p>Something like this:</p>

<p>ASSIGN(map, dest, { param0Name, param1Name, param2Name })</p>
"
"<p>I've been attempting to code a Bi-Cubic resize algorithm for in-memory bitmaps.  I'm familiar with how bi-cubic interpolation works, and I've used both the <a href=""http://en.wikipedia.org/wiki/Bicubic_interpolation"" rel=""nofollow noreferrer"">Wikipedia article</a> and <a href=""http://code.google.com/a/eclipselabs.org/p/bicubic-interpolation-image-processing/source/browse/trunk/test.c?r=2"" rel=""nofollow noreferrer"">existing implementations</a> as a guide towards coding my own version.</p>

<p>The following is my simple implementation.  Here, <code>bmap</code> is a <code>vector</code> containing the bitmap data, and <code>get_subpixel</code> is simply a function that treats the bitmap as a 3D array composed of <code>X x Y x Channel</code> pixels, and returns a single sub-pixel at the specified coordinates.</p>

<pre><code>std::vector&lt;unsigned char&gt; bicubic_resize(
    std::vector&lt;unsigned char&gt;&amp; bmap, std::size_t bmap_width, std::size_t bmap_height,
    std::size_t channels, std::size_t dest_width, std::size_t dest_height)
{
    std::vector&lt;unsigned char&gt; out(dest_width * dest_height * 3);

    const double tx = double(bmap_width) / dest_width;
    const double ty = double(bmap_height) / dest_height;
    const std::size_t row_stride = dest_width * channels;
    unsigned char C[5] = { 0 };

    for (unsigned i = 0; i &lt; dest_height; ++i)
    {
        for (unsigned j = 0; j &lt; dest_width; ++j)
        {
            const int x = int(tx * j);
            const int y = int(ty * i);
            const double dx = tx * j - x;
            const double dy = ty * i - y;

            for (int k = 0; k &lt; 3; ++k)
            {
                for (int jj = 0; jj &lt; 4; ++jj)
                {
                    const int idx = y - 1 + jj;
                    unsigned char a0 = get_subpixel(bmap, idx, x, k);
                    unsigned char d0 = get_subpixel(bmap, idx, x - 1, k) - a0;
                    unsigned char d2 = get_subpixel(bmap, idx, x + 1, k) - a0;
                    unsigned char d3 = get_subpixel(bmap, idx, x + 2, k) - a0;
                    unsigned char a1 = -1.0 / 3 * d0 + d2 - 1.0 / 6 * d3;
                    unsigned char a2 = 1.0 / 2 * d0 + 1.0 / 2 * d2;
                    unsigned char a3 = -1.0 / 6 * d0 - 1.0 / 2 * d2 + 1.0 / 6 * d3;
                    C[jj] = a0 + a1 * dx + a2 * dx * dx + a3 * dx * dx * dx;

                    d0 = C[0] - C[1];
                    d2 = C[2] - C[1];
                    d3 = C[3] - C[1];
                    a0 = C[1];
                    a1 = -1.0 / 3 * d0 + d2 -1.0 / 6 * d3;
                    a2 = 1.0 / 2 * d0 + 1.0 / 2 * d2;
                    a3 = -1.0 / 6 * d0 - 1.0 / 2 * d2 + 1.0 / 6 * d3;
                    out[i * row_stride + j * channels + k] = a0 + a1 * dy + a2 * dy * dy + a3 * dy * dy * dy;
                }
            }
        }
    }

    return out;
}
</code></pre>

<p>This code works perfectly for certain destination sizes.  For example, if the original bitmap is <strong><code>500 X 366</code></strong>, and the destination size is <strong><code>250 x 183</code></strong>, the algorithm works perfectly:</p>

<p><strong>Original:</strong><br>
<img src=""https://i.stack.imgur.com/PbX09.jpg"" alt=""enter image description here"">
<br>
<strong>Resized</strong>:<br>
<img src=""https://i.stack.imgur.com/c0HKR.jpg"" alt=""enter image description here"">
<br></p>

<p>However, for certain other destination sizes, such as <strong><code>100 x 73</code></strong>, the destination image is distorted:
<br>
<img src=""https://i.stack.imgur.com/PdbbT.jpg"" alt=""enter image description here""></p>

<p>I've been going over the interpolation code, and I can't see what I'm doing incorrectly.</p>

<p>I'd appreciate any hints, suggestions, or answers.</p>
"
"<p>The obvious way to convert a bimap to std::map, doesnt seem to work. Is below the correct/good way to convert? Is there a better/shorter way?</p>

<pre><code>typedef boost::bimap&lt;int, std::string&gt; MapType;
MapType _bimap;
//Fill _bimap
MapType::left_map&amp; lmap = _bimap.left;
//std::map&lt;int, std::string&gt; bmap(lmap.begin(), lmap.end()); //THIS DOESNT WORK
std::map&lt;int, std::string&gt; bmap;
BOOST_FOREACH(MapType::left_const_reference entry, lmap)
{
   bmap[entry.first] = entry.second;
}
</code></pre>
"
"<p>In a C++ <code>std::map</code>, is there any way to search for the key given the mapped value? Example:</p>

<p>I have this map:</p>

<pre><code>map&lt;int,string&gt; myMap;
myMap[0] = ""foo"";
</code></pre>

<p>Is there any way that I can find the corresponding <code>int</code>, given the value <code>""foo""</code>?</p>

<pre><code>cout &lt;&lt; myMap.some_function(""foo"") &lt;&lt;endl;

Output: 0
</code></pre>
"
"<p>In the following SO question: <a href=""https://stackoverflow.com/questions/2067955/fast-bitmap-blur-for-android-sdk"">https://stackoverflow.com/questions/2067955/fast-bitmap-blur-for-android-sdk</a> @zeh claims a port of a java blur algorithm to C runs 40 times faster.</p>

<p>Given that the bulk of the code includes only calculations, and all allocations are only done ""one time"" before the actual algorithm number crunching - can anyone explain why this code runs 40 times faster? Shouldn't the Dalvik JIT translate the bytecode and dramatically reduce the gap to native compiled code speed?</p>

<p>Note: I have not confirmed the x40 performance gain myself for this algorithm, but all serious image manipulation algorithm I encounter for Android, are using the NDK - so this supports the notion that NDK code will run much faster.</p>
"
"<p>Im working on an open-source project ""powder toy"" and manged to compile it under msvc. Run fine. But when I include a new header in air.h, compiling gives errors such as:</p>

<p>'GetUserNameA! is not a member of 'SaveInfo' in  GameController.cpp file. </p>

<p>and</p>

<p>syntax error: '::' in BitmapBrush.h file. ---> pointing min - max of windows.</p>

<p>Both files are untouched and does not have anything in common with the header I added:</p>

<p>Aux_cl.h  ---> added to beginning of air.h</p>

<p>this header has just opencl headers which powdertoy does not have them in any of other cpp/h files.</p>

<p>What am I doing wrong?
If I delete the inclusion of Aux_cl, project compiles fine even with the opencl bindings in the Aux_cl(this not bind to anything, just compiled separately I think)</p>

<p><strong>Edit: When I add ""#undef min"" and ""#undef GetUserName"" before those error points, it compiles file, I wonder how it works without my header files included before.</strong></p>

<p>Edit2: Should I add #def blabla just after the functions after those #undef blabla ?</p>

<p>Here is the</p>

<p>Air.h:</p>

<pre><code>#ifndef AIR_H
#define AIR_H
#include ""Config.h""
#include ""Aux_cl.h""

class Simulation;

class Air
{
public:
    Simulation &amp; sim;
    int airMode;
    float ambientAirTemp;
    Aux_cl *gpu;
    //Arrays from the simulation
    unsigned char (*bmap)[XRES/CELL];
    unsigned char (*emap)[XRES/CELL];
    float (*fvx)[XRES/CELL];
    float (*fvy)[XRES/CELL];
    //
    float vx[YRES/CELL][XRES/CELL];
    float ovx[YRES/CELL][XRES/CELL];
    float vy[YRES/CELL][XRES/CELL];
    float ovy[YRES/CELL][XRES/CELL];
    float pv[YRES/CELL][XRES/CELL];
    float opv[YRES/CELL][XRES/CELL];
    float hv[YRES/CELL][XRES/CELL];
    float ohv[YRES/CELL][XRES/CELL]; // Ambient Heat
    unsigned char bmap_blockair[YRES/CELL][XRES/CELL];
    unsigned char bmap_blockairh[YRES/CELL][XRES/CELL];
    float kernel[9];
    void make_kernel(void);
    void update_airh(void);
    void update_air(void);
    void Clear();
    void ClearAirH();
    void Invert();
    Air(Simulation &amp; sim);
};

#endif
</code></pre>

<p>Aux_cl.h:</p>

<pre><code>#pragma once

#define __CL_ENABLE_EXCEPTIONS
#include&lt;CL\opencl.h&gt;
#include&lt;CL\cl.hpp&gt;
#include&lt;CL\cl.h&gt;
#include""ClKernelFactory.h""   // this has nothing but string variables and simple function. No other includes about windows or powder toy
#define FIRST_COMPUTE_DEVICE 0
/*
Simple compute helper class for your heavy work loads.
Uses OpenCL 1.2 headers so you may need an up-to-date CPU or an AMD-GPU for now.
Instances of this classes are different contexts and should be compiled serially.
Computation can be concurrent without fear.

Writer: Huseyin Tugrul BUYUKISIK
*/

class Aux_cl
{

public:
    cl::Context *context;
    std::vector&lt;cl::Program::Sources&gt; sources;
    std::vector&lt;cl::Program&gt; programs;
    std::vector&lt;std::vector&lt;cl::Device&gt;&gt; devicesCPU;
    std::vector&lt;std::vector&lt;cl::Device&gt;&gt; devicesGPU;

    cl::CommandQueue cq;
    std::vector&lt;cl::Buffer&gt; buffers;
    std::vector&lt;cl::Memory&gt; memories;
    std::vector&lt;cl::NDRange&gt; globalRanges;
    std::vector&lt;cl::NDRange&gt; localRanges;
    std::vector&lt;cl::NDRange&gt; referenceRanges;

    std::vector&lt;std::string&gt; kernelFunctionsToBeCompiled;
    std::vector&lt;std::string&gt; kernelNames;
    std::vector&lt;std::string&gt; bufferNames;
    std::vector&lt;cl::Kernel&gt; kernelFunctions;
    std::vector&lt;std::pair&lt;std::vector&lt;int&gt;,int&gt;&gt; bufferTargetsForKernels; // {500}, {501, 502},{530} ... --&gt; buffer ids
                                                            // 0,1,2,... --&gt; kernel ids
    std::vector&lt;std::pair&lt;int,std::vector&lt;std::string&gt;&gt;&gt; bufferDefinitions;
    std::vector&lt;std::pair&lt;int,std::string&gt;&gt; kernelDefinitions;
    std::vector&lt;cl::Platform&gt; platforms;

    cl_context_properties *context_properties;
    std::string CPU_GPU; //""gpu"" ""GPU""  ""graphics"" ""GRAPHICS"" ""cpu"" ""CPU""
    int kernelId;
    int bufferId;
    int numberOfCPU;
    int numberOfGPU;
    int first_CPU_platform;
    int first_CPU_device;
    int first_GPU_platform;
    int first_GPU_device;

    int second_CPU_platform;
    int second_CPU_device;
    int second_GPU_platform;
    int second_GPU_device;


    int which_one;
    static const int FIRST=0, SECOND=1, THIRD=2, FOURTH=3, OMG=4;
    Aux_cl(std::string gpu_or_cpu, int whichOne)
    {

        which_one=whichOne;
        CPU_GPU=gpu_or_cpu;
        kernelId=0;
        bufferId=0;
        numberOfGPU=0;
        numberOfCPU=0;
        cl::Platform::get(&amp;platforms);

        for(int i=0;i&lt;platforms.size();i++)
        {
            devicesCPU.push_back(std::vector&lt;cl::Device&gt;());  // one device list for each platform (AMD, NVIDIA, INTEL, ...)
        }

        for(int i=0;i&lt;platforms.size();i++)
        {
            devicesGPU.push_back(std::vector&lt;cl::Device&gt;());  // one device list for each platform (AMD, NVIDIA, INTEL, ...)
        }


        //selecting the platform that has a cpu or gpu specified in construction
        for(int i=0;i&lt;platforms.size();i++)
        {
            platforms[i].getDevices(CL_DEVICE_TYPE_CPU,&amp;devicesCPU[i]);
        }
        //selecting the platform that has a cpu or gpu specified in construction
        for(int i=0;i&lt;platforms.size();i++)
        {
            platforms[i].getDevices(CL_DEVICE_TYPE_GPU,&amp;devicesGPU[i]);
        }


        //searching device lists for a gpu or cpu (as selected in construction)
        for(int i=0;i&lt;platforms.size();i++)
        {
            bool notFoundYet=true;
            bool notFoundYet2=true;

            if(devicesCPU[i].size()&gt;0)
            for(int j=0;j&lt;devicesCPU[i].size();j++)
            {
                if(notFoundYet)
                {
                    first_CPU_platform=i;
                    first_CPU_device=j;
                    notFoundYet=false;
                }

                if((!notFoundYet)&amp;&amp;(notFoundYet2))
                {
                    second_CPU_platform=i;
                    second_CPU_device=j;
                    notFoundYet2=false;
                }
                numberOfCPU++;
            }
        }
        //searching device lists for a gpu or cpu (as selected in construction)
        for(int i=0;i&lt;platforms.size();i++)
        {
            bool notFoundYet=true;bool notFoundYet2=true;
            if(devicesGPU[i].size()&gt;0)
            for(int j=0;j&lt;devicesCPU[i].size();j++)
            {
                if(notFoundYet)
                {
                    first_GPU_platform=i;
                    first_GPU_device=j;
                    notFoundYet=false;
                }

                if((!notFoundYet)&amp;&amp;(notFoundYet2))
                {
                    second_CPU_platform=i;
                    second_CPU_device=j;
                    notFoundYet2=false;
                }
                numberOfGPU++;
            }
        }


    };

    void AddKernelFromFactory(KernelIngredients ki)
    {
        AddKernelToPool(ki.bodyOfKernel, ki.nameOfKernel,
                        ki.globalX,ki.globalY,
                        ki.localX,ki.localY);
    }

    void AddKernelToPool(std::string KernelItself, std::string KernelName,
                         int GlobalRangeX,int GlobalRangeY,
                         int LocalRangeX,int LocalRangeY)
    {
        if(GlobalRangeY!=0)
        {
            kernelFunctionsToBeCompiled.push_back(KernelItself);
            kernelNames.push_back(KernelName);
            globalRanges.push_back(cl::NDRange(GlobalRangeX,GlobalRangeY));
            localRanges.push_back(cl::NDRange(LocalRangeX,LocalRangeY));
            referenceRanges.push_back(cl::NDRange(0,0));
            kernelDefinitions.push_back(std::pair&lt;int,std::string&gt;(kernelId,KernelName));
            kernelId++;
        }
        else
        {
            kernelFunctionsToBeCompiled.push_back(KernelItself);
            kernelNames.push_back(KernelName);
            globalRanges.push_back(cl::NDRange(GlobalRangeX));
            localRanges.push_back(cl::NDRange(LocalRangeX));
            referenceRanges.push_back(cl::NDRange(0));
            kernelDefinitions.push_back(std::pair&lt;int,std::string&gt;(kernelId,KernelName));
            kernelId++;

        }
    };

    void AddBufferToPool(std::string nameOfBuffer,std::string typeOfBuffer, int sizeOfBuffer)
    {
        // 0,{""a"",""float"",""8192""}
        std::vector&lt;std::string&gt; BufferNameTypeSize;
        BufferNameTypeSize.push_back(nameOfBuffer);
        BufferNameTypeSize.push_back(typeOfBuffer);
        BufferNameTypeSize.push_back(std::to_string(sizeOfBuffer));
        bufferDefinitions.push_back(std::pair&lt;int,std::vector&lt;std::string&gt;&gt;(bufferId,BufferNameTypeSize));
        bufferNames.push_back(BufferNameTypeSize[0]);
        bufferId++;
    }



    void WireBuffersToSingleKernel(std::vector&lt;std::string&gt; buffers, std::string theKernel )
    {

        std::vector&lt;int&gt; bufferL;
        int index=-1;
        for(int i=0;i&lt;buffers.size();i++)
        {

            for(int j=0;j&lt;bufferDefinitions.size();j++)
            {
                if(bufferDefinitions[j].second[0]==(buffers[i]))
                {
                    bufferL.push_back(bufferDefinitions[j].first);
                }
            }

            for(int k=0;k&lt;kernelDefinitions.size();k++)
            {
                if(kernelDefinitions[k].second==(theKernel))
                {
                    index=kernelDefinitions[k].first;
                }
            }
        }
        bufferTargetsForKernels.push_back(std::pair&lt;std::vector&lt;int&gt;,int&gt;(bufferL,index));
        // buffers {23,33,10,1,40} for the kernel {3} as a pair

    }


    void compile()
    {
        if(which_one==FIRST)
        {
            //clGetPlatformIDs(1,&amp;platform_id,NULL);
            if((CPU_GPU==(""CPU""))||(CPU_GPU==(""cpu"")))
            {
                cl_context_properties properties[] = { CL_CONTEXT_PLATFORM, (cl_context_properties)(platforms[first_CPU_platform])(), 0};
                context=new cl::Context(CL_DEVICE_TYPE_CPU, properties);
            }

            if((CPU_GPU==(""GPU""))||(CPU_GPU==(""gpu"")))
            {
                cl_context_properties properties[] = { CL_CONTEXT_PLATFORM, (cl_context_properties)(platforms[first_GPU_platform])(), 0};
                context=new cl::Context(CL_DEVICE_TYPE_GPU, properties);
            }
        }

        if(which_one==SECOND)
        {
            //clGetPlatformIDs(1,&amp;platform_id,NULL);
            if((CPU_GPU==(""CPU""))||(CPU_GPU==(""cpu"")))
            {
                cl_context_properties properties[] = { CL_CONTEXT_PLATFORM, (cl_context_properties)(platforms[second_CPU_platform])(), 0};
                context=new cl::Context(CL_DEVICE_TYPE_CPU, properties);
            }

            if((CPU_GPU==(""GPU""))||(CPU_GPU==(""gpu"")))
            {
                cl_context_properties properties[] = { CL_CONTEXT_PLATFORM, (cl_context_properties)(platforms[second_GPU_platform])(), 0};
                context=new cl::Context(CL_DEVICE_TYPE_GPU, properties);
            }
        }
        /*
        for(int i=0;i&lt;platforms.size();i++)
        {
            devices[i]=context[0].getInfo&lt;CL_CONTEXT_DEVICES&gt;(); // device lists are created
        }
        */


        if(which_one==FIRST)
        {

            for(int i=0;i&lt;kernelFunctionsToBeCompiled.size();i++)
            {
                sources.push_back(cl::Program::Sources());
                sources[i].push_back(std::make_pair(kernelFunctionsToBeCompiled[i].data(),kernelFunctionsToBeCompiled[i].length()));
                programs.push_back(cl::Program(context[0],sources[i]));

                if((CPU_GPU==(""CPU""))||(CPU_GPU==(""cpu"")))
                {
                    programs[i].build(devicesCPU[first_CPU_platform]);
                }

                if((CPU_GPU==(""GPU""))||(CPU_GPU==(""gpu"")))
                {
                    programs[i].build(devicesGPU[first_GPU_platform]);
                }

                kernelFunctions.push_back(cl::Kernel(programs[i],kernelNames[i].data()));
            }

            if((CPU_GPU==(""CPU""))||(CPU_GPU==(""cpu"")))
            {
                    cq=cl::CommandQueue(context[0],devicesCPU[first_CPU_platform][first_CPU_device]);
            }
            if((CPU_GPU==(""GPU""))||(CPU_GPU==(""gpu"")))
            {
                    cq=cl::CommandQueue(context[0],devicesGPU[first_GPU_platform][first_GPU_device]);
            }


        }

        if(which_one==SECOND)
        {

            for(int i=0;i&lt;kernelFunctionsToBeCompiled.size();i++)
            {
                sources.push_back(cl::Program::Sources());
                sources[i].push_back(std::make_pair(kernelFunctionsToBeCompiled[i].data(),kernelFunctionsToBeCompiled[i].length()));
                programs.push_back(cl::Program(context[0],sources[i]));

                if((CPU_GPU==(""CPU""))||(CPU_GPU==(""cpu"")))
                {
                    programs[i].build(devicesCPU[second_CPU_platform]);
                }

                if((CPU_GPU==(""GPU""))||(CPU_GPU==(""gpu"")))
                {
                    programs[i].build(devicesGPU[second_GPU_platform]);
                }

                kernelFunctions.push_back(cl::Kernel(programs[i],kernelNames[i].data()));
            }

            if((CPU_GPU==(""CPU""))||(CPU_GPU==(""cpu"")))
            {
                    cq=cl::CommandQueue(context[0],devicesCPU[second_CPU_platform][second_CPU_device]);
            }
            if((CPU_GPU==(""GPU""))||(CPU_GPU==(""gpu"")))
            {
                    cq=cl::CommandQueue(context[0],devicesGPU[second_GPU_platform][second_GPU_device]);
            }


        }


        for(int i=0;i&lt;bufferDefinitions.size();i++)
        {
            int sizeOfBuffer=std::stoi(bufferDefinitions[i].second[2]);
            if(bufferDefinitions[i].second[1]==""float"")
            {
                buffers.push_back(cl::Buffer(context[0],CL_MEM_READ_WRITE,sizeof(cl_float)*sizeOfBuffer));
            }
            if(bufferDefinitions[i].second[1]==""int"")
            {
                buffers.push_back(cl::Buffer(context[0],CL_MEM_READ_WRITE,sizeof(cl_int)*sizeOfBuffer));
            }
            if(bufferDefinitions[i].second[1]==""double"")
            {
                buffers.push_back(cl::Buffer(context[0],CL_MEM_READ_WRITE,sizeof(cl_double)*sizeOfBuffer));
            }
            if(bufferDefinitions[i].second[1]==""long"")
            {
                buffers.push_back(cl::Buffer(context[0],CL_MEM_READ_WRITE,sizeof(cl_long)*sizeOfBuffer));
            }

            if(bufferDefinitions[i].second[1]==""char"")
            {
                buffers.push_back(cl::Buffer(context[0],CL_MEM_READ_WRITE,sizeof(cl_char)*sizeOfBuffer));
            }

        }

        for(int i=0;i&lt;bufferTargetsForKernels.size();i++)
        {
            for(int j=0;j&lt;bufferTargetsForKernels[i].first.size();j++)
            {
                kernelFunctions[bufferTargetsForKernels[i].second].setArg(j,buffers[bufferTargetsForKernels[i].first[j]]);
            }
        }

    }

    void SelectClBuffersToWriteOnThem()
    {

    }

    void SelectClBuffersToReadFromThem()
    {

    }

    void WriteToClFromCPP(std::string clArrayName,float *arrayCPP)
    {
        for(int i=0;i&lt;buffers.size();i++)
        {
            if(bufferNames[i]==clArrayName)
            {
                cq.finish();
                cq.enqueueWriteBuffer(buffers[i],CL_TRUE,0,sizeof(cl_float)*(std::atoi(bufferDefinitions[i].second[2].data())),arrayCPP);

                cq.finish();
            }
        }
    }


    void WriteToClFrom2DCPP(std::string clArrayName,static float *arrayCPP) // 2D array = contiguous?
    {

        for(int i=0;i&lt;buffers.size();i++)
        {
            if(bufferNames[i]==clArrayName)
            {
                cq.finish();
                cq.enqueueWriteBuffer(buffers[i],CL_TRUE,0,sizeof(cl_float)*(std::atoi(bufferDefinitions[i].second[2].data())), arrayCPP);
                cq.finish();

            }
        }
    }

    void WriteToClFrom2DCPP(std::string clArrayName,static char *arrayCPP) // 2D array = contiguous?
    {

        for(int i=0;i&lt;buffers.size();i++)
        {
            if(bufferNames[i]==clArrayName)
            {
                cq.finish();
                cq.enqueueWriteBuffer(buffers[i],CL_TRUE,0,sizeof(cl_char)*(std::atoi(bufferDefinitions[i].second[2].data())), arrayCPP);
                cq.finish();

            }
        }
    }




    void ReadFromClToCPP(std::string clArrayName, float *arrayCPP)
    {
        for(int i=0;i&lt;buffers.size();i++)
        {
            if(bufferNames[i]==clArrayName)
            {
                cq.finish();
                cq.enqueueReadBuffer(buffers[i],CL_TRUE,0,sizeof(cl_float)*(std::atoi(bufferDefinitions[i].second[2].data())),arrayCPP);
                cq.finish();
            }
        }
    }

    void ReadFromClTo2DCPP(std::string clArrayName,static float *arrayCPP) // 2D arrays are contiguous?
    {
        for(int i=0;i&lt;buffers.size();i++)
        {
            if(bufferNames[i]==clArrayName)
            {
                cq.finish();
                cq.enqueueReadBuffer(buffers[i],CL_TRUE,0,sizeof(cl_float)*(std::atoi(bufferDefinitions[i].second[2].data())), arrayCPP);
                cq.finish();
            }
        }
    }

    void ReadFromClTo2DCPP(std::string clArrayName,static char *arrayCPP) // 2D arrays are contiguous?
    {
        for(int i=0;i&lt;buffers.size();i++)
        {
            if(bufferNames[i]==clArrayName)
            {
                cq.finish();
                cq.enqueueReadBuffer(buffers[i],CL_TRUE,0,sizeof(cl_char)*(std::atoi(bufferDefinitions[i].second[2].data())), arrayCPP);
                cq.finish();
            }
        }
    }


    std::vector&lt;int&gt; computeList;

    void MakeKernelListToRun(std::vector&lt;std::string&gt; listOfKernels)
    {
        computeList.clear();
        for(int j=0;j&lt;listOfKernels.size();j++)
        {
            for(int i=0;i&lt;kernelNames.size();i++)
            {
                if(listOfKernels[j]==kernelNames[i])
                {
                    computeList.push_back(i);
                }
            }
        }
    }



    void ComputeList()
    {
        for(int i=0;i&lt;computeList.size();i++)
        {
            cq.enqueueNDRangeKernel(kernelFunctions[computeList[i]],referenceRanges[computeList[i]],globalRanges[computeList[i]],localRanges[computeList[i]]);
        }
    }



    void Compute(std::string kernelName)
    {
        for(int i=0;i&lt;kernelNames.size();i++)
        {
            if(kernelName==kernelNames[i])
            {
                cq.enqueueNDRangeKernel(kernelFunctions[i],referenceRanges[i],globalRanges[i],localRanges[i]);
            }
        }
    }

    void releaseClResources()
    {
        cq.finish();
        // opencl c++ bindings wrapper deletes / releases automatically when of no use
    }

    ~Aux_cl(void)
    {
        delete context;
    };
};
</code></pre>

<p>Last edit:</p>

<p>In KernelIngredients.cpp there is only #include ""KernelIngredients.h""</p>

<p>In KernelIngredients.h there is no inclusion</p>

<p>In ClKernelFactory.h there is only #include ""KernelIngredients.h""</p>

<p>In ClKernelFactory.cpp there is only #include ""ClKernelFactory.h""</p>

<p>In Aux_cl.cpp there is only #include ""Aux_cl.h""</p>

<p>In Aux_cl.h there is only opencl inclusions (i wish these dont use the windows things that clashes with min() and GetUserName() :S )</p>

<p>In Air.h there are  #include ""Aux_cl.h"" and #include""ClKernelFactory.h""</p>
"
"<p>Im making an opencl wrapper that uses a different command queue for each buffer.</p>

<p>All read/write oprations are non-blocking.</p>

<p><strong>The problem is, one of the read/write operations is not issued(as it seems from profiler). CodeXL profiler shows holes. I marked them on the picture.</strong></p>

<p><img src=""https://i.stack.imgur.com/oU0n2.png"" alt=""enter image description here""></p>

<p><strong>Question: What can cause this problem? I check cl errors but all give CL_SUCCESS.</strong></p>

<p>The flow of c++ opencl 1.2 program:</p>

<pre><code>  (from main thread)
   issue write buffer 0
   issue write buffer 1
   issue write buffer N

   (from many threads by openmp body)
   clFinish(queue0)
   clFinish(queue1)
   clFinish(queue2)

   (from main thread)
   issue kernel 0
   issue kernel 1
   issue kernel N
   clFinish(kernelQueue)

  (from main thread)
   issue read buffer 0
   issue read buffer 1
   issue read buffer N

   (from many threads by openmp body)
   clFinish(queue0)
   clFinish(queue1)
   clFinish(queue2) ----&gt; has some holes!!!
   clFinish(queueN)
</code></pre>

<p>Here is how main thread looks:</p>

<pre><code>void Air::update_air_and_h_gpu(void)
{
    if (airMode != 4)
    {




            /*  update air*/

        gpu-&gt;WriteToClFrom2DCPP(""pv"",&amp;pv[0][0]);
        gpu-&gt;WriteToClFrom2DCPP(""vx"",&amp;vx[0][0]);
        gpu-&gt;WriteToClFrom2DCPP(""vy"",&amp;vy[0][0]);
        gpu-&gt;WriteToClFrom2DCPP(""fvx"",&amp;fvx[0][0]);
        gpu-&gt;WriteToClFrom2DCPP(""fvy"",&amp;fvy[0][0]);
        gpu-&gt;WriteToClFrom2DCPP(""bmap_blockair"",&amp;bmap_blockair[0][0]);
        gpu-&gt;WriteToClFrom2DCPP(""bmap"",&amp;bmap[0][0]);
        gpu-&gt;WriteToClFromCPP(""kernelArr"",&amp;kernel[0]);


            /* update heat*/
        gpu-&gt;WriteToClFrom2DCPP(""hv"",&amp;hv[0][0]);
        gpu-&gt;WriteToClFrom2DCPP(""ambientAirTemp"",&amp;(ambientAirTemp));
        gpu-&gt;WriteToClFrom2DCPP(""gravityMode"",&amp;(sim.gravityMode));
        gpu-&gt;WriteToClFrom2DCPP(""bmap_blockairh"",&amp;bmap_blockairh[0][0]);


        gpu-&gt;syncW();

        /* update air*/
        gpu-&gt;Compute(""UpdateAirReduceEdge0"");
        gpu-&gt;Compute(""UpdateAirReduceEdge1"");
        gpu-&gt;Compute(""UpdateAirClearVelWall"");
        gpu-&gt;Compute(""UpdateAirPressAdjVel"");
        gpu-&gt;Compute(""UpdateAirVelAdjPress"");
        gpu-&gt;Compute(""UpdateAirBigLoop"");
        gpu-&gt;Compute(""UpdateAirBigLoop2"");

        /* update heat*/
        gpu-&gt;Compute(""UpdateAirHeatLoop0"");
        gpu-&gt;Compute(""UpdateAirHeatLoop1"");
        gpu-&gt;Compute(""UpdateAirHeatLastLoop"");
        gpu-&gt;Compute(""UpdateAirHeatLastLoop2"");

        gpu-&gt;sync();

        /*update air*/
        gpu-&gt;ReadFromClTo2DCPP(""pv"",&amp;pv[0][0]);
        gpu-&gt;ReadFromClTo2DCPP(""vx"",&amp;vx[0][0]);
        gpu-&gt;ReadFromClTo2DCPP(""vy"",&amp;vy[0][0]);

        /* update heat*/
        gpu-&gt;ReadFromClTo2DCPP(""hv"",&amp;hv[0][0]);


        gpu-&gt;syncR();



    }

}
</code></pre>

<p>Here is how gpu->syncR() and gpu->syncW are done through openmp(activated in options too):</p>

<pre><code>void syncR()
{
    omp_set_num_threads(2);  //tried 8 but holes still exist
    #pragma omp parallel for
    for(int i=0;i&lt;cqR.size();i++)
    {
        cqR[i].finish();
    }
}

void syncW()
{
    omp_set_num_threads(2); //tried 8 but holes still exist
    #pragma omp parallel for
    for(int i=0;i&lt;cqW.size();i++)
    {

        cqW[i].finish();
    }
}
</code></pre>

<p>Here is a closer look:</p>

<p>See the blue bars on the right side, one of them is missing some times.
<img src=""https://i.stack.imgur.com/IWiJt.png"" alt=""enter image description here""></p>

<p>Device: HD7870
Host: FX8150</p>

<p>Opencl 1.2 C++ bindings.</p>
"
"<p>I have a struct with two members an int and a string. </p>

<pre><code>struct A
{
 int a;
 string b;
}

vector&lt;A&gt; pl;
pl = getPL(); //getPL returns a vector&lt;A&gt;
for ( auto: pl )
{
 vector&lt;A&gt;tr;
 tr = getTR() //getTR returns vector&lt;A&gt;
 for(auto: tr)
 {
  //store tr somewhere..
 }

}
</code></pre>

<p>I want to create a <code>map&lt;A, vector&lt;A&gt;&gt;</code> so that each pl object can hold one vector. How to do that? Is there any other way or data structure in c++ that can achieve what I am trying to do.
Thanks, </p>
"
"<p>How do you construct a file system disk image and then look at its disk layout in bitmap files? How do you add directories to it?
I've used mkfs.ext2 on a file that I made using dd but I'm not sure if its done correctly.
I need to be able to see the inodes and inode table and see how they relate to the blocks.</p>
"
"<p>This is my implementation of the Box class:</p>

<pre><code>class Box {
    friend ostream&amp; operator&lt;&lt;(ostream &amp;os, const Box &amp;b);
    friend bool operator&lt;(const Box &amp;left, const Box &amp;right);
public:
    Box(int i, double d);
    ~Box();
private:
    int i;
    double d;
};

Box::Box(int _i, double _d):i(_i), d(_d) {}

Box::~Box() {}

bool operator&lt;(const Box &amp;left, const Box &amp;right)
{
    return (left.i &lt; right.i);
}

ostream&amp; operator&lt;&lt;(ostream &amp;os, const Box &amp;b)
{
    os &lt;&lt; b.d;
    return os;
}
</code></pre>

<p>This the test code:</p>

<pre><code>int main()
{
    Box b1(3,2), b2(2,1), b3(0, 9);
    map&lt;Box, int&gt; bmap;
    bmap.insert(pair&lt;Box,int&gt;(b1, 10));
    bmap.insert(pair&lt;Box,int&gt;(b2, 10));
    bmap.insert(pair&lt;Box,int&gt;(b3, 10));
    for (map&lt;Box,int&gt;::iterator iter = bmap.begin(); iter != bmap.end(); ++iter)
    {
        cout &lt;&lt; iter-&gt;first &lt;&lt; "" "";
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>If I remove the definition of operator&lt; on the Box class, the compiler will complain (an error) if I try to insert a Box object into std::map.</p>

<p>I have some experience with Java and I know in similar cases I just have to let Box implement Comarable. And Java compiler will check this contract at compile time, because Map in Java requires its key type conform to Comparable.</p>

<p>And if I want to define my own map type in Java, I just need to write:</p>

<pre class=""lang-java prettyprint-override""><code>public class MyMap&lt;K extends Comparable&lt;K&gt;, V&gt;
</code></pre>

<p>So my question is, if I want to implement my own map type (say, MyMap) in C++, how to define MyMap so that the compiler knows at compile time that ""MyMap requires its key_type has its own overloaded definition of operator&lt;""?</p>
"
"<p>I'm using a <code>boost::icl::interval_map</code> to map byte ranges to a set of strings.  The map is loaded from a (sorted) disk file, and then I do lookups using the code below.</p>

<p>The problem is the lookups are really slow.</p>

<p>In my test, I inserted 66425 ranges into the map.  I profiled the code and basically &gt; 99.9% of the time is spent in various Boost functions (there's not a particular function that is slow, there's a lot of time spread over many functions).</p>

<p>What can be done to make this faster?</p>

<p>Is my tree unbalanced (how do I find out?  how can I rebalance it?)</p>

<p>Is using set&lt;string&gt; a problem?</p>

<p>Is calculating the intersection of the map and the window a problem?  (Although it's what I need, so I can't see how else to do it).</p>

<pre><code>using namespace std;
typedef set&lt;string&gt; objects;
typedef boost::icl::interval_map&lt;uint64_t, objects&gt; ranges;
void
find_range (const ranges *map, uint64_t start, uint64_t end,
            void (*f) (uint64_t start, uint64_t end, const char *object,
                       void *opaque),
            void *opaque)
{
  boost::icl::interval&lt;uint64_t&gt;::type window;
  window = boost::icl::interval&lt;uint64_t&gt;::right_open (start, end);

  ranges r = *map &amp; window;

  ranges::iterator iter = r.begin ();
  while (iter != r.end ()) {
    boost::icl::interval&lt;uint64_t&gt;::type range = iter-&gt;first;
    uint64_t start = range.lower ();
    uint64_t end = range.upper ();

    objects obj_set = iter-&gt;second;
    objects::iterator iter2 = obj_set.begin ();
    while (iter2 != obj_set.end ()) {
      f (start, end, iter2-&gt;c_str (), opaque);
      iter2++;
    }
    iter++;
  }
}
</code></pre>

<p>The first few profile entries:</p>

<pre><code>  %   cumulative   self              self     total
 time   seconds   seconds    calls  us/call  us/call  name
  9.77      0.13     0.13 21866814     0.01           boost::icl::interval_bounds::interval_bounds(unsigned char)
  6.02      0.21     0.08  9132134     0.01           boost::icl::interval_traits&lt;boost::icl::discrete_interval&lt;unsigned long, std::less&gt; &gt;::lower(boost::icl::discrete_interval&lt;unsigned long, std::less&gt; const&amp;)
  6.02      0.29     0.08  6004967     0.01           boost::enable_if&lt;boost::icl::is_discrete_interval&lt;boost::icl::discrete_interval&lt;unsigned long, std::less&gt; &gt;, bool&gt;::type boost::icl::is_empty&lt;boost::icl::discrete_interval&lt;unsigned long, std::less&gt; &gt;(boost::icl::discrete_interval&lt;unsigned long, std::less&gt; const&amp;)
  5.26      0.36     0.07 21210093     0.00           boost::icl::discrete_interval&lt;unsigned long, std::less&gt;::bounds() const
  5.26      0.43     0.07 11964109     0.01           std::less&lt;unsigned long&gt;::operator()(unsigned long const&amp;, unsigned long const&amp;) const
  4.51      0.49     0.06 35761849     0.00           std::_Rb_tree&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::_Identity&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;, std::less&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt;, std::allocator&lt;std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &gt; &gt;::_S_left(std::_Rb_tree_node_base const*)
  4.51      0.55     0.06 12009934     0.00           boost::icl::operator==(boost::icl::interval_bounds, boost::icl::interval_bounds)
  3.76      0.60     0.05 12078493     0.00           boost::icl::discrete_interval&lt;unsigned long, std::less&gt;::upper() const
  3.76      0.65     0.05 12077959     0.00           boost::enable_if&lt;boost::icl::is_interval&lt;boost::icl::discrete_interval&lt;unsigned long, std::less&gt; &gt;, boost::icl::interval_traits&lt;boost::icl::discrete_interval&lt;unsigned long, std::less&gt; &gt;::domain_type&gt;::type boost::icl::upper&lt;boost::icl::discrete_interval&lt;unsigned long, std::less&gt; &gt;(boost::icl::discrete_interval&lt;unsigned long, std::less&gt; const&amp;)
  3.76      0.70     0.05  8837475     0.01           boost::icl::interval_bounds::bits() const
  3.76      0.75     0.05  6004967     0.01           boost::enable_if&lt;boost::icl::is_interval&lt;boost::icl::discrete_interval&lt;unsigned long, std::less&gt; &gt;, bool&gt;::type boost::icl::domain_less_equal&lt;boost::icl::discrete_interval&lt;unsigned long, std::less&gt; &gt;(boost::icl::interval_traits&lt;boost::icl::discrete_interval&lt;unsigned long, std::less&gt; &gt;::domain_type const&amp;, boost::icl::interval_traits&lt;boost::icl::discrete_interval&lt;unsigned long, std::less&gt; &gt;::domain_type const&amp;)
  3.01      0.79     0.04  5891650     0.01           boost::icl::is_right_closed(boost::icl::interval_bounds)
</code></pre>

<p>Data set: <a href=""http://oirase.annexia.org/tmp/bmap.txt"" rel=""nofollow"">http://oirase.annexia.org/tmp/bmap.txt</a> <br>
Full code: <a href=""http://git.annexia.org/?p=virt-bmap.git;a=tree"" rel=""nofollow"">http://git.annexia.org/?p=virt-bmap.git;a=tree</a></p>
"
"<p>I converted </p>

<pre><code>  for(std::set&lt;shape::Face&gt;::iterator face_iter=vec_face.begin(); face_iter!=vec_face.end(); face_iter++)
   {
     hiddenCorner(other, bmap, *face_iter);
   }
</code></pre>

<p>into </p>

<pre><code>for_each(vec_face.begin(), vec_face.end(), boost::bind(hiddenCorner, other, bmap, _1));
</code></pre>

<p>Obviously it is less verbose, but how about efficiency?</p>

<p>hiddenCorner is a void function which update bmap (bmap is a std::map). </p>

<p><strong>NOTE</strong>: vec_face is not a really big size set.  </p>
"
"<p>How can i map numbers like this:</p>

<pre><code>1 =&gt; 0x01;
2 =&gt; 0x03;
3 =&gt; 0x07;
4 =&gt; 0x0F;
....
8 =&gt; 0xFF;
</code></pre>

<p>I have only 8 numbers to map and i need this for my RT embedded system so the solution must be efficient.
Is there a way to implement this using ENUM or DEFINE?
I don't want to use switch statement. Should i use an array:</p>

<pre><code>BYTE bMap[8] =
{
    0x01,
    0x03,
    0x07,
    0x0F,
    ....
    0xFF,
}
</code></pre>

<p>or is there another way?
Thank you! Max.</p>
"
"<p>The original xv6-rev7 operating system contains:<br>
12 directed blocks<br>
1 indirect blcok(points to 128 blocks)  </p>

<p>This means we have 140 blocks.<br>
Each block's size is 512KB ==> 512 * 140 = 71,680 ~= 70KB is the limit of file's size in xv6.</p>

<p>I want to implemet triple indirect access in xv6 in order to support files with size of 40MB.</p>

<p>In order to do it I will need to implement double indirect before the triple indirect.<br>
So I took 2 directed blocks from the 12 I had.<br>
 1 for the double indirect and the other for the triple indirect.<br>
This is what I have right now:<br>
Direct: 10 blocks<br>
Single indirect: 128<br>
Double indirect: 128*128<br>
Triple indirect: 4*128*128 (I am using 4 instead of 128 because this is enough for 40MB)    </p>

<p>This is why <code>#define NDIRECT 10</code> and <code>uint addrs[NDIRECT+3];</code> </p>

<p>File's size limit = (10 + 128 + 128*128 + 4*128*128)*512kb = 42,013,696 ~= 42MB  </p>

<p>So I understand the concept.
The implementation of the triple-indirection is in function <code>bmap</code> in file <code>fs.c</code>.<br>
This is how it looks:<br>
<img src=""https://i.stack.imgur.com/DCsib.png"" alt=""enter image description here""></p>

<p>For some reason when I am trying to create file with size of 8.5MB it fails:
<img src=""https://i.stack.imgur.com/v4wIp.png"" alt=""enter image description here""><br>
<em>I am using bochs emulator</em></p>

<p>I am also not sure to what values I need to change in mkfs.c:</p>

<pre><code>int nblocks = 20985;
int nlog = LOGSIZE;
int ninodes = 200;
int size = 21029;
</code></pre>

<p><strong>fs.h:</strong>  </p>

<pre><code>// On-disk file system format.
// Both the kernel and user programs use this header file.

// Block 0 is unused.
// Block 1 is super block.
// Blocks 2 through sb.ninodes/IPB hold inodes.
// Then free bitmap blocks holding sb.size bits.
// Then sb.nblocks data blocks.
// Then sb.nlog log blocks.

#define ROOTINO 1  // root i-number
#define BSIZE 512  // block size

// File system super block
struct superblock {
  uint size;         // Size of file system image (blocks)
  uint nblocks;      // Number of data blocks
  uint ninodes;      // Number of inodes.
  uint nlog;         // Number of log blocks
};

#define NDIRECT 10
#define NINDIRECT (BSIZE / sizeof(uint))
#define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT*NINDIRECT + 4*NINDIRECT*NINDIRECT)

// On-disk inode structure
struct dinode {
  short type;           // File type
  short major;          // Major device number (T_DEV only)
  short minor;          // Minor device number (T_DEV only)
  short nlink;          // Number of links to inode in file system
  uint size;            // Size of file (bytes)
  uint addrs[NDIRECT+3];   // Data block addresses
};

// Inodes per block.
#define IPB           (BSIZE / sizeof(struct dinode))

// Block containing inode i
#define IBLOCK(i)     ((i) / IPB + 2)

// Bitmap bits per block
#define BPB           (BSIZE*8)

// Block containing bit for block b
#define BBLOCK(b, ninodes) (b/BPB + (ninodes)/IPB + 3)

// Directory is a file containing a sequence of dirent structures.
#define DIRSIZ 14

struct dirent {
  ushort inum;
  char name[DIRSIZ];
};
</code></pre>

<p><strong>fs.c:</strong>  </p>

<pre><code>// Return the disk block address of the nth block in inode ip.
// If there is no such block, bmap allocates one.
static uint
bmap(struct inode *ip, uint bn)
{
  uint addr, *a;
  struct buf *bp;

  if(bn &lt; NDIRECT){
    if((addr = ip-&gt;addrs[bn]) == 0)
      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);
    return addr;
  }
  bn -= NDIRECT;

  if(bn &lt; NINDIRECT){
    // Load indirect block, allocating if necessary.
    if((addr = ip-&gt;addrs[NDIRECT]) == 0)
      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);
    bp = bread(ip-&gt;dev, addr);
    a = (uint*)bp-&gt;data;
    if((addr = a[bn]) == 0){
      a[bn] = addr = balloc(ip-&gt;dev);
      log_write(bp);
    }
    brelse(bp);
    return addr;
  }

  /* Double indirect */
  bn -= NINDIRECT;
  if(bn &lt; NINDIRECT*NINDIRECT){
        // Load 2nd indirect block, allocating if necessary.
        if((addr = ip-&gt;addrs[NDIRECT+1]) == 0) // 2d block. NDIRECT+1 is to get the index vector
          ip-&gt;addrs[NDIRECT+1] = addr = balloc(ip-&gt;dev);

        bp = bread(ip-&gt;dev, addr);
        a = (uint*)bp-&gt;data;
        if ((addr = a[bn/(NINDIRECT)]) == 0) { /* get index for 1st
                                                    indirection. (NINDIRECT is 128) */
              a[bn/(NINDIRECT)] = addr = balloc(ip-&gt;dev);
              log_write(bp);
          }
          brelse(bp);               /* release the double indirect table
                                       (main level) */

        bp = bread(ip-&gt;dev, addr);
        a = (uint*)bp-&gt;data;

         if ((addr = a[bn%(NINDIRECT)]) == 0) { /*  get the 2nd level table */
              a[bn%(NINDIRECT)] = addr = balloc(ip-&gt;dev);
              log_write(bp);
          }

        brelse(bp);
        return addr;
    }

   /* Triple indirect */

      bn -= NINDIRECT*NINDIRECT;
      if(bn &lt; 4*NINDIRECT*NINDIRECT){
        // Load 3rd indirect block, allocating if necessary.
        if((addr = ip-&gt;addrs[NDIRECT+2]) == 0) // 3d block. NDIRECT+2 is to get the index vector
          ip-&gt;addrs[NDIRECT+2] = addr = balloc(ip-&gt;dev);

        bp = bread(ip-&gt;dev, addr);
        a = (uint*)bp-&gt;data;

        if ((addr = a[bn/(NINDIRECT*4)]) == 0) { /* get index for 2st
                                                    indirection. (NINDIRECT is 128) */
              a[bn/(NINDIRECT*4)] = addr = balloc(ip-&gt;dev);
              log_write(bp);
          }
          brelse(bp);

        bp = bread(ip-&gt;dev, addr);
        a = (uint*)bp-&gt;data;

        if ((addr = a[bn/(NINDIRECT*NINDIRECT*4)]) == 0) {

              a[bn/(NINDIRECT*NINDIRECT*4)] = addr = balloc(ip-&gt;dev);
              log_write(bp);
          }

          brelse(bp);


         if ((addr = a[bn%(NINDIRECT*NINDIRECT*4)]) == 0) {
              a[bn%(NINDIRECT*NINDIRECT*4)] = addr = balloc(ip-&gt;dev);
              log_write(bp);
          }

        brelse(bp);
        return addr;
    }

  panic(""bmap: out of range"");
}
</code></pre>

<p><strong>mkfs.c:</strong>  </p>

<pre><code>#define stat xv6_stat  // avoid clash with host struct stat
#include ""types.h""
#include ""fs.h""
#include ""stat.h""
#include ""param.h""

int nblocks = 20985;
int nlog = LOGSIZE;
int ninodes = 200;
int size = 21029;
</code></pre>

<p><strong>bigfile.c:</strong></p>

<pre><code>#include ""types.h""
#include ""stat.h""
#include ""user.h""
#include ""fcntl.h""
void
help()
{
  printf(1, ""usage:\nfiles &lt;name&gt; &lt;letter&gt; &lt;num&gt;\n""
            ""e.g. nfiles foo a 40\n creates a file foo, with 40 times the letter a\n"");
}

void
num2str(int i, char str[3])
{
  str[2]=i%10+'0';
  i=i/10;
  str[1]=i%10+'0';
  i=i/10;
  str[0]=i%10+'0';
  i=i/10;
}
#define BUF_SZ 512

int
main(int argc, char *argv[])
{
    int i, count, fd, n;
    // char *name;
    // char c;
    char buf[BUF_SZ];
    if (argc !=4) {
        help();
        exit();
    }
    count = atoi(argv[3]);
    if((fd=open(argv[1], O_CREATE|O_RDWR))&lt;0) {
        printf(2,""Failed to open file: %s\n"", argv[1]);
        exit();
    }
    for (i=0; i&lt;BUF_SZ;i++)
        buf[i]=argv[2][0];
    for (i=0; i&lt;count/BUF_SZ;i++)
        if ((n=write(fd,buf,BUF_SZ)) != BUF_SZ)
        {
            printf(2,""Failed 1 to Write count=%d\n"",i*BUF_SZ);
            exit();
        }

    for (i=0; i&lt;count%BUF_SZ;i++)
        if ((n=write(fd,argv[2],1)) != 1)
        {
            printf(2,""Failed 2 to Write count=%d\n"",count-i);
            exit();
        }

  exit();
}
</code></pre>
"
"<p>I am building a forensic tool, that shall read and write from file slacks. At the moment I use JNI to call the C functions <strong>read()</strong> and <strong>write()</strong> to write a buffer to the FAT SD card (also EXT4 internal memory would be nice). I use those because you can pass the length to read/write thus ignoring EOF.
I already tried writing by using a standard write and then <strong>truncate</strong> it in order to write in the file slack, which works on ubuntu 14.04 but not on Android (API 21).
Reading more from a file than the actuall file size does not reflect the flie slack on the SD-card.
There are tools e.g. ""bmap"" or ""slacker.exe"" (for NTFS) that manage to access file slacks. I am in need of a way to ignore EOF or handle it myself. I would prefere not to change existing file system drivers.
I appreciate any suggestions.</p>

<p>here is some sample code (that does not work yet): </p>

<pre><code>jstring
Java_com_example_hellojni_HelloJni_write(JNIEnv *env, jobject thiz, jstring path)
{
char *cpath = (*env)-&gt;GetStringUTFChars(env, path, NULL);
int raw_file_descriptor = open(cpath,O_WRONLY,0);
lseek(raw_file_descriptor,0,SEEK_END);
char block_buffer [4096] = ""hidden"";
int buffer_length = 6;
int wret = write(raw_file_descriptor,block_buffer,buffer_length); // increases file size and moves EOF - I don't want that
LOGD("" char written: %d"", wret);
free(cpath);
return (*env)-&gt;NewStringUTF(env, ""write ok "");
}

jbyteArray
Java_com_example_hellojni_HelloJni_read2(JNIEnv *env, jobject thiz, jstring path) {

char *cpath = (*env)-&gt;GetStringUTFChars(env, path, NULL);
LOGD(""open %s with "", cpath);
int raw_file_descriptor = open(cpath,O_RDONLY,0);
char buffer [4096];
int readretval = read(raw_file_descriptor, buffer, 50); // stops at EOF - I want it to continue reading all 50 bytes from the SD-card - This gives me the file content until EOF and then I get some random characters from the uninitialized buffer.
LOGD(""read (%d) buffer with length  %d: %s"", readretval, sizeof(buffer), buffer);
int i; // Debug code
for (i=0; i &lt; 49; ++i) {
    LOGD(""%c"",buffer[i]);
}

close(raw_file_descriptor);
free(cpath);
return NULL;
}
</code></pre>
"
"<p>I have an activity containing 4 images in total. They are all matching the resolution of a 1080x1920 device. When I run the activity with those images, which are loaded directly in my activity via the XML, it runs <strong>tremendously slow</strong> in my Genymotion emulator and <strong>lags</strong> on a real Android device.
<br>
<br>
Here is the setup:</p>

<pre><code>&lt;android.support.design.widget.AppBarLayout
...&gt;
&lt;android.support.design.widget.CollapsingToolbarLayout
...&gt;
&lt;LinearLayout
            android:layout_width=""match_parent""
            android:layout_height=""200dp""
            android:orientation=""vertical""
            app:layout_collapseMode=""parallax""&gt;

            &lt;ImageView
                android:layout_width=""match_parent""
                android:layout_height=""match_parent""
                android:id=""@+id/imageView""
                android:src=""@drawable/shot_header""
                android:scaleType=""centerCrop"" /&gt;

 &lt;/LinearLayout&gt;
 &lt;android.support.v7.widget.Toolbar
            .../&gt;
 &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;
 &lt;/android.support.design.widget.AppBarLayout&gt;
</code></pre>

<p>The first image is in a CollapsingToolbarlayout. The resolution of the image is <strong>1080x649</strong> PNG.
<br>
<br>
The content_activity:
<br>
This image fills the parent width.It's resolution is <strong>1080x772</strong> PNG.</p>

<pre><code> &lt;ImageView
    android:layout_width=""match_parent""
    android:layout_height=""250dp""
    android:id=""@+id/main_image""
    android:layout_below=""@+id/shot_error_field""
    android:src=""@drawable/forehand_midpng""
    android:adjustViewBounds=""true""
    android:scaleType=""centerCrop""
    android:layout_marginTop=""15dp""/&gt;
</code></pre>

<p>The other 2 images are in a <em>LinearLayout</em>, their resolution is <strong>500x399</strong></p>

<pre><code>&lt;LinearLayout
    android:orientation=""horizontal""
    android:layout_width=""match_parent""
    android:layout_height=""wrap_content""
    android:layout_below=""@+id/main_image""&gt;

    &lt;ImageView
        android:layout_width=""150dp""
        android:layout_height=""150dp""
        android:id=""@+id/imageView3""
        android:src=""@drawable/forehand_mid_wrong""
        android:layout_weight=""1""/&gt;

    &lt;View
        android:layout_width=""0dp""
        android:layout_height=""1dp""
        android:layout_weight=""1"" &gt;
    &lt;/View&gt;

    &lt;ImageView
        android:layout_width=""150dp""
        android:layout_height=""150dp""
        android:id=""@+id/imageView4""
        android:src=""@drawable/forehand_mid_wrong""
        android:layout_weight=""1""/&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p>To summarize, I have an activity with 4 ImageViews, populated with properly sized images, which should no problem for a modern Android device. The problem is that this activity is running extremely slow and lagging due to a high memory consumption.
<br>
<br>
Am I doing something wrong? How can I further optimize those images?
<br>
<br>
I looked into other threads- <a href=""https://stackoverflow.com/questions/477572/strange-out-of-memory-issue-while-loading-an-image-to-a-bitmap-object"">out of memory issue</a> but none seems to propose a solution to such a problem.</p>
"
"<p>I need to change the way that I include headers in a larger project that I'm working on. I was able to simulate the errors I currently get with a smaller, single program.</p>

<p>By way of example, the following compiles:</p>

<pre><code>#include &lt;map&gt;

class C;

class A {
public:
    C&amp; add();
    std::map&lt;int,C&gt; Cmap;
    void dosomethingwithC();
};

class B {
public:
    A&amp; add();
    std::map&lt;int,A&gt; Amap;
};

class C {
public:
    B&amp; add();
    std::map&lt;int,B&gt; Bmap;
};

int main()
{
    C c;
    auto&amp; emplacedB = c.add();
    auto&amp; emplacedA = emplacedB.add();
    auto&amp; emplacedC = emplacedA.add();
    emplacedC.add();
    return 0;
}

C&amp; A::add()
{
    auto emplace_results = Cmap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    auto&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;
}

B&amp; C::add()
{
    auto emplace_results = Bmap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    //auto&amp; emplaced_pair = *pair_iterator;
    std::pair&lt;const int,B&gt;&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;
}

A&amp; B::add()
{
    auto emplace_results = Amap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    auto&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;;
}

void A::dosomethingwithC()
{
    Cmap[3].add();
}
</code></pre>

<p>But, if I move <code>A</code>'s function definition closer to <code>A</code>, then the following does not compile:</p>

<pre><code>#include &lt;map&gt;

class C;

class A {
public:
    C&amp; add();
    std::map&lt;int,C&gt; Cmap;
    void dosomethingwithC();
};

C&amp; A::add()
{
    auto emplace_results = Cmap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    auto&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;
}

class B {
public:
    A&amp; add();
    std::map&lt;int,A&gt; Amap;
};

class C {
public:
    B&amp; add();
    std::map&lt;int,B&gt; Bmap;
};

int main()
{
    C c;
    auto&amp; emplacedB = c.add();
    auto&amp; emplacedA = emplacedB.add();
    auto&amp; emplacedC = emplacedA.add();
    emplacedC.add();
    return 0;
}

B&amp; C::add()
{
    auto emplace_results = Bmap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    //auto&amp; emplaced_pair = *pair_iterator;
    std::pair&lt;const int,B&gt;&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;
}

A&amp; B::add()
{
    auto emplace_results = Amap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    auto&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;;
}

void A::dosomethingwithC()
{
    Cmap[3].add();
}
</code></pre>

<p>Even though <code>class C</code> is declared I get an error. The error explains that <code>std::pair</code> uses <em>undefined</em> <code>class C</code>.</p>

<p>What is the correct way to structure the headers and includes to make this compile?</p>
"
"<p>Why does including a declaration resolve a missing definition error? This is related to <a href=""https://stackoverflow.com/q/36666368/1460794"">an earlier question</a>. </p>

<p>In the following set of files I am surprised that a definition is sought for a class that is not used and then when I include only a declaration for the class the program compiles.</p>

<p>I have added comments for the includes that I had to add, but can't understand why they're needed in those particular .cpp files.</p>

<p>A.h</p>

<pre><code>#ifndef A_h
#define A_h

#include &lt;map&gt;

class C;

class A {
public:
    C&amp; add();
    std::map&lt;int,C&gt; Cmap;
    void dosomethingwithC();
};

#endif
</code></pre>

<p>B.h</p>

<pre><code>#ifndef B_h
#define B_h

#include &lt;map&gt;

class A;

class B {
public:
    A&amp; add();
    std::map&lt;int,A&gt; Amap;
};

#endif
</code></pre>

<p>C.h</p>

<pre><code>#ifndef C_h
#define C_h

#include &lt;map&gt;

class B;

class C {
public:
    B&amp; add();
    std::map&lt;int,B&gt; Bmap;
};

#endif
</code></pre>

<p>A.cpp</p>

<pre><code>#include ""A.h""

#include ""B.h""// Required here, but B isn't used in this file.
              // Without B.h the error is
              // error C2079: 'std::pair&lt;const _Kty,_Ty&gt;::second' uses undefined class 'B'
              // But B.h only includes the declaration, not the definition

#include ""C.h""

C&amp; A::add()
{
    auto emplace_results = Cmap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    auto&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;
}


void A::dosomethingwithC()
{
    Cmap[3].add();
}
</code></pre>

<p>B.cpp</p>

<pre><code>#include ""A.h""
#include ""B.h""
#include ""C.h"" // also required here

A&amp; B::add()
{
    auto emplace_results = Amap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    auto&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;;
}
</code></pre>

<p>C.cpp</p>

<pre><code>#include ""A.h"" // also required here
#include ""B.h""
#include ""C.h""

B&amp; C::add()
{
    auto emplace_results = Bmap.emplace(std::piecewise_construct,
        std::forward_as_tuple(3),
        std::forward_as_tuple());
    auto pair_iterator = emplace_results.first;
    //auto&amp; emplaced_pair = *pair_iterator;
    std::pair&lt;const int,B&gt;&amp; emplaced_pair = *pair_iterator;
    auto&amp; map_value = emplaced_pair.second;
    return map_value;
}
</code></pre>

<p>Main.cpp</p>

<pre><code>#include ""A.h""
#include ""B.h""
#include ""C.h""

int main()
{
    C c;
    auto&amp; emplacedB = c.add();
    auto&amp; emplacedA = emplacedB.add();
    auto&amp; emplacedC = emplacedA.add();
    emplacedC.add();
    return 0;
}
</code></pre>
"
"<p>The <code>GetObject()</code> documentation says that when <code>lpvObject</code> is NULL, the function returns the number of bytes required.  But, I am getting 0, which is the return value when it fails.</p>

<p>I've been searching and trying to figure out what I'm doing wrong.</p>

<p>I've just got a basic window setup using the <code>WM_PAINT</code> message:</p>

<pre><code>case WM_PAINT:
{
    PAINTSTRUCT ps;
    HDC hdc;
    hdc = BeginPaint(hwnd, &amp;ps);
    HBITMAP hbmap;
    hbmap = (HBITMAP) LoadImage(NULL, str_path, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE | LR_CREATEDIBSECTION);
    BITMAP bm;
    HDC bmapmemory = CreateCompatibleDC(hdc);
    SelectBitmap(bmapmemory, hbmap);
    int a = GetObject(hbmap, sizeof(BITMAP), NULL);

    BitBlt(hdc, 0, 0, 750, 750, bmapmemory, 0, 0, SRCCOPY);
    char c[64];
    sprintf_s(c, sizeof(c), ""%f\n"", a);
    OutputDebugStringA(c);

    DeleteDC(bmapmemory);
    DeleteObject(bmap);

    EndPaint(hwnd,&amp; ps);

    return 0;
}
</code></pre>

<p>As I said, <code>a</code> is always 0, or failure, for the <code>GetObject()</code> function call.</p>
"
"<p>I would like to know how to write a <code>bimap</code> which is actually too large( 180 million to 3000 million entries) to a binary file and then read to do some operation. To create a <code>bimap</code> I have the following code, where I created two streams to write and read binary data. I also insert the elements into the <code>bimap</code>. </p>

<pre><code>#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;fstream&gt;
#include &lt;boost/bimap.hpp&gt;
#include &lt;boost/bimap/unordered_set_of.hpp&gt;
#include &lt;boost/bimap/unordered_multiset_of.hpp&gt;

namespace bimaps = boost::bimaps;
typedef boost::bimap&lt;bimaps::unordered_set_of&lt;unsigned long long int&gt;,
        bimaps::unordered_multiset_of&lt;unsigned long long int &gt; &gt; bimap_reference;
typedef bimap_reference::value_type position;
bimap_reference numbers;

int main()
{
    std::ofstream outfile (""bmap"",std::ofstream::binary);
    std::ifstream infile (""bmap"",std::ifstream::binary);

    numbers.insert(position(123456, 100000));
    numbers.insert(position(234567, 80000));
    numbers.insert(position(345678, 100000));
    numbers.insert(position(456789, 80000));

    //want to write the file

    //want to read the file


    // So that I can perform the following operation
    using ritr = bimap_reference::right_const_iterator;
    std::pair&lt;ritr, ritr&gt; range = numbers.right.equal_range(80000);
    auto itr = range.first;
    std::cout&lt;&lt;""first: ""&lt;&lt;itr-&gt;first&lt;&lt;std::endl;
    if(itr != numbers.right.end() &amp;&amp; itr-&gt;second ==80000){
        for (itr = range.first; itr != range.second; ++itr)
        {
            std::cout&lt;&lt;""numbers:""&lt;&lt;itr-&gt;second&lt;&lt;""&lt;-&gt;""&lt;&lt;itr-&gt;first&lt;&lt;std::endl;
        }
    }
    else {
        std::cout&lt;&lt;""Not found:""&lt;&lt;std::endl;
    }
    return 0;
}
</code></pre>

<p>I want to write the <code>bimap</code>, and then read it again to perform some operation. How to do it. </p>
"
"<p>I have two list containing an important number of object with each <code>N</code> elements:</p>

<pre><code>List&lt;Foo&gt; objectsFromDB = {{MailId=100, Status=""""}, {{MailId=200, Status=""""}, {MailId=300, Status=""""} ... {MailId=N , Status= N}}

List &lt;Foo&gt; feedBackStatusFromCsvFiles = {{MailId=100, Status= ""OPENED""}, {{MailId=200, Status=""CLICKED""}, {MailId=300, Status=""HARDBOUNCED""} ... {MailId=N , Status= N}}
</code></pre>

<p>Little Insights:
 <code>objectFromDB</code> retrieves row of my database by calling a Hibernate method.</p>

<p><code>feedBackStatusFromCsvFiles</code> calls a CSVparser method and unmarshall to Java objects.</p>

<p>My entity class <code>Foo</code> has all setters and getters. So I know that the basic idea is to use a foreach like this:</p>

<pre><code>     for (Foo fooDB : objectsFromDB) {
          for(Foo fooStatus: feedBackStatusFromCsvFiles){
              if(fooDB.getMailId().equals(fooStatus.getMailId())){
                    fooDB.setStatus(fooStatus.getStatus());
                }
               }
            }
</code></pre>

<p>As far as my modest knowledge of junior developer is, I think it is a very bad practice doing it like this? Should I implement a Comparator and use it for iterating on my list of objects? Should I also check for null cases?</p>

<p>Thanks to all of you for your answers!</p>
"
"<p>I have the following file, which is part of a larger (but still small) program. The program compiles regardless of header inclusion order but it seg faults if I include <code>&lt;fstream&gt;</code> after my local files; if I include it before my local header files, the program runs fine.</p>

<pre><code>#include &lt;fstream&gt;
#include ""Bitmap.h""
#include ""BitmapInfoHeader.h""
#include ""BitmapFileHeader.h""

namespace bmap
{

Bitmap::Bitmap(int width, int height) : _width(width), _height(height), _pixels(new uint8_t[width * height * 3]{}) { }

void Bitmap::set_pixel(int x, int y, uint8_t red, uint8_t blue, uint8_t green) { }

bool Bitmap::write(string filename)
{
  BitmapFileHeader file_header;
  BitmapInfoHeader info_header;

  file_header.file_size = sizeof(BitmapInfoHeader) + sizeof(BitmapFileHeader) + _width * _height * 3;
  file_header.data_offset = sizeof(BitmapInfoHeader) + sizeof(BitmapFileHeader);

  info_header.width = _width;
  info_header.height = _height;

  std::ofstream outfile(filename, ios::out | ios::binary);
  if(!outfile) { return false; }
  outfile.write((char *)(&amp;file_header), sizeof(file_header));
  outfile.write((char *)(&amp;info_header), sizeof(info_header));
  outfile.write((char *)(_pixels.get()), _width * _height * 3);
  outfile.close();
  return true;
}

Bitmap::~Bitmap() { }

}
</code></pre>

<p>The header files included in the file above are shown below.</p>

<p>Bitmap.h:</p>

<pre><code>#ifndef BITMAP_H_
#define BITMAP_H_

#include &lt;cstdint&gt;
#include &lt;string&gt;

using namespace std;

namespace bmap{

class Bitmap
{
 private:
  int _width{0};
  int _height{0};
  unique_ptr&lt;uint8_t[]&gt; _pixels{nullptr};

 public:
  Bitmap(int width, int height);
  bool write(string filename);
  void set_pixel(int x, int y, uint8_t red, uint8_t blue, uint8_t green);
  virtual ~Bitmap();
};
}

#endif
</code></pre>

<p>BitmapFileHeader.h:</p>

<pre><code>#ifndef BITMAPFILEHEADER_H_
#define BITMAPFILEHEADER_H_

#include &lt;cstdint&gt;

namespace bmap
{

#pragma pack(2)
struct BitmapFileHeader
{
  char header[2]{ 'B', 'M' };
  int32_t file_size;
  int32_t reserved{0};
  int32_t data_offset;
};
}

#endif
</code></pre>

<p>BitmapInfoHeader.h:</p>

<pre><code>#ifndef BITMAPINFOHEADER_H_
#define BITMAPINFOHEADER_H_

#include &lt;cstdint&gt;

namespace bmap
{

#pragma pack(2)
  struct BitmapInfoHeader
  {
    int32_t header_size{40};
    int32_t width;
    int32_t height;
    int16_t planes{1};
    int16_t bits_per_pixel{24};
    int32_t compression{0};
    int32_t data_size{0};
    int32_t horizontal_resolution{2400};
    int32_t vertical_resolution{2400};
    int32_t colors{0};
    int32_t important_colors{0};
  };
}
#endif
</code></pre>

<p>I thought it might be some dependency between header files but there doesn't seem to be.  I have also tried renaming the <code>Bitmap::write</code> method because I thought it might be clashing with the write method in <code>&lt;fstream&gt;</code> somehow, but that didn't change anything.  Any ideas?</p>

<p>GDB gives the following info:</p>

<pre><code>Program received signal SIGSEGV, Segmentation fault.
0x00007fff994bdf24 in std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::flush() () from /usr/lib/libc++.1.dylib
(gdb) where
#0  0x00007fff994bdf24 in std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::flush() () from /usr/lib/libc++.1.dylib
#1  0x00007fff994c299e in std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::sentry::sentry(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;) () from /usr/lib/libc++.1.dylib
#2  0x00007fff994c41a6 in std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;::write(char const*, long) () from /usr/lib/libc++.1.dylib
#3  0x0000000100001626 in bmap::Bitmap::write (this=0x7fff5fbffa50, filename=...) at Bitmap.cpp:26
#4  0x0000000100004d48 in main () at Mandelbrot.cpp:11
(gdb)
</code></pre>
"
"<p>i want to compare the current time and file creation time in Perl but both are in different format. localtime is in this format:</p>

<pre><code>22116291110813630
</code></pre>

<p>and file creation time is </p>

<pre><code>Today, December 29, 2008, 2:38:37 PM
</code></pre>

<p>How do i compare which one is greater and their difference?</p>
"
"<p>I'm experiencing a bizarre issue where my system clock knows that it's daylight savings time, but glibc seems not to. This is an up-to-date Ubuntu installation, and I have checked /etc/localtime and it has the correct changeover time for last week's switch to DST.</p>

<p>The current correct timezone for me is Pacific Daylight Time (UTC-7). When I ask my system what time zone I'm in, it tells me correctly:</p>

<pre><code>$ date +%z
-0700
</code></pre>

<p>But when I run the following program:</p>

<pre><code>#include &lt;time.h&gt;
#include &lt;stdio.h&gt;

int main() {
  tzset();
  printf(""%lu\n"", timezone);
  return 0;
}
</code></pre>

<p>The output is, incorrectly:</p>

<pre><code>28800
</code></pre>

<p>Which corresponds to UTC-8, or Pacific Standard Time. (And no, TZ is not set in my environment)</p>

<p>I thought glibc and the date program would get their time zone information from the same source, but apparently either they don't or I'm misunderstanding how the glibc timezone global works.</p>

<p>The basic questions are then:</p>

<ol>
<li><em>Why are these two outputs different</em></li>
<li><em>How can I reliably detect the system UTC offset from a C program?</em></li>
</ol>
"
"<p>I have an object Foo which has a global variable, Time currentTime</p>

<p>Foo has two methods which are called from different threads.</p>

<pre><code>update()
{
    currentTime = currentTime + timeDelay;
}

restart(Time newTime)
{
    currentTime = newTime;
}
</code></pre>

<p>I am seeing behavior on a restart, the time changes correctly and other times where currentTime does not seem to reset (or it does reset but then update sets it back somehow.</p>

<p>The method update is called roughly every second or so while restart only occurs when a user initiates a restart event (presses a button). I think this is threading timing issue, any suggestions or comments on what is happening are welcome.</p>
"
"<p>Is there a cross-platform way to get the current date and time in C++?</p>
"
"<p>I want to perform the action at a certain timeout, like fire an
event. I figured out how to do every n number of seconds, but not 1.5
seconds. Here is what I have. Please suggest how to handle my case:</p>

<pre><code>void Publish()
{
    static  int local_time=time(NULL);

     int current_time = time (NULL);
     if((current_time+PUBLISH_TIMEOUT)&gt;local_time)
      {
           fireEvent();
            local_time=current_time;
      }
}
</code></pre>
"
"<p>What is the simplest way to write a timer in C/C++?</p>

<p>Hi,</p>

<p>What is the simplest way to write a timer, say in C/C++? Previously I used a for loop and a do-while loop. I used the for loop as a counter and the do-while loop as a comparison for ""end of time"". The program worked as I wanted it to, but consumed too much system resources.</p>

<p>I'm looking for the simplest way to write a timer.</p>

<p>Thank you!</p>

<p>EDIT:</p>

<p>The program works on a set of servers both Linux and Windows, so it's a multiplatform environment. I dont want to use the unsleep or sleep function as I'm trying to write everything from scratch.</p>

<p>The nature of the program: The program counts power time and battery time on systems.</p>

<p>EDIT2:</p>

<p>OK, it seems that this caused some confusion so I'm going to try to explain what I have done so far. I've created a program that runs in the background and powers off the system if it's idle for a certain amount of time, it also checks for the battery life on a specific system and goes to stand by mode if the system has been running on battery for a while. I input the time manually so I need a timer. I want to write it from scratch as it's a part of a personal project I've been working on.</p>
"
"<p>In our server/client-setup we're experiencing some weird behaviour. The client is a C/C++-application which uses OCI to connect to an Oracle server (using the <a href=""http://otl.sourceforge.net"" rel=""nofollow noreferrer"">OTL</a> library).</p>

<p>Every now and then the DB server dies in a way (yes this is the core issue, but from application-side we're unable to solve it but have to deal with it anyway), that the machine does not respond anymore to new requests/connections but the existing ones, like the Oracle-connections, do not drop or time out. Queries sent to the DB just never return successfully anymore.</p>

<p>What possibilities (if any) are provided by Oracle to detect these stalled connections from the client-application side and recover in a more or less safe way?</p>
"
"<p>I have something like this:</p>

<pre><code>char *current_day, *current_time;
system(""date +%F"");
system(""date +%T"");
</code></pre>

<p>It prints the current day and time in the stdout, but I want to get this output or assign them to the <code>current_day</code> and <code>current_time</code> variables, so that I can do some processing with those values later on.</p>

<pre><code>current_day ==&gt; current day
current_time ==&gt; current time
</code></pre>

<p>The only solution that I can think of now is to direct the output to some file, and then read the file and then assign the values of date and time to <code>current_day</code> and <code>current_time</code>. But I think this is not a good way. Is there any other short and elegant way?</p>
"
"<p>I need to get the current time in a ""HH:MM:SS""-format into a character array (string) so I can output the result later simply with a <code>printf(""%s"", timeString);</code></p>

<p>I'm pretty confused on the <code>timeval</code> and <code>time_t</code> types btw, so any explanation would be awesome:)</p>

<p>EDIT:
So I tried with strftime etc, and it kinda worked. Here is my code:</p>

<pre><code>time_t current_time;
struct tm * time_info;
char timeString[8];

time(&amp;current_time);
time_info = localtime(&amp;current_time);

strftime(timeString, 8, ""%H:%M:%S"", time_info);
puts(timeString);
</code></pre>

<p>But the output is this: ""13:49:53a??J`aS?""</p>

<p>What is going on with the ""<strong>a??J`aS?</strong>"" at the end?</p>
"
"<p>I am writing a program that will be used on a Solaris machine. I need a way of keeping track of how many seconds has passed since the start of the program. I'm talking very simple here. For example I would have an int seconds = 0; but how would I go about updating the seconds variable as each second passes?</p>

<p>It seems that some of the various time functions that I've looked at only work on Windows machines, so I'm just not sure.</p>

<p>Any suggestions would be appreciated.</p>

<p>Thanks for your time.</p>
"
"<p>I have the following situation:</p>

<p>There is a windows folder that has been mounted on a Linux machine. There could be multiple folders (setup before hand)
in this windows mount. I have to do something (preferably a script to start with) to watch these folders.</p>

<p>These are the steps:
Watch for any incoming file(s). Make sure they are transferred completely.
Move it to another folder.
I do not have any control over the file transfer program on the windows machine. It is a secure FTP I believe.
So I cannot ask that process to send me a trailer file to ensure the completion of file transfer.</p>

<p>I have written a bash script. I would like to know about any potential pitfalls with this approach. Reason is,
there is a possibility of mulitple copies of this script running for multiple directories like this.</p>

<p>At the moment, there could be upto 100 directories that may have to be monitored.</p>

<p>Following is the script. I'm sorry for pasting a very long one here. Please take your time to review it and
comment / criticize it. :-)</p>

<p>It takes 3 parameters, the folder that has to be watched, the folder where the file has to be moved,
and a time interval, which has been explained below.</p>

<p>I'm sorry there seems to be a problem with the alignment. Markdown doesn't seem to like it. I tried to organize it properly, but not able to do so.</p>

<p><code>Linux servername 2.6.9-42.ELsmp #1 SMP Wed Jul 12 23:27:17 EDT 2006 i686 i686 i386
GNU/Linux</code></p>

<pre><code>#!/bin/bash
log_this()
{
    message=""$1""
    now=`date ""+%D-%T""`
    echo $$"": ""$now "": "" $message
}
usage()
{
    cat &lt;&lt; EOF
Usage: $0 &lt;Directory to be watched&gt; &lt;Directory to transfer&gt; &lt;time interval&gt;
Time interval is the amount of time after which the modification time of a
file will be monitored.
EOF
    `exit 1`
}

if [ $# -lt 2 ]
then
    usage
fi

WATCH_DIR=$1
APP_DIR=$2

if [ ! -d ""$WATCH_DIR"" ]
then
    log_this ""FATAL: WATCH_DIR, $WATCH_DIR does not exist. Exiting""
    exit 1
fi

if [ ! -d ""$APP_DIR"" ]
then
    log_this ""APP_DIR: $APP_DIR does not exist. Exiting""
    exit 1
fi


# This needs to be set after considering the rate of file transfer.
# Represents the seconds elapsed after the last modification to the file.
# If not supplied as parameter, defaults to 3.

seconds_between_mods=$3

if ! [[ ""$seconds_between_mods"" =~ ^[0-9]+$ ]]; then
        if [ ${#seconds_between_mods} -eq 0 ]; then
                log_this ""No value supplied for elapse time. Defaulting to 3.""
                seconds_between_mods=3
        else
                log_this ""Invalid value provided for elapse time""
                exit 1
        fi
fi

log_this ""Start Monitor.""

while true
do
        ls -1 $WATCH_DIR | while read file_name
        do
            log_this ""Start Monitoring for $file_name""

            # Refer only the modification with reference to the mount folder.
            # If there is a diff in time between servers, we are in trouble.

            token_file=$WATCH_DIR/foo.$$
            current_time=`touch $token_file &amp;&amp; stat -c ""%Y"" $token_file`
            rm -f $token_file 2&gt;/dev/null

            log_this ""Current Time: $current_time""
            last_mod_time=`stat -c ""%Y"" $WATCH_DIR/$file_name`

            elapsed_time=`expr $current_time - $last_mod_time`
            log_this ""Elapsed time ==&gt; $elapsed_time""

            if [ $elapsed_time -ge $seconds_between_mods ]
            then
                    log_this ""Moving $file_name to $APP_DIR""

                    # In case if there is no space left on the target mount, hide the     file
                    # in the mount itself and remove the incomplete file from APP_DIR.
                    mv $WATCH_DIR/$file_name $APP_DIR
                    if [ $? -ne 0 ]
                    then
                            log_this ""FATAL: mv failed!! Hiding $file_name""
                            rm $APP_DIR/$file_name
                            mv $WATCH_DIR/$file_name $WATCH_DIR/.$file_name
                            log_this ""Removed $APP_DIR/$file_name. Look for $WATCH_DIR/.$file_name and submit later.""
                    fi

                    log_this ""End Monitoring for $file_name""
            else
                    log_this ""$file_name: Transfer seems to be in progress""
            fi
    done
    log_this ""Nothing more to monitor.""
    echo
    sleep 5
done
</code></pre>
"
"<p>I want to find the exact time where a media file is currently paused at (or playing) in a running Totem instance using D-Bus. To be precise, what I want is available from the Totem python console (if the plugin exists and is enabled) by the following command:</p>

<pre><code>&gt;&gt;&gt; print totem_object.props.current_time
732616
</code></pre>

<p>which I understand is milliseconds.</p>

<p>So far:
I've never used D-Bus before, so I'm in the process of going through D-Bus and python-dbus documentation. I've also fired up D-Feet and found that the <code>org.gnome.Totem</code> bus name and the <code>/Factory</code> object I can use the <code>org.freedesktop.DBus.Properties</code> interface methods.</p>

<p>I'm currently at this point:</p>

<pre><code>&gt;&gt;&gt; import dbus
&gt;&gt;&gt; seb= dbus.SessionBus()
&gt;&gt;&gt; t= seb.get_object('org.gnome.Totem', '/Factory')
&gt;&gt;&gt; tif= dbus.Interface(t, 'org.freedesktop.DBus.Properties')
&gt;&gt;&gt; tif.GetAll('')
dbus.Dictionary({}, signature=dbus.Signature('sv'))
</code></pre>

<p>I can't find even a proper how-to, so any help will be greatly appreciated.</p>
"
"<p>I have a python script that is constantly grabbing data from Twitter and writing the messages to a file. The question that I have is every hour, I want my program to write the current time to the file. Below is my script. Currently, it gets into the timestamp function and just keeps printing out the time every 10 seconds.</p>

<pre><code>#! /usr/bin/env python
import tweetstream
import simplejson
import urllib
import time
import datetime
import sched

class twit:
    def __init__(self,uname,pswd,filepath):
        self.uname=uname
        self.password=pswd
        self.filepath=open(filepath,""wb"")

    def main(self):
        i=0
        s = sched.scheduler(time.time, time.sleep)
        output=self.filepath

        #Grab every tweet using Streaming API
        with tweetstream.TweetStream(self.uname, self.password) as stream:
            for tweet in stream:
                if tweet.has_key(""text""):
                    try:
                        #Write tweet to file and print it to STDOUT
                        message=tweet['text']+ ""\n""
                        output.write(message)
                        print tweet['user']['screen_name'] + "": "" + tweet['text'], ""\n""

                        ################################
                        #Timestamp code
                        #Timestamps should be placed once every hour
                        s.enter(10, 1, t.timestamp, (s,))
                        s.run()
                    except KeyError:
                        pass
    def timestamp(self,sc):
        now = datetime.datetime.now()
        current_time= now.strftime(""%Y-%m-%d %H:%M"")
        print current_time
        self.filepath.write(current_time+""\n"")


if __name__=='__main__':
    t=twit(""rohanbk"",""cookie"",""tweets.txt"")
    t.main()
</code></pre>

<p>Is there anyway for my script to do it without constantly checking the time every other minute with an IF statement to see how much time has elapsed? Can I use a scheduled task like how I've done above with a slight modification to my current implementation?</p>
"
"<p>I am wondering is there any function that would return the current time in seconds, just 2 digits of seconds? I'm using gcc 4.4.2.</p>
"
"<p>Based on <a href=""http://www.kernel.org/doc/man-pages/online/pages/man5/acct.5.html"" rel=""nofollow noreferrer"">sys/acct.h</a> (V1, not V3) I need to gather some user usage statistics based on a parser that parser the acct file line by line. The parser will run and parse the entire file every N seconds and I need to gather user statistics accumulated since the last run (N seconds back). I'm not sure what will be the most appropriate way to do it based on the info provided by sys/acct.h.</p>

<p>Maybe something like this:</p>

<pre><code>if ((ac_btime + ac_etime) &lt; (current_time - N)) { gather; }
</code></pre>

<p>Also comp_t is said to be ""floating-point value consisting of a 3-bit, base-8 exponent, and a 13-bit mantissa"", but I think u_int16_t is just a unsigned short int. Should I be converting it to long it with the provided formula or not?</p>
"
"<p>Please see the code below:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

using namespace std;

int main(void)
{
      time_t current_time = 1270715952;
      cout &lt;&lt; ""Subscriber current timestamp:"" &lt;&lt; current_time &lt;&lt; endl;
      tm* currentTm = localtime(&amp;current_time);
      char tmp_str[256];
      //2010-04-08T11:39:12
      snprintf(tmp_str,
         sizeof(tmp_str),
         ""%04d%02d%02d%02d%02d%02d.000"",
         currentTm-&gt;tm_year+1900,
         currentTm-&gt;tm_mon+1,
         currentTm-&gt;tm_mday,
         currentTm-&gt;tm_hour,
         currentTm-&gt;tm_min,
         currentTm-&gt;tm_sec);
      cout &lt;&lt; ""Subscriber current date:"" &lt;&lt; tmp_str &lt;&lt; endl;
      tm tmpDateScheduleFrom, tmpDateScheduleTo;
      memset(&amp;tmpDateScheduleFrom, 0, sizeof(tm));
      memset(&amp;tmpDateScheduleTo, 0, sizeof(tm));
      //2010-04-08T11:00
      tmpDateScheduleFrom.tm_sec  = 0;
      tmpDateScheduleFrom.tm_min  = 0;
      tmpDateScheduleFrom.tm_hour = 11;
      tmpDateScheduleFrom.tm_mday = 8;
      tmpDateScheduleFrom.tm_mon  = 3;
      tmpDateScheduleFrom.tm_year = 110;
      //2010-04-08T12:00
      tmpDateScheduleTo.tm_sec  = 0;
      tmpDateScheduleTo.tm_min  = 0;
      tmpDateScheduleTo.tm_hour = 12;
      tmpDateScheduleTo.tm_mday = 8;
      tmpDateScheduleTo.tm_mon  = 3;
      tmpDateScheduleTo.tm_year = 110;
      time_t localFrom   = mktime(&amp;tmpDateScheduleFrom);
      time_t localTo     = mktime(&amp;tmpDateScheduleTo);
      cout &lt;&lt; ""Subscriber current timestamp:"" &lt;&lt; current_time &lt;&lt; endl;
      cout &lt;&lt; ""Subscriber localFrom:"" &lt;&lt; localFrom &lt;&lt; endl;
      cout &lt;&lt; ""Subscriber localTo:"" &lt;&lt; localTo &lt;&lt; endl;
      return 0;
}
</code></pre>

<p>The results are the following:</p>

<pre><code>Subscriber current timestamp:1270715952
Subscriber current date:20100408113912.000
Subscriber current timestamp:1270715952
Subscriber localFrom:1270717200
Subscriber localTo:1270720800
</code></pre>

<p>Why the current subscriber timestamp (subscriber date and time: 2010-04-08T11:39:12) is not between the range localFrom (timestamp of date/time: 2010-04-08T11:00:00) and LocalTo (timestamp of date/time: 2010-04-08T12:00:00)?</p>
"
"<p>I have a system that generates particles from sources and updates their positions. Currently, I have written a program in OpenGL which calls my <code>GenerateParticles(...)</code> and <code>UpdateParticles(...)</code> and displays my output. One functionality that I would like my system to have is being able to generate <code>n</code> particles per second. In my <code>GenerateParticles(...)</code> and <code>UpdateParticles(...)</code> functions, I accept 2 important parameters: <code>current_time</code> and <code>delta_time</code>. In <code>UpdateParticles(...)</code>, I update the position of my particle according to the following formula: <code>new_pos = curr_pos + delta_time*particle_vector</code>. How can I use these parameters and global variables (or other mechanisms) to produce <code>n</code> particles per second?</p>
"
"<p>I have to create an ""Expires"" value 5 minutes in the future, but I have to supply it in UNIX Timestamp format.  I have this so far, but it seems like a hack.</p>

<pre><code>def expires():
    '''return a UNIX style timestamp representing 5 minutes from now'''
    epoch = datetime.datetime(1970, 1, 1)
    seconds_in_a_day = 60 * 60 * 24
    five_minutes = datetime.timedelta(seconds=5*60)
    five_minutes_from_now = datetime.datetime.now() + five_minutes
    since_epoch = five_minutes_from_now - epoch
    return since_epoch.days * seconds_in_a_day + since_epoch.seconds
</code></pre>

<p>Is there a module or function that does the timestamp conversion for me?</p>
"
"<p>I need to deal with a counter that gives me ticks for my application. The counter is 32bits so what i need to know is how to deal with it when it wraps. for example:</p>

<p>I have a function that returns a (timestamp + shifttime) and i have another function that will return 1 or 0 depending whether or not the time has elapsed, but there could a possibility that that my counter will wrap how do I deal with this ?. </p>

<p>Thanks </p>

<p>Thanks a lot for all the responses guys. I will give more detail in this edit. </p>

<p>I am using the STM32 Cortex-M3. I wanna use the RTC counter to use it as the tick for my application to schedule tasks that need to happen at certain intervals. The RTC can generate an overflow interrupt so it's not a problem to detect the interrupt. the main problem that I have(or at least I think is a problem) is when certain tasks gets a (timestamp+shift) ie.</p>

<pre><code>
int main( void )
{
FlashLedTimeStamp = ReturnCounter( 20 );  // currentcounter value + a shift of 20
StatusLedTimeStamp = ReturnCounter( 3 );  // currentcounter value + a shift of 3

//then later on ....
while(1)
{
    /* other tasks could go here */

    if( HasTimeElapsed( FlashLedTimeStamp );
    {
       /* do something and get another timestamp value */
       FlashLedTimeStamp = ReturnCounter( 20 );  // currentcounter value + a shift of 20
    }

    if( HasTimeElapsed( StatusLedTimeStamp );
    {
       /* do something and get another timestamp value */
       FlashLedTimeStamp = StatusLedTimeStamp( 3 );  // currentcounter value + a shift of 3
    }
}
}
</code></pre>

<p>lets assume that my RTC counter is only 8 bits long to make the math easy. </p>

<p>if my current counter is at 250 when I get my timestamps that means that FlashLedTimeStamp = 14 and StatusLedTimeStamp = 253 how would i check to see that FlashLedTimeStamp has expired ??</p>

<p>keep in mind that I dont necessarily check all the time to see what the current counter is and whether or not certain timestamp has expired.  I hope this makes it clear what the problem I have is thanks to all in advanced. </p>
"
"<p>I need some way in c++ to keep track of the number of milliseconds since program execution.  And I need the precision to be in milliseconds. (In my googling, I've found lots of folks that said to include time.h and then multiply the output of <code>time()</code> by 1000 ... this won't work.)</p>
"
"<p>What is the most efficient way of getting current time/date/day/year in C language? As I have to execute this many times, I need a real efficient way.
I am on freeBSD.</p>

<p>thanks in advance.</p>
"
"<p>I want to write MJPEG picture internet stream viewer. I think getting jpeg images using sockets it's not very hard problem. But i want to know how to make accurate streaming.</p>

<pre><code>while (1)
{
     get_image()
     show_image()
     sleep (SOME_TIME) // how to make it accurate?
}
</code></pre>

<p>Any suggestions would be great.</p>
"
"<p>I'm writing a PyGTK GUI application in Ubuntu to browse some images, and I'd like to open an image in the default image viewer application when it is double-clicked (like when it is opened in Nautilus).<br>
How can I do it?</p>
"
"<p>How do you obtain the current timestamp in Sqlite? current_time, current_date, current_timestamp both return formatted dates, instead of a long.</p>

<pre><code>sqlite&gt; insert into events (timestamp) values (current_timestamp);
sqlite&gt; insert into events (timestamp) values (current_date);
sqlite&gt; insert into events (timestamp) values (current_time);
sqlite&gt; select * from events;
1|2010-09-11 23:18:38
2|2010-09-11
3|23:18:51
</code></pre>

<p>What I want:</p>

<pre><code>4|23234232
</code></pre>
"
"<p>I want to make a call - either a function call or doing some condition for a PERIOD of time ... typically 10 - 20 seconds.</p>

<p>I would get some user input for the amount of time and do that ... </p>

<p>What is the proper function to use on Linux/Unix systems?</p>

<p>gettimeofday seems to be the way to go ... or perhaps  time_t time(time_t *t) ... seems simple. What is preferred?</p>
"
"<p>I am trying to create a stopwatch in C++, something similar to Java's <a href=""http://download.oracle.com/javase/1.4.2/docs/api/java/util/TimerTask.html"" rel=""nofollow"">TimerTask</a>. I like their library since it already has threading built in. I have seen <a href=""http://svn.boost.org/svn/boost/sandbox/chrono/libs/chrono/doc/html/index.html"" rel=""nofollow"">Boost Chrono</a>, however, it's still in development and would prefer not to use it.</p>

<p>My current implementation has been without luck (I am going by memory right now so this might be a little pseudo code like).</p>

<pre><code>boost::asio::io_service io;
boost::asio::deadline_timer timer(io);


Initialize()
{
  boost::shared_ptr&lt;boost::thread&gt; thread = boost::shared_ptr&lt;boost::thread&gt;(
      new boost::thread(
        boost::bind(&amp;boost::asio::io_service::run, &amp;io)
  );
}

Start()
{
   timer.async_wait(
       bind(&amp;HandleTimerEvent, this, asio::placeholders::error)
   );
}

Stop()
{
  timer.cancel
}

Tick()
{
   cout &lt;&lt; ""THE TIME IS: "" &lt;&lt; timer.current_time &lt;&lt; endl; // Pseudo code for current_time.
}

HandleTimerEvent(boost::system::error_code&amp; e)
{
  cout &lt;&lt; ""Timer has ended: "" &lt;&lt; e &lt;&lt; endl;
}
</code></pre>

<p>What I would like to have is to have the thread continuously call <code>Tick()</code> and print out the current time. Also, my current implementation seems to have the thread as blocking the rest of the application which is something I definitely don't want. How would I do both of these things?</p>

<p>I am a noob when it comes to threading so please forgive me if I stated something that doesn't seem right.</p>
"
"<p>So, the situation is this.  I've got a C++ library that is doing some interprocess communication, with a <code>wait()</code> function that blocks and waits for an incoming message.  The difficulty is that I need a <em>timed</em> wait, which will return with a status value if no message is received in a specified amount of time.</p>

<p>The most elegant solution is probably to rewrite the library to add a timed wait to its API, but for the sake of this question I'll assume it's not feasible.  (In actuality, it looks difficult, so I want to know what the other option is.)</p>

<p>Here's how I'd do this with a busy wait loop, in pseudocode:</p>

<pre><code>while(message == false &amp;&amp; current_time - start_time &lt; timeout)
{
  if (Listener.new_message()) then message = true;
}
</code></pre>

<p>I don't want a busy wait that eats processor cycles, though.  And I also don't want to just add a <code>sleep()</code> call in the loop to avoid processor load, as that means slower response.  I want something that does this with a proper sort of blocks and interrupts.  If the better solution involves threading (which seems likely), we're already using <code>boost::thread</code>, so I'd prefer to use that.</p>

<p>I'm posting this question because this seems like the sort of situation that would have a clear ""best practices"" right answer, since it's a pretty common pattern.  What's the right way to do it?</p>

<p><strong>Edit to add:</strong> A large part of my concern here is that this is in a spot in the program that's both performance-critical and critical to avoid race conditions or memory leaks.  Thus, while ""use two threads and a timer"" is helpful advice, I'm still left trying to figure out how to actually implement that in a safe and correct way, and I can easily see myself making newbie mistakes in the code that I don't even know I've made.  Thus, some actual example code would be really appreciated!</p>

<p>Also, I have a concern about the multiple-threads solution: If I use the ""put the blocking call in a second thread and do a timed-wait on that thread"" method, what happens to that second thread if the blocked call never returns?  I know that the timed-wait in the first thread will return and I'll see that no answer has happened and go on with things, but have I then ""leaked"" a thread that will sit around in a blocked state forever?  Is there any way to avoid that?  (Is there any way to avoid that and avoid leaking the second thread's memory?)  A complete solution to what I need would need to avoid having leaks if the blocking call doesn't return.</p>
"
"<p>I am using date_time to abstract away platform peculiarities. and I need to produce a 64-bit microsec resolution uint64_t which will be used in serialization. I do not understand what is going wrong below.</p>

<pre><code>#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;
#include &lt;boost/cstdint.hpp&gt;
#include &lt;iostream&gt;

using namespace boost::posix_time;
using boost::uint64_t;

ptime UNIX_EPOCH(boost::gregorian::date(1970,1,1));

int main() {
    ptime current_time = microsec_clock::universal_time();

    std::cout &lt;&lt; ""original time: ""&lt;&lt; current_time &lt;&lt; std::endl;

    long microsec_since_epoch = ((current_time -UNIX_EPOCH).total_microseconds());

    ptime output_ptime = UNIX_EPOCH + microseconds(microsec_since_epoch);
        std::cout &lt;&lt; ""Deserialized time : "" &lt;&lt; output_ptime &lt;&lt; std::endl;

    std::cout &lt;&lt; ""Microsecond output: "" &lt;&lt; microsec_since_epoch &lt;&lt; std::endl;

    std::cout &lt;&lt; ""Microsecond to second arithmetic: ""
        &lt;&lt; microsec_since_epoch/(10*10*10*10*10*10) &lt;&lt; std::endl;

    std::cout &lt;&lt; ""Microsecond to tiume_duration, back to microsecond : "" &lt;&lt;
        microseconds(microsec_since_epoch).total_microseconds() &lt;&lt; std::endl;


    return 0;
}
</code></pre>

<p>Here is the output I get. </p>

<pre><code>original time: 2010-Dec-17 09:52:06.737123
Deserialized time : 1970-Jan-16 03:10:41.577454
Microsecond output: 1292579526737123
Microsecond to second arithmetic: 1292579526
Microsecond to tiume_duration, back to microsecond : 1307441577454
</code></pre>

<p>When I switch to using <code>total_seconds()</code> and +<code>seconds(..)</code> The problems dissapear --i.e., input changes to:</p>

<pre><code>2010-Dec-15 18:26:22.606978
2010-Dec-15 18:26:22
</code></pre>

<p>date_time claims to use a 64-bit type internally, and <code>2^64? (10^6?3600?24?365) ~= 584942</code> even <code>2^60? (10^6?3600?24?365) ~= 36558</code>.</p>

<p>The opening lines from wikipedia have this to say about Posix time </p>

<blockquote>
  <p>Unix time, or POSIX time, is a system
  for describing points in time, defined
  as the number of seconds elapsed since
  midnight Coordinated Universal Time
  (UTC) of January 1, 1970</p>
</blockquote>

<p>Why is such Massive truncation going on 40 years down the line ? </p>

<p>How do I use the full 64-bit space with microsecond resolution using boost::date_time ?</p>

<p><strong>--edit1 in response to hans--</strong></p>

<p>The post has been changed to reflect the integer output of the duration.total_microseconds() part. Note 1292576572566904?(10^6?3600?24?365) ~= 40.98 years. The output from seconds has not been updated.</p>

<p><strong>--edit2--</strong>
Downscaling the microseconds to seconds before the ""deserialization"" step, also works well. This approach solved my problem,I only need the microsecond resolution at creation, and I can live without it at deserialization.</p>

<p>I do still want to know the what and why of the problem.</p>
"
"<p>Given a <code>time_t</code> as <code>1291121400</code>, how do I get the date of that day formatted as <code>20101130</code>?</p>
"
"<p>In C, accessing an array index is faster or accessing by pointer is faster?
By faster I mean, which one would take less clock cycle.
The array is not an constant array.</p>
"
"<p>Can I basically do something like:</p>

<pre><code>register_function_hook('myFunctionHook');
</code></pre>

<p>so then when any function is run:</p>

<pre><code>functionA(); //The hook runs myFunctionHook();
anoterFunction(); //The hook runs myFunctionHook();
Class::functionA(); //The hook runs myFunctionHook();
</code></pre>

<p>Does such a thing exist?</p>

<p>-- Edit --</p>

<p>What I want to do is to get a breakdown of durations of each function. Ie. Performance Tuning. I want to get an idea of what takes all the time without installing xDebug on my Apache server, however I don't know if it is possible.</p>
"
"<p>I want to delete records from a database when they are 7 days or older. I have my server time set to UK time but for some reason the code I wrote below always echo's <strong>Account Deleted as 7 or more days old</strong> and for some reason it's not working. Before I test on my test database I decided to use a simple echo for now, but as I say it won't work.</p>

<p>Anyone have any suggestions why it's not working? I must be doing something wrong.</p>

<pre><code>&lt;?php

// Get Current Time
$current_time = time();

/* The time i used below (unix) for testing is
18-02-2011 14:34:24 (yesterdays date/time) */
$account_delete = strtotime(time('1298039664'));

if ($current_time - $account_delete &gt;= (7*24*60*60)){
echo 'Account Deleted as 7 or more days old';
} else {
  echo 'Account Not Deleted as less than 7 days old';
}

?&gt;
</code></pre>
"
"<p>When will clock_gettime() return a smaller value, using CLOCK_MONOTONIC, due to reaching it's maximum value? I don't mean the little warps that have been described as bugs, but something like a counter reset.</p>

<p>Is it time measured, or is it related to the absolute number of ticks?</p>

<p>I have to implement a timer (1 or 2 second intervals), and i don't need that much precision. But the aplication may be running several hours without restarting. (i estimate 1 day max).</p>

<p>I wan't to be shure i won't make any mistakes that may lead to it stop comunicating.</p>

<p>Does timerfd already takes care of this issue?</p>
"
"<p>follow my question title.
And I realize it using the code below:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/time.h&gt;

#define COFF (1 &lt;&lt; 20) //1MB
#define LOW_BYTE (1 &lt;&lt; 10) //1kb
#define UP_BYTE (1 &lt;&lt; 23) //8MB
#define MAX UP_BYTE/sizeof(double)

double a[MAX] = {1};

double current_time(void)
{
    double timestamp;

    struct timeval tv;
    gettimeofday(&amp;tv, 0);

    timestamp = (double)((double)(tv.tv_sec*1e6) +(double)tv.tv_usec);
    return timestamp;
}

void test_band_width(int size){
    int i;
    volatile double r = 0;
    for (i=0; i &lt; size; i+=16) {
        r += a[i];
    }
}

int main(int argc, char* argv[]){
    int k, size;
    double cycles;
    double t_start=0.0, t_end=0.0, time=0.0;
    for (k=UP_BYTE; k &gt;= LOW_BYTE; k &gt;&gt;= 1) {
        size = k / sizeof(double);
        t_start = current_time();
        test_band_width(size);
        t_end = current_time();
        //printf(""time is %lf\n"",t_end-t_start);
        time = (t_end-t_start);
        printf(""time2 is %lf\n\n\n"",time);
        printf(""This time the BandWith is %.7f\n"",k/(16*time));
    }
    return 0;
}
</code></pre>

<p>But there may be some problem when I tested my PC, maybe the way I test the systime?</p>
"
"<p>I am currently building a PHP framework (original, i know) and  im working on some optimisation features for it. One dilema I have come accross is what is the best way to cache MySQL results? I know some people will say, first optimise your MySQL etc, but lets say for arguments sake, my query takes 1 minute to run and is as optimised as possible.</p>

<p>What would be the best way to cache the results in PHP so I dont have to rerun the query every page load?</p>

<p>My first thought was to maybe loop through the results, add them to an array... serialize them and then store in a file. Now as creating the cache only occurs once, I can afford the overhead of the serialize function if the array contains say 1 million results. How ever, loading the cached file and then unserializing the array on every pageload, could have performance impact.</p>

<p>Would it then be a better idea to while caching, instead of serializing the results and the writing to file, write to the file in a way that displays the results in a PHP readable array. So when it loads, there is no unserialize overhead.</p>

<p>Are there any other (read: faster) ways to cache a slow query for frequent use?</p>
"
"<p>I am using the below bit of code to get the <code>timestamps</code> of files on my cloud server and then delete any that are over a certain age. </p>

<p>For now the code is set to delete anything older than 10 minutes for testing. </p>

<p>However it deletes everything, even if I upload some files then run the script 10 seconds later.</p>

<p>Is there some small problem I am not seeing?</p>

<pre><code>    $auth-&gt;authenticate();

    //connect
    $conn = new CF_Connection($auth);

    //create a handle for the CLOUD FILES container we want to delete from
    $daily_dose = $conn-&gt;get_container('daily_dose');

    //delete the obeject
    $daily_packages = $daily_dose-&gt;list_objects();
    //print_r($daily_packages);
    //$public_container = $conn-&gt;get_container(""public"");

    //$file_age = 86400; // 1 day in seconds
    $file_age = 600; // 10 minutes

    echo 'current time: ';
    echo $current_time = time();
    echo '&lt;br&gt;';
    echo 'time offset: ';
    echo $previous_day = $current_time - $file_age;
    echo '&lt;br&gt;';

    foreach($daily_packages as $package)
    {
        echo $item = $daily_dose-&gt;get_object($package);
        $modified = $item-&gt;last_modified;
        echo ' ' . $modified;
        echo ' -&gt; ' . strtotime($modified);
        echo '&lt;br&gt;';

        //If the modified time of the file is less the current time - 1 day in seconds (older than 1 day) delete it
        if ( $modified &lt; $previous_day )
        {
            //delete the file
            $daily_dose-&gt;delete_object($item);
        }
    }
</code></pre>
"
"<pre><code>time_t raw_time = time(NULL);
tm* current_time = localtime(&amp;raw_time);
</code></pre>

<p>I got the answer myself... I totally messed up the warnings. Thanks anyway.</p>
"
"<p>I am currently using this function to benchmark some php scripts, the script gets the microtime it takes to execute, and writes it to a log on the server, but the problem i am having is that i have no idea what are some decent times. the script is below followed by some of my times, can anyone give me an idea on what kind of times i want to be within the range of?</p>

<p><strong>PLACE AT THE BEGINNING OF THE PAGE</strong></p>

<pre><code>global $start_time; $start_time = microtime();
</code></pre>

<p><strong>PLACE AT THE END OF THE PAGE</strong></p>

<pre><code>global $start_time;
$ra_start = explode(' ', $start_time);
$ra_end = explode(' ', microtime());
$cpu_time = ($ra_end[1]+$ra_end[0]) - ($ra_start[1]+$ra_start[0]);
$f = fopen('/home/mcbeav/cpu_usage.log', 'a', 1);
// time seconds request by_ip
fwrite($f, date('m-d-Y H:m').""\t"".$cpu_time.""\t"".$_SERVER['SERVER_NAME'].""\t"".$_SERVER['PHP_SELF'].""\t"".$_SERVER['REMOTE_ADDR'].""\n"");
fclose($f);
</code></pre>

<p><strong>RESULTS FOR THE SAME PAGE</strong></p>

<pre><code>0.10285401344299
0.021783828735352
0.018580913543701
0.042204856872559
</code></pre>
"
"<p>I'm working on a class project in which I must write a command line shell with the following requirements:</p>

<ul>
<li>The shell must able to read buffered input</li>
<li>Buffer should be 64 characters</li>
<li>Error conditions should be handled
<ul>
<li>Exceeded buffer size</li>
<li>Interruptions (when a signal arrives) ? see the man page for read()</li>
<li>Invalid input (unparsable characters, blank lines, etc)</li>
<li>Any other error that may be encountered.</li>
</ul></li>
<li>Shell must have a history of at least 20 items, and the history must not be of a static size. When the history buffer is full, the oldest item is removed and the newest item added.</li>
<li>Programs should be able to run in the foreground or background. (using &amp;)</li>
<li>Ctrl-D will exit the shell</li>
<li>Ctrl-C will print the complete history</li>
<li>The Command ?history? will also print the complete history. Newest items will be at the bottom of the list.</li>
<li>All other signals will be trapped and displayed to the user in the shell</li>
<li>Program will use the read() command to read in input, unless the arrow keys are supported</li>
</ul>

<p>I have opted to implement arrow keys for history cycling, so I'm using ncurses for input, rather than read(). I think I'm doing all right using strtok() to parse input, and fork() and execvp() to run the processes, but I'm not doing all right implementing ncurses correctly. All I've gotten it to do so far is init a new screen, display the prompt, then segfault upon any key press. Not good.</p>

<p>I reckon the problem must be in my design. I'm not wrapping my head around ncurses too well. What sort of data structures should I be using for this project? How should I handle the ncurses setup, teardown, and everything in between? What's the deal with windows and screens, and should I have a single globally accessible window/screen that I work with? Also, I've been trying to use a char* for the input buffer, and a char** for the command history, but I have no experience in C, so despite reading up on malloc, calloc, and realloc, I'm not sure of the best way to store commands in the buffer and the history. Any tips on managing these char arrays?</p>

<p><strong>tl;dr: How do I use ncurses correctly to make a command line shell, and how do I handle the command memory management with C?</strong></p>

<p>I realize this is a pretty hefty question. :(</p>

<p><em>edit: I have already seen <a href=""http://www.gnu.org/software/libc/manual/html_node/Implementing-a-Shell.html"" rel=""nofollow"">http://www.gnu.org/software/libc/manual/html_node/Implementing-a-Shell.html</a> and <a href=""http://www.linuxinfor.com/english/NCURSES-Programming/"" rel=""nofollow"">http://www.linuxinfor.com/english/NCURSES-Programming/</a> but the ncurses documentation has actually too much overhead. I just want to use its ability to recognize arrow keys.</em></p>
"
"<p>I need a linux bash script to know the time in seconds when a particular folder was modified.
Can someone please help me? </p>

<p>My current script below is getting the current time stamp and the last time the folder was modified, but i do not know how to proceed.</p>

<pre><code>[root@cgf01 log]# more CheckLastCdr.sh
#get current timestamp
current_time=`date`

#get last CDR timestamp
last_cdr_time=`find /tmp/log/ -exec stat \{} --printf=""%y\n"" \; | sort -n -r | head -1`


echo $current_time
echo $last_cdr_time
</code></pre>

<p>when i run this script i am getting the following:</p>

<pre><code>[root@cgf01 log]# ./CheckLastCdr.sh
./CheckLastCdr.sh: line 6: 2011-04-05: command not found
Tue Apr 5 16:19:31 CEST 2011
2011-04-05 16:14:33.000000000 +0200
</code></pre>

<p>thanks in advance</p>
"
"<p>this code compiles in Linux but not Solaris, because apparently ppoll() is Linux specific (I get an undefined symbol error in Solaris with GCC). Any help converting it? I don't think just using poll() is a good idea, but then again, I didn't write this code. (I got it from <a href=""https://stackoverflow.com/questions/5545331/writing-a-command-line-shell-with-c-trying-to-use-ncurses-c-for-the-first-time/5548778#5548778"">Writing a command line shell with C; trying to use ncurses/C for the first time</a>)</p>

<pre><code>#include &lt;poll.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;termios.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

/** VT100 command to clear the screen. Use puts(VT100_CLEAR_SCREEN) to clear
 *  the screen. */
#define VT100_CLEAR_SCREEN ""\033[2J""

/** VT100 command to reset the cursor to the top left hand corner of the
 *  screen. */
#define VT100_CURSOR_TO_ORIGIN ""\033[H""

struct frame_s
{
    int x;
    int y;
    char *data;
};

static int draw_frame(struct frame_s *frame)
{
    int row;
    char *data;
    int attrib;

    puts(VT100_CLEAR_SCREEN);
    puts(VT100_CURSOR_TO_ORIGIN);

    for (row = 0, data = frame-&gt;data; row  &lt; frame-&gt;y; row++, data += frame-&gt;x)
    {
        /*  0 for normal, 1 for bold, 7 for reverse. */
        attrib = 0;

        /*  The VT100 commands to move the cursor, set the attribute, and the
         *  actual frame line. */
        fprintf(stdout, ""\033[%d;%dH\033[0m\033[%dm%.*s"", row + 1, 0, attrib, frame-&gt;x, data);
        fflush(stdout);
    }

    return (0);
}

int main(void)
{
    const struct timespec timeout = { .tv_sec = 1, .tv_nsec = 0 };
    struct frame_s frame;
    struct termios tty_old;
    struct termios tty_new;
    unsigned char line[128];
    unsigned int count = 0;
    int ret;
    struct pollfd fds[1];
    sigset_t sigmask;
    struct tm *tp;
    time_t current_time;

    /*  Set up a little frame. */
    frame.x = 80;
    frame.y = 5;
    frame.data = malloc(frame.x * frame.y);

    if (frame.data == NULL)
    {
        fprintf(stderr, ""No memory\n"");
        exit (1);
    }

    memset(frame.data, ' ', frame.x * frame.y);

    /*  Get the terminal state. */
    tcgetattr(STDIN_FILENO, &amp;tty_old);
    tty_new = tty_old;

    /*  Turn off ""cooked"" mode (line buffering) and set minimum characters
     *  to zero (i.e. non-blocking). */
    tty_new.c_lflag &amp;= ~ICANON;
    tty_new.c_cc[VMIN] = 0;

    /*  Set the terminal attributes. */
    tcsetattr(STDIN_FILENO, TCSANOW, &amp;tty_new);

    /*  Un-mask all signals while in ppoll() so any signal will cause
     *  ppoll() to return prematurely. */
    sigemptyset(&amp;sigmask);

    fds[0].events = POLLIN;
    fds[0].fd = STDIN_FILENO;

    /*  Loop forever waiting for key presses. Update the output on every key
     *  press and every 1.0s (when ppoll() times out). */
    do
    {
        fds[0].revents = 0;
        ret = ppoll(fds, sizeof(fds) / sizeof(struct pollfd), &amp;timeout, &amp;sigmask);

        if (fds[0].revents &amp; POLLIN)
        {
            ret = read(STDIN_FILENO, &amp;line[count], sizeof(line) - count);

            if (ret &gt; 0)
            {
                line[count + ret] = '\0';

                if (strcmp(&amp;line[count], ""\033[A"") == 0)
                {
                    snprintf(frame.data, frame.x, ""up"");
                    count = 0;
                }
                else if (strcmp(&amp;line[count], ""\033[B"") == 0)
                {
                    snprintf(frame.data, frame.x, ""down"");
                    count = 0;
                }
                else if (line[count] == '\n')
                {
                    snprintf(frame.data, frame.x, ""entered: %s"", line);
                    count = 0;
                }
                else
                {
                    count += ret;
                }
            }
        }

        /*  Print the current time to the output buffer. */
        current_time = time(NULL);
        tp = localtime(&amp;current_time);
        strftime(&amp;frame.data[1 * frame.x], frame.x, ""%Y/%m/%d %H:%M:%S"", tp);

        /*  Print the command line. */
        line[count] = '\0';
        snprintf(&amp;frame.data[(frame.y - 1) * frame.x], frame.x, ""$ %s"", line);

        draw_frame(&amp;frame);
    }
    while (1);

    /*  Restore terminal and free resources. */
    tcsetattr(STDIN_FILENO, TCSANOW, &amp;tty_old);
    free(frame.data);

    return (0);
}
</code></pre>
"
"<p>a kind user here gave me some code to work with for a command line shell, but I want it to output to <code>stdout</code> and <code>stderr</code> instead of using a screen or whatever it is doing right now. I am new to C so I don't know anything about converting it. I also need its ability to detect arrow keys preserved... I'm trying to make a simplistic bash clone. This is what I have right now, it's about 50% my code and 50% others'... yes, it is buggy. There are large sections commented out because they were no longer being used or because they were broken. Ignore them. :)</p>

<p>The particular difficulty is in the use of <code>draw_frame()</code> in <code>main()</code>.</p>

<pre><code>#include ""os1shell.h""
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt; /* standard unix functions, like getpid()       */
#include &lt;sys/types.h&gt;  /* various type definitions, like pid_t         */
#include &lt;signal.h&gt; /* signal name macros, and the kill() prototype */
#include &lt;ncurses/curses.h&gt; /* a library for cursor-based programs  */

#include &lt;poll.h&gt;
#include &lt;termios.h&gt;
#include &lt;time.h&gt;

/** VT100 command to clear the screen. Use puts(VT100_CLEAR_SCREEN) to clear
 *  the screen. */
#define VT100_CLEAR_SCREEN ""\033[2J""

/** VT100 command to reset the cursor to the top left hand corner of the
 *  screen. */
#define VT100_CURSOR_TO_ORIGIN ""\033[H""

struct frame_s {
int x;
int y;
char *data;
};

char* inputBuffer;  /* the command input buffer, will be length 65 and null
                * terminated. */
char** cmdHistory;  /* the command history, will be no longer than 20
                * elements and null terminated. */
int historySize = 0;

void addToHistory(char* newItem) {
    char** h;
    int historySize = 0;
    for (historySize; historySize &lt; 21; ++historySize) {
        if (cmdHistory[historySize] == NULL) break;
    }
    if (historySize == 20) {
        char** newPtr = cmdHistory + sizeof(char *);
        free(cmdHistory[0]);
        cmdHistory = newPtr;
        h = (char**)realloc(cmdHistory,21*sizeof(char *));
        cmdHistory = h;
        cmdHistory[19] = newItem;
        cmdHistory[20] = NULL;
    } else {
        h = (char**)realloc(cmdHistory,(historySize+2)*sizeof(char *));
        cmdHistory = h;
        cmdHistory[historySize] = newItem;
        cmdHistory[historySize+1] = NULL;
    }
}

/* Some help from http://stackoverflow.com/users/1491/judge-maygarden*/
char** getArguments(char* input) {
    char** arguments;
    int k = 0;
    char* tokenized;
    arguments = calloc(1, sizeof (char *));
    tokenized = strtok(input, "" &amp;"");
    while (tokenized != NULL) {
        arguments[k] = tokenized;
        ++k;
        arguments = realloc(arguments, sizeof (char *) * (k + 1));
        tokenized = strtok(NULL, "" &amp;"");
    }

    // an extra NULL is required to terminate the array for execvp()
    arguments[k] = NULL;

    return arguments;
}

void printHistory(struct frame_s *frame) {
    snprintf(frame-&gt;data, frame-&gt;x, ""\n\n"");
    char** currCmd = cmdHistory;
    while (*currCmd != NULL) {
        snprintf(frame-&gt;data[(2*frame-&gt;x)], frame-&gt;x, ""%s\n"", *currCmd);
        currCmd++;
    }
    snprintf(frame-&gt;data, frame-&gt;x, ""\n\n"");
}

/* Some help from http://stackoverflow.com/users/659981/ben*/
static int draw_frame(struct frame_s *frame) {
    int row;
    char *data;
    int attrib;

    puts(VT100_CLEAR_SCREEN);
    puts(VT100_CURSOR_TO_ORIGIN);

    for (   row = 0, data = frame-&gt;data;
        row  &lt; frame-&gt;y;
        row++, data += frame-&gt;x ) {
        //  0 for normal, 1 for bold, 7 for reverse.
        attrib = 0;

        //  The VT100 commands to move the cursor, set the attribute,
        //  and the actual frame line.
        fprintf(    stdout,
                ""\033[%d;%dH\033[0m\033[%dm%.*s"",
                row + 1,
                0,
                attrib, frame-&gt;x, data);
        fflush(stdout);
    }

    return (0);
}

/* Some help from http://stackoverflow.com/users/659981/ben*/
int main(void) {
    const struct timespec timeout = { .tv_sec = 1, .tv_nsec = 0 };
    struct frame_s frame;
    struct termios tty_old;
    struct termios tty_new;
    unsigned char line[65];     // the input buffer
    unsigned int count = 0;     // the count of characters in the buff
    int ret;
    struct pollfd fds[1];
    sigset_t sigmask;
    struct tm *tp;
    time_t current_time;

    cmdHistory = (char**)calloc(21,sizeof(char *)); // initialize the
                            // command history
    cmdHistory[20] = NULL;      // null terminate the history
    int histInd = 0;        // an index for the history for arrows

    int t;
    int r;
    char** downTemp;
    char** enterTemp;

    //  Set up a little frame.
    frame.x = 80;
    frame.y = 32;
    frame.data = malloc(frame.x * frame.y);

    if (frame.data == NULL) {
        fprintf(stderr, ""No memory\n"");
        exit (1);
    }

    memset(frame.data, ' ', frame.x * frame.y);

    //  Get the terminal state.
    tcgetattr(STDIN_FILENO, &amp;tty_old);
    tty_new = tty_old;

    //  Turn off ""cooked"" mode (line buffering) and set minimum characters
    //  to zero (i.e. non-blocking).
    tty_new.c_lflag &amp;= ~ICANON;
    tty_new.c_cc[VMIN] = 0;

        // Set the terminal attributes.
        tcsetattr(STDIN_FILENO, TCSANOW, &amp;tty_new);

    //  Un-mask all signals while in ppoll() so any signal will cause
    //  ppoll() to return prematurely.
    sigemptyset(&amp;sigmask);

    fds[0].events = POLLIN;
    fds[0].fd = STDIN_FILENO;

    // Loop forever waiting for key presses. Update the output on every key
    // press and every 1.0s (when ppoll() times out).
    do {
        fd_set rdset;
        int nfds = STDIN_FILENO + 1;

        FD_ZERO(&amp;rdset);
        FD_SET(STDIN_FILENO, &amp;rdset);
        ret = pselect(nfds, &amp;rdset, NULL, NULL, &amp;timeout, &amp;sigmask);

        if (ret &lt; 0) {          // check for pselect() error.
            if (errno == EINTR) {
                continue;
            } else {
                break;
            }
        }

        if (FD_ISSET(STDIN_FILENO, &amp;rdset)) {
            ret = read(STDIN_FILENO,&amp;line[count],sizeof(line)-count);

//  do {
//      fds[0].revents = 0;
//      ret = poll(fds, sizeof(fds) / sizeof(struct pollfd), 1000);
//
//      if (fds[0].revents &amp; POLLIN) {
//          ret = read(STDIN_FILENO,&amp;line[count],sizeof(line)-count);

            if (ret &gt; 0) {
                line[count + ret] = '\0';

                if (strcmp(&amp;line[count], ""\033[A"") == 0) {
                    if (histInd &gt; 0) {
                        --histInd;
                    }
                    count = 0;
                    if(cmdHistory[histInd]!=NULL) {
                        snprintf(&amp;frame.data[(2*frame.x)],
                            frame.x,
                            ""hist: %s"",
                            cmdHistory[histInd]);
                        strcpy(line, cmdHistory[histInd]);
                    }
                } else if (strcmp(&amp;line[count],""\033[B"")==0) {
                    char** downTemp = cmdHistory;
                    r = 0;
                    while (*downTemp != NULL) {
                        ++downTemp;
                        ++r;
                    }
                    if (histInd &lt; r-1 &amp;&amp; r!= 0) {
                        ++histInd;
                    }
                    count = 0;
                    if(cmdHistory[histInd]!=NULL) {
                        snprintf(&amp;frame.data[(2*frame.x)],
                            frame.x,
                            ""hist: %s"",
                            cmdHistory[histInd]);
                        strcpy(line, cmdHistory[histInd]);
                    }
                } else if (line[count] == 127) {
                    if (count != 0) {
                        line[count] = '\0';
                        count -= ret;
                    }
                    snprintf(&amp;frame.data[(2*frame.x)], frame.x, ""backspace"");
                } else if (line[count] == '\n') {
                    char** arguments = getArguments(line);
                    snprintf(   &amp;frame.data[(2*frame.x)],
                            frame.x,
                            ""entered: %s"",
                            line);
                    if (count &gt; 0) {
                        int hasAmpersand = 0;
                        char* cmd = (char*)
                            malloc(65*sizeof(char));
                        strcpy(cmd, line);
                        addToHistory(cmd);
                        /*
                        char* temp = cmd;
                        while (*temp != '\0') {
                            if (*temp == '&amp;') {
                                hasAmpersand = 1;
                            }
                            ++temp;
                        }
                        pid_t pid;
                        pid = fork();
                        if (pid == 0) {
                            int exeret;
                            exeret = execvp(*arguments,
                                    arguments);
                            if (exeret &lt; 0) {
                                snprintf(
                                    &amp;frame.data[
                                        (2*frame.x)],
                                    frame.x,
                                    ""Exec failed.\n\n"");
                                exit(1);
                            }
                        } else if (pid &lt; 0) {
                            snprintf(
                                &amp;frame.data[
                                    (2*frame.x)],
                                frame.x,
                                ""Fork failed.\n\n"");
                            exit(1);
                        } else if (pid &gt; 0) {
                            if (!hasAmpersand) {
                                wait(NULL);
                            }
                            free(arguments);
                            snprintf(frame.data,
                                frame.x,
                                ""\n\n"");
                        }*/
                    } else {
                        free(arguments);
                    }
                    enterTemp = cmdHistory;
                    t = 0;
                    while (*enterTemp != NULL) {
                        ++enterTemp;
                        ++t;
                    }
                    if (t &gt; histInd) histInd = t;
                    count = 0;
                } else {
                    //snprintf( frame.data,
                    //      frame.x,
                    //      ""char: %c"",
                    //      line[count]);
                    count += ret;
                }
            }
        }

        // Print the current time to the output buffer.
        //current_time = time(NULL);
        //tp = localtime(&amp;current_time);
        //strftime( &amp;frame.data[1 * frame.x],
        //      frame.x,
        //      ""%Y/%m/%d %H:%M:%S"",
        //      tp);

        //  Print the command line.
        line[count] = '\0';
        snprintf(   frame.data,
                frame.x,
                ""OS1Shell -&gt; %s"",
                line);

        draw_frame(&amp;frame);
    } while (1);

    //  Restore terminal and free resources.
    tcsetattr(STDIN_FILENO, TCSANOW, &amp;tty_old);
    free(frame.data);
    int n = 0;
    while (n &lt; 21) {
        free(cmdHistory[n]);
        ++n;
    }
    free(cmdHistory);

    return (0);
}
</code></pre>

<p>Any help getting it to act more like bash would be highly appreciated! Part of the credit is for using <code>stderr</code> correctly anyways, so it would definitely help to take the <code>stdin</code>/<code>stdout</code>/<code>stderr</code> approach.</p>
"
"<p>I have a program which executes constantly and I need to save data every minute.</p>

<p>The program process data and every minute I want to save the value of a variable and do some statistical operations to know the variation of this variable.</p>

<p>I thought i can make it with a signal, SIGALRM and alarm(60). My subquestion is, can I put a class method as the destiny method for SIGALRM?</p>

<p>Any other idea to execute a method to save data and do some operations every minute ??</p>

<p>The program is written in C++, runs in Linux an a mono-core processor. </p>
"
"<p>I am developing a simple game in c++, a chase-the-dot style one, where you must click a drawn circle on the display and then it jumps to another random location with every click, but I want to make the game end after 60 seconds or so, write the score to a text file and then upon launching the program read from the text file and store the information into an array and somehow rearrange it to create a high score table.
I think I can figure out the high score and mouse clicking in a certain area myself, but I am completely stuck with creating a possible timer.
Any help appreciated, cheers!</p>
"
"<p>I'm looking for a way to be able to know how much time it's been since my program was started, at any given time. A sort of timer that would keep running while the main code is doing everything else, and that can be called at any time.</p>

<p>The context is an OpenGL application on Windows, and as well as knowing which keyboard keys are being pressed (using glutKeyboardFunc), I'd like to know <strong><em>when</em></strong> exactly each key is pressed. All of this info is written into an XML file that will later be used to replay everything the user did. (sort of like the replay functionality in a car racing game, but more simple).</p>
"
"<p>All,</p>

<p>I have a database field which actually computes the time spent from the time the quiz started to the current time. This was done at some point of time (recorded as current time) and now I have an Unixtimestamp value for it </p>

<p>i.e. Suppose the start time was 5/5/2011 1pm and the current time was populated at 5/5/2011 2pm. So the difference is calculated and stored as an Unix timestamp. </p>

<p>Now I don't know when this was actually done and now I have to revert back to hours spent taking the quiz. So here a Unix timestamp needs to be converted back to hours, in this case return 1 hour. Can anyone please help me understand how to do this?</p>
"
"<p>I'm writing a c program with an mysql database connection
and I'm having difficulties creating my mysql queries...</p>

<p>i want to you a variable integer in my mysql query, but i can't seem to get i right...</p>

<p>my current query looks like this...</p>

<pre><code>mysql_query(conn, ""INSERT INTO markerherkenning (MARKER_ID, DATETIME) values(1, CURRENT_TIME())"");
</code></pre>

<p>my marker_ID value should be a variable value, so i can reduce my code...</p>

<p>i have used this guide to get me going...
<strong>(http://zetcode.com/tutorials/mysqlcapitutorial)</strong></p>

<p>thanks for helping</p>
"
"<p>EI have function which takes as parameter pointer to vector:  </p>

<pre><code>void Function(std::vector&lt;type&gt;* aa)
</code></pre>

<p>Now inside this function I want to filter out data from that vector to another vector and I want to change data of original vector by changing values of this temporary one. Damn it's hard to understand something like:</p>

<pre><code>void Function(std::vector&lt;type&gt;* aa)
{
    std::vector&lt;type*&gt; temp; //to this vector I filter out data and by changning
    //values of this vector I want to autmatically change values of aa vector
}
</code></pre>

<p>I have something like that:</p>

<pre><code>void Announce_Event(std::vector&lt;Event&gt;&amp; foo)
{
    std::vector&lt;Event&gt; current;
    tm current_time = {0,0,0,0,0,0,0,0,0};
    time_t thetime;
    thetime = time(NULL);
    localtime_s(&amp;current_time, &amp;thetime);
    for (unsigned i = 0; i &lt; foo.size(); ++i) {
        if (foo[i].day == current_time.tm_mday &amp;&amp;
            foo[i].month == current_time.tm_mon &amp;&amp;
            foo[i].year == current_time.tm_year+1900)
        {
            current.push_back(foo[i]);
        }
    }
    std::cout &lt;&lt; current.size() &lt;&lt; std::endl;
    current[0].title = ""Changed""; //&lt;-- this is suppose to change value.
}
</code></pre>

<p>That does not change original value.</p>
"
"<p>I have a <code>.sh</code> file stored in some Linux system.  The full path of the file is:</p>

<pre><code>/comviva/CPP/Kokila/TransactionHandler/scripts/stopTH.sh
</code></pre>

<p>I am tring to execute it by</p>

<pre><code>Runtime.getRuntime().exec(`/comviva/CPP/Kokila/TransactionHandler/scripts/stopTH.sh`)
</code></pre>

<p>but it is throwing some exception.</p>

<p>I want to execute that file from my java program in an MS-Windows environment; is it possible?</p>
"
"<p>Is there a way to get this information from the <code>/proc</code> directory? I want to be able to get how long each process has been running on seconds.</p>

<p>EDIT: I needed to do this from C++. Sorry for the confusion.</p>
"
"<p>I have a scenery full of mountains and water developed in C. I want to add a Sun in the scenery. But the sun do not appears in the scenery. Attached below is my code. Please help me do this..</p>

<pre><code>// Include files
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;
#include &lt;gl\gl.h&gt;
#include ""gl/Glu.h""
#include ""Gl/glut.h""
#include&lt;math.h&gt;
#include&lt;conio.h&gt;

#include ""resources.h""
#include ""fovdemo.h""

// Global variables
HINSTANCE hInstance;
HWND hWnd;
HDC hDC;
HGLRC hRC;
float cam_x, cam_y, cam_z;
float cam_yaw, cam_pitch;
float hfov, aspect;
int fovmode;
bool active;
static int useRGB = 1;
static int useLighting = 1;
static int useFog = 0;
static int useDB = 1;
static int useLogo = 0;
static int useQuads = 1;

static int tick = -1;
static int moving = 1;

#define GREY    0
#define RED     1
#define GREEN   2
#define BLUE    3
#define CYAN    4
#define MAGENTA 5
#define YELLOW  6
#define BLACK   7
static float lightPos[4] =
{2.0, 4.0, 2.0, 1.0};

static float lightAmb[4] ={0.2, 0.2, 0.2, 1.0};
static float lightDiff[4] ={0.8, 0.8, 0.8, 1.0};
static float lightSpec[4] ={0.4, 0.4, 0.4, 1.0};
static float fogColor[4] ={0.0, 0.0, 0.0, 0.0};
static float fogIndex[1] ={0.0};

static unsigned char shadowPattern[128] =
{
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,  /* 50% Grey */
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
  0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55
};



// Function prototypes
LRESULT CALLBACK MainWndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK DummyProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM) { return false; }

float GetTime ()
{
    return (float)GetTickCount() / 1000.0f;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// WINMAIN FUNCTION
/////////////////////////////////////////////////////////////////////////////////////////////

int WINAPI WinMain (HINSTANCE hThisInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    MSG msg;
    WNDCLASSEX wc;
    // Copy instance handle into global variable
    hInstance = hThisInstance;

    // Check for previous instance
    if (hPrevInstance)
    {
        MessageBox(NULL, ""Sorry, you can only start one instance of this program at a time."", ""Can't Start Program"", MB_OK);
        return 0;
    }

    // Register window class
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.lpszClassName = ""FovDemoClass"";
    wc.lpfnWndProc = MainWndProc;
    wc.hInstance = hInstance;
    wc.hbrBackground = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
    wc.style = CS_VREDRAW | CS_HREDRAW;
    wc.lpszMenuName = NULL;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    if (!RegisterClassEx(&amp;wc)) return 0;
        // Create main window
    hWnd = CreateWindow(""FovDemoClass"", ""Fov Demo"", WS_POPUP, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN), NULL, NULL, hInstance, NULL);
    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);

    //Sun Code
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();
    glTranslatef(200, 300, 0.0f);
    static const int circle_points = 100;
    static const float angle = 2.0f * 3.1416f / circle_points;
        // this code (mostly) copied from question:
    glBegin(GL_POLYGON);
    double angle1=0.0;
    glVertex2d(50 * cos(0.0) , 50 * sin(0.0));
    int i;
    for (i=0; i&lt;circle_points; i++)
    {
        glVertex2d(50 * cos(angle1), 50 *sin(angle1));
        angle1 += angle;
    }
    glEnd();
    glPopMatrix();

    // Main message loop
    while (GetMessage(&amp;msg, NULL, 0, 0))
    {
        TranslateMessage(&amp;msg);
        DispatchMessage(&amp;msg);
    }
    return msg.wParam;
}

/////////////////////////////////////////////////////////////////////////////////////////////
// MAINWNDPROC FUNCTION
/////////////////////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK MainWndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static POINT mousepos;
    static float last_frame_time;

    switch (message)
    {
        case WM_CREATE:
        {
            HWND hWndLoading;
            PIXELFORMATDESCRIPTOR pfd;
            int nBestMatch;
            // Show loading dialog box
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            hWndLoading = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_LOADING), hWnd, DummyProc);
            ShowWindow(hWndLoading, SW_SHOWNORMAL);
            UpdateWindow(hWndLoading);

            // Get window DC
            hDC = GetDC(hWnd);

            // Set up the OpenGL pixel format for this window
            memset(&amp;pfd, 0, sizeof(PIXELFORMATDESCRIPTOR));
            pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);
            pfd.nVersion = 1;
            pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
            pfd.iPixelType = PFD_TYPE_RGBA;
            pfd.cColorBits = 32;
            pfd.cDepthBits = 32;
            nBestMatch = ChoosePixelFormat(hDC, &amp;pfd);
            SetPixelFormat(hDC, nBestMatch, &amp;pfd);

            // Set up OpenGL
            hRC = wglCreateContext(hDC);
            wglMakeCurrent(hDC, hRC);
            OpenGL_Init();

            // Get rid of loading dialog
            SetCursor(LoadCursor(NULL, IDC_ARROW));
            DestroyWindow(hWndLoading);
            last_frame_time = GetTime();
            active = true;
            fovmode = FF_NORMAL;
            aspect = (float)GetSystemMetrics(SM_CXSCREEN) / GetSystemMetrics(SM_CYSCREEN);
            hfov = 90.0f;
            return 0;


        }

        case WM_ACTIVATE:
        {
            if (LOWORD(wParam) == WA_INACTIVE)
            {
                active = false;
                ShowWindow(hWnd, SW_MINIMIZE);      // Minimize when alt-tabbed away, since it's a fullscreen window
            }
            else
            {
                active = true;
                last_frame_time = GetTime();
                InvalidateRect(hWnd, NULL, false);
            }
            return 0;
        }

        case WM_PAINT:
        {
            if (active)
            {
                // Calculate time it took to draw last frame
                float current_time = GetTime();
                float frametime = current_time - last_frame_time;
                last_frame_time = current_time;
                // Handle input, logic, whatnot
                OpenGL_Logic(frametime);
                // Render the scene
                OpenGL_SetupView(fovmode);
                OpenGL_Render();
                // Flush and flip
                glFlush();
                SwapBuffers(hDC);
            }
            else
            {
                // If inactive, just rerender when we need to
                OpenGL_SetupView(fovmode);
                OpenGL_Render();
                glFlush();
                SwapBuffers(hDC);
                ValidateRect(hWnd, NULL);
            }

            return 0;
        }

        case WM_CHAR:
        {
            // Respond to keypresses
            switch (wParam)
            {
                // 'F' switches between preset fov modes
                case 'f':
                case 'F':
                {
                    ++fovmode;
                    if (fovmode == NUM_FOVMODES) fovmode = 0;

                    switch (fovmode)
                    {
                        case FF_NORMAL:     // Normal fov, full frame viewport
                        {
                            aspect = (float)GetSystemMetrics(SM_CXSCREEN) / GetSystemMetrics(SM_CYSCREEN);
                            hfov = 90.0f;
                            break;
                        }
                        case WS_WIDE:       // Wide fov with a widescreen viewport (aspect ratio of 2.35, same as theatre)
                        {
                            aspect = 2.35f;
                            hfov = 140.0f;
                            break;
                        }
                        case FF_WIDE:       // Wide fov with a full-frame viewport
                        {
                            aspect = (float)GetSystemMetrics(SM_CXSCREEN) / GetSystemMetrics(SM_CYSCREEN);
                            hfov = 140.0f;
                            break;
                        }
                        case 'd':
                            {
                                if (useLighting)
                                {
                                    glEnable(GL_LIGHTING);
                                }
                                glEnable(GL_LIGHT0);
                                glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
                                glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
                                glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
                                glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
                                glEnable(GL_NORMALIZE);
                                if (useFog){
                                    glEnable(GL_FOG);
                                }
                                glFogfv(GL_FOG_COLOR, fogColor);
                                glFogfv(GL_FOG_INDEX, fogIndex);
                                glFogf(GL_FOG_MODE, GL_EXP);
                                glFogf(GL_FOG_DENSITY, 0.5);
                                glFogf(GL_FOG_START, 1.0);
                                glFogf(GL_FOG_END, 3.0);
                                glEnable(GL_CULL_FACE);
                                glCullFace(GL_BACK);
                                glShadeModel(GL_SMOOTH);
                                glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
                                if (useLogo) {
                                }
                                else {
                                    glPolygonStipple((const GLubyte *) shadowPattern);
                                }

                                glClearColor(0.0, 0.0, 0.0, 1);
                                glClearIndex(0);
                                glClearDepth(1);

                            }
                    break;
                }

                // Escape key exits
                case 27:
                {
                    DestroyWindow(hWnd);
                    break;
                }
            }

            // Make sure window is redrawn
            InvalidateRect(hWnd, NULL, false);

            return 0;
            }

        case WM_LBUTTONDOWN:
        {
            if (active)
            {
                // Capture mouse and hide cursor
                SetCapture(hWnd);
                ShowCursor(false);

                // Save off mouse position
                GetCursorPos(&amp;mousepos);
            }

            return 0;
        }


        case WM_MOUSEMOVE:
        {
            // Move view angles if dragging left button
            if (active &amp;&amp; (wParam &amp; MK_LBUTTON))
            {
                POINT pt;
                int deltax, deltay;
                bool wrap = false;

                // Get current mouse position
                GetCursorPos(&amp;pt);

                // Calculate deltas
                deltax = pt.x - mousepos.x;
                deltay = pt.y - mousepos.y;

                // Wrap mouse position if needed
                if (pt.x == GetSystemMetrics(SM_CXSCREEN) - 1)
                    pt.x = 0, wrap = true;
                else if (pt.x == 0)
                    pt.x = GetSystemMetrics(SM_CXSCREEN) - 1, wrap = true;
                if (pt.y == GetSystemMetrics(SM_CYSCREEN) - 1)
                    pt.y = 0, wrap = true;
                else if (pt.y == 0)
                    pt.y = GetSystemMetrics(SM_CYSCREEN) - 1, wrap = true;
                if (wrap)
                    SetCursorPos(pt.x, pt.y);

                // Save off new mouse position
                mousepos = pt;

                // Change view angles accordingly
                cam_yaw -= (float)deltax * MOUSE_CAMERA_ANGLE_FACTOR;
                cam_pitch -= (float)deltay * MOUSE_CAMERA_ANGLE_FACTOR;

                // Wrap yaw and clamp pitch
                if (cam_yaw &gt; 360.0f) cam_yaw -= 360.0f;
                if (cam_yaw &lt; 0.0f) cam_yaw += 0.0f;
                if (cam_pitch &gt; 90.0f) cam_pitch = 90.0f;
                if (cam_pitch &lt; -90.0f) cam_pitch = -90.0f;

                InvalidateRect(hWnd, NULL, false);
            }

            return 0;
        }

        case WM_LBUTTONUP:
        {
            if (active)
            {
                // Release mouse capture and show cursor
                ReleaseCapture();
                ShowCursor(true);
            }
            return 0;
        }

        case WM_DESTROY:
        {
            // Shut down OpenGL
            wglMakeCurrent(NULL, NULL);
            wglDeleteContext(hRC);
            ReleaseDC(hWnd, hDC);
            PostQuitMessage(0);
            return 0;
        }

        default:
        {
            return DefWindowProc(hWnd, message, wParam, lParam);
        }
    }
}
}
</code></pre>
"
"<p>I am working on a network programming using epoll. It seems like working fine. I would like to add a timeout function so if a client doesn't sent anything for a long period time then it will just disconnect the client. </p>

<p>How do I do this? I know that I can set the timeout in epoll_wait but this is not for the individual socket...</p>

<p>Thanks in advance...</p>
"
"<p>I'm hacking away at a simple game to teach myself C and I've come up against an infuriatingly simple problem that I haven't been able to Google an answer to.</p>

<p>Code follows, apologies for its noobie terribleness (criticisms appreciated!):</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;SDL/SDL.h&gt;

#define AMOUNT_OF_ENEMIES 10
#define AMOUNT_OF_PIXELS_TO_MOVE 50.0

struct enemy
{
    int alive;
    SDL_Rect rect;
};

void create_enemy(struct enemy *position)
{
// Take a pointer to an array. Iterate through array looking for any 'dead' instances.
// (Re)initialise when found, ignore entirely if array is full of alive instances.

int j = 0;
while(position[j].alive == 1 &amp;&amp; j &lt; AMOUNT_OF_ENEMIES)
{
    ++j;
}

if(position[j].alive == 0)
{
    position[j].alive = 1;
    position[j].rect.y = 0;
}
}

void update_enemies(struct enemy *position)
{
// Iterate through a passed array looking for alive instances. If found increment     vertical position,
// unless instance is at bottom of screen in which case it's marked as dead.

int j = 0;
while(j &lt; AMOUNT_OF_ENEMIES)
{
    if(position[j].alive == 1)
    {
        position[j].rect.y += 1;
        if(position[j].rect.y &gt; 570)
        {
            position[j].alive = 0;
            }
        }
        ++j;
    }
}

int main(void)
{
// INITS *********************************************************************
int k;
int current_time = 0;
int previous_time = 0;
float difference_in_time = 0.0;

// Load SDL library
if(SDL_Init(SDL_INIT_EVERYTHING) != 0)
{
    printf(""Problem, yo\n"");
    return 1;
}

// Setup event queue
SDL_Event event;

// Create array to store enemys, initialise it
struct enemy *enemy_array = malloc(sizeof(struct enemy) * AMOUNT_OF_ENEMIES);
int j;
for(j = 0; j &lt; AMOUNT_OF_ENEMIES; ++j)
{
    enemy_array[j].alive = 0;
    enemy_array[j].rect.x = 150;
    enemy_array[j].rect.y = 0;
}

// Create an array to flag keypresses, initialise it
int pressed_keys[323];
int l;
for(l = 0; l &lt; 323; ++l)
{
    pressed_keys[l] = 0;
}

// Create surfaces
SDL_Surface *screen = SDL_SetVideoMode(300, 600, 0, SDL_HWSURFACE);
int black = SDL_MapRGB(screen-&gt;format, 0, 0, 0);

SDL_Surface *tower = SDL_LoadBMP(""tower.bmp"");
SDL_Rect tower_rect;
tower_rect.x = 50;
tower_rect.y = 0;
tower_rect.w = 200;
tower_rect.h = 600;

SDL_Surface *dude = SDL_LoadBMP(""dude.bmp"");
float dude_x = 0.0;
SDL_Rect dude_rect;
dude_rect.x = 120;
dude_rect.y = 500;
dude_rect.w = 60;
dude_rect.h = 100;

SDL_Surface *enemy = SDL_LoadBMP(""enemy.bmp"");

// GAME LOOP *****************************************************************
while(1)
{
    current_time = SDL_GetTicks();
    difference_in_time = (float)(current_time - previous_time) / 1000;
    previous_time = current_time;

    if(SDL_PollEvent(&amp;event))
    {
        if(event.key.keysym.sym == SDLK_DOWN)
        {
            create_enemy(enemy_array);
        }
        else
        {
            switch(event.type)
            {
                case SDL_QUIT:
                    printf(""NOOOOOO\n"");
                    SDL_FreeSurface(screen);
                    SDL_FreeSurface(tower);
                    SDL_FreeSurface(enemy);
                    free(enemy_array);
                    SDL_Quit();
                return 0;

                case SDL_KEYDOWN:
                    pressed_keys[event.key.keysym.sym] = 1;
                    break;

                case SDL_KEYUP:
                    pressed_keys[event.key.keysym.sym] = 0;
                    break;
            }
        }
    }

    if(pressed_keys[SDLK_LEFT] &amp;&amp; dude_rect.x &gt; 50)
    {
        dude_rect.x -= (AMOUNT_OF_PIXELS_TO_MOVE * difference_in_time);
    }

    if(pressed_keys[SDLK_RIGHT] &amp;&amp; dude_rect.x &lt; 190)
    {
        dude_rect.x += (AMOUNT_OF_PIXELS_TO_MOVE * difference_in_time);
    }

    update_enemies(enemy_array);

    SDL_FillRect(screen, NULL, black);
    SDL_BlitSurface(tower, NULL, screen, &amp;tower_rect);
    for(k = 0; k &lt; AMOUNT_OF_ENEMIES; ++k)
    {
        if(enemy_array[k].alive == 1)
        {
            SDL_BlitSurface(enemy, NULL, screen, &amp;enemy_array[k].rect);
        }
    }
    SDL_BlitSurface(dude, NULL, screen, &amp;dude_rect);
    SDL_Flip(screen);
}
return 0;
}
</code></pre>

<p>The issue arises at this part:</p>

<pre><code>if(pressed_keys[SDLK_LEFT] &amp;&amp; dude_rect.x &gt; 50)
{
    dude_rect.x -= (AMOUNT_OF_PIXELS_TO_MOVE * difference_in_time);
}

if(pressed_keys[SDLK_RIGHT] &amp;&amp; dude_rect.x &lt; 190)
{
    dude_rect.x += (AMOUNT_OF_PIXELS_TO_MOVE * difference_in_time);
}
</code></pre>

<p>The 'dude' object moves to the left correctly, but nothing happens when the right arrow key is pressed.</p>

<p>Adding a printf tells me the if statement is being executed correctly. Removing difference_in_time makes it work, so it's either something to do with that variable or the operation of it and AMOUNT_OF_PIXELS_TO_MOVE. </p>

<p>I just can't for the life of me figure out why the former block executes correctly and the latter (which is essentially the same thing) doesn't. I'm sure it's something simple I've overlooked but I'm going insane trying to find it.</p>
"
"<p>I am writing some simple client/server code using UDP. The program works fine, but if I only start the client, the recvfrom method does not block. However, when I remove the sendto method, recvfrom starts to block. Any idea of what is going on?</p>

<p>Here is the client side code:</p>

<pre><code>    int server_length;                      /* Length of server struct */
    char send_buffer[256] = ""hi"";           /* Data to send */
    time_t current_time;                    /* Time received */

    while(true)
    {

        /* Tranmsit data to get time */
        server_length = sizeof(struct sockaddr_in);
        if (sendto(m_oSocket, send_buffer, (int)strlen(send_buffer) + 1, 0, (struct sockaddr *)&amp;m_oServer, server_length) == -1)
        {
            fprintf(stderr, ""Error transmitting data.\n"");
            continue;
        }

        /* Receive time */

        if (recvfrom(m_oSocket, (char *)&amp;current_time, (int)sizeof(current_time), 0, (struct sockaddr *)&amp;m_oServer, &amp;server_length) &lt; 0)
        {
            fprintf(stderr, ""Error receiving data.\n"");
            continue;
        }

        /* Display time */
        printf(""Current time: %s\n"", ctime(&amp;current_time));

        Sleep(1000);
    }
</code></pre>

<p>And here is the initialization:</p>

<pre><code>unsigned short m_iPortnumber;
struct sockaddr_in m_oServer;
struct sockaddr_in m_oClient;
SOCKET m_oSocket;
WSADATA w;                              /* Used to open Windows connection */
    int a1, a2, a3, a4;                     /* Server address components in xxx.xxx.xxx.xxx form */

    a1 = 192;
    a2 = 168;
    a3 = 2;
    a4 = 14;
    m_iPortnumber = 52685;

    /* Open windows connection */
    if (WSAStartup(0x0101, &amp;w) != 0)
    {
        fprintf(stderr, ""Could not open Windows connection.\n"");
        exit(0);
    }

    /* Open a datagram socket */
    m_oSocket = socket(AF_INET, SOCK_DGRAM, 0);
    if (m_oSocket == INVALID_SOCKET)
    {
        fprintf(stderr, ""Could not create socket.\n"");
        WSACleanup();
        exit(0);
    }

    /* Clear out server struct */
    memset((void *)&amp;m_oServer, '\0', sizeof(struct sockaddr_in));

    /* Set family and port */
    m_oServer.sin_family = AF_INET;
    m_oServer.sin_port = htons(m_iPortnumber);

    /* Set server address */
    m_oServer.sin_addr.S_un.S_un_b.s_b1 = (unsigned char)a1;
    m_oServer.sin_addr.S_un.S_un_b.s_b2 = (unsigned char)a2;
    m_oServer.sin_addr.S_un.S_un_b.s_b3 = (unsigned char)a3;
    m_oServer.sin_addr.S_un.S_un_b.s_b4 = (unsigned char)a4;

    /* Clear out client struct */
    memset((void *)&amp;m_oClient, '\0', sizeof(struct sockaddr_in));

    /* Set family and port */
    m_oClient.sin_family = AF_INET;
    m_oClient.sin_addr.s_addr=INADDR_ANY;
    m_oClient.sin_port = htons(0);

    /* Bind local address to socket */
    if (bind(m_oSocket, (struct sockaddr *)&amp;m_oClient, sizeof(struct sockaddr_in)) == -1)
    {
        fprintf(stderr, ""Cannot bind address to socket.\n"");
        closesocket(m_oSocket);
        WSACleanup();
        exit(0);
    }
</code></pre>
"
"<p>I have a lot of files, say 1000 files, each with 4mb. Totally there are 4gb. I would like to sort them by using unix sort, here is my command:</p>

<pre><code>sort -t ',' -k 1,1 -k 5,7 -k 22,22 -k 2,2r INPUT_UNSORTED_${current_time}.DAT -o INPUT_SORTED_${current_time}.DAT
</code></pre>

<p>where INPUT_UNSORTED is a big file created by appending the 1000 files. So there is another 4gb. INPUT_SORTED is another 4gb too.</p>

<p>And I discovered unix sort used a temp folder to sort the files, and the temp files may reach to 4gb too.</p>

<p>How can I reduce disk usage without losing performance?</p>
"
"<p>I need to parse many html files using php.</p>

<pre><code>foreach($url_array as $url){

     $file = file_get_contents($url);

     parse_html($file);

}
</code></pre>

<p>For some reasons (file is too big), function parse_html() take very long time to run or has memory leak in it.</p>

<p><strong>I want to monitor function parse_html(). If the running time exceed a given time, should continue to parse the next url and disregard the current one.</strong></p>

<p>For most of the time, my codes runs great but there are some urls can not be parsed. There is no error output and I guess it is memory leak. </p>
"
"<p>I have a requirement that I have to give xx ms to execute a function. After xx ms I have to abort that function. Please help me how to implement it in C. </p>
"
"<p>I have a single thread server process that watches few (around 100) sockets via epoll in a loop, my question is that how to decide the optimum value of epoll_wait timeout value, since this is a single threaded process, everything is triggered off epoll_wait , if there is no activity on sockets, program remains idle, my guess is that if i give too small timeout, which causes too many epoll_wait calls there is no harm because even though my process is doing too many epoll_wait calls, it would be sitting idle otherwise, but there is another point, I run many other processes on this (8 core) box, something like 100 other process which are clients to this process, I am wondering how timeout value impacts cpu context switiching, i.e if i give too small timeout which results in many epoll_wait call will my server process be put in waiting many more times vs when I give a larger timeout value which results in fewer epoll_wait calls.</p>

<p>any thoughts/ideas.</p>

<p>Thanks</p>
"
"<p>Im doing a game in C on console application and I need to print a timer while the user play the game at the same time, I don't know how to program that well, actually I just start using this compiler so I don't know a lot of multithreads and stuff but this is the far as I get, here is an example of two functions the first one is the ""timer"" and the second its just some question, <strong><em>my doubt is if I can run these 2 functions at the same time, and how I can print the timer while I can answer those 2 question without interrupting the console.</em></strong></p>

<p>EXAMPLE:</p>

<pre><code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;


DWORD WINAPI Timer(int limit)
{
    int secs = 1;
    time_t unix;

    struct tm * timeinfo;
    time(&amp;unix);
    timeinfo = localtime(&amp;unix);

    int t1 = timeinfo-&gt;tm_sec;
    int t2 = timeinfo-&gt;tm_sec;
    int i = 0;

    while(1 == 1)
    {
       time(&amp;unix);
       timeinfo = localtime(&amp;unix);
       if((t1 + i)  == timeinfo-&gt;tm_sec)
       {
              system(""cls"");
              printf(""time left %d seconds\n"", timeinfo-&gt;tm_sec - t2 - limit);
              i++;
       }
       if(timeinfo-&gt;tm_sec &gt;= (t1 + limit))
       {
            break;
            printf(""Your time its done"");
       }
    }
    return 0;
}

DWORD WINAPI Questionary()
{
    puts(""testing\n\n"");

    int age, height;
    printf(""Please write your age: "");
    scanf(""%d"", &amp;age);
    printf(""Please write your height: "");
    scanf(""%d"", &amp;height);
    printf(""\n\nThe numbers written are %d y %d"", age, height);
    return NULL;
}
int main()
{
    int i, limit;
    HANDLE tempo;
    HANDLE questions;
    DWORD ThreadId;

    printf(""\nHow much time would you like for your timer countdown? "");
    scanf(""%d"", &amp;limit);

    //Funcion Handle
    questions= CreateThread(NULL,0,Questionary,1,0,&amp;ThreadId);
    WaitForSingleObject(preguntas,INFINITE);

    tempo= CreateThread(NULL,0,Timer(limit),1,0,&amp;ThreadId);
    WaitForSingleObject(tiempofinal,limit*40);


    return 0;
}
</code></pre>
"
"<p>I know when a program is run, the main() function is executed first. But when does the initialization of global variables declared outside the main() happens? I mean if I declare a variable like this:</p>

<pre><code>unsigned long current_time = millis();

void main() {
    while () {
        //some code using the current_time global variable
    }
}
</code></pre>

<p>Here, the exact time when the global variable initializes is important. Please tell what happens in this context.</p>
"
"<p>I have got some problem implementing bullet physics into my opengl game. The thing is that it doesn't want to update my translatef value continously but only at the end.
The code for bullet looks like this:</p>

<pre><code>void CGL::initPhysics( void ) {
broadphase = new btDbvtBroadphase();
collisionConfiguration = new btDefaultCollisionConfiguration();
dispatcher = new btCollisionDispatcher(collisionConfiguration);
solver = new btSequentialImpulseConstraintSolver;
dynamicsWorld = new btDiscreteDynamicsWorld(dispatcher,broadphase,solver,collisionConfiguration);

dynamicsWorld-&gt;setGravity(btVector3(0,-10,0));


ballShape = new btSphereShape(1);
pinShape = new btCylinderShape(btVector3(1,1,1));
pinShape-&gt;setMargin(0.04);

fallMotionState = new btDefaultMotionState(btTransform(btQuaternion(0,0,0,1),btVector3(0,10,0)));
btScalar mass = 1;
btVector3 fallInertia(0,0,0);
ballShape-&gt;calculateLocalInertia(mass,fallInertia);

btCollisionShape* groundShape = new btStaticPlaneShape(btVector3(0,1,0),1);

btDefaultMotionState* groundMotionState = new btDefaultMotionState(btTransform(btQuaternion(0,0,0,1),btVector3(0,-1,0)));
btRigidBody::btRigidBodyConstructionInfo groundRigidBodyCI(0,groundMotionState,groundShape,btVector3(0,0,0));
btRigidBody* groundRigidBody = new btRigidBody(groundRigidBodyCI);
dynamicsWorld-&gt;addRigidBody(groundRigidBody);

btRigidBody::btRigidBodyConstructionInfo fallRigidBodyCI(mass,fallMotionState,ballShape,fallInertia);
btRigidBody* fallRigidBody = new btRigidBody(fallRigidBodyCI);
dynamicsWorld-&gt;addRigidBody(fallRigidBody);

for (int i=0 ; i&lt;300 ; i++) {
    dynamicsWorld-&gt;stepSimulation(1/60.f,10);

    btTransform trans;
    fallRigidBody-&gt;getMotionState()-&gt;getWorldTransform(trans);

    fallY = trans.getOrigin().getY();
}
state_list.remove( STATE_FALL_BALL );
printf(""stoped\n"");
</code></pre>

<p>}</p>

<p>And the drawing function which is called at the beginning looks like this:</p>

<pre><code>void CGL::fallingBall( void ) {
glPushMatrix();

float colBall2[4] = { 0.0f, 0.0f, 1.0f, 1.0f };
glMaterialfv( GL_FRONT, GL_AMBIENT, colBall2);

glTranslatef(0.0f,fallY,0.0f);

printf(""fallY: %f\n"",fallY);

glutSolidSphere(1.0f,20,20);

glPopMatrix();
</code></pre>

<p>}</p>

<p>The thing is that it shows correct value in this function's printf but translation is called only at the beginning I mean I can only see the last state.</p>

<p><strong>EDIT</strong></p>

<p>This is changed function and loop. Gathering all the info I supose it should now work but it doesn't. It doesn't draw anything.</p>

<pre><code>initPhysics(){
    for (int i=0 ; i&lt;500 ; i++)
    {
        draw();

    }
    state_list.remove( STATE_FALL_BALL );
    printf(""stoped\n"");
}

void CGL::draw(void)
{
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
            current_time = getTime();
            since_update = current_time - last_update;
            printf(""time: %f\n"",since_update);
            if(since_update&gt;timestep)
            {
                dynamicsWorld-&gt;stepSimulation(timestep,10);
                last_update = current_time;
            }
            btTransform trans;
            fallRigidBody-&gt;getMotionState()-&gt;getWorldTransform(trans);

            fallY = trans.getOrigin().getY();
            fallingBall();
            printf(""fallY: %f\n"",fallY);
glFlush();
    }
</code></pre>

<p>And beginning variable declaratins look like that:</p>

<pre><code>last_update = 0;
timestep = 100;
current_time = 0;
since_update = 0;
</code></pre>
"
"<p>I have an issue with inserting time in a text file. I use the following code and i get <code>|21,43,1,3,10,5| Wed Feb 01 20:42:32 2012</code> which is normal but what i WANT TO DO is place the time before the numbers for example like <code>Wed Feb 01 20:42:32 2012  |21,43,1,3,10,5|</code> However, i cant do so cause when i use the fprintf with ctime function before fprintf the numbers it recognizes the \n within ctime and so it changes line 1st and then printing the numbers. It goes like:</p>

<pre><code>    Wed Feb 01 20:42:32 2012
    |21,43,1,3,10,5|
</code></pre>

<p>which is something that i dont want... How can i fprintf the time without swiching to the next line in the text??? Thanks in advance!</p>

<pre><code>fprintf(file,""   |"");
    for (i=0;i&lt;6;i++)
    {
        buffer[i]=(lucky_number=rand()%49+1);       //range 1-49
        for (j=0;j&lt;i;j++)
        {
            if (buffer[j]==lucky_number)
                i--;
        }
        itoa (buffer[i],draw_No,10);
        fprintf(file,""%s"",draw_No);
        if (i!=5)
            fprintf(file,"","");
    }
    fprintf(file,""|     %s"",ctime(&amp;t));
</code></pre>
"
"<p>I'm trying to write a simple pygame program where some boxes move around on the screen. I'm following <a href=""http://www.sacredchao.net/~piman/writing/sprite-tutorial.shtml"" rel=""nofollow"">this example</a>.</p>

<p>The tutorial has the following structure:</p>

<pre><code>class Box(pygame.sprite.Sprite):
...
    def update(self, currtime):
        if self.next_update_time &lt; current_time:
           print time.time() # I added this to debug
           # Do some stuff
           self.next_update_time = current_time + 10

box = Box()
while True:
    pygame.time.delay(10)
    time = pygame.time.get_ticks()
    box.update(time)
</code></pre>

<p>My boxes move, but not very smoothly. They speed up and slow down a fair bit. When I plot the points at which an update happens, I get <a href=""http://imgur.com/uudje"" rel=""nofollow"">this</a>.</p>

<p>Does this look like a problem with the design proposed in the tutorial I'm following? Is it a problem with my hardware?</p>

<p>EDIT:
Based on Radomir Dopieralski's answer, the better approach is:</p>

<pre><code>class Box(pygame.sprite.Sprite):
...
    def update(self):
           # Do some stuff

box = Box()
clock = pygame.time.Clock()
while True:
    clock.tick(100)
    box.update()
</code></pre>
"
"<p>I'm using Posix Message Queues on Linux. Basically, I have multiple threads that receive messages from the same queue by calls to <code>mq_timedreceive</code>. </p>

<p>If more than one thread is running at the same time and the queue is not empty, am I guaranteed that a message does not get received more than once (i.e. the message does not get delivered to multiple threads)?</p>

<p>To be sure, I could synchronize the receive with a mutex, but I'd like to avoid this lock if possible. I read all the man pages (<code>man mq_overview(3)</code>) but without finding anything explicit.</p>

<p>Thanks in advance.  </p>
"
"<p>I would like to subtract current_time with previously_saved_time and check if it's bigger then wait_time. wait time should be an int. Can someone give me a simple example? In other words:</p>

<pre><code>if ((current_time - previously_saved_time) &gt; wait_time) {
    do something;
}
</code></pre>
"
"<h2>Some background information</h2>

<p>The files I would like to download is kept at the external server for a week, and a new XML file(10-50mb large) is created there every hour with a different name. I would like the large file to be downloaded to my server chunk by chunk in the background each time my website is loaded, perhaps 0.5mb each time, and then resume the download the next time someone else loads the website. This would require my site to have atleast 100 pageloads each hour to stay updated, so perhaps abit more of the file each time if possible. I have researched <strong>simpleXML</strong>, <strong>XMLreader</strong>, <strong>SAX parsing</strong>, but whatever I do, it seems it takes too long to parse the file directly, therefore I would like a different approach, namely downloading it like described above.</p>

<p>If I download a 30mb <strong>large XML file</strong>, I can parse it locally with XMLreader in 3 seconds(250k iterations) only, but when I try to do the same from the external server limiting it to 50k iterations, it uses 15secs to read that small part, so it would not be possible to parse it directly from that server it seems.</p>

<h2>Possible solutions</h2>

<p>I think it's best to use <strong>cURL</strong>. But then again, perhaps <strong>fopen()</strong>, <strong>fsockopen()</strong>, <strong>copy()</strong> or <strong>file_get_contents()</strong> are the way to go. I'm looking for advice on what functions to use to make this happen, or different solutions on how I can parse a 50mb external XML file into a <strong>mySQL</strong> database.</p>

<p>I suspect a <strong>Cron</strong> job every hour would be the best solution, but I am not sure how well that would be supported by webhosting companies, and I have no clue how to do something like that. But if thats the best solution, and the majority thinks so, I will have to do my research in that area too.</p>

<p>If a <strong>java applet/javascript</strong> running in the background would be a better solution, please point me in the right direction when it comes to functions/methods/libraries there aswell.</p>

<h1>Summary</h1>

<ul>
<li>What's the best solution to downloading parts of a file in the
background, and resume the download each time my website is loaded
until its completed?</li>
<li>If the above solution would be moronic to even try, what
language/software would you use to achieve the same thing(download a large file every hour)?</li>
</ul>

<p>Thanks in advance for all answers, and sorry for the long story/question.</p>

<p>Edit: I ended up using this solution to get the files with cron job scheduling a php script. It checks my folder for what files I already have, generates a list of the possible downloads for the last four days, then downloads the next XMLfile in line.
</p>

<pre><code>&lt;?php
$date = new DateTime();
$current_time = $date-&gt;getTimestamp();
$four_days_ago = $current_time-345600;

echo 'Downloading: '.""\n"";
for ($i=$four_days_ago; $i&lt;=$current_time; ) {
    $date-&gt;setTimestamp($i);

    if($date-&gt;format('H') !== '00') {
        $temp_filename = $date-&gt;format('Y_m_d_H') .""_full.xml"";
        if(!glob($temp_filename)) {
            $temp_url = 'http://www.external-site-example.com/'.$date-&gt;format('Y/m/d/H') ."".xml"";
            echo $temp_filename.' --- '.$temp_url.'&lt;br&gt;'.""\n"";
            break; // with a break here, this loop will only return the next file you should download
        }
    }
    $i += 3600;
}

set_time_limit(300);
$Start = getTime();

$objInputStream = fopen($temp_url, ""rb"");
$objTempStream = fopen($temp_filename, ""w+b"");

stream_copy_to_stream($objInputStream, $objTempStream, (1024*200000));

$End = getTime();
echo '&lt;br&gt;It took '.number_format(($End - $Start),2).' secs to download ""'.$temp_filename.'"".';

function getTime() {
    $a = explode (' ',microtime());
    return(double) $a[0] + $a[1];
}
?&gt;
</code></pre>

<p>edit2: I just wanted to inform you that there is a way to do what I asked, only it would'nt work in my case. With the amount of data I need the website would have to have 400+ visitors an hour for it to work properly. But with smaller amounts of data there are some options; <a href=""http://www.google.no/search?q=poormanscron"" rel=""nofollow"">http://www.google.no/search?q=poormanscron</a></p>
"
"<p>Every connection requires one thread for each, and for now, we're allowing only certain number of connections per period. So every time a user connects, we increment the counter if we're within certain period from the last time we set the check time. </p>

<pre><code>1.get current_time = time(0)
2.if current_time is OUTSIDE certain period from check_time,
  set counter = 0, and check_time = current_time.
3.(otherwise, just leave it the way it is)
4.if counter &lt; LIMIT, counter++ and return TRUE
5.Otherwise return FALSE
</code></pre>

<p>But this is independent of actually how many threads we have running in the server, so I'm thinking of a way to allow connections depending on this number.</p>

<p>The problem is that we're actually using a third-party api for this, and we don't know exactly how long the connection will last. First I thought of creating a child thread and run ps on it to pass the result to the parent thread, but it seems like it's going to take more time since I'll have to parse the output result to get the total number of threads, etc. I'm actually not sure if I'm making any sense.. I'm using c++ by the way. Do you guys have any suggestions as to how I could implement the new checking method? It'll be very much appreciated. </p>
"
"<p>In this code I parse a file (containing the output from <code>ls -lrt</code>) for a log file's modification date. Then I move all log files into a new folder with their modification dates added to the filenames, and than making a tar of all those files.</p>

<p>The problem I am getting is in the <code>while</code> loop. Because it's reading the data for all the files the while loop keeps on running 15 times. I understand that there is some issue in the code but I can't figure it out.</p>

<p>Inside the while loop I am splitting the <code>ls -lrt</code> records to find the log file modified date. <code>$file</code> is the output of the <code>ls</code> command that I am storing in the text file <code>/scripts/yagya.txt</code> in order to get the modification date. But the <code>while</code> loop is executing 15 times since there are 15 log files in the folder which match the pattern.</p>

<pre><code>#!/usr/bin/perl
use File::Find;
use strict;

my @field;
my $filenew;
my $date;
my $file = `ls -lrt /scripts/*log*`;
my $directory=""/scripts/*.log"";
my $current = localtime;
my $current_time = $current;
$current_time = s/\s+//g;
my $freetime = $current_time;
my $daytime = substr($current_time,0,8);
my $seconddir = ""/$freetime/"";

system (""mkdir $seconddir"");

open (MYFILE,""&gt;/scripts/yagya.txt"");
print MYFILE ""$file"";
close (MYFILE);

my $data = ""/scripts/yagya.txt"";
my $datas = ""/scripts/"";
my %options = (
    wanted =&gt; \&amp;wanted,
    untaint =&gt; 1
);

find (\%options, $datas);
sub wanted {
    if (/[._]log\d*$/){
        my $files;
        my @fields;
        my $fields;
        chomp;
        $files=$_;

        open (MYFILE,$data);
        while(&lt;MYFILE&gt;){
            chop;
            s/#.*//;
            next unless /\S/;
            @fields = (split)[5,6,7];
            $fields = join('',@fields), ""\n"";
        }
        close (MYFILE);

        system (""mv  $files $seconddir$fields$files"");
    }
}

system (""tar cvf /$daytime/$daytime.tar.gz /$daytime/*log*"");
system (""rm $seconddir*log*"");

system (""rm $data"");
</code></pre>
"
"<p>While trying to write code which returns 24 hours less than a given time, <code>mktime()</code>shows inconsistent output. I calculate it similar to this: <code>current_time(GMT) - 86400</code> which should return the right value. All we need to do is calculate based on the input time; we used <code>mktime()</code> to change the time and get the GMT time and then do the regular calculation. I included my code below.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main()
{
    time_t currentTime, tempTime;
    struct tm *localTime;

    time(&amp;currentTime);
    //localTime = localtime(&amp;currentTime);
    localTime = gmtime(&amp;currentTime); //get the time in GMT as we are in PDT

    printf(""Time %2d:%02d\n"", (localTime-&gt;tm_hour)%24, localTime-&gt;tm_min);
    localTime-&gt;tm_hour = 19; // Set the time to 19:00 GMT
    localTime-&gt;tm_min = 0;
    localTime-&gt;tm_sec = 0;
    tempTime = mktime(localTime);
    //tempTime = mktime(localTime) - timezone;

    printf(""Current time is %ld and day before time is %ld\n"", currentTime, (currentTime - 86400));
    printf(""Current timezone is %ld \n"", timezone);

    printf(""New time is %ld and day before time is %ld\n"",tempTime, (tempTime - 86400));
}
</code></pre>

<p>But when we check the output it is coming back incorrect after the call to call <code>mktime()</code>. Below is the output of above program.</p>

<pre><code>$ ./a.out
Time 11:51
Current time is 1341229916 and day before time is 1341143516
New time is 1341284400 and day before time is 1341198000
$ ./print_gmt 1341229916
Mon Jul  2 11:51:56 2012
$ ./print_gmt 1341143516
Sun Jul  1 11:51:56 2012
$ ./print_gmt 1341284400
Tue Jul  3 03:00:00 2012
$ ./print_gmt 1341198000
Mon Jul  2 03:00:00 2012
$ date
Mon Jul  2 04:52:46 PDT 2012
</code></pre>

<p>Now if we un-comment the line which subtracts the timezone (present in time.h), then the output is as expected. Below is the value for timezone in above program</p>

<pre><code>$ ./a.out
. . .
Current timezone is 28800
. . .
</code></pre>

<p>So why is there such inconsistent behavior for <code>mktime()</code> although the man pages do not mention such adjustment of the timezone.
Is there something we are missing while doing such conversions?</p>

<p>Thanks in advance.</p>
"
"<p>I was using following code segment to calculate utc offset, but I realize sometimes it's returning wrong results:</p>

<pre><code>double DateTime::getUTCOffset()
{
    time_t currtime;

    struct tm * timeinfo;



    time ( &amp;currtime );

    timeinfo = gmtime ( &amp;currtime );

    time_t utc = mktime( timeinfo );

    timeinfo = localtime ( &amp;currtime );

    time_t local = mktime( timeinfo );



    // Get offset in hours from UTC

    double offsetFromUTC = ((difftime(local, utc) / HOUR_IN_SECONDS) );

    // Adjust for DST

    if (timeinfo-&gt;tm_isdst)
    {
        offsetFromUTC += 1;
    }
    return offsetFromUTC;
}
</code></pre>

<p>%90 of the time it's correct though, what's the best way of calculating utc offset?</p>
"
"<p>I am writing to write a program that will make use of multithreading. I tried to read about multithreading and was able to get a sample program working. However I have run into a glitch and I am not sure what is going wrong. I am posting the sample program and will highlight where I am experiencing trouble.</p>

<pre><code>#include &lt;Windows.h&gt;
#include &lt;process.h&gt;
#include &lt;iostream&gt;
#include &lt;cassert&gt;
#include &lt;ctime&gt;

#import ""calc.dll"" \
auto_rename no_namespace no_smart_pointers \
raw_native_types named_guids

using namespace std;

HANDLE  th_mutex;

struct  Arguments
{
    string  case_id;

    string  file;
};
//____________________________________

unsigned int __stdcall TestThread(void *args)
{
    int i   =   0,
        j   =   0;

    cout &lt;&lt; ""Inside thread"" &lt;&lt; endl;

    for (i = 0; i &lt;= 10000; i++)
    {
        for (j = 0; j &lt;= 100000; j++)
        {
        }

        if (i == 10000)
            cout &lt;&lt; ""The value of i inside the thread = "" &lt;&lt; i &lt;&lt; endl;
    }

    return  EXIT_SUCCESS;
}
//____________________________________

unsigned int __stdcall Thread(void *args)
{
    CoInitialize(0);
    {
        Arguments   *input;

        input   =   (Arguments *) args;

        time_t  current_time;
        time(&amp;current_time);
        cout &lt;&lt; ctime(&amp;current_time) &lt;&lt; endl;

        IHeatExchangerNetwork   *hxNetwork  =   0;
        IDispatchPtr        theUnit     =   0;
        IHeatTransferUnit   *unit       =   0;

        VARIANT vAppend;

        _bstr_t filename,
            output;

        filename    =   input-&gt;file.c_str();
        filename    +=  input-&gt;case_id.c_str();
        filename    +=  "".dat"";

        output      =   input-&gt;file.c_str();
        output      +=  input-&gt;case_id.c_str();
        output      +=  "".dbo"";

        cout &lt;&lt; filename &lt;&lt; endl;
        cout &lt;&lt; output &lt;&lt; endl;

        HRESULT hr  =   CoCreateInstance(CLSID_HeatExchangerNetwork,
                             0,
                             CLSCTX_ALL,
                             DIID_IHeatExchangerNetwork,
                             reinterpret_cast&lt;void**&gt;(&amp;hxNetwork));

        theUnit     =   hxNetwork-&gt;LoadHeatTransferUnit(filename, HxUnitTypeKey::HxUnitTypeCrossflow);

        hr  =   theUnit-&gt;QueryInterface(DIID_IHeatTransferUnit, reinterpret_cast&lt;void**&gt;(&amp;unit));

        hxNetwork-&gt;Run(0, 0);

        vAppend.boolVal = false;
        unit-&gt;WriteDBOFile(output, OutputData, vAppend);

        time(&amp;current_time);
        cout &lt;&lt; ctime(&amp;current_time) &lt;&lt; endl;
    }

    CoUninitialize();

    return  EXIT_SUCCESS;
}
//____________________________________

int main()
{
    DWORD   retval;

    Arguments   args[2];

    args[0].case_id =   ""1"";
    args[0].file    =   ""C:\\Documents and Settings\\User\\My Documents\\Test Cases\\1\\"";

    args[1].case_id =   ""2"";
    args[1].file    =   ""C:\\Documents and Settings\\User\\My Documents\\Test Cases\\2\\"";

    th_mutex    =   CreateMutex(NULL, FALSE, NULL);

    if (th_mutex == NULL)
    {
        printf(""CreateMutex error: %d\n"", GetLastError());
        return 1;
    }

//  ================================
//  Basic testing of calling threads
//  ================================
    HANDLE  hnd1;

    cout &lt;&lt; ""Before creating new thread"" &lt;&lt; endl;

    hnd1    =   (HANDLE) _beginthreadex(NULL, 0, &amp;TestThread, NULL, 0, 0);

    cout &lt;&lt; ""After creating thread"" &lt;&lt; endl;

//  ====================================
//  Calling Calc routine through threads
//  ====================================
    HANDLE  hnd2,
        hnd3;

    hnd2    =   (HANDLE) _beginthreadex(NULL,
                                        0,
                                        &amp;Thread,
                                        (void *)&amp;args[0],
                                        0,
                                        0);
    hnd3    =   (HANDLE) _beginthreadex(NULL,
                                        0,
                                        &amp;Thread,
                                        (void *)&amp;args[1],
                                        0,
                                        0);

    WaitForSingleObject(hnd1, INFINITE);
    WaitForSingleObject(hnd2, INFINITE);
    WaitForSingleObject(hnd3, INFINITE);

    GetExitCodeThread(hnd1, &amp;retval); // Gets the return value from the function
    CloseHandle(hnd1);
    CloseHandle(hnd2);
    CloseHandle(hnd3);

    return EXIT_SUCCESS;
}
</code></pre>

<p>The problem I am facing is when I execute the program I get the following output</p>

<pre><code>Before creating new thread
After creating threadInside thread

Thu Aug 09 10:56:58 2012
Thu Aug 09 10:56:58 2012


C:\Documents and Settings\User\My Documents\Test Cases\1\1.datC:\Documents and Settings\User
\My Documents\Test Cases\2\2.dat

C:\Documents and Settings\kcomandur\My Documents\Test Cases\1\1.dboC:\Documents and Settings\User
\My Documents\Test Cases\2\2.dbo

The value of i inside the thread = 10000
Thu Aug 09 10:57:08 2012
</code></pre>

<p>and then program crashes. I get the following error</p>

<pre><code>Debug Error!
Program: ...MultiThreading.exe
R6010
-abort() has been called
(Press Retry to debug the application)
</code></pre>

<p>When I do a retry, the break occurs in the generated .tli file in the following location starting with _com_dispatch_method</p>

<pre><code>#pragma implementation_key(723)
inline IDispatch * IHeatExchangerNetwork::LoadHeatTransferUnit ( BSTR filename, enum HxUnitTypeKey unitType ) {
    IDispatch * _result = 0;
    _com_dispatch_method(this, 0x20, DISPATCH_METHOD, VT_DISPATCH, (void*)&amp;_result,
        L""\x0008\x0003"", filename, unitType);
    return _result;
}
</code></pre>

<p>The filename variable has the value</p>

<pre><code>C:\Documents and Settings\User\My Documents\Test Cases\2\2.dat
</code></pre>

<p>I tried using mutex and modified the Thread function</p>

<pre><code>unsigned int __stdcall Thread(void *args)
{
    CoInitialize(0);
    {
        WaitForSingleObject(th_mutex, INFINITE);

        // Same content as original Thread function.
        // Not writing it again to minimize space

        ReleaseMutex(th_mutex);
    }

    CoUninitialize();

    return  EXIT_SUCCESS;
}
//____________________________________
</code></pre>

<p>This time the program crashes at the following location _com_dispatch_method in the .tli file</p>

<pre><code>#pragma implementation_key(966)
inline long IHeatTransferUnit::WriteDBOFile ( BSTR filename, short io, const VARIANT &amp; vAppend ) {
    long _result = 0;
    _com_dispatch_method(this, 0x32, DISPATCH_METHOD, VT_I4, (void*)&amp;_result,
        L""\x0008\x0002\x080c"", filename, io, &amp;vAppend);
    return _result;
}
</code></pre>

<p>By using mutex the error is being generated by the thread which has the HANDLE hnd3. The variable filename has the value</p>

<pre><code>C:\Documents and Settings\User\My Documents\Test Cases\2\2.dbo
</code></pre>

<p>Also by using mutex I was able to get past the previous error location.</p>

<p>I am not sure if I really need a mutex as the following call</p>

<pre><code>hxNetwork-&gt;Run(0, 0);
</code></pre>

<p>works on two different files that are no way related to each other. Also this is the most time consuming portion of the program and hence I wanted to run 2 cases simultaneously.</p>

<p>By using mutex the way I did, it runs the first case and then the second case.</p>

<p>Also the I have no control over the calc.dll. It is a third part software and I am not sure if supports multithreading or not.</p>

<p>So I would like to know what I need to do to get both the runs going and also be able to output the 2 files</p>

<p>Thanks in advance</p>
"
"<p>I have a camera class, which is initialized like so: </p>

<pre><code>CameraFP::CameraFP()  {
    this-&gt;aspect_ratio = 800.0f / 600.0f;
    this-&gt;fov = 45.0f;
    this-&gt;near_plane = 0.1f;
    this-&gt;far_plane = 1000.0f;
    this-&gt;position = glm::vec3(0, 0, 0);
    this-&gt;target = position + glm::vec3(0, 0, -1);
    this-&gt;up = glm::vec3(0, 1, 0);
    this-&gt;m_rotation = glm::mat4(1.0);

    m_view = glm::lookAt(position, target, up);
    m_projection = glm::perspective(fov, aspect_ratio, near_plane, far_plane);
}
</code></pre>

<p>And here are other functions of import:</p>

<pre><code>void CameraFP::update(sf::Window *app)  {
    process_keyboard(app);
    process_mouse(app);

    calculate_view();
}

void CameraFP::process_keyboard(sf::Window *app)  {
    const sf::Input *input = &amp;app-&gt;GetInput();

    up = m_rotation * glm::vec3(0, 1, 0);

    glm::vec3 forward = glm::vec3(0, 0, -1);
    glm::vec3 forward_rotated = m_rotation * forward;

    glm::vec3 right = glm::vec3(1, 0, 0);
    glm::vec3 right_rotated = m_rotation * right;

    if (input-&gt;IsKeyDown(sf::Key::W))  {
        position += forward_rotated;
    }
    if (input-&gt;IsKeyDown(sf::Key::S))  {
        position -= forward_rotated;
    }
    if (input-&gt;IsKeyDown(sf::Key::A))  {
        position -= right_rotated;
    }
    if (input-&gt;IsKeyDown(sf::Key::D))  {
        position += right_rotated;
    }
}

void CameraFP::process_mouse(sf::Window *app)  {
    // TODO: Make the below constants, and take framerate into account
    GLfloat SPEED_X = 0.000001f;
    GLfloat SPEED_Y = 0.000001f;

    GLfloat mouse_x = app-&gt;GetInput().GetMouseX();
    GLfloat mouse_y = app-&gt;GetInput().GetMouseY();

    GLfloat mouse_x_delta = old_mouse_x - mouse_x;
    GLfloat mouse_y_delta = old_mouse_y - mouse_y;

    if (mouse_x_delta != 0 ||
        mouse_y_delta != 0)  {
        if (mouse_x_delta != 0)  {
            y_rot += mouse_x_delta * SPEED_X;

            m_rotation = glm::rotate(m_rotation, y_rot, glm::vec3(0, 1, 0));
        }
        if (mouse_y_delta != 0)  {
            x_rot += mouse_y_delta * SPEED_Y;

            m_rotation = glm::rotate(m_rotation, x_rot, glm::vec3(1, 0, 0));;
        }
    }

    this-&gt;old_mouse_x = mouse_x;
    this-&gt;old_mouse_y = mouse_y;

    app-&gt;SetCursorPosition(app-&gt;GetWidth() / 2, app-&gt;GetHeight() / 2);
}


void CameraFP::calculate_view()  {
    glm::vec3 forward = glm::vec3(0, 0, -1);
    glm::vec3 forward_rotated = m_rotation * forward;

    target = position += glm::normalize(forward_rotated);

    m_view = glm::lookAt(position, target, up);
}
</code></pre>

<p>My problem is that when I compile the project, the compiler outputs an error saying:</p>

<pre><code>\CameraFP.cpp|59|error: no match for 'operator*' in '((CameraFP*)this)-&gt;CameraFP::m_rotation * glm::detail::tvec3&lt;float&gt;(((const int&amp;)((const int*)(&amp;0))), ((const int&amp;)((const int*)(&amp;1))), ((const int&amp;)((const int*)(&amp;0))))'|
</code></pre>

<p>From what I understand vec = mat4 * vec should yield a rotated vector? Since I haven't been able to test this code, I don't know if the function work correctly.</p>

<p><strong>Edit</strong></p>

<p>Updated code according to the comments and awnsers. My problem is now that I get a BSOD, somewhere in the render function...</p>

<pre><code>void CameraFP::process_keyboard(sf::Window *app)  {
    const sf::Input *input = &amp;app-&gt;GetInput();

    up = m_rotation * glm::vec4(0.0f, 1.0f, 0.0f, 0.0f);

    glm::vec4 forward = glm::vec4(0.0f, 0.0f, -1.0f, 0.0f);
    glm::vec4 forward_rotated = m_rotation * forward;

    glm::vec4 right = glm::vec4(1.0f, 0.0f, 0.0f, 0.0f);
    glm::vec4 right_rotated = m_rotation * right;

    if (input-&gt;IsKeyDown(sf::Key::W))  {
        position += forward_rotated;
    }
    if (input-&gt;IsKeyDown(sf::Key::S))  {
        position -= forward_rotated;
    }
    if (input-&gt;IsKeyDown(sf::Key::A))  {
        position -= right_rotated;
    }
    if (input-&gt;IsKeyDown(sf::Key::D))  {
        position += right_rotated;
    }
}

void CameraFP::process_mouse(sf::Window *app)  {
    // TODO: Make the below constants, and take framerate into account
    GLfloat SPEED_X = 0.000001f;
    GLfloat SPEED_Y = 0.000001f;

    GLfloat mouse_x = app-&gt;GetInput().GetMouseX();
    GLfloat mouse_y = app-&gt;GetInput().GetMouseY();

    GLfloat mouse_x_delta = old_mouse_x - mouse_x;
    GLfloat mouse_y_delta = old_mouse_y - mouse_y;

    if (mouse_x_delta != 0 ||
        mouse_y_delta != 0)  {
        if (mouse_x_delta != 0)  {
            y_rot += mouse_x_delta * SPEED_X;

            m_rotation = glm::rotate(m_rotation, y_rot, glm::vec3(0.0f, 1.0f, 0.0f));
        }
        if (mouse_y_delta != 0)  {
            x_rot += mouse_y_delta * SPEED_Y;

            m_rotation = glm::rotate(m_rotation, x_rot, glm::vec3(1.0f, 0.0f, 0.0f));;
        }
    }

    this-&gt;old_mouse_x = mouse_x;
    this-&gt;old_mouse_y = mouse_y;

    app-&gt;SetCursorPosition(app-&gt;GetWidth() / 2, app-&gt;GetHeight() / 2);
}

void CameraFP::calculate_view()  {
    glm::vec4 forward = glm::vec4(0.0f, 0.0f, -1.0f, 0.0f);
    glm::vec4 forward_rotated = m_rotation * forward;

    target = position += forward_rotated;

    m_view = glm::lookAt(v4tov3(position), v4tov3(target), v4tov3(up));
}

glm::vec3 v4tov3(glm::vec4 v1)  {
    return glm::vec3(v1.x, v1.y, v1.z);
}
</code></pre>

<p><strong>Edit 2</strong></p>

<p>Problem now is with the camera rotation with the mouse, it just doesn't work, for some reason changes on the x axis oft times effect change on the y and vice versa. In addition, if I move the mouse right or left on the x axis (y rotation) the camera rotates left...</p>

<pre><code>void CameraFP::process_mouse(sf::Clock *clock, sf::Window *app)  {
    // TODO: Make the below constants, and take framerate into account
    GLfloat SPEED_X = 0.25f;
    GLfloat SPEED_Y = 0.25f;

    GLfloat screen_x = app-&gt;GetWidth();
    GLfloat screen_y = app-&gt;GetHeight();

    GLfloat mouse_x = float(screen_x / 2 - app-&gt;GetInput().GetMouseX());
    GLfloat mouse_y = float(screen_y / 2 - app-&gt;GetInput().GetMouseY());

    GLfloat mouse_x_delta = old_mouse_x - mouse_x;
    GLfloat mouse_y_delta = old_mouse_y - mouse_y;

    GLfloat current_time = clock-&gt;GetElapsedTime();
    GLfloat delta_time = current_time - last_time;

    this-&gt;last_time = current_time;

    if (mouse_x_delta != 0 ||
        mouse_y_delta != 0)  {
        if (mouse_x_delta != 0)  {
            y_rot += glm::radians(delta_time * SPEED_X * mouse_x);

            m_rotation = glm::rotate(m_rotation, y_rot, glm::vec3(0.0f, 1.0f, 0.0f));

            std::cout &lt;&lt; ""Y Rotation: "" &lt;&lt; y_rot &lt;&lt; ""\n"";
        }
        if (mouse_y_delta != 0)  {
            x_rot += glm::radians(delta_time * SPEED_Y * mouse_y);

            m_rotation = glm::rotate(m_rotation, x_rot, glm::vec3(1.0f, 0.0f, 0.0f));

            std::cout &lt;&lt; ""X rotation: "" &lt;&lt; x_rot &lt;&lt; ""\n"";
        }
    }

    app-&gt;SetCursorPosition(screen_x / 2, screen_y / 2);

    this-&gt;old_mouse_x = float(screen_x / 2 - app-&gt;GetInput().GetMouseX());
    this-&gt;old_mouse_y = float(screen_y / 2 - app-&gt;GetInput().GetMouseY());
}
</code></pre>
"
"<p>I am trying to figure out how to create a little Python script that can take the following parameters:</p>

<ol>
<li>prompt - string </li>
<li>time to wait as an integer</li>
<li>number of characters before stopping</li>
</ol>

<p>The last one is the number of characters I can enter before the program stops accepting characters and starts processing the input. I've seen some people use Python's select.select <a href=""https://stackoverflow.com/questions/1335507/keyboard-input-with-timeout-in-python"">method</a>, but that doesn't account for the 3rd item. I'm leaning towards curses, although I don't know if it supports a timeout which is making me think of threads. Any insights would be great! This will run on Linux with Python 2.6.</p>
"
"<p>This might sound like an obvious question, but I'm new to CouchDB, so I thought it was worthwhile asking in case there is something about CouchDB's structure that changes the situation that I didn't know about.  For reasons out of my control, I have to build a queue-like structure out of CouchDB.  For simplicity's sake, let's say I'm queueing IDs for jobs to be executed later.  Note that there will be no duplicates.</p>

<p>I'm trying to figure out what the best way to structure this is.  As I currently see it, I have a few options:</p>

<ol>
<li>Store the queue items as entries in a <code>queue</code> database with the IDs as <code>_id</code>, and store the dequeued items in a similar <code>dequeued</code> database with the IDs as the <code>_id</code>.  Each record in each database wouldn't have any other information other than the (mandatory) <code>_id</code> and <code>_rev</code>.</li>
<li>Have a single queueing database, and that database will contain one record with <code>_id = 'queue'</code> and one record with <code>_id = 'dequeued'</code>.  Within each of the two records, there will be an arbitrary number of keys, each of which will be an ID for the jobs to be executed (or that were already executed).  The values associated in the database with the keys will be irrelevant, possibly just a Boolean.</li>
<li>Have a single queueing database, and within that database, have a single record called <code>queue</code>.  Within that record, have two keys: <code>queue</code> and <code>dequeued</code>.  Each of those keys will have as its associated value an arbitrary-length list of job execution IDs.</li>
</ol>

<p><strong>1</strong> is slightly less desirable because it requires two databases, and <strong>2</strong> strikes me as a poor choice because it requires loading the entire list of queued or dequeued items in order to read a list item or make any changes.  However, <strong>3</strong> is nice in that it allows for the whole list of IDs to be an ordered list rather than key/value pairs, which makes it easier to pick a random item from the list to be the next job to be executed, since I don't actually need to know any key names (since there are none).</p>

<p>I'm looking for whichever provides the best performance.  Any thoughts on this?</p>

<h3>Update</h3>

<p>For people reading this question in the future, I've built my CouchDB queuing module, <code>CouchQueue</code>, a work in progress.</p>

<p>You can get it <code>npm install couchqueue</code>.</p>

<p>Take a look (and please comment, pull request, etc.) <a href=""https://github.com/jdotjdot/CouchQueue"" rel=""nofollow"">here</a> at Github.</p>
"
"<p>I'm trying to write a basic HTTP file server using sockets in C and have two main problems.  </p>

<p>First, when I try to access ""ip:port/"" through a browser, I get the index.html file but it's in complete gibberish.  However, when I access ""ip:port/not_in_directory"" my little custom 404 message comes back just fine.  If I set the default file to a existing pdf file, gibberish comes back as well (length of pdf gibberish). </p>

<p>Secondly, when I try to access ""ip:port/file_that_exists"", I get my 404 instead of the correct file.  While debugging, I do see that scratch_pad has the correct file name, with no excess or missing characters, but !access(scratch_pad, R_OK) still comes out to be 0.  Is there some necessary cast even though access() takes a char* for the file name?</p>

<p>EDIT: Second issue has been solved (I was using a pointer to deallocated buffer as file name).  However, everything that's picked up by the browser is gibberish.  I'm removing more non-essential code.  </p>

<pre><code>#define FILE_NOT_FOUND ""HTTP/1.0 404 FILE NOT FOUND\r\n""
#define FILE_FOUND ""HTTP/1.0 200 OK\r\n""
#define SERVER_NAME ""Server: Test Server\r\n""
#define CONTENT_TYPE ""Content-Type: text/html\r\n""
#define DATE ""Date: ""
#define MESSAGE_BREAK ""\r\n""
#define NOT_FOUND_HTML ""&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;title&gt;404 Not Found&lt;/title&gt;\n&lt;body&gt;\n&lt;p&gt;Nope&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\r\n""

  if(!access(pulled_name, R_OK | W_OK)) {
      printf(""file found on server\n"");
      server_file = fopen(pulled_name, ""rb+"");
      fseek(server_file, 0L, SEEK_END);
      file_size = ftell(server_file);
      fseek(server_file, 0l, SEEK_SET);
      printf(""opened successfully and set file_size to %i\n"", file_size);
      getting_time = time(NULL);
      c_time = localtime(&amp;getting_time);
      current_time = asctime(c_time);
      printf(""set time for message\n"");

  message = malloc((int) strlen(FILE_FOUND)
                + (int) strlen(SERVER_NAME)
                + (int) strlen(CONTENT_TYPE)
                + (int) strlen(DATE)
                + (int) strlen(current_time)
                + (int) strlen(MESSAGE_BREAK));

  printf(""malloc'ed message\n"");

  message_size = (int)(strlen(message)*sizeof(char));
  memset(message, 0, message_size);
  strcpy(message, FILE_FOUND);
  strcat(message, SERVER_NAME);
  strcat(message, CONTENT_TYPE);
  strcat(message, DATE);
  strcat(message, current_time);
  strcat(message, MESSAGE_BREAK);
  printf(""built message\n"");

  printf(""set message_size to %i\n"", message_size);
  while(total_sent &lt; message_size) {
    n = send(new_socket_fd, message, message_size, 0);
    if (n==-1) {
      printf(""error sending message\n"");
      break;
    }
    total_sent += n;
    printf(""sent %i\n"", total_sent);
  }
  free(message);

  total_sent = 0;
  while(total_sent &lt; file_size) {
    n = send(new_socket_fd, server_file, file_size, 0);
    if (n==-1) {
      printf(""error sending file\n"");
      break;
    }
    total_sent += n;
    printf(""sent %i\n"", total_sent);
  }
  fclose(server_file);
  close(new_socket_fd);
  printf(""closed client connection!\n"");
</code></pre>
"
"<p>I am trying to get current time in C using <code>time_t current_time = time(NULL)</code>.
As I understand, it would return me the current time of system.
I am later trying to convert it into GMT time using struct <code>tm* gmt = gmtime(&amp;current_time)</code>.</p>

<p>I print both times using <code>ctime()</code> and <code>asctime()</code> functions.</p>

<p>The current time on my system is GMT + 1. But <code>gmtime()</code> returns me the same time as <code>current_time</code> is. I could not understand why <code>gmtime()</code> is returning me same time. Any help will be appreciated.</p>

<p>Ok here is the code and the output: Current time that windows is showing is 17:54 (Stockholm zone; GMT+1). I want something to return me 15:54. Or perhaps my understanding is wrong ...</p>

<pre><code>time_t current_time = time(NULL);

struct tm* gmt = gmtime(&amp;current_time);
struct tm* loc = localtime(&amp;current_time);

printf(""current time: %s\n"", ctime(&amp;current_time));
printf(""gmt time %s\n"", asctime(gmt));
printf(""local time %s\n"", asctime(loc));
</code></pre>

<p>Output:</p>

<pre><code>current time: Mon Oct  8 17:54:06 2012

gmt time Mon Oct  8 17:54:06 2012

local time Mon Oct  8 17:54:06 2012
</code></pre>

<p><strong>Accepted Solution:</strong> <strong>From Simes</strong></p>

<p>That's probably your problem. Check the value of your TZ environment variable; if not present, it will default to GMT. Cygwin doesn't automatically pick up the time zone setting from Windows. See also <a href=""https://stackoverflow.com/questions/11655003/localtime-returns-gmt-for-windows-programs-running-on-cygwin-shells"">localtime returns GMT for windows programs running on cygwin shells</a></p>
"
"<p>I am working on an exercise on C++ which demands to simulate a service queue and it asks to do it with a round,one dimension array.So it demands, when a customer comes to          insert in the queue his name, the number of his card  and the arrival time in the queue.</p>

<p>So my first question is how can I enter all these elements in one position of the array?(I don't know if it is called cell of array or position,English is not my native)  Each customer will have to occupy only one position of the array and I have to insert all of his info in one position. I already know the conditions on how to insert or extract an element from a round queue I just don't know how to do  it for lots of them.</p>

<p>Secondly it asks to print  how much time the customer has to wait in queue depending on how much people are waiting before him (it doesn't have to be too precise though).</p>
"
"<p>I'm having some trouble writing Pseduocode for a homework assignment in my operating systems class in which we are programming in C.  </p>

<blockquote>
  <p>You   will    be  implementing    a   Producer-Consumer   program with    a    bounded    buffer  queue   of  N   elements,   P   producer    threads and C   consumer    threads
  (N, P   and C   should  be  command line    arguments   to  your    program,    along   with    three    additional parameters, X,  Ptime   and Ctime,  that    are described   below).     <strong>Each<br>
  Producer    thread  should  Enqueue X   different numbers   onto    the queue   (spin-waiting    for    Ptime*100,000 cycles    in  between each    call    to  Enqueue).       Each    Consumer    thread<br>
  should  Dequeue P*X/C   items   from    the queue   (spin-waiting   for Ctime*100,000 cycles
  in  between each    call    to  Dequeue).</strong>         The main    program should  create/initialize   the
  Bounded Buffer  Queue,  print   a   timestamp,  spawn   off C   consumer    threads &amp;   P<br>
  producer    threads,    wait    for all of  the threads to  finish  and then    print   off another
  timestamp   &amp;   the duration    of  execution.</p>
</blockquote>

<p>My main difficulty is understanding what my professor means by spin-waiting for the variables times 100,000. I have bolded the section that is confusing me.</p>

<p>I understand a time stamp will be used to print the difference between each thread. We are using semaphores and implementing synchronization at the moment. Any suggestions on the above queries would be much appreciated.  </p>
"
"<p>I am aware that there are available functions and libraries that allow concurrency in c.</p>

<p>(pthread.h, fork() etc.)</p>

<p>However, I was wondering if there is any way to simulate concurrency in C, without actually having to use more than one thread?</p>

<p>Example scenario: </p>

<p>There is a main program loop running and outputting calculations. Somehow another function notifies the main function that the time is now 12:00 p.m. and the program should stop outputting calculations as the user is going off to lunch. At 12:30 this function notifies the main function to start outputting calculations again.</p>

<p>Can someone point me in the right direction on how to do this?</p>

<p><strong>EDIT:</strong></p>

<p>In essence I believe there should be 2 ways to do this:</p>

<p>The first would be the main program constantly checking the alternate function so it knows when the clock hits 12:00. <em>(this is very simple and I know how to do this)</em></p>

<p>The second would be having the alternate function contact the main program whenever required (i.e. at 12:00 and 12:30).</p>
"
"<p>I am using two threads, one is downloading, other one is supposed to check how many bytes are downloaded.</p>

<p>Here is the exact code of my program:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;curl/curl.h&gt;
#include &lt;curl/easy.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;unistd.h&gt;

CURLcode res;
FILE *fp;

size_t write_data(void *ptr, size_t size, size_t nmemb, FILE *stream) {
    size_t written;
    written = fwrite(ptr, size, nmemb, stream);
    return written;
}

void *downloadThread() {
    CURL *curl;

    char *url = ""http://imgsrc.hubblesite.org/hu/db/images/hs-2006-10-a-hires_jpg.jpg"";
    char outfilename[FILENAME_MAX] = ""picture.jpg"";
    curl = curl_easy_init();
    if (curl) {
        fp = fopen(outfilename,""wb"");
        curl_easy_setopt(curl, CURLOPT_URL, url);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);
        printf(""File download started\n"");
        res = curl_easy_perform(curl);
        printf(""File download finished\n"");
        curl_easy_cleanup(curl);
        //fclose(fp);
    }
}

void *checkThread() {
    while(1) {
        int prev=ftell(fp);
        fseek(fp, 0L, SEEK_END);
        int downloadedFile=ftell(fp);
        fseek(fp,prev,SEEK_SET); //go back to where we were
        //int downloadedFile = 0; /* instead of 0 it should be something with ""res"" variable */
        printf(""The file size is  %d\n"", downloadedFile);
        usleep(1000000);
    }
}

void setThread() {
    //Thread settings
    pthread_t tid1, tid2;
    pthread_attr_t attr;
    pthread_attr_init(&amp;attr);
    pthread_create(&amp;tid1,&amp;attr,downloadThread, NULL);
    pthread_create(&amp;tid2,&amp;attr,checkThread, NULL);
    pthread_join(tid1, NULL);
    pthread_join(tid2, NULL);
}

int main() {
    setThread();
    return 0;
}
</code></pre>

<p>So this one gives the result of what I wanted but I want to do this without saving into a file.</p>
"
"<p>I have a perl script that is getting the current time coming through in a but I am also looking to get the date 45 days prior to the current time as well. Here is what I have:</p>

<p>*already tried using date::calc DHMS which is why the second is formatted the way it is but it keeps returning an error</p>

<pre><code># get the current time stamp
use POSIX qw( strftime );
my $current_time = strftime(""%Y-%m-%d %H:%M:%S"", localtime);

print ""\n$current_time\n"";

# get the date 45 days ago
my $time = strftime(""%Y, %m, %d, %H, %M, %S"", localtime);

print ""\n$time\n\n"";
</code></pre>
"
"<p>Say that I have the following <code>boost::odeint</code> code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;boost/array.hpp&gt;
#include &lt;boost/numeric/odeint.hpp&gt;
using namespace std;
using namespace boost::numeric::odeint;

const double sigma = 10.0;
const double R = 28.0;
const double b = 8.0 / 3.0;

typedef boost::array&lt; double , 3 &gt; state_type;

void lorenz( const state_type &amp;x , state_type &amp;dxdt , double t ){
    dxdt[0] = sigma * ( x[1] - x[0] );
    dxdt[1] = R * x[0] - x[1] - x[0] * x[2];
    dxdt[2] = -b * x[2] + x[0] * x[1];
}

void write_lorenz( const state_type &amp;x , const double t ){
    cout &lt;&lt; t &lt;&lt; '\t' &lt;&lt; x[0] &lt;&lt; '\t' &lt;&lt; x[1] &lt;&lt; '\t' &lt;&lt; x[2] &lt;&lt; endl;
}

int main(int argc, char **argv){
    state_type x = { 10.0 , 1.0 , 1.0 }; // initial conditions
    cout&lt;&lt;""Steps: ""&lt;&lt;integrate( lorenz , x , 0.0 , 25.0 , 0.1 , write_lorenz )&lt;&lt;endl;
}
</code></pre>

<p>How can I modify the code so that integrate will break after a certain number of steps? I'm running a large number of integrations and want to avoid spending too much time on integrating any particular system.</p>

<p>I've thought of using <code>integrate_n_steps()</code>, but this may mean that the integration proceeds past the end time I am interested in.</p>
"
"<p>I am getting a segfault when dereferencing an iterator which has been initiallized to list.begin().</p>

<pre><code>list&lt;data&gt;::iterator it;
for(int i=0; i&lt; n; i++)
{
    it = (list_empty[i]).begin();
    while(it != (list_empty[i]).end())
    {
        cout&lt;&lt;""PROBLEM HERE: size=""&lt;&lt;it-&gt;process.size&lt;&lt;endl;
        //cout&lt;&lt;""log file i=""&lt;&lt;i&lt;&lt;endl;
        log_file_start(current_time, it,""list of empty"");
        it++;
    }
}
</code></pre>

<p>This is the error from the gdb:</p>

<pre><code>Program received signal SIGSEGV, Segmentation fault.
[Switching to process 2888]
0x0804ecc0 in log_file_buddy (list_delay=..., list_vp=...,
    list_empty=0x805a00c, method=..., current_time=0, n=10)
    at fuctions_of_mm.cpp:425
425         cout&lt;&lt;""PROBLEM HERE: size=""&lt;&lt;it-&gt;process.size &lt;&lt; endl;
</code></pre>

<p>Output of gdb with bt full, shows that iterator is NULL.</p>

<pre><code>(gdb) bt full
#0  0x0804ecc0 in log_file_buddy (list_delay=..., list_vp=...,
    list_empty=0x805a00c, method=..., current_time=0, n=10)
    at fuctions_of_mm.cpp:425
        i = 8
        it = {_M_node = 0x0}
        out = &lt;incomplete type&gt;
</code></pre>

<p>Although the iterator is NULL, the <code>it != (list_empty[i]).end()</code> is evaluated.
what is wrong?</p>

<p><strong>EDIT:</strong>
Sorry for the omission.
This is it: <code>list_empty = new list&lt;data&gt;[n];</code>
N is a parameter given, representing this: 2^{N} = Size_of_Memory</p>

<p><strong>EDIT #2:</strong>
This is the definition:</p>

<pre><code>typedef struct data{
    int position;
    vp proccess;
    int delay;
    int current_life;
    int time_start;
    int time_stop;
    int part_of_memory;
    bool operator ==(const data&amp; st)
    {
      return proccess.pid == st.proccess.pid;
    }
}data;
</code></pre>

<p>And the definition of vp:</p>

<pre><code>    typedef struct {
    int size;
    int pid;//prosdiorisths diergasias
 }vp
</code></pre>

<p><strong>And a value for n: <code>n = 10</code>.</strong></p>

<p><strong>the declaration of list_empty is list&lt; data > *list_empty; .</strong></p>
"
"<p>I'm programming a robot, and unfortunately in its autonomous mode I'm having some issues.
I need to set an integer to 1 when a button is pressed, but in order for the program to recognize the button, it must be in a while loop. As you can imagine, the program ends up in an infinite loop and the integer values end up somewhere near 4,000.</p>

<pre><code> task autonomous()
   {
    while(true)
        {
    if(SensorValue[positionSelectButton] == 1)
        {
            positionSelect = positionSelect + 1;
            wait1Msec(0350);
        }
        }
   }
</code></pre>

<p>I've managed to get the value by using a wait, but I do NOT want to do this. Is there any other way I can approach this?</p>
"
"<p>currently we are planing to do this using alarmmanager service .. check the below code</p>

<p>is there better approch? </p>

<p>Intent intent1= new Intent(ScheduleManagement.this,ScheduleManagementService.class);
        Intent intent2= new Intent(ScheduleManagement.this,ScheduleManagementService.class);
        Intent intent3= new Intent(ScheduleManagement.this,ScheduleManagementService.class);</p>

<pre><code>    intent1.putExtra(""msg"", ""Good morning Sweety "");

   intent1.putExtra(""msg"", ""Good afternoon  "");
  intent1.putExtra(""msg"", ""Good night "");



     /*pendingIntent will fire based on the time
     * request code also differ...
     * same pending intent object...
     * same service but intent properties are different.
     *  */

    Date dt=new Date();

    Log.d(""sri"", ""sriii""+dt.getTime());

    long current_time=calendar.getTimeInMillis();
    pendingIntent =PendingIntent.getService(ScheduleManagement.this,1, intent1,3);
    alarmManager.set(AlarmManager.RTC_WAKEUP, current_time+1000000, pendingIntent);

    /*pendingIntent =PendingIntent.getService(ScheduleManagement.this,2, intent2,3);
    alarmManager.set(AlarmManager.RTC_WAKEUP, current_time +2000000, pendingIntent);*/

    pendingIntent =PendingIntent.getService(ScheduleManagement.this,3, intent3,3);
    alarmManager.set(AlarmManager.RTC_WAKEUP, current_time +3000000, pendingIntent);
</code></pre>
"
"<p>I have a service that shows a specific button when a session is ""ready"", i.e. 15 minutes beforehand and through the session.</p>

<p>I am doing this by pulling up all recently requested sessions, analyzing their timestamps, and then pulling out a specific ID if that session is upcoming. Here is the code:</p>

<pre><code>$session_check_query = ""SELECT * FROM requested_sessions WHERE username_t = '{$_SESSION['username']}'"";
$session_check_process = mysql_query($session_check_query);

date_default_timezone_set($_SESSION['timezone']);
$current_time = time();

while ($sessions = mysql_fetch_array($session_check_process)) {
    if ($sessions['time_from_t'] - $current_time &lt;= 900 &amp;&amp; $current_time - $sessions['time_from_t'] &gt; 0 &amp;&amp; $sessions['accepted'] == 1) {
        $session_id = $sessions['id'];
    }
}
</code></pre>

<p>The problem is that when I echo $session_id in the loop it will output 1, 2, 3, 4. This means that it feels that all of my sessions in the database meet this criteria when they don't only one does.</p>

<p>Is there a problem with this code? time_from_t is in UNIX format.</p>
"
"<p>I am writing a code in c and I need to add milliseconds to the current time given by :</p>

<pre><code>current_time = time(NULL);
loc_time=localtime(&amp;current_time);
</code></pre>

<p>Say the local time is 20:00:00:10. I want to adding 10 seconds and display it so it displays 20:00:00:20. I am fairly new to c so any help is much appreciated.
I am confused as time is in int format and, to add milli seconds I will have to add .001 seconds to the current second which is not an int.</p>
"
"<p>I am writing a code in c and I need to add milliseconds to the current time
So far, i have :</p>

<p>current_time = time(NULL);
loc_time=localtime(&amp;current_time); </p>

<p>however this only gives HH:MM:SS when I need HH:MM:SS:MM </p>

<p>Say the local time is 20:00:00:10. I want to adding 10 milliseconds and display it so it displays 20:00:00:20. I am fairly new to c so any help is much appreciated. I am confused as time is of type int format and, to add milli seconds I will have to add .001 seconds to the current second which is not an int.</p>
"
"<p>I am calculating time elapsed in milli seconds for each successive call to handler function using the code below. When i use usleep(1000) i.e. 1 ms time difference between each call is 10 ms and when i use usleep(1000000) i.e. 1 sec surprisingly time interval between each call falls down to less than 1 ms. Following is the code snippet :</p>

<pre><code>    #include&lt;stdio.h&gt;
    #include&lt;stdlib.h&gt;
    #include&lt;sys/time.h&gt;
    #include&lt;unistd.h&gt;

    struct timeval start_time;
    void handler(int);

    int main()
    {
            struct timeval current_time;
            int i=0;
            gettimeofday(&amp;start_time,0);
            gettimeofday(&amp;current_time,0);
            printf(""%012.3fms: emulationbegins\n"",((current_time.tv_usec-start_time.tv_usec)/1000.0));

            while(i++&lt;5)
            {
                    usleep(1000); // compare with usleep(1000000)
                    handler(i);
            }

            return 0;
    }

    void handler(int i)
    {
            printf(""In Handler %d\n"",i);
            struct timeval current_time;
            gettimeofday(&amp;current_time,0);
            printf(""%012.3fms: Handler Called\n"",((current_time.tv_usec-start_time.tv_usec)/1000.0));
            return;
    }
</code></pre>
"
"<p>I have been working on a Round Robin Scheduling Program. My inputs are: </p>

<pre><code>Process     Arrival Time    Burst Time
   1            0               4
   2            2               2
   3            4               3
   4            6               5
   5            7               1
</code></pre>

<p>Time Slice is 3 units!
My output must be: </p>

<pre><code>Process     AT      BT      WT      TT      FT
   1        0       4       9       13      13
   2        2       2       1       3       5
   3        4       3       1       4       8
   4        6       5       4       9       15
   5        7       1       4       5       12
</code></pre>

<p>But I am not getting the correct results(WT &amp; FT) for Process 1, 4 &amp; 5. Here's my code, can anyone please help me fix it and get the above results?</p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;
struct proc
{
    int id;
    int arrival;
    int burst;
    int rem;
    int wait;
    int finish;
    int ti;
    int turnaround;
    float ratio;
}process[10];

int no,k;
int chkprocess(int);

void main()
{
 int i,j,t,time = 0,n;
 struct proc temp;
 int nextprocess(int);
 clrscr();
 printf(""\n \n Enter the number of processes: "");
 scanf(""%d"", &amp;n);
 printf(""\n \n Enter the time slice of the CPU: "");
 scanf(""%d"", &amp;t);

 for(i = 1; i &lt;= n; i++)
 {
  process[i].id = i;
  printf(""\n\nEnter the arrival time for process %d: "", i);
  scanf(""%d"", &amp;(process[i].arrival));
  printf(""\nEnter the burst time for process %d: "", i);
  scanf(""%d"", &amp;(process[i].burst));
  process[i].rem = process[i].burst;
  process[i].ti=0;
  process[i].wait=0;
  process[i].finish=0;
 }

 for(i = 1; i &lt;= n; i++)
 {
  for(j = i + 1; j &lt;= n; j++)
  {
   if(process[i].arrival &gt; process[j].arrival)
   {
    temp = process[i];
    process[i] = process[j];
    process[j] = temp;
   }
  }
 }

 no = 0;
 j = 1;

 while(chkprocess(n) == 1)
 {
  if(process[no + 1].arrival == time)
   no++;
  if((process[j].ti&lt;=t)&amp;&amp;(process[j].rem !=0))
  {
   process[j].rem--;
   process[j].ti++;
   for(i = 1; i &lt;= no; i++)
   {
    if((i!=j) &amp;&amp; (process[i].rem != 0))
     process[i].wait++;
   }
  }
  if(process[j].rem==0)
   process[j].finish=time;
  if((process[j].ti &gt;= t)||(process[j].rem==0))
  {
   process[j].ti = 0;
   j=nextprocess(j);
  }
  time++;
 }
 process[n].finish = time;
 printf(""\n\n Process  Arrival  Burst   Waiting  Finishing turnaround  Tr/Tb \n"");
 printf(""%5s %9s %7s %10s %8s %9s\n\n"", ""id"", ""time"", ""time"", ""time"", ""time"", ""time"");
 for(i = 1; i &lt;= n; i++)
 {
  process[i].turnaround = process[i].wait + process[i].burst;
  process[i].ratio = (float)process[i].turnaround / (float)process[i].burst;
  printf(""%5d %8d %7d  %8d %10d %9d %10.1f "", process[i].id, process[i].arrival,
                          process[i].burst,
                          process[i].wait, process[i].finish,
                          process[i].turnaround, process[i].ratio);

  printf(""\n\n"");
 }
 getch();
}

int chkprocess(int s)
{
 int i;
 for(i = 1; i &lt;= s; i++)
 {
  if(process[i].rem != 0)
   return 1;
 }
 return 0;
}

int nextprocess(int k)
{
 int i;
 i=k+1;
 while(chkprocess(i) &amp;&amp; i!=k)
 {
  if(process[i].rem != 0)
   return i;
  else
   i=(i+1)%no;
 }
}
</code></pre>

<p>Thank You   </p>
"
"<p>I'm reading the kernel of Linux 0.12, the codes in inode.c:</p>

<pre><code>static int _bmap(struct m_inode * inode,int block,int create)
{
    struct buffer_head * bh;
    int i;

    if (block&lt;0)
        panic(""_bmap: block&lt;0"");
    if (block &gt;= 7+512+512*512)
        panic(""_bmap: block&gt;big"");
    if (block&lt;7) {
        if (create &amp;&amp; !inode-&gt;i_zone[block])
            if (inode-&gt;i_zone[block]=new_block(inode-&gt;i_dev)) {
                inode-&gt;i_ctime=CURRENT_TIME;
                inode-&gt;i_dirt=1;
            }
        return inode-&gt;i_zone[block];
    }
block -= 7;
    if (block&lt;512) {
        if (create &amp;&amp; !inode-&gt;i_zone[7])
            if (inode-&gt;i_zone[7]=new_block(inode-&gt;i_dev)) {
                inode-&gt;i_dirt=1;
                inode-&gt;i_ctime=CURRENT_TIME;
            }
        if (!inode-&gt;i_zone[7])
            return 0;
        if (!(bh = bread(inode-&gt;i_dev,inode-&gt;i_zone[7])))
            return 0;
        i = ((unsigned short *) (bh-&gt;b_data))[block];
        if (create &amp;&amp; !i)
            if (i=new_block(inode-&gt;i_dev)) {
                ((unsigned short *) (bh-&gt;b_data))[block]=i;
                bh-&gt;b_dirt=1;
            }
        brelse(bh);
        return i;
    }
block -= 512;
    if (create &amp;&amp; !inode-&gt;i_zone[8])
        if (inode-&gt;i_zone[8]=new_block(inode-&gt;i_dev)) {
            inode-&gt;i_dirt=1;
            inode-&gt;i_ctime=CURRENT_TIME;
        }
    if (!inode-&gt;i_zone[8])
        return 0;
    if (!(bh=bread(inode-&gt;i_dev,inode-&gt;i_zone[8])))
        return 0;
    i = ((unsigned short *)bh-&gt;b_data)[block&gt;&gt;9];
    if (create &amp;&amp; !i)
        if (i=new_block(inode-&gt;i_dev)) {
            ((unsigned short *) (bh-&gt;b_data))[block&gt;&gt;9]=i;
            bh-&gt;b_dirt=1;
        }
    brelse(bh);
    if (!i)
        return 0;
    if (!(bh=bread(inode-&gt;i_dev,i)))
        return 0;
    i = ((unsigned short *)bh-&gt;b_data)[block&amp;511];
    if (create &amp;&amp; !i)
        if (i=new_block(inode-&gt;i_dev)) {
            ((unsigned short *) (bh-&gt;b_data))[block&amp;511]=i;
            bh-&gt;b_dirt=1;
        }
    brelse(bh);
    return i;
}
</code></pre>

<p>I konw that i_zone[0] ~ i_zone[6] can store a block. But the i_zone how to
stand for 512 blocks?  and i_zone[8] how to stand for 512*512 blocks ?</p>

<p>Thank you </p>
"
"<p>I have a log file in my C program which I am trying to make entries to every time the user executes a query. It works, apart from it prints the date and time to one line and the activity string to the line below. I need it to print the whole entry to one line. I have tried everything and don't understand why it won't work. I think it is something to do with the time_string. Please can someone help? Code is shown below;</p>

<pre><code>/*
 * This function writes a log to the log file.
 */
 void write_log(char *activity) {
     FILE *lf;
     time_t current_time;
     char *time_string;

     current_time = time(NULL);
     time_string = ctime(&amp;current_time);
     strcat(time_string, activity);
     lf = fopen(""logs.txt"", ""a+"");
     fprintf(lf, ""%s\n"", activity);
     fclose(lf);
 }
</code></pre>

<p>The function is called in the main and is passed a string literal for the activity.</p>
"
"<p>I want to run a function for example func() exactly 1 time per second. However the running time of func() is about 500 ms. How Can I do that? I know if the running time of the function is low, I can write a while loop in func() and sleep() for 1 second after each execution. But now, the running time is high. What should I do to ensure the func() run exactly 1 time per second? Thanks.</p>
"
"<pre><code>void AODV::rt_resolve(Packet *p) {
    struct hdr_cmn *ch = HDR_CMN(p);
    struct hdr_ip *ih = HDR_IP(p);
    aodv_rt_entry *rt;
    ch-&gt;xmit_failure_ = aodv_rt_failed_callback;
    ch-&gt;xmit_failure_data_ = (void*) this;
    rt = rtable.rt_lookup(ih-&gt;daddr());

    if(rt == 0) {
      rt = rtable.rt_add(ih-&gt;daddr());
    }

    if(rt-&gt;rt_flags == RTF_UP) {
       assert(rt-&gt;rt_hops != INFINITY2);
     #ifdef PREDICTION
        double breakTime = 2000.0;
        if (ch-&gt;num_forwards() != 0 &amp;&amp; ch-&gt;next_hop_ == index){
        Node *currentNode = Node::get_node_by_address(index);
        breakTime = currentNode-&gt;getTime(ch-&gt;prev_hop_);

     if (breakTime &lt; 2000.0 &amp;&amp; breakTime &gt; CURRENT_TIME
      &amp;&amp; (breakTime - CURRENT_TIME &lt; PREDICTION_TIME_FOR_UNICAST)
      &amp;&amp; (rt-&gt;rt_prevnode_warning == 0)){
        //printf(""\nPREDICTION:: at %.9f on node %d prev node %d , dst %d, will break at %.9f\n"", CURRENT_TIME, index, ch-&gt;prev_hop_, ih-&gt;daddr(), breakTime);
        sendLPW(ch-&gt;prev_hop_, breakTime);
        rt-&gt;rt_prevnode_warning ++;
    }
}
#endif
forward(rt, p, NO_DELAY);
}
</code></pre>

<p>In the above code of MAODV i am getting following error </p>

<pre><code>In member function ?void AODV::rt_resolve(Packet*)?:
 aodv/aodv.cc:569:34: error: ?class Node? has no member named ?getTime?
</code></pre>
"
"<p>I am trying to write a system call to get the current time. However, I keep getting expected ) before struct.</p>

<p>My system call definition is </p>

<p>SYSCALL_DEFINE1(current_xtime,struct timespec *, current_time)</p>

<p>This line gives the error. I am using linux kernel version 3.8.8. What could cause it?</p>
"
"<p>I want to write simple unix-application that measures tcp-connection speed.
So I have:</p>

<ul>
<li>server listens on specified port, accepts connections and measures speed</li>
<li>client sends messages (continuously)</li>
</ul>

<p>I thought that measurement on server is somthing like this:</p>

<pre><code>clock_gettime(CLOCK_REALTIME, &amp;start);
size = recv(csocket_fd, buf, BUFFER_SIZE, 0);
clock_gettime(CLOCK_REALTIME, &amp;end);
</code></pre>

<p>but it seems like it's wrong way. </p>

<p>any suggestions?</p>
"
"<p>I have this procedure in a smartmeter daemon to log a counter of gas consumption:</p>

<pre><code>void http_post(const char *vzuuid) {

sprintf(url, ""http://%s:%d/%s/data/%s.json?ts=%llu"", vzserver, vzport, vzpath, vzuuid, unixtime());

CURL *curl;
CURLcode curl_res;

curl_global_init(CURL_GLOBAL_ALL);

curl = curl_easy_init();

if(curl)
{
    FILE* devnull = NULL;
    devnull = fopen(""/dev/null"", ""w+"");

    curl_easy_setopt(curl, CURLOPT_USERAGENT, DAEMON_NAME "" "" DAEMON_VERSION );
    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, """");

    curl_easy_setopt(curl, CURLOPT_WRITEDATA, devnull);

        if( (curl_res = curl_easy_perform(curl)) != CURLE_OK) {
        syslog(LOG_INFO, ""HTTP_POST(): %s"", curl_easy_strerror(curl_res) );
        }

    curl_easy_cleanup(curl);
    fclose ( devnull );

}

curl_global_cleanup();
}
</code></pre>

<p>I want to execute this only if the last call is more than 10s ago. I Thought of a global variable last_time to remember the last timestamp and to compare it with the actual timestamp in an if ... then construct around all that curl stuff. For that the direct use of unixtime() should be buffered in another variable current_time to be used to be compared with last_time.</p>

<p>Can anybody help me please? I am not used to use C...</p>

<p>Thank you!</p>
"
"<p>I have the following two headers.</p>

<pre><code>#ifndef DRD_EVENT_HPP
#define DRD_EVENT_HPP

#include &lt;functional&gt;

namespace drd
{

  template &lt;typename Clock&gt;
   class event
   {
     public:

      using clock = Clock;
      using time_point = typename clock::time_point;

     template &lt;class F, class... Args&gt;
       event(time_point et, F&amp;&amp; f, Args&amp;&amp;... args) :
        Task(std::bind&lt;void&gt;(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)),
        Time(et) {}

      void perform() ///Can throw std::bad_function_call
      {
         Task();
         Task = nullptr;
      }

      ///Returns the event time.
      time_point time() const noexcept
      { return Time; }

      ///Checks if the event has not been performed yet.
      bool pending() const noexcept
      { return static_cast&lt;bool&gt;(Task); }

     private:

      std::function&lt; void()&gt; Task;
      time_point Time;
   };

   struct later_event
   {
      template &lt;class Clock&gt;
       bool operator()(const event&lt;Clock&gt;&amp; lhs, const event&lt;Clock&gt;&amp; rhs)
       const noexcept
       {
          return lhs.time() &gt; rhs.time();
       }
   };

}

#endif // DRD_EVENT_HPP


#ifndef DRD_DISCRETE_SIMULATION_HPP
#define DRD_DISCRETE_SIMULATION_HPP

#include &lt;exception&gt;
#include &lt;chrono&gt;
#include &lt;queue&gt;
#include ""event.hpp""

namespace drd
{
 namespace des ///Discrete event simulation
 {

  template &lt;class Rep, class Period = std::ratio&lt;1&gt;&gt;
   class simulation_engine
   {
      public:

        class clock;
        using time_point = typename clock::time_point;
        using duration = typename clock::duration;
        using event_type = event&lt;clock&gt;;

      public:


      ///Constructs an event ""in-place"" and inserts it in the events list
      template &lt;typename... EventArgs&gt;
       void schedule(EventArgs&amp;&amp;... event_args_)
       {
          EventsList.emplace(std::forward&lt;EventArgs&gt;(event_args_)...);
       }

      bool has_pending_events() const noexcept
      { return not EventsList.empty(); }


      ///Advances the clock until the next event time and then the event
      ///is performed, if the events list was empty the behavior is undefined.
      void next_event()
      {
         auto Event = EventsList.top();
         EventsList.pop();
         clock::advance_until(Event.time());
         Event.perform();
      }

      ///Calls next_event() while the events list is not empty.
      void simulate()
      { while (has_pending_events()) next_event();}


      ///Performs all of events whose time is scheduled before or just at the
      ///moment t, then advances the clock until t.

      void simulate_until(time_point t)
      {
        while(has_pending_events() and EventsList.top().time() &lt;= t)
          next_event();
        clock::advance_until(t);
      }

      void simulate_for(duration d)
      {  simulate_until(clock::now() + d); }



      private:

        std::priority_queue&lt;event_type, std::vector&lt;event_type&gt;,
                            later_event&gt; EventsList;
   };


 ///clock type that is thread-independent and adjustable by
 ///simulation_engine

  template &lt;class Rep, class Period&gt;
  class simulation_engine&lt;Rep,Period&gt;::clock
  {
    public:

     using rep = Rep;
     using period = Period;
     using duration = std::chrono::duration&lt;rep,period&gt;;
     using time_point = std::chrono::time_point&lt;clock&gt;;

    public:

     static constexpr bool is_steady = false;

    public:

      static time_point now() noexcept
      { return CurrentTime;}

    private:

      static void reset() noexcept
      { CurrentTime = time_point(); }

      static void adjust(time_point t) noexcept
      { CurrentTime = t; }

      static void advance_until(time_point t)
      {
        if(t &lt; CurrentTime)
         throw std::logic_error(""advance_until cannot set the clock back."");
        CurrentTime = t;
      }

      friend simulation_engine&lt;Rep,Period&gt;;

    private:

       static thread_local time_point CurrentTime;
  };

 template &lt;class Rep, class Period&gt;
   thread_local typename simulation_engine&lt;Rep,Period&gt;::clock::time_point
   simulation_engine&lt;Rep,Period&gt;::clock::CurrentTime;


 }
}

#endif //DRD_DISCRETE_SIMULATION_HPP
</code></pre>

<p>I was wondering if I should make member functions of simulation_engine static, because objects own independent events list and share the same clock,  and might happen a synchronization problem. </p>

<p>What should I do?</p>

<p>Sorry for my english and the extensive code.
I hope your answer, thank you in advance.</p>
"
"<p>Linux ramfs uses simple_rename(), but why in such function the new_dentry and old_inode are not linked to each other?</p>

<p>Here is the source code of simple_rename() for your reference:</p>

<pre><code>int simple_rename(struct inode *old_dir, struct dentry *old_dentry,
                struct inode *new_dir, struct dentry *new_dentry)
{
        struct inode *inode = old_dentry-&gt;d_inode;
        int they_are_dirs = S_ISDIR(old_dentry-&gt;d_inode-&gt;i_mode);

        if (!simple_empty(new_dentry))
                return -ENOTEMPTY;

        if (new_dentry-&gt;d_inode) {
                simple_unlink(new_dir, new_dentry);
                if (they_are_dirs)
                        drop_nlink(old_dir);
        } else if (they_are_dirs) {
                drop_nlink(old_dir);
                inc_nlink(new_dir);
        }

        old_dir-&gt;i_ctime = old_dir-&gt;i_mtime = new_dir-&gt;i_ctime =
                new_dir-&gt;i_mtime = inode-&gt;i_ctime = CURRENT_TIME;

        return 0;
}
</code></pre>

<p>Thanks!</p>
"
"<p>OLSR class file<br>
  OLSR.cc</p>

<pre><code>OLSR::link_sensing
(OLSR_msg&amp; msg, const nsaddr_t &amp;receiver_iface, const nsaddr_t &amp;sender_iface, const int &amp;index)

{
OLSR_hello&amp; hello = msg.hello();
double now = CURRENT_TIME;
bool updated = false;
bool created = false;

OLSR_link_tuple* link_tuple = state_.find_link_tuple(sender_iface);
if (link_tuple == NULL)
{
    // We have to create a new tuple
    link_tuple = new OLSR_link_tuple;
    link_tuple-&gt;nb_iface_addr() = sender_iface;
    link_tuple-&gt;local_iface_addr() = receiver_iface;

    //For testing only
    if(sender_iface == 168427530 &amp;&amp; receiver_iface == 169082900 ) //Error occur at this line
    {
        link_tuple-&gt;link_quality_metric() = 0.9;
    }
</code></pre>

<p>OLSR header file
    OLSR.h</p>

<pre><code>virtual bool        link_sensing(OLSR_msg&amp;, const nsaddr_t &amp;, const nsaddr_t &amp;, const int &amp;);
</code></pre>

<p>error get: Description<br>
no match for 'operator==' in 'receiver_iface == 169082900'  </p>
"
"<p>I am using IPG CarMaker and am trying to export the data to another machine using UDP, real time.
I am referring to <a href=""http://www.codeproject.com/Articles/11740/A-simple-UDP-time-server-and-client-for-beginners"" rel=""nofollow"">http://www.codeproject.com/Articles/11740/A-simple-UDP-time-server-and-client-for-beginners</a>.
I want to send the position of the car whenever the client requests it. Now I have included the above code into CarMakers main loop which has a timestep of 1 ms. There is no problem while I build the program (using Visual Studio 2010). But when I try running simulations in CarMaker, the following line causes the simulation to get timed out:</p>

<p>bytes_received = recvfrom(sd, buffer, BUFFER_SIZE, 0, (struct sockaddr *)&amp;client, &amp;client_length);</p>

<p>As a result my simulation does not start at all!
Is it because I don't have a client running alongside at the same time? Please help! The code in the main loop is as follows:</p>

<p>User_DrivMan_Calc (double dt)
{
    client_length = (int)sizeof(struct sockaddr_in);</p>

<pre><code>bytes_received = recvfrom(sd, buffer, BUFFER_SIZE, 0, (struct sockaddr *)&amp;client, &amp;client_length);

if (bytes_received &lt; 0)
{
    fprintf(f, ""Could not receive datagram.\n"");
    closesocket(sd);
    WSACleanup();
    exit(0);
}

/* Check for time request */

if (strcmp(buffer, ""GET DISTANCE\r\n"") == 0)
{
    /* Get current time */
    current_time = time(NULL);
    d = Car.Distance;
    /* Send data back */
    if (sendto(sd, (char *)&amp;d, (int)sizeof(d), 0, (struct sockaddr *)&amp;client, client_length) != (int)sizeof(d))
    {
        fprintf(f, ""Error sending datagram.\n"");
        closesocket(sd);
        WSACleanup();
        exit(0);
    }
}

return 0;
</code></pre>

<p>}</p>
"
"<p>Im starting with some SystemC coding and i'm trying to use a Network-on-chip simulator called ""Noxim"", which i've heard is very smooth and simple. However, im getting this common error when I'm trying to ""make"" some part of the simulation</p>

<pre><code>terminate called after throwing an instance of 'std::out_of_range'
  what():  basic_string::substr
Abort
</code></pre>

<p>I think it comes from a cpp code, which I DO NOT own and, sincerely, dont fully understand. The code can be found bellow, and the full Noxim distribution can be found here: <a href=""https://github.com/alexayin/Noxim"" rel=""nofollow"">https://github.com/alexayin/Noxim</a></p>

<p>The code is at Noxim/other/</p>

<p>Noxim_explorer.cpp and sim.cfg are strongly related to the lab im trying to do.</p>

<p>Please, if someone has solved this problem or have any idea, it would be very helpful.</p>

<p>FOR THE RECORD: I got stucked when trying to follow this lab <a href=""http://access.ee.ntu.edu.tw/noxim/Lab2.pdf"" rel=""nofollow"">http://access.ee.ntu.edu.tw/noxim/Lab2.pdf</a>, 'cause I couldnt get any info in the matlab file</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;cassert&gt;
#include &lt;cstdlib&gt;
#include &lt;sys/time.h&gt;

using namespace std;

//---------------------------------------------------------------------------

#define DEFAULT_KEY          ""default""
#define AGGREGATION_KEY      ""aggregation""
#define EXPLORER_KEY         ""explorer""
#define SIMULATOR_LABEL      ""simulator""
#define REPETITIONS_LABEL    ""repetitions""
#define TMP_DIR_LABEL        ""tmp""

#define DEF_SIMULATOR        ""./noxim""
#define DEF_REPETITIONS      5
#define DEF_TMP_DIR          ""./""

#define TMP_FILE_NAME        "".noxim_explorer.tmp""

#define RPACKETS_LABEL       ""% Total received packets:""
#define RFLITS_LABEL         ""% Total received flits:""
#define AVG_DELAY_LABEL      ""% Global average delay (cycles):""
#define AVG_THROUGHPUT_LABEL ""% Global average throughput (flits/cycle):""
#define THROUGHPUT_LABEL     ""% Throughput (flits/cycle/IP):""
#define MAX_DELAY_LABEL      ""% Max delay (cycles):""
#define TOTAL_ENERGY_LABEL   ""% Total energy (J):""

#define MATLAB_VAR_NAME      ""data""
#define MATRIX_COLUMN_WIDTH  15

//---------------------------------------------------------------------------

typedef unsigned int uint;

// parameter values
typedef vector&lt;string&gt; TParameterSpace;

// parameter name, parameter space
typedef map&lt;string, TParameterSpace&gt; TParametersSpace;

// parameter name, parameter value
typedef vector&lt;pair&lt;string, string&gt; &gt; TConfiguration;

typedef vector&lt;TConfiguration&gt; TConfigurationSpace;

struct TExplorerParams
{
  string simulator;
  string tmp_dir;
  int    repetitions;
};

struct TSimulationResults
{
  double       avg_delay;
  double       throughput;
  double       avg_throughput;
  double       max_delay;
  double       total_energy;
  unsigned int rpackets;
  unsigned int rflits;
};

//---------------------------------------------------------------------------

double GetCurrentTime()
{
  struct timeval tv;

  gettimeofday(&amp;tv, NULL);

  return tv.tv_sec + (tv.tv_usec * 1.0e-6);
}

//---------------------------------------------------------------------------

void TimeToFinish(double elapsed_sec,
          int completed, int total,
          int&amp; hours, int&amp; minutes, int &amp;seconds)
{
  double total_time_sec = (elapsed_sec * total)/completed;
  double remain_time_sec = total_time_sec - elapsed_sec;

  seconds = (int)remain_time_sec % 60;
  minutes = ((int)remain_time_sec / 60) % 60;
  hours   = (int)remain_time_sec / 3600;
}

//---------------------------------------------------------------------------

bool IsComment(const string&amp; s)
{
  return (s == """" || s.at(0) == '%');
}

//---------------------------------------------------------------------------

string TrimLeftAndRight(const string&amp; s)
{
  int len = s.length();

  int i, j;
  for (i=0; i&lt;len &amp;&amp; s.at(i) == ' '; i++) ;
  for (j=len-1; j&gt;=0 &amp;&amp; s.at(j) == ' '; j--) ;

  return s.substr(i,j-i+1);
}

//---------------------------------------------------------------------------

bool ExtractParameter(const string&amp; s, string&amp; parameter)
{
  uint i = s.find(""["");

  if (i != string::npos)
    {
      uint j = s.rfind(""]"");

      if (j != string::npos)
    {
      parameter = s.substr(i+1, j-i-1);
      return true;
    }
    }

  return false;
}

//---------------------------------------------------------------------------

bool GetNextParameter(ifstream&amp; fin, string&amp; parameter)
{
  bool found = false;

  while (!fin.eof() &amp;&amp; !found)
    {
      string s;
      getline(fin, s);

      if (!IsComment(s))
    found = ExtractParameter(s, parameter);
    }

  return found;
}

//---------------------------------------------------------------------------w

string MakeStopParameterTag(const string&amp; parameter)
{
  string sparameter = ""[/"" + parameter + ""]"";

  return sparameter;
}

//---------------------------------------------------------------------------

bool ManagePlainParameterSet(ifstream&amp; fin,
                 const string&amp; parameter,
                 TParametersSpace&amp; params_space,
                 string&amp; error_msg)
{
  string str_stop = MakeStopParameterTag(parameter);
  bool   stop = false;

  while (!fin.eof() &amp;&amp; !stop)
    {
      string s;
      getline(fin, s);

      if (!IsComment(s))
    {
      if (s.find(str_stop) != string::npos)
        stop = true;
      else
        params_space[parameter].push_back(TrimLeftAndRight(s));
    }
    }

  return true;
}

//---------------------------------------------------------------------------

bool ExpandInterval(const string&amp; sint,
            TParameterSpace&amp; ps,
            string&amp; error_msg)
{
  istringstream iss(sint);

  double min, max, step;

  iss &gt;&gt; min;
  iss &gt;&gt; max;
  iss &gt;&gt; step;

  string param_suffix;
  getline(iss, param_suffix);

  for (double v=min; v&lt;=max; v+=step)
    {
      ostringstream oss;
      oss &lt;&lt; v;
      ps.push_back(oss.str() + param_suffix);
    }

  return true;
}

//---------------------------------------------------------------------------

bool ManageCompressedParameterSet(ifstream&amp; fin,
                  const string&amp; parameter,
                  TParametersSpace&amp; params_space,
                  string&amp; error_msg)
{
  string str_stop = MakeStopParameterTag(parameter);
  bool   stop = false;

  while (!fin.eof() &amp;&amp; !stop)
    {
      string s;
      getline(fin, s);

      if (!IsComment(s))
    {
      if (s.find(str_stop) != string::npos)
        stop = true;
      else
        {
          if (!ExpandInterval(s, params_space[parameter], error_msg))
        return false;
        }
    }
    }

  return true;
}

//---------------------------------------------------------------------------

bool ManageParameter(ifstream&amp; fin,
             const string&amp; parameter,
             TParametersSpace&amp; params_space,
             string&amp; error_msg)
{
  bool err;

  if (parameter == ""pir"")
    err = ManageCompressedParameterSet(fin, parameter, params_space, error_msg);
  else
    err = ManagePlainParameterSet(fin, parameter, params_space, error_msg);

  return err;
}

//---------------------------------------------------------------------------

bool ParseConfigurationFile(const string&amp; fname,
                TParametersSpace&amp; params_space,
                string&amp; error_msg)
{
  ifstream fin(fname.c_str(), ios::in);

  if (!fin)
    {
      error_msg = ""Cannot open "" + fname;
      return false;
    }

  while (!fin.eof())
    {
      string parameter;

      if ( GetNextParameter(fin, parameter) )
    {
      if (!ManageParameter(fin, parameter, params_space, error_msg))
        return false;
    }
    }

  return true;
}

//---------------------------------------------------------------------------

bool LastCombination(const vector&lt;pair&lt;int,int&gt; &gt;&amp; indexes)
{
  for (uint i=0; i&lt;indexes.size(); i++)
    if (indexes[i].first &lt; indexes[i].second-1)
      return false;

  return true;
}

//---------------------------------------------------------------------------

bool IncrementCombinatorialIndexes(vector&lt;pair&lt;int,int&gt; &gt;&amp; indexes)
{
  for (uint i=0; i&lt;indexes.size(); i++)
    {
      if (indexes[i].first &lt; indexes[i].second - 1)
    {
      indexes[i].first++;
      return true;
    }
      indexes[i].first = 0;
    }

  return false;
}

//---------------------------------------------------------------------------

TConfigurationSpace Explore(const TParametersSpace&amp; params_space)

{
  TConfigurationSpace conf_space;

  vector&lt;pair&lt;int,int&gt; &gt; indexes; // &lt;index, max_index&gt;

  for (TParametersSpace::const_iterator psi=params_space.begin();
       psi!=params_space.end(); psi++)
      indexes.push_back(pair&lt;int,int&gt;(0, psi-&gt;second.size()));

  do
    {
      int i = 0;
      TConfiguration conf;
      for (TParametersSpace::const_iterator psi=params_space.begin();
       psi!=params_space.end(); psi++)
    {
      conf.push_back( pair&lt;string,string&gt;(psi-&gt;first,
                          psi-&gt;second[indexes[i].first]));
      i++;
    }
      conf_space.push_back(conf);
    }
  while (IncrementCombinatorialIndexes(indexes));

  return conf_space;
}

//---------------------------------------------------------------------------

bool RemoveParameter(TParametersSpace&amp; params_space,
             const string&amp; param_name,
             TParameterSpace&amp; param_space,
             string&amp; error_msg)
{
  TParametersSpace::iterator i = params_space.find(param_name);

  if (i == params_space.end())
    {
      error_msg = ""Cannot extract parameter '"" + param_name + ""'"";
      return false;
    }

  param_space = params_space[param_name];
  params_space.erase(i);

  return true;
}

//---------------------------------------------------------------------------

bool RemoveAggregateParameters(TParametersSpace&amp; params_space,
                   TParameterSpace&amp;  aggregated_params,
                   TParametersSpace&amp; aggragated_params_space,
                   string&amp; error_msg)
{
  for (uint i=0; i&lt;aggregated_params.size(); i++)
    {
      string param_name = aggregated_params[i];
      TParameterSpace param_space;
      if (!RemoveParameter(params_space, param_name, param_space, error_msg))
    return false;

      aggragated_params_space[param_name] = param_space;
    }

  return true;
}

//---------------------------------------------------------------------------

string ParamValue2Cmd(const pair&lt;string,string&gt;&amp; pv)
{
  string cmd;

  if (pv.first == ""topology"")
    {
      istringstream iss(pv.second);

      int  width, height;
      char times;
      iss &gt;&gt; width &gt;&gt; times &gt;&gt; height;

      ostringstream oss;
      oss &lt;&lt; ""-dimx "" &lt;&lt; width &lt;&lt; "" -dimy "" &lt;&lt; height;

      cmd = oss.str();
    }
  else
    cmd = ""-"" + pv.first + "" "" + pv.second;

  return cmd;
}

//---------------------------------------------------------------------------

string Configuration2CmdLine(const TConfiguration&amp; conf)
{
  string cl;

  for (uint i=0; i&lt;conf.size(); i++)
    cl = cl + ParamValue2Cmd(conf[i]) + "" "";

  return cl;
}

//---------------------------------------------------------------------------

string Configuration2FunctionName(const TConfiguration&amp; conf)
{
  string fn;

  for (uint i=0; i&lt;conf.size(); i++)
    fn = fn + conf[i].first + ""_"" + conf[i].second + ""__"";

  // Replace "" "", ""-"", ""."", ""/"" with ""_""
  int len = fn.length();
  for (int i=0; i&lt;len; i++)
    if (fn.at(i) == ' ' || fn.at(i) == '.' || fn.at(i) == '-' || fn.at(i) == '/')
      fn[i] = '_';

  return fn;
}

//---------------------------------------------------------------------------

bool ExtractExplorerParams(const TParameterSpace&amp; explorer_params,
               TExplorerParams&amp; eparams,
               string&amp; error_msg)
{
  eparams.simulator   = DEF_SIMULATOR;
  eparams.tmp_dir     = DEF_TMP_DIR;
  eparams.repetitions = DEF_REPETITIONS;

  for (uint i=0; i&lt;explorer_params.size(); i++)
    {
      istringstream iss(explorer_params[i]);

      string label;
      iss &gt;&gt; label;

      if (label == SIMULATOR_LABEL)
    iss &gt;&gt; eparams.simulator;
      else if (label == REPETITIONS_LABEL)
    iss &gt;&gt; eparams.repetitions;
      else if (label == TMP_DIR_LABEL)
    iss &gt;&gt; eparams.tmp_dir;
      else
    {
      error_msg = ""Invalid explorer option '"" + label + ""'"";
      return false;
    }
    }

  return true;
}

//---------------------------------------------------------------------------

bool PrintHeader(const string&amp; fname,
         const TExplorerParams&amp; eparams,
         const string&amp; def_cmd_line, const string&amp; conf_cmd_line,
         ofstream&amp; fout,
         string&amp; error_msg)
{
  fout.open(fname.c_str(), ios::out);
  if (!fout)
    {
      error_msg = ""Cannot create "" + fname;
      return false;
    }

  fout &lt;&lt; ""% fname: "" &lt;&lt; fname &lt;&lt; endl
       &lt;&lt; ""% "" &lt;&lt; eparams.simulator &lt;&lt; "" ""
       &lt;&lt; conf_cmd_line &lt;&lt; "" "" &lt;&lt; def_cmd_line
       &lt;&lt; endl &lt;&lt; endl;

  return true;
}

//---------------------------------------------------------------------------

bool PrintMatlabFunction(const string&amp; mfname,
             ofstream&amp; fout,
             string&amp; error_msg)
{
  fout &lt;&lt; ""function [max_pir, max_throughput, min_delay] = "" &lt;&lt; mfname &lt;&lt; ""(symbol)"" &lt;&lt; endl
       &lt;&lt; endl;

  return true;
}

//---------------------------------------------------------------------------

bool ReadResults(const string&amp; fname,
         TSimulationResults&amp; sres,
         string&amp; error_msg)
{
  ifstream fin(fname.c_str(), ios::in);
  if (!fin)
    {
      error_msg = ""Cannot read "" + fname;
      return false;
    }

  int nread = 0;
  while (!fin.eof())
    {
      string line;
      getline(fin, line);

      uint pos;

      pos = line.find(RPACKETS_LABEL);
      if (pos != string::npos)
    {
      nread++;
      istringstream iss(line.substr(pos + string(RPACKETS_LABEL).size()));
      iss &gt;&gt; sres.rpackets;
      continue;
    }

      pos = line.find(RFLITS_LABEL);
      if (pos != string::npos)
    {
      nread++;
      istringstream iss(line.substr(pos + string(RFLITS_LABEL).size()));
      iss &gt;&gt; sres.rflits;
      continue;
    }

      pos = line.find(AVG_DELAY_LABEL);
      if (pos != string::npos)
    {
      nread++;
      istringstream iss(line.substr(pos + string(AVG_DELAY_LABEL).size()));
      iss &gt;&gt; sres.avg_delay;
      continue;
    }

      pos = line.find(AVG_THROUGHPUT_LABEL);
      if (pos != string::npos)
    {
      nread++;
      istringstream iss(line.substr(pos + string(AVG_THROUGHPUT_LABEL).size()));
      iss &gt;&gt; sres.avg_throughput;
      continue;
    }

      pos = line.find(THROUGHPUT_LABEL);
      if (pos != string::npos)
    {
      nread++;
      istringstream iss(line.substr(pos + string(THROUGHPUT_LABEL).size()));
      iss &gt;&gt; sres.throughput;
      continue;
    }

      pos = line.find(MAX_DELAY_LABEL);
      if (pos != string::npos)
    {
      nread++;
      istringstream iss(line.substr(pos + string(MAX_DELAY_LABEL).size()));
      iss &gt;&gt; sres.max_delay;
      continue;
    }

      pos = line.find(TOTAL_ENERGY_LABEL);
      if (pos != string::npos)
    {
      nread++;
      istringstream iss(line.substr(pos + string(TOTAL_ENERGY_LABEL).size()));
      iss &gt;&gt; sres.total_energy;
      continue;
    }
    }

  if (nread != 7)
    {
      error_msg = ""Output file "" + fname + "" corrupted"";
      return false;
    }

  return true;
}

//---------------------------------------------------------------------------

bool RunSimulation(const string&amp; cmd_base,
           const string&amp; tmp_dir,
           TSimulationResults&amp; sres,
           string&amp; error_msg)
{
  string tmp_fname = tmp_dir + TMP_FILE_NAME;
  //  string cmd = cmd_base + "" &gt;&amp; "" + tmp_fname; // this works only with csh and bash
  string cmd = cmd_base + "" &gt;"" + tmp_fname + "" 2&gt;&amp;1""; // this works with sh, csh, and bash!

  cout &lt;&lt; cmd &lt;&lt; endl;
  system(cmd.c_str());
  if (!ReadResults(tmp_fname, sres, error_msg))
    return false;

  string rm_cmd = string(""rm -f "") + tmp_fname;
  system(rm_cmd.c_str());

  return true;
}

//---------------------------------------------------------------------------

string ExtractFirstField(const string&amp; s)
{
  istringstream iss(s);

  string sfirst;

  iss &gt;&gt; sfirst;

  return sfirst;
}

//---------------------------------------------------------------------------

bool RunSimulations(double start_time,
            pair&lt;uint,uint&gt;&amp; sim_counter,
            const string&amp; cmd, const string&amp; tmp_dir, const int repetitions,
            const TConfiguration&amp; aggr_conf,
            ofstream&amp; fout,
            string&amp; error_msg)
{
  int    h, m, s;

  for (int i=0; i&lt;repetitions; i++)
    {
      cout &lt;&lt; ""# simulation "" &lt;&lt; (++sim_counter.first) &lt;&lt; "" of "" &lt;&lt; sim_counter.second;
      if (i != 0)
    cout &lt;&lt; "", estimated time to finish "" &lt;&lt; h &lt;&lt; ""h "" &lt;&lt; m &lt;&lt; ""m "" &lt;&lt; s &lt;&lt; ""s"";
      cout &lt;&lt; endl;

      TSimulationResults sres;
      if (!RunSimulation(cmd, tmp_dir, sres, error_msg))
    return false;

      double current_time = GetCurrentTime();
      TimeToFinish(current_time-start_time, sim_counter.first, sim_counter.second, h, m, s);

      // Print aggragated parameters
      fout &lt;&lt; ""  "";
      for (uint i=0; i&lt;aggr_conf.size(); i++)
    fout &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; ExtractFirstField(aggr_conf[i].second); // this fix the problem with pir
      // fout &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; aggr_conf[i].second;

      // Print results;
      fout &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; sres.avg_delay
       &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; sres.throughput
       &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; sres.max_delay
       &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; sres.total_energy
       &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; sres.rpackets
       &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; sres.rflits
       &lt;&lt; endl;
    }

  return true;
}

//---------------------------------------------------------------------------

bool PrintMatlabVariableBegin(const TParametersSpace&amp; aggragated_params_space,
                  ofstream&amp; fout, string&amp; error_msg)
{
  fout &lt;&lt; MATLAB_VAR_NAME &lt;&lt; "" = ["" &lt;&lt; endl;
  fout &lt;&lt; ""% "";
  for (TParametersSpace::const_iterator i=aggragated_params_space.begin();
       i!=aggragated_params_space.end(); i++)
    fout &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; i-&gt;first;

  fout &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; ""avg_delay""
       &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; ""throughput""
       &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; ""max_delay""
       &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; ""total_energy""
       &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; ""rpackets""
       &lt;&lt; setw(MATRIX_COLUMN_WIDTH) &lt;&lt; ""rflits"";

  fout &lt;&lt; endl;

  return true;
}

//---------------------------------------------------------------------------

bool GenMatlabCode(const string&amp; var_name,
           const int fig_no,
           const int repetitions, const int column,
           ofstream&amp; fout, string&amp; error_msg)
{
  fout &lt;&lt; var_name &lt;&lt; "" = [];"" &lt;&lt; endl
       &lt;&lt; ""for i = 1:rows/"" &lt;&lt; repetitions &lt;&lt; "","" &lt;&lt; endl
       &lt;&lt; ""   ifirst = (i - 1) * "" &lt;&lt; repetitions &lt;&lt; "" + 1;"" &lt;&lt; endl
       &lt;&lt; ""   ilast  = ifirst + "" &lt;&lt; repetitions &lt;&lt; "" - 1;"" &lt;&lt; endl
       &lt;&lt; ""   tmp = "" &lt;&lt; MATLAB_VAR_NAME &lt;&lt; ""(ifirst:ilast, cols-6+"" &lt;&lt; column &lt;&lt; "");"" &lt;&lt; endl
       &lt;&lt; ""   avg = mean(tmp);"" &lt;&lt; endl
       &lt;&lt; ""   [h sig ci] = ttest(tmp, 0.1);"" &lt;&lt; endl
       &lt;&lt; ""   ci = (ci(2)-ci(1))/2;"" &lt;&lt; endl
       &lt;&lt; ""   "" &lt;&lt; var_name &lt;&lt; "" = ["" &lt;&lt; var_name &lt;&lt; ""; "" &lt;&lt; MATLAB_VAR_NAME &lt;&lt; ""(ifirst, 1:cols-6), avg ci];"" &lt;&lt; endl
       &lt;&lt; ""end"" &lt;&lt; endl
       &lt;&lt; endl;

  fout &lt;&lt; ""figure("" &lt;&lt; fig_no &lt;&lt; "");"" &lt;&lt; endl
       &lt;&lt; ""hold on;"" &lt;&lt; endl
       &lt;&lt; ""plot("" &lt;&lt; var_name &lt;&lt; ""(:,1), "" &lt;&lt; var_name &lt;&lt; ""(:,2), symbol);"" &lt;&lt; endl
       &lt;&lt; endl;

  return true;
}

//---------------------------------------------------------------------------

bool GenMatlabCodeSaturationAnalysis(const string&amp; var_name,
                     ofstream&amp; fout, string&amp; error_msg)
{

  fout &lt;&lt; endl
       &lt;&lt; ""%-------- Saturation Analysis -----------"" &lt;&lt; endl
       &lt;&lt; ""slope=[];""  &lt;&lt; endl
       &lt;&lt; ""for i=2:size("" &lt;&lt; var_name &lt;&lt; ""_throughput,1),""  &lt;&lt; endl
       &lt;&lt; ""    slope(i-1) = ("" &lt;&lt; var_name &lt;&lt; ""_throughput(i,2)-"" &lt;&lt; var_name &lt;&lt; ""_throughput(i-1,2))/("" &lt;&lt; var_name &lt;&lt; ""_throughput(i,1)-"" &lt;&lt; var_name &lt;&lt; ""_throughput(i-1,1));""  &lt;&lt; endl
       &lt;&lt; ""end""  &lt;&lt; endl
       &lt;&lt; endl
       &lt;&lt; ""for i=2:size(slope,2),""  &lt;&lt; endl
       &lt;&lt; ""    if slope(i) &lt; (0.95*mean(slope(1:i)))""  &lt;&lt; endl
       &lt;&lt; ""        max_pir = "" &lt;&lt; var_name &lt;&lt; ""_throughput(i, 1);""  &lt;&lt; endl
       &lt;&lt; ""        max_throughput = "" &lt;&lt; var_name &lt;&lt; ""_throughput(i, 2);""  &lt;&lt; endl
       &lt;&lt; ""        min_delay = "" &lt;&lt; var_name &lt;&lt; ""_delay(i, 2);""  &lt;&lt; endl
       &lt;&lt; ""        break;""  &lt;&lt; endl
       &lt;&lt; ""    end""  &lt;&lt; endl
       &lt;&lt; ""end""  &lt;&lt; endl;

  return true;
}

//---------------------------------------------------------------------------

bool PrintMatlabVariableEnd(const int repetitions,
                ofstream&amp; fout, string&amp; error_msg)
{
  fout &lt;&lt; ""];"" &lt;&lt; endl &lt;&lt; endl;

  fout &lt;&lt; ""rows = size("" &lt;&lt; MATLAB_VAR_NAME &lt;&lt; "", 1);"" &lt;&lt; endl
       &lt;&lt; ""cols = size("" &lt;&lt; MATLAB_VAR_NAME &lt;&lt; "", 2);"" &lt;&lt; endl
       &lt;&lt; endl;

  if (!GenMatlabCode(string(MATLAB_VAR_NAME) + ""_delay"", 1,
             repetitions, 1, fout, error_msg))
    return false;

  if (!GenMatlabCode(string(MATLAB_VAR_NAME) + ""_throughput"", 2,
             repetitions, 2, fout, error_msg))
    return false;

  if (!GenMatlabCode(string(MATLAB_VAR_NAME) + ""_maxdelay"", 3,
             repetitions, 3, fout, error_msg))
    return false;

  if (!GenMatlabCode(string(MATLAB_VAR_NAME) + ""_totalenergy"", 4,
             repetitions, 4, fout, error_msg))
    return false;

  if (!GenMatlabCodeSaturationAnalysis(string(MATLAB_VAR_NAME), fout, error_msg))
    return false;

  return true;
}

//---------------------------------------------------------------------------

bool RunSimulations(const TConfigurationSpace&amp; conf_space,
            const TParameterSpace&amp;     default_params,
            const TParametersSpace&amp;    aggragated_params_space,
            const TParameterSpace&amp;     explorer_params,
            string&amp;                    error_msg)
{
  TExplorerParams eparams;
  if (!ExtractExplorerParams(explorer_params, eparams, error_msg))
    return false;

  // Make dafault parameters string
  string def_cmd_line;
  for (uint i=0; i&lt;default_params.size(); i++)
    def_cmd_line = def_cmd_line + default_params[i] + "" "";

  // Explore configuration space
  TConfigurationSpace aggr_conf_space = Explore(aggragated_params_space);

  pair&lt;uint,uint&gt; sim_counter(0, conf_space.size() * aggr_conf_space.size() * eparams.repetitions);

  double start_time = GetCurrentTime();
  for (uint i=0; i&lt;conf_space.size(); i++)
    {
      string conf_cmd_line = Configuration2CmdLine(conf_space[i]);

      string   mfname = Configuration2FunctionName(conf_space[i]);
      string   fname  = mfname + "".m"";
      ofstream fout;
      if (!PrintHeader(fname, eparams,
               def_cmd_line, conf_cmd_line, fout, error_msg))
    return false;

      if (!PrintMatlabFunction(mfname, fout, error_msg))
    return false;

      if (!PrintMatlabVariableBegin(aggragated_params_space, fout, error_msg))
    return false;

      for (uint j=0; j&lt;aggr_conf_space.size(); j++)
    {
      string aggr_cmd_line = Configuration2CmdLine(aggr_conf_space[j]);
      /*
      string cmd = eparams.simulator + "" ""
        + def_cmd_line + "" ""
        + conf_cmd_line + "" ""
        + aggr_cmd_line;
      */
      string cmd = eparams.simulator + "" ""
            + aggr_cmd_line + "" ""
        + def_cmd_line + "" ""
        + conf_cmd_line;

      if (!RunSimulations(start_time,
                  sim_counter, cmd, eparams.tmp_dir, eparams.repetitions,
                  aggr_conf_space[j], fout, error_msg))
        return false;
    }

      if (!PrintMatlabVariableEnd(eparams.repetitions, fout, error_msg))
    return false;
    }

  return true;
}

//---------------------------------------------------------------------------

bool RunSimulations(const string&amp; script_fname,
            string&amp;       error_msg)
{
  TParametersSpace ps;

  if (!ParseConfigurationFile(script_fname, ps, error_msg))
    return false;


  TParameterSpace default_params;
  if (!RemoveParameter(ps, DEFAULT_KEY, default_params, error_msg))
    cout &lt;&lt; ""Warning: "" &lt;&lt; error_msg &lt;&lt; endl;


  TParameterSpace  aggregated_params;
  TParametersSpace aggragated_params_space;
  if (!RemoveParameter(ps, AGGREGATION_KEY, aggregated_params, error_msg))
    cout &lt;&lt; ""Warning: "" &lt;&lt; error_msg &lt;&lt; endl;
  else
    if (!RemoveAggregateParameters(ps, aggregated_params,
                  aggragated_params_space, error_msg))
      return false;

  TParameterSpace explorer_params;
  if (!RemoveParameter(ps, EXPLORER_KEY, explorer_params, error_msg))
    cout &lt;&lt; ""Warning: "" &lt;&lt; error_msg &lt;&lt; endl;

  TConfigurationSpace conf_space = Explore(ps);

  if (!RunSimulations(conf_space, default_params,
              aggragated_params_space, explorer_params, error_msg))
    return false;


  return true;
}


//---------------------------------------------------------------------------

int main(int argc, char **argv)
{
  if (argc &lt; 2)
    {
      cout &lt;&lt; ""Usage: "" &lt;&lt; argv[0] &lt;&lt; "" &lt;cfg file&gt; [&lt;cfg file&gt;]"" &lt;&lt; endl;
      return -1;
    }

  for (int i=1; i&lt;argc; i++)
    {
      string fname(argv[i]);
      cout &lt;&lt; ""# Exploring configuration space "" &lt;&lt; fname &lt;&lt; endl;

      string error_msg;

      if (!RunSimulations(fname, error_msg))
    cout &lt;&lt; ""Error: "" &lt;&lt; error_msg &lt;&lt; endl;

      cout &lt;&lt; endl;
    }

  return 0;
}

//---------------------------------------------------------------------------
</code></pre>
"
"<p>Alright, so I have the following code:</p>

<pre><code>   if (!clock_is_24h_style()) {
   if (current_time-&gt;tm_hour &lt;= 3)
  set_container_image(&amp;time_format_image, RESOURCE_ID_NBC, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 4 &amp;&amp; current_time-&gt;tm_min &lt;= 29)
  set_container_image(&amp;time_format_image, RESOURCE_ID_ETODAY, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 4 &amp;&amp; current_time-&gt;tm_min &gt;= 30)
  set_container_image(&amp;time_format_image, RESOURCE_ID_9NEWSMORN, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 5)
  set_container_image(&amp;time_format_image, RESOURCE_ID_9NEWSMORN, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 6)
  set_container_image(&amp;time_format_image, RESOURCE_ID_9NEWSMORN, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 12 &amp;&amp; current_time-&gt;tm_min &lt;= 29)
  set_container_image(&amp;time_format_image, RESOURCE_ID_IMAGE_PM_MODE, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 12 &amp;&amp; current_time-&gt;tm_min &gt;= 30)
  set_container_image(&amp;time_format_image, RESOURCE_ID_NBC, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 13 &amp;&amp; current_time-&gt;tm_min &lt;= 29)
  set_container_image(&amp;time_format_image, RESOURCE_ID_WTC, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 13 &amp;&amp; current_time-&gt;tm_min &gt;= 30)
  set_container_image(&amp;time_format_image, RESOURCE_ID_BEARS, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 14 &amp;&amp; current_time-&gt;tm_min &lt;= 29)
  set_container_image(&amp;time_format_image, RESOURCE_ID_WTC, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 14 &amp;&amp; current_time-&gt;tm_min &gt;= 30)
  set_container_image(&amp;time_format_image, RESOURCE_ID_BEARS, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 15)
  set_container_image(&amp;time_format_image, RESOURCE_ID_NBC, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 16)
  set_container_image(&amp;time_format_image, RESOURCE_ID_9NEWS4, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 17)
  set_container_image(&amp;time_format_image, RESOURCE_ID_9NEWS5, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 18 &amp;&amp; current_time-&gt;tm_min &lt;= 29)
  set_container_image(&amp;time_format_image, RESOURCE_ID_9NEWS6, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 18 &amp;&amp; current_time-&gt;tm_min &gt;= 30)
  set_container_image(&amp;time_format_image, RESOURCE_ID_NN, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 19)
  set_container_image(&amp;time_format_image, RESOURCE_ID_NBC, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 20)
  set_container_image(&amp;time_format_image, RESOURCE_ID_WTC, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 21)
  set_container_image(&amp;time_format_image, RESOURCE_ID_BEARS, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 22)
  set_container_image(&amp;time_format_image, RESOURCE_ID_NBC, GPoint(0, 0));

else if (current_time-&gt;tm_hour == 23 &amp;&amp; current_time-&gt;tm_min &lt;= 34)
  set_container_image(&amp;time_format_image, RESOURCE_ID_9NEWS10, GPoint(0, 0));

else if (current_time-&gt;tm_hour &gt;= 23 &amp;&amp; current_time-&gt;tm_min &gt;= 35)
  set_container_image(&amp;time_format_image, RESOURCE_ID_NBC, GPoint(0, 0));

else {
  layer_remove_from_parent(&amp;time_format_image.layer.layer);
  bmp_deinit_container(&amp;time_format_image);
}
</code></pre>

<p>It makes it so the image on the watch changes at a certain time, which is great and awesome works great.</p>

<p>However, the code cycles daily, and does this day by day making, and its only accurate during weekdays (Monday-Friday) and was wondering how I could make it so that code only apply to Monday-Friday, while a separate code will apply to Saturday and another for Sunday. Thank you!</p>
"
"<p>I have a file that an application updates every few seconds, and I want to extract a single number field in that file, and record it into a list for use later. So, I'd like to make an infinite loop where the script reads a source file, and any time it notices a change in a particular figure, it writes that figure to an output file.</p>

<p>I'm not sure why I can't get Python to notice that the source file is changing:</p>

<pre><code>#!/usr/bin/python

import re
from time import gmtime, strftime, sleep



def write_data(new_datapoint):
        output_path = '/media/USBHDD/PythonStudy/torrent_data_collection/data_one.csv'
        outfile = open(output_path, 'a')
        outfile.write(new_datapoint)
        outfile.close()


forever = 0
previous_data = ""0""

while forever &lt; 1:
        input_path = '/var/lib/transmission-daemon/info/stats.json'
        infile = open(input_path, ""r"")
        infile.seek(0)
        contents = infile.read()

        uploaded_bytes = re.search('""uploaded-bytes"":\s(\d+)', contents)

        if uploaded_bytes:
                current_time = strftime(""%Y-%m-%d %X"", gmtime())
                current_data = uploaded_bytes.group(1)
                if current_data != previous_data:
                        write_data("",""+ current_time + ""$"" + uploaded_bytes.group(1))
                        previous_data = uploaded_bytes.group(1)
                infile.close()
                sleep(5)
        else:
                print ""couldn't write"" + strftime(""%Y-%m-%d %X"", gmtime())
                infile.close()
                sleep(60)
</code></pre>

<p>As is now, the (messy) script writes once correctly, and then I can see that although my source file (stats.json) file is changing, my script never picks up on any changes. It keeps on running, but my output file doesn't grow.</p>

<p>I thought that an <code>open()</code> and a <code>close()</code> would do the trick, and then tried throwing in a <code>.seek(0)</code>.</p>

<p>What file method am I missing to ensure that python re-opens and re-reads my source file, (stats.json)? </p>
"
"<p>I was solving a problem where i was asked to output the list of numbers satisfying certain conditions. The score awarded depended upon the size of the output ( as it is a partial marking question). How do i restrict my code to keep outputting the numbers till it does hits the time limit. </p>
"
"<p>I am building a music player using gstreamer-1.0. I am using sqlite3 to store meta data of the mp3 files. And I would like to use dbus for communication between gstreamer and database. This is basically to isolate the UI and the framework of the music player separately. While doing so I would like to retreive meta data which has been already stored in the database. I am returning it through a structure. Question is, how do I write the xml file for returning a structure through a function. My structure and function are as shown below.`</p>

<pre><code>struct string_vars{
  std::string title;
  std::string album;
  std::string artist;
  std::string genre;
  volatile long int real_time;
  volatile long int current_time;
};

struct string_vars Gstreamer_class::req_meta_data(char *song_path
{
  start_playbin_for_database(song_path);
  return label_data;
}
</code></pre>

<p>I tried like this:-</p>

<pre><code>&lt;method name=""req_meta_data""&gt;
    &lt;arg type=""s"" name=""song_path"" direction=""in""&gt;
    &lt;arg type=""(issssxx)"" name=""label_data"" direction=""out""&gt;
&lt;/method&gt;
</code></pre>

<p>I guess its wrong. It threw me an error:-</p>

<blockquote>
  <p>Unable to load ""value-dbus-music.xml"": Can't put  element here
  make: *** [value-server-stub.h] Error 1</p>
</blockquote>

<p>Please help me.</p>
"
"<p>I want to delete all the files in the public_html directory of my domain by a single command. For this one of SO's questions had this answer:</p>

<pre><code>&lt;?php
array_map('unlink', glob(""path/to/temp/*""));
?&gt;
</code></pre>

<p>How can i add exceptions to this, maybe using this code or something else? I don't want to delete file(s) running the delete code as this file too will be in the public_html folder.</p>
"
"<p>My goal is to determine expiry of an item to when it was acquired(bought) and when it is sold.There is a TTL value associated with each of the item.</p>

<p>I am doing following :</p>

<pre><code>time_t currentSellingTime;
long currentSystemTime = time(&amp;currentSellingTime); // this gives me epoch millisec of now()

long TTL = &lt;some_value&gt;L;
long BuyingTime = &lt;some_value&gt; // this is also in epoch millsec


if(currentSystemTime &gt;  TTL+BuyingTime))
{
//throw exception
// item is expired
}
</code></pre>

<p>My question is how to sum two epoch millisec and compare it with another epoch millsec in C++</p>
"
"<p>I am creating an application for a training management system. I have to check if thge current date and time is greater than the date and time in the db. If so, hide some buttons. But my code is not working. </p>

<p>I don't know what I have done wrong. I am stuck on this for hours now. The date in db is in the format <code>dd-mm-yyyy</code> and time is in <code>H:i</code>. Here is what I've tried:</p>

<pre><code>    end_Time = data.end_Time; // to get the time from db
    var CurrentDate = new Date();
    var arrDate = end_Time[0].end_date.split(""-"");
    var dbDate = new Date(arrDate[2], arrDate[1] - 1, arrDate[0]);
    var hours = CurrentDate.getHours();
    var minutes = (""0"" + (CurrentDate.getMinutes())).slice(-2);
    var Current_Time = hours + "":"" + minutes;

    if (dbDate &lt; CurrentDate) {
        if ((end_Time[0].end_time) &lt; Current_Time) {
            $(""#updateTrainingButton"").hide();
            $(""#sendInvitationButton"").hide();
            $(""#cancelTrainingButton"").hide();
        }
    }
</code></pre>
"
"<p>Problem: To retrieve files from a particular ""path"" which satisfy the below criteria:
it should be a file whose date falls in between 'startDate' and 'endDate'</p>

<p>Example:
fetch(path,startDate,endDate):
    path-> path of the directory
    startDate-> date as listed in ls (Jun 27)
    endDate-> date as listed in ls</p>

<p>And also, I am not able to store the o/p of 'ls -lrt' so as to check for a particular pattern.
Can someone help me !!!</p>
"
"<p>I was playing around with the time.sleep function from python's standard library and found it inadequate for sub-ms delays. From testing I found it to actually wait 1.1-1.2 ms for a 1ms wait. Implementing a busy wait got the accuracy to within 1%. I used:</p>

<pre><code>def busy_wait(dt):
    current_time = time.time()
    while (time.time() &lt; current_time+dt):
        pass
</code></pre>

<p>and could get down to 0.0001 seconds before breaking 1% accuracy.</p>

<p>The main questions I have are:</p>

<ul>
<li>Why is the sleep function so inaccurate (possibly a C issue)? Will getting a better CPU with a higher clock speed change this?</li>
<li>Why would anyone use sleep? The only advantage I see, power conservation, is limited to embedded systems, no?</li>
<li>Would it be viable to compensate for sleep's inaccuracy with calibration? Like so:</li>
</ul>

<pre>
def sleep(dt):
    sleep(calibration_function(dt))
</pre>

<p>As an aside, I read that sleep doesn't even function well with long wait times: <a href=""https://stackoverflow.com/questions/1941177/upper-limit-in-python-time-sleep"">Upper limit in Python time.sleep()?</a>
I also read somewhere on SO of making a loop of shorter time intervals to increase precision, but that is useless when I want to delay 0.01 sec. <a href=""https://stackoverflow.com/a/1212070/2534876"">Karl Voigtland</a> mentions using ctypes' nanosleep, but I feel this is overkill and that time.sleep should do it's intended behavior.</p>

<p>time.sleep is a broken python feature? Or does nobody care about accurate time measurement enough?</p>
"
"<p>Apologies if this question has already been answered.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;

using namespace std;

int main () {

srand( time(NULL) );
cout &lt;&lt; rand();
}
</code></pre>

<p>""implicit conversion loses integer precision: 'time_t' (aka 'long') to 'unsigned int'""</p>

<p>Is the error message Im getting when I execute the code above. I am using xcode 4.6.1. Now when I use a different complier such as the one from codepad.org it executes perfectly fine generating what seems like random numbers so I am assuming it is an xcode issue that I need to work around?</p>

<p>I have JUST started programming so I am a complete beginner when it comes to this. Is there a problem with my code or is it my complier? </p>

<p>Any help would be appreciated! </p>
"
"<p>I am building a dynamic MySQL user search query that is to be able to handle many different search criteria. I considered writing a stored procedure, but ended up building the query in the client (prepared statement in PHP). Among the criteria is to be able to search for users' ages, i.e. between X and Y years old. I am wondering how to do this as efficiently as possible. The end query will be fairly complex and have several joins and may be run on a few million rows in the future, so I need to optimize it where I can. I am storing a user's date of birth in an indexed <code>DATE</code> column that has the <code>YYYY-MM-DD</code> format. I have the following User Defined Function (UDF) for calculating a user's age:</p>

<pre><code>RETURN (DATE_FORMAT(current_time, '%Y') - DATE_FORMAT(date_of_birth, '%Y') - (DATE_FORMAT(current_time, '00-%m-%d') &lt; DATE_FORMAT(date_of_birth, '00-%m-%d')));
</code></pre>

<p>The details of the calculation are not important; I am more concerned with how it is used. One of my worries is that using this UDF in my WHERE clause would slow the query down significantly, because it needs to be run on every single row, even though I made the UDF deterministic. I cannot guarantee that there will be other criteria to narrow the matching rows down before checking ages. I can't just check the date of birth against a date, because that would not be accurate. I am thinking whether pulling the above calculation out of the UDF and embedding it directly within the query's WHERE clause would be make a noticeable difference (I think yes). The downside would then be that the WHERE clause is further complicated with such a calculation (or actually two, unless there is a way to reuse the result). But I guess there is no way to avoid those calculations. Is performing this calculation in the WHERE clause the way to go in regards to performance, or is there a better way?</p>

<p>Theoretically, I guess I could even add an <code>age</code> column in the <code>user</code> table and calculate the age when a user registers and run a scheduled job/cronjob every night to update ages for users that have a birthday of today (if I can select that efficiently). This would surely speed up my search query, but would introduce redundant data. Therefore I would really only want to do this if the calculation cannot be done efficiently within the search query itself.</p>

<p>So, to sum up: I need to search for users within a range of ages (e.g. 25 to 30). Should I calculate the age in the WHERE clause, or would that be very slow because it has to be done on every row? Is it a sacrifice I have to make, or do I have better alternatives?</p>

<p>Any help is much appreciated.</p>
"
"<p>I am trying to make a small server in c++ which would simply echo anything it receives through an infiniband connection. I am also using the Sockets Direct Protocol and POSIX sockets under Ubuntu.</p>

<p>Unfortunately, the only advice i found on the internet was about how i should create the socket using AF_INET_SDP domain, just like here:</p>

<pre><code>#define AF_INET_SDP 27

int socketfd = socket(AF_INET_SDP, SOCK_STREAM, 0);
</code></pre>

<p>I manage to bind the socket, i call the listen(...) function but the server hangs when trying to accept connections, while on the client side i only receive a timeout when trying to connect.</p>

<p>I also have an older similar application written in Java (both the client and the server) which communicates through infiniband and it works properly.</p>

<p>Can someone give me an example of an application using infiniband or point me towards some sort of documentation which could help me?</p>

<p>Thanks.</p>
"
"<p>I need to build simple ksh/bash scrip or whatever on Linux t that know to count time from reference time</p>

<p>When I type the date command as the following:</p>

<pre><code>   date

   Wed Jul 17 18:13:27 IDT 2013
</code></pre>

<p>or</p>

<pre><code>   [root@linux /var/tmp]# current_time=` date `
   [root@linux /var/tmp]# echo $current_time

                          Wed Jul 17 18:21:51 IDT 2013
</code></pre>

<p>So I get here the current date .</p>

<p>What I need is to count for example 10 min from the current date ,</p>

<p>so after 10 min I will print the message</p>

<pre><code>     echo ?sorry 10 min was ended?
</code></pre>

<p>how to count time from the reference time ? </p>
"
"<p>I would like to print the current time and the time of 10 minutes ago, but I don't know how to generate a time_t of X minutes ago...</p>

<pre><code>#include &lt;time.h&gt;

time_t current_time;
time_t tenMinutesAgo;

current_time = time(NULL);
tenMinutesAgo = ???;

printf(""current time = %s, 10 minutes ago = %s\n"",ctime(current_time),ctime(tenMinutesAgo));
</code></pre>

<p>Any help would be much appreciated!</p>
"
"<p>here is sample program to get the month or year or time request from multiple client to server
in server program, here i am not able to send ""Fri Jan 11 11:59:51 2008""  the full string from buffer in server program to client.only Fri alone read in the client.</p>

<p><strong>SERVER program</strong></p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include&lt;sys/stat.h&gt;
#include&lt;time.h&gt;

int main(int argc,char **argv) {
    int len,ch=0;
    int sockfd,newfd;
    struct sockaddr_in servaddr,cliaddr;
    char str[1000];

    sockfd=socket(AF_INET,SOCK_STREAM,0);
    if(sockfd&lt;0)
        printf(""cannot create socket"");

    bzero(&amp;servaddr,sizeof(servaddr));

    servaddr.sin_family=AF_INET;
    servaddr.sin_addr.s_addr=INADDR_ANY;
    servaddr.sin_port=htons(7220);

    if(bind(sockfd,(struct sockaddr*)&amp;servaddr,sizeof(servaddr))&lt;0)
        printf(""Bind error"");

    listen(sockfd,5);

    len=sizeof(cliaddr);
    time_t current_time = time(NULL);
    struct tm* local_time = localtime(&amp;current_time);
    char *buff=asctime(local_time);
    int leng=sizeof(buff);

    //strcpy(buff,buff1);

    printf(""%d"",leng);
    printf(""%s"",buff);

    int n=0;

    while(1) {
        newfd=accept(sockfd,(struct sockaddr*)&amp;cliaddr,&amp;len);
        printf(""request from client%d"",n++);
        n=write(newfd,buff,sizeof(buff));
        //n=write(newfd,buff1+1,sizeof(buff1));
        printf(""message sent to client%d"",n);
    }

    close(newfd);
    close(sockfd);
}
</code></pre>

<p><strong>CLIENT program</strong></p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;string.h&gt;
#include&lt;stdlib.h&gt;

int main(int argc,char **argv) {
    int len;
    int sockfd,n;
    struct sockaddr_in servaddr,cliaddr;
    char str[7][100],st[3][100];
    int d,m,choice=0;
    char buff[1024],buff1[1024];

    sockfd=socket(AF_INET,SOCK_STREAM,0);
    bzero(&amp;servaddr,sizeof(servaddr));

    servaddr.sin_family=AF_INET;
    servaddr.sin_addr.s_addr=inet_addr(argv[1]);
    servaddr.sin_port=htons(7220);

    connect(sockfd,(struct sockaddr*)&amp;servaddr,sizeof(servaddr));

    bzero(&amp;buff,sizeof(buff));
    bzero(&amp;buff1,sizeof(buff1));

    n=read(sockfd,buff,sizeof(buff));

    printf(""hai"");

    puts(buff);

    //puts(buff1);
    /*strcpy(str[1],strtok(buff,"" ""));
    strcpy(str[2],strtok(NULL,"" ""));
    strcpy(str[0],strtok(NULL,"" ""));
    strcpy(str[4],strtok(NULL,"" ""));
    strcpy(str[3],strtok(NULL,"" ""));
    while(choice!=6) {
        printf(""\n\nMENU\n"");
        printf(""1.DATE\n"");
        printf(""2.DAY\n"");
        printf(""3.MONTH\n"");
        printf(""4.YEAR\n"");
        printf(""5.TIME\n"");
        printf(""6.EXIT\n"");
        printf(""ENTER CHOICE\n"");
        scanf(""%d"",&amp;choice);
        switch(choice) {
          case 1: printf(""date %s"",str[0]);
            break;
          case 2: printf(""day %s"",str[1]);
            break;
          case 3: printf(""month %s"",str[2]);
            break;
          case 4: printf(""year %s"",str[3]);
            break;
          case 5: printf(""time %s"",str[4]);
            break;
        }
    }*/

    close(sockfd);
    return 0;
}
</code></pre>
"
"<p>I have a program that records data from a serial port. Every so often, I want to split up files such that the data logs don't become very large. The problem is, after I recreate the FILE* and try to write into it, the program crashes. No compiler errors/warnings before hand also...</p>

<p>The program does create one log for the first time interval, but once it's time to create a new data log, it crashes at the fwrite.</p>

<p>First off, initializations/declarations.</p>

<pre><code>char * DATA_DIR = ""C:\DATA"";
sprintf(path,""%s%s%s"",DATA_DIR,curtime,"".log""); //curtime is just the current time in a string
FILE * DATA_LOG = fopen(path, ""wb+"");
</code></pre>

<p>And later on in a while loop</p>

<pre><code>if(((CURRENT_TIME-PREVIOUS_TIME) &gt; (SEC_IN_MINUTE * MINUTE_CHUNKS) ) &amp;&amp; (MINUTE_CHUNKS != 0) &amp;&amp; FIRST_TIME == 0) //all this does is just checks if its time to make a new file
{
    fclose(DATA_LOG); //end the current fileread

    char * path;
    char curtime[16];

    //gets the current time and saves it to a file name
    sprintf(curtime , ""%s"" , currentDateTime());
    sprintf(path,""%s%s%s"",DATA_DIR,curtime,"".log"");

    DATA_LOG = fopen(path, ""wb+""); //open the new file

    //just some logic (not relevant to problem)
    PREVIOUS_TIME = CURRENT_TIME;
    newDirFlag = 1;
}
fwrite(cdata , sizeof(char) , numChars , DATA_LOG); //crashes here. cdata, sizeof, and numChars don't change values
</code></pre>

<p>Any ideas why is this happening? I'm stumped.</p>
"
"<p>I have seen this <a href=""http://en.wikipedia.org/wiki/C_date_and_time_functions"" rel=""nofollow noreferrer"">example</a>:</p>

<pre><code>#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    time_t current_time;
    char* c_time_string;

    /* Obtain current time as seconds elapsed since the Epoch. */
    current_time = time(NULL);
</code></pre>

<p>however while debugging in eclipse I see in the <code>watch</code> area:</p>

<p><code>time(NULL)    error evaluating</code> </p>

<p>even though I have</p>

<p><code>#include &lt;time.h&gt;</code></p>

<p>how can I fix this?</p>

<p><img src=""https://i.stack.imgur.com/0FtLW.png"" alt=""enter image description here""></p>
"
"<p>I?ve searching ways to calculate the speed of an android device. I found something, but even though I couldn?t solve it.</p>

<p>I?m applying the formule V = Vo + a*t to calculate the speed, and using the TYPE_LINEAR_ACCELEROMETER. Nonetheless I don?t get coherent results I don?t know why.
If i move the device toward the right the axis X dont grow up, and if i do toward the left, it doesn?t neither. Idem for up and down. Even when it?s stopped there are variations (not g!!, but others).</p>

<p>Here it?s my code commented. If someone can help I'd be thankful =)</p>

<pre><code>public class MainActivity extends Activity implements SensorEventListener, OnClickListener {

    TextView txtGravity,txtMax;
    Button btnStart;

    private long previousMarkTime;
    private Vector currentSpeed;

    private Boolean measure;

    private SensorManager mSensorManager;
    private Sensor mSensor;


    @SuppressLint(""InlinedApi"")
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        measure = false;

        txtGravity = (TextView)findViewById(R.id.textView1);
        txtMax = (TextView)findViewById(R.id.textView2);

        btnStart = (Button)findViewById(R.id.button1);
        btnStart.setOnClickListener(this);

        mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
        mSensor = mSensorManager.getDefaultSensor(Sensor.TYPE_LINEAR_ACCELERATION);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }

    @Override
    public void onAccuracyChanged(Sensor arg0, int arg1) {
        // TODO Auto-generated method stub

    }

    @Override
    public void onSensorChanged(SensorEvent a) {
        if(previousMarkTime==0){
                        // I get the first time
            previousMarkTime = System.currentTimeMillis();
            return;
        }

        long current_time= System.currentTimeMillis();

        // Here I calculate the diference between now and the previous time
        long t = current_time- previousMarkTime;

        // I create a vector to store the acceleration
        Vector aceleracionPorT = new Vector(a.values[0], a.values[1], a.values[2]);
        double t_f = (float)t;

        // This is   a*t
        aceleracionPorT.doMultiplyScalar(t_f/1000);

        // and this is    Vo + a*t
        currentSpeed.sum(aceleracionPorT);


        previousMarkTime = t_actual;

        // I show the results
        txtGravity.setText(currentSpeed.toString(""0.000"") + ""\n""+
                           aceleracionPorT.toString(""0.000""));

    }
    @Override
      protected void onResume() {
        super.onResume();
      }

      @Override
      protected void onPause() {
        super.onPause();
        measure = false;
        mSensorManager.unregisterListener(this);
      }

    @Override
    public void onClick(View id) {
        if(id==btnStart){
            measure = !measure;
            if(measure) {
                mSensorManager.registerListener(this, mSensor, SensorManager.SENSOR_DELAY_FASTEST);
                currentSpeed = new Vector(0,0,0);
                previousMarkTime = 0;
            }
            else txtGravity.setText("""");
        }
    }
}
</code></pre>
"
"<p>I know I can use <code>date +%s</code> and <code>stat</code> in Linux system.</p>

<p>But as Solaris does not support those format or command for epoch,
how can I create a shellscript to compare file modification time and current time ?</p>

<p>modification file time should be within 10 min comparing to current time.</p>

<pre><code>[ShellScript]

Current_Time=
Modification_Time=

Compare = Current_Time - Modification_time

if [""$Compare"" -gt 600]; then
Echo ""there is no find found within 10 min""
else
Echo ""Found the file""
if
</code></pre>
"
"<p>I need to solve the producer-consumer problem requiring a single process solution using threads within a process. The main routine of the single process should setup and initialize the required ring buffers and control variables in global memory where they can be seen by all other threads of the process. The main routine will then begin creating some number of producer threads and some number of consumer threads. </p>

<p>I did a lot of research on the internet and was able to code some of it. However, it doesn't seem to be working right and I'm getting deadlocks for all the values. Can someone please help me out?</p>

<p>My header file:</p>

<pre><code>    #include &lt;sys/signal.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/signal.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

#define         NUMFLAVORS          4
#define         NUMSLOTS            400
#define         NUMCONSUMERS        50
#define     NUMPRODUCERS        30
#define       NoOfDozens        200

struct  DONUT_SHOP {
    int         flavor [NUMFLAVORS] [NUMSLOTS];
    int         outptr [NUMFLAVORS];
    int     in_ptr [NUMFLAVORS];
    int     serial [NUMFLAVORS];
};
</code></pre>

<p>My program:</p>

<pre><code>    void    *sig_waiter ( void *arg );
    void    *producer   ( void *arg );
    void    *consumer ( void *arg) ;
    void    sig_handler ( int );



/****************************/
/*      GLOBAL VARIABLES    */
/****************************/

#include ""ml_pc.h""

    struct DONUT_SHOP   shared_ring;
    int         space_count [NUMFLAVORS];
    int         donut_count [NUMFLAVORS];
    int         serial [NUMFLAVORS];
    pthread_mutex_t     prod [NUMFLAVORS];
    pthread_mutex_t     cons [NUMFLAVORS];
    pthread_cond_t      prod_cond [NUMFLAVORS];
    pthread_cond_t      cons_cond [NUMFLAVORS];
    pthread_t       thread_id [NUMCONSUMERS+1], sig_wait_id;


int  main ( int argc, char *argv[] )
{
    int         i, j, k, nsigs;
    struct timeval      randtime, first_time, last_time;
    struct sigaction    new_act;
    int         arg_array[NUMCONSUMERS];
    sigset_t        all_signals;
    int sigs[]      = { SIGBUS, SIGSEGV, SIGFPE };
    pthread_attr_t      thread_attr;
    struct sched_param  sched_struct;






/**********************************************************************/
/* INITIAL TIMESTAMP VALUE FOR PERFORMANCE MEASURE                    */
/**********************************************************************/

        gettimeofday (&amp;first_time, (struct timezone *) 0 );


        for ( i = 0; i &lt; NUMCONSUMERS + 1 ; i++ ) {
            arg_array [i] = i+1;    /** SET ARRAY OF ARGUMENT VALUES **/
        }

/**********************************************************************/
/* GENERAL PTHREAD MUTEX AND CONDITION INIT AND GLOBAL INIT           */
/**********************************************************************/

    for ( i = 0; i &lt; NUMFLAVORS; i++ ) {
        pthread_mutex_init ( &amp;prod [i], NULL );
        pthread_mutex_init ( &amp;cons [i], NULL );
        pthread_cond_init ( &amp;prod_cond [i],  NULL );
        pthread_cond_init ( &amp;cons_cond [i],  NULL );
        shared_ring.outptr [i]      = 0;
        shared_ring.in_ptr [i]      = 0;
        shared_ring.serial [i]      = 0;
        space_count [i]         = NUMSLOTS;
        donut_count [i]         = 0;
    }



/**********************************************************************/
/* SETUP FOR MANAGING THE SIGTERM SIGNAL, BLOCK ALL SIGNALS           */
/**********************************************************************/

    sigfillset (&amp;all_signals );
    nsigs = sizeof ( sigs ) / sizeof ( int );
    for ( i = 0; i &lt; nsigs; i++ ){
            sigdelset ( &amp;all_signals, sigs [i] );
        }
    sigprocmask ( SIG_BLOCK, &amp;all_signals, NULL );
    sigfillset (&amp;all_signals );
    for( i = 0; i &lt;  nsigs; i++ ) {
            new_act.sa_handler  = sig_handler;
            new_act.sa_mask     = all_signals;
            new_act.sa_flags    = 0;
            if ( sigaction ( sigs[i], &amp;new_act, NULL ) == -1 ){
                    perror(""can't set signals: "");
                    exit(1);
            }
    }

    printf ( ""just before threads created\n"" );


/*********************************************************************/
/* CREATE SIGNAL HANDLER THREAD, PRODUCER AND CONSUMERS              */
/*********************************************************************/

        if ( pthread_create (&amp;sig_wait_id, NULL,
                    sig_waiter, NULL) != 0 ){

                printf ( ""pthread_create failed "" );
                exit ( 3 );
        }

       pthread_attr_init ( &amp;thread_attr );
       pthread_attr_setinheritsched ( &amp;thread_attr,
        PTHREAD_INHERIT_SCHED );

        #ifdef  GLOBAL

        sched_struct.sched_priority = sched_get_priority_max(SCHED_OTHER);
        pthread_attr_setinheritsched ( &amp;thread_attr,
        PTHREAD_EXPLICIT_SCHED );
        pthread_attr_setschedpolicy ( &amp;thread_attr, SCHED_OTHER );
        pthread_attr_setschedparam ( &amp;thread_attr, &amp;sched_struct );
        pthread_attr_setscope ( &amp;thread_attr,
        PTHREAD_SCOPE_SYSTEM );
         #endif

    if ( pthread_create (&amp;thread_id[0], &amp;thread_attr,
                        producer, NULL ) != 0 ) {
        printf ( ""pthread_create failed "" );
        exit ( 3 );
    }

    for ( i = NUMPRODUCERS; i &lt; NUMCONSUMERS + 1; i++ ) {
        if ( pthread_create ( &amp;thread_id [i], &amp;thread_attr,
                consumer, ( void * )&amp;arg_array [i]) != 0 ){
            printf ( ""pthread_create failed"" );
            exit ( 3 );
        }
    }

    printf ( ""just after threads created\n"" );

/*********************************************************************/
/* WAIT FOR ALL CONSUMERS TO FINISH, SIGNAL WAITER WILL              */
/* NOT FINISH UNLESS A SIGTERM ARRIVES AND WILL THEN EXIT            */
/* THE ENTIRE PROCESS....OTHERWISE MAIN THREAD WILL EXIT             */
/* THE PROCESS WHEN ALL CONSUMERS ARE FINISHED                       */
/*********************************************************************/

    for ( i = 1; i &lt; NUMCONSUMERS + 1; i++ ) {
                    pthread_join ( thread_id [i], NULL );
    }

/*****************************************************************/
/* GET FINAL TIMESTAMP, CALCULATE ELAPSED SEC AND USEC           */
/*****************************************************************/


    gettimeofday (&amp;last_time, ( struct timezone * ) 0 );
            if ( ( i = last_time.tv_sec - first_time.tv_sec) == 0 )
            j = last_time.tv_usec - first_time.tv_usec;
            else{
            if ( last_time.tv_usec - first_time.tv_usec &lt; 0 ) {
                i--;
                j = 1000000 +
                   ( last_time.tv_usec - first_time.tv_usec );
                } else {
                j = last_time.tv_usec - first_time.tv_usec; }
                   }
    printf ( ""Elapsed consumer time is %d sec and %d usec\n"", i, j );

    printf ( ""\n\n ALL CONSUMERS FINISHED, KILLING  PROCESS\n\n"" );
    exit ( 0 );
}

/*********************************************/
/* INITIAL PART OF PRODUCER.....             */
/*********************************************/

void    *producer ( void *arg )
{
    int     i, j, k;
    int         rand_donuts;
    unsigned short  xsub1 [3];
    struct timeval  randtime;
    int threadid = pthread_self ( );
    FILE *prod_file ;
    char prod_id[10];
    char prod_filename[20]=""prod_"";
    gettimeofday ( &amp;randtime, ( struct timezone * ) 0 );
    xsub1 [0] = ( unsigned short     )randtime.tv_usec;
    xsub1 [1] = ( unsigned short     ) ( randtime.tv_usec &gt;&gt; 16 );
    xsub1 [2] = ( unsigned short     ) ( pthread_self );

    while ( 1 )
    {
      rand_donuts = nrand48 ( xsub1 ) &amp; 3;

      pthread_mutex_lock ( &amp;prod [rand_donuts] );

      /** check if there is space available to produce donuts **/

    while ( space_count [rand_donuts] == 0 )
    {
                pthread_cond_wait ( &amp;prod_cond [rand_donuts], &amp;prod [rand_donuts] );
        }


    serial[rand_donuts] ++;

    fprintf(prod_file,""thread %d is producing donuts of type :%d , serial number of donut: %d \n"",threadid,rand_donuts,serial[rand_donuts]);

    shared_ring.flavor[rand_donuts][shared_ring.in_ptr[rand_donuts]]=serial[rand_donuts];

    /** Increment in_ptr modulo NUMSLOTS **/
    shared_ring.in_ptr[rand_donuts] = (shared_ring.in_ptr[rand_donuts]+1) % NUMSLOTS ;

    /** Decrement the space count **/
    space_count [rand_donuts] --;

        pthread_mutex_unlock ( &amp;prod [rand_donuts] );

    /* get cons mutex */
    /* inc donut count */
    /* unlock cons mutex */
    /* signal cons_condx_var */

    pthread_mutex_lock(&amp;cons [rand_donuts]);

    donut_count [rand_donuts]++;

    pthread_mutex_unlock(&amp;cons [rand_donuts]);

    pthread_cond_signal(&amp;cons_cond[rand_donuts]);

    usleep(10000);
    }
    fclose(prod_file);
    return NULL;
}



/*********************************************/
/* Consumer Code ,starts here    */
/*********************************************/



void    *consumer ( void *arg )
{
    int     i, j, k, m, id ,rand_donuts,outptr,numofdonut;
    unsigned short  xsub [3];
    struct timeval  randtime;

    int printresult;
    int     serial [NUMFLAVORS];
    int collection [NUMFLAVORS][12];
    FILE *cons_file;
    char fileid[10];
    char cons_filename[10]=""cons_"";


    time_t current_time;
    id = *( int * ) arg;

     sprintf(fileid, ""%d"", id) ;
     strcat(cons_filename,fileid);



    gettimeofday ( &amp;randtime, ( struct timezone * ) 0 );
    xsub [0] = ( unsigned short )randtime.tv_usec;
    xsub [1] = ( unsigned short ) ( randtime.tv_usec &gt;&gt; 16 );
    xsub [2] = ( unsigned short ) ( pthread_self );



    if ((cons_file = fopen(cons_filename, ""a+"")) == NULL)
           fprintf(stderr, ""Cannot open %s\n"", ""cons_file"");

    for( i = 0; i &lt; 10; i++ )
    {


        for( k = 0; k &lt; NUMFLAVORS; k++)
        {
                    for( m = 0; m &lt; 12; m++)
            {
                    collection[k][m] = -1;
}

        }



        for(k = 0; k &lt; NUMFLAVORS; k++)
        {
            serial [k] = 0;
        }


        for( m = 0; m &lt; 12; m++ )
        {

            rand_donuts = nrand48( xsub ) &amp; 3;


        /*******************************************************
        get cons mutex
        check donut count
        loop:
        if donut count == 0
        wait cons_condx_var
        *******************************************************/

            pthread_mutex_lock ( &amp;cons [rand_donuts] );
            while ( donut_count [rand_donuts] == 0 )
            {
                pthread_cond_wait ( &amp;cons_cond [rand_donuts], &amp;cons [rand_donuts] );
            }

        /************************************************
            Consume donut
        ************************************************/




            outptr = shared_ring.outptr[rand_donuts];
            numofdonut = shared_ring.flavor[rand_donuts][outptr];
            collection[rand_donuts][serial[rand_donuts]]=numofdonut ;
            serial[rand_donuts] ++;

            outptr ++;
            shared_ring.outptr[rand_donuts] = outptr % NUMSLOTS;

            donut_count [rand_donuts] --;



            pthread_mutex_unlock ( &amp;cons [rand_donuts] );



            /* lock producer mutex */
            pthread_mutex_lock(&amp;prod [rand_donuts]);

            /*increment the space count*/
            space_count [rand_donuts] ++;

            /* unlock producer mutex */
            pthread_mutex_unlock(&amp;prod [rand_donuts]);

            //signal the producer
            pthread_cond_signal(&amp;prod_cond[rand_donuts]);

            }




                current_time=time(NULL);
            fprintf(cons_file,""Consumer %d finished collecting dozen#: %d  \n"",id,i);
            fprintf(cons_file,""Consumer thread#: %d , time: %s, Dozen#: %d"",id,asctime(localtime(&amp;current_time)),i);
            fprintf(cons_file,""\t plain \t jelly \t coconut \t honey-dip \t"");
            fprintf(cons_file,""\n"");

            printresult=0;
for (i = 1; i &lt; NoOfDozens; i++)
{
            for( m = 0; m &lt; 12  &amp;&amp; printresult &lt;=3 ; m++)
            {
                printresult = 0;
                for(k = 0; k &lt; NUMFLAVORS ; k++)
                {
                    if(collection[k][m] &gt;= 0)
                    {
                        fprintf(cons_file,""\t %d \t"",collection[k][m]);
                        printresult = 0;
                    }
                    else
                    {
                        fprintf(cons_file,""\t   \t"");
                        printresult =printresult+1;
                    }

                }
                fprintf(cons_file,""\n"");
            }

}


/*Sleeping*/

    fflush(cons_file);
         usleep(1000); /* sleep 1 ms */
         }


        fprintf(cons_file,""Consumer %d finished  collecting all 10 dozen donuts  \n"",id);
        fclose(cons_file);
         return NULL;
}

/***********************************************************/
/* PTHREAD ASYNCH SIGNAL HANDLER ROUTINE...                */
/***********************************************************/

void    *sig_waiter ( void *arg )
{
    sigset_t    sigterm_signal;
    int     signo;

    sigemptyset ( &amp;sigterm_signal );
    sigaddset ( &amp;sigterm_signal, SIGTERM );
    sigaddset ( &amp;sigterm_signal, SIGINT );

    if (sigwait ( &amp;sigterm_signal, &amp; signo)  != 0 ) {
        printf ( ""\n  sigwait ( ) failed, exiting \n"");
        exit(2);
    }
    printf ( ""process going down on SIGNAL (number %d)\n\n"", signo );
    exit ( 1 );
    return NULL;
}


/**********************************************************/
/* PTHREAD SYNCH SIGNAL HANDLER ROUTINE...                */
/**********************************************************/

void    sig_handler ( int sig )
{
    pthread_t   signaled_thread_id;
    int     i, thread_index;

    signaled_thread_id = pthread_self ( );
    for ( i = 0; i &lt; (NUMCONSUMERS + NUMPRODUCERS ); i++) {
        if ( signaled_thread_id == thread_id [i] )  {
                thread_index = i;
                break;
        }
    }
    printf ( ""\nThread %d took signal # %d, PROCESS HALT\n"",
                thread_index, sig );
    exit ( 1 );
}
</code></pre>

<p>Can someone please tell me where I'm going wrong and what changes I need to make?? Thanks in advance!!</p>
"
"<p>In the following lines of code, I am taking a request line (<code>GET</code> or <code>HEAD &lt;filename&gt; HTTP/1.0</code>), and get the information about the file.</p>

<p>This is working correctly for html/text files and image/gif files.</p>

<p>However, when I put a directory in , the program tells it is a socket, or unknown, while it is supposed to tell it is a directory.</p>

<p>It is strange because I copied the code from UNIX <code>man</code> example, and the example code in <code>man</code> recognizes the directory when I put directory as the argument.</p>

<p>Only difference is that my program takes the file(or directory) name during execution from the user input(client-server), while the UNIX program takes the name from the command line argument.</p>

<p>What is the problem?</p>

<pre><code>class request {
    vector&lt;string&gt; requests;
    string message;
    bool valid, isGET, isHEAD;
    public:


    explicit request(char line[]): requests(split_string(line)), valid(true) {

        struct stat sb;
        if(stat(requests[1].c_str(), &amp;sb) == -1) {
            cerr &lt;&lt; ""Usage: GET or HEAD (filename) HTTP/1.0"" &lt;&lt; endl;
            valid = false;
            exit(EXIT_FAILURE);
        }

        string cont_type = ""Content-Type: "";

        switch (sb.st_mode &amp; S_IFMT) {
            case S_IFBLK:  printf(""block device\n"");            break;
            case S_IFCHR:  printf(""character device\n"");        break;
            case S_IFDIR:  cont_type += ""directory\n""; cout &lt;&lt; ""DIRECTORY"" &lt;&lt;endl;          break;
            case S_IFIFO:  printf(""FIFO/pipe\n"");               break;
            case S_IFLNK:  printf(""symlink\n"");                 break;
            case S_IFREG:  {
                string ext = requests[1].substr(requests[1].size()-6, 6);
                if(ext.find("".html"") != string::npos || ext.find("".txt"") != string::npos) {cont_type += ""text/html file\n"";}
                else if(ext.find("".jpg"") != string::npos || ext.find("".jpeg"") != string::npos || ext.find("".gif"") != string::npos || ext.find("".png"") != string::npos) {cont_type += ""image/gif file\n"";}
                else {cont_type += ""regular file\n"";}
                                                                break;
            }
            case S_IFSOCK: printf(""socket\n"");                  break;
            default:       printf(""unknown?\n"");                break;
        }
    }
</code></pre>

<p>Just in case I add the whole code, which is a server that can be connected using <code>telnet localhost 8080</code>:</p>

<pre><code>#define BUF_LEN 8192

#include&lt;queue&gt;
#include&lt;sstream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
 extern ""C"" {
#include&lt;sys/types.h&gt;
#include&lt;sys/stat.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netdb.h&gt;
#include&lt;unistd.h&gt;
#include&lt;stdio.h&gt;
#include&lt;sys/time.h&gt;
}

using std::vector;
using std::string;
using std::cerr;
using std::cout;
using std::endl;
using std::stringstream;
using std::queue;
using std::priority_queue;

char* time_stamp();

class request {
    vector&lt;string&gt; requests;
    string message;
    off_t filesize;
    bool valid, isGET, isHEAD;
    public:
    request() : valid(true) {}

    explicit request(char line[]): requests(split_string(line)), valid(true) {
        if(requests[0] == ""GET"") isGET = true;
        else if(requests[0] == ""HEAD"") isHEAD = true;
        else {
            cerr &lt;&lt; ""Usage: GET or HEAD (filename) HTTP/1.0"" &lt;&lt; endl;
        }

        //chdir();

        struct stat sb;
        if(stat(requests[1].c_str(), &amp;sb) == -1) {
            cerr &lt;&lt; ""Usage: GET or HEAD (filename) HTTP/1.0"" &lt;&lt; endl;
            valid = false;
//            exit(EXIT_FAILURE);
        }

        filesize = sb.st_size;
        string lmstring(ctime(&amp;sb.st_mtime));
        string lm = ""Last-Modified: "" + lmstring;

        string cont_type = ""Content-Type: "";

        switch (sb.st_mode &amp; S_IFMT) {
            case S_IFBLK:  cout &lt;&lt; ""block device"" &lt;&lt; endl;       break;
            case S_IFCHR:  cout &lt;&lt; ""character device"" &lt;&lt; endl;   break;
            case S_IFDIR:  cont_type += ""directory\n""; cout &lt;&lt; ""DIRECTORY"" &lt;&lt;endl;          break;
            case S_IFIFO:  cout &lt;&lt; ""FIFO/pipe"" &lt;&lt; endl;          break;
            case S_IFLNK:  cout &lt;&lt; ""symlink"" &lt;&lt; endl;            break;
            case S_IFREG:  {
                string ext = requests[1].substr(requests[1].size()-6, 6);
                if(ext.find("".html"") != string::npos || ext.find("".txt"") != string::npos) {cont_type += ""text/html file\n"";}
                else if(ext.find("".jpg"") != string::npos || ext.find("".jpeg"") != string::npos || ext.find("".gif"") != string::npos || ext.find("".png"") != string::npos) {cont_type += ""image/gif file\n"";}
                else {cont_type += ""regular file\n"";}
                                                                break;
            }
            case S_IFSOCK: cout &lt;&lt; ""socket"" &lt;&lt; endl;            break;
            default:       cout &lt;&lt; ""unknown?"" &lt;&lt; endl;          break;
        }

        stringstream cl_ss;
        cl_ss &lt;&lt; ""Content-Length: "" &lt;&lt; sb.st_size &lt;&lt; '\n';
        string cont_len = cl_ss.str();
        message = lm + cont_type + cont_len;

        FILE * pFile;
        long lSize;
        char * buffer;
        size_t result;
/*
        if(isGET) {
            pFile = fopen ( requests[1].c_str() , ""r"" );
            if (pFile==NULL) {fputs (""File error"",stderr); exit (1);}

            // obtain file size:
            fseek (pFile , 0 , SEEK_END);
            lSize = ftell (pFile);
            rewind (pFile);

            // allocate memory to contain the whole file:
            buffer = (char*) malloc (sizeof(char)*lSize);
            if (buffer == NULL) {fputs (""Memory error"",stderr); exit (2);}

            // copy the file into the buffer:
            result = fread (buffer,1,lSize,pFile);
            if (result != lSize) {fputs (""Reading error"",stderr); exit (3);}

            // the whole file is now loaded in the memory buffer.

            // terminate
            fclose (pFile);
            free (buffer);
        }
        cout &lt;&lt; buffer &lt;&lt; endl;*/
    }

    bool operator&lt;(const request&amp; rhs) const{
        return filesize &lt; rhs.filesize;
    }

    string getMessage() const {
        return this-&gt;message;
    }

    vector&lt;string&gt; split_string(char line[]) {
        vector&lt;string&gt; vec_str;
        char* token;
        token = strtok(line, "" "");

        while (token != NULL) {
            string temp_str(token);
            vec_str.push_back(temp_str);
            token = strtok(NULL, "" "");
        }
        return vec_str;
    }
};

int main() {

    int status;
    struct addrinfo host_info; // The struct that getaddrinfo() fills up with data.
    struct addrinfo *host_info_list; // Pointer to the linked list of host_info's.

    // The MAN page of getaddrinfo() states ""All the other fields in the structure pointed
    // to by hints must contain either 0 or a null pointer, as appropriate."" When a struct
    // is created in C++, it will be given a block of memory. This memory is not necessarily
    // empty. Therefore we use the memset function to make sure all fields are NULL.
    memset(&amp;host_info, 0, sizeof host_info);

    std::cout &lt;&lt; ""Setting up the structs..."" &lt;&lt; std::endl;

    host_info.ai_family = AF_UNSPEC;     // IP version not specified. Can be both.
    host_info.ai_socktype = SOCK_STREAM; // Use SOCK_STREAM for TCP or SOCK_DGRAM for UDP.
    host_info.ai_flags = AI_PASSIVE;     // IP Wildcard

    // Now fill up the linked list of host_info struts with ???????????????
    status = getaddrinfo(NULL, ""8080"", &amp;host_info, &amp;host_info_list);

    // getaddrinfo returns 0 on success, or some other value when an error occurred.

    if (status != 0) std::cout &lt;&lt; ""getaddrinfo error"" &lt;&lt; gai_strerror(status);

    std::cout &lt;&lt; ""Creating a socket..."" &lt;&lt; std::endl;
    int socketfd; // The socket descripter
    socketfd = socket(host_info_list-&gt;ai_family, host_info_list-&gt;ai_socktype, host_info_list-&gt;ai_protocol);

    if(socketfd == -1)  std::cout &lt;&lt; ""socket error "" &lt;&lt; std::endl;

    std::cout &lt;&lt; ""Binding socket..."" &lt;&lt; std::endl;

    // we use to make the setsockopt() function to make sure the port is not in use
    // by a previous execution of our code.

    int yes = 1;
    status = setsockopt(socketfd, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));
    status = bind(socketfd, host_info_list-&gt;ai_addr, host_info_list-&gt;ai_addrlen);
    if (status == -1)  std::cout &lt;&lt; ""bind error"" &lt;&lt; std::endl;

    std::cout &lt;&lt; ""Listen()ing for connections..."" &lt;&lt; std::endl;
    status = listen(socketfd, 5);
    if (status == -1)  std::cout &lt;&lt; ""listen error"" &lt;&lt; std::endl;

    int new_sd;
    struct sockaddr_storage their_addr;
    socklen_t addr_size = sizeof(their_addr);
    new_sd = accept(socketfd, (struct sockaddr *)&amp;their_addr, &amp;addr_size);

    if (new_sd == -1) {
        std::cout &lt;&lt; ""listen error"" &lt;&lt; std::endl;
    }
    else {
        std::cout &lt;&lt; ""Connection accepted. Using new socketfd : "" &lt;&lt; new_sd &lt;&lt; std::endl;
    }





    // after success on listen()ing, loop waiting
    int done;
    ssize_t bytes_received;
    char buf[BUF_LEN];
    fd_set ready;

    while (!done) {

/* fd_set contains the following fields:

 typedef struct fd_set {
        u_int   fd_count;               //how many are SET?
        SOCKET  fd_array[FD_SETSIZE];   //an array of SOCKETs
} fd_set;
*/


    FD_ZERO(&amp;ready);
    FD_SET(new_sd, &amp;ready);
    FD_SET(fileno(stdin), &amp;ready);

    if (select((new_sd + 1), &amp;ready, 0, 0, 0) &lt; 0) {
        cerr &lt;&lt; ""Error from select"" &lt;&lt; endl;
        std::exit(1);
    }

    if (FD_ISSET(fileno(stdin), &amp;ready)) {
        if((bytes_received = read(fileno(stdin), buf, BUF_LEN)) &lt;= 0)
            done++;
        send(new_sd, buf, bytes_received, 0);
    }

    std::cout &lt;&lt; ""Waiting to receive data..."" &lt;&lt; std::endl;
    bytes_received = recv(new_sd, buf, BUF_LEN, 0); // recv or recvfrom???

    // If no data arrives, the program will just wait here until some data arrives.

    if (bytes_received == 0) std::cout &lt;&lt; ""host shut down."" &lt;&lt; std::endl;
    if (bytes_received == -1) std::cout &lt;&lt; ""receive error!"" &lt;&lt; std::endl;
    std::cout &lt;&lt; bytes_received &lt;&lt; "" bytes received: "" &lt;&lt; std::endl;
    buf[bytes_received] = '\0';
    std::cout &lt;&lt; ""elements of 'buf'"" &lt;&lt; buf &lt;&lt; std::endl;


    std::cout &lt;&lt; ""Send()ing back a message..."" &lt;&lt; std::endl;

    request tobeadded(buf);
    request rq;
    if(true) {
        queue&lt;request&gt; qr;
        qr.push(tobeadded);
        rq = qr.front();
        qr.pop();
    }
    else {
        priority_queue&lt;request&gt; pqr;
        pqr.push(tobeadded);
        rq = pqr.top();
        pqr.pop();
    }

    string timeheader = ""Time: "";
    const char* t_h = timeheader.c_str();
    char* timestamp = time_stamp();
    string server = ""Server: myhttp\n"";
    const char* serv = server.c_str();

    const char* lm_ct_cl = rq.getMessage().c_str();

    char *msg = new char[strlen(t_h) + strlen(timestamp) + strlen(serv) + strlen(lm_ct_cl) + 1];

    *msg = '\0';
    strcat(msg, t_h);
    strcat(msg, timestamp);
    strcat(msg, serv);
    strcat(msg, lm_ct_cl);

    int len;
    ssize_t bytes_sent;
    len = strlen(msg);
    bytes_sent = send(new_sd, msg, len, 0);

    //write(fileno(stdout), buf, bytes_received);
    }

    std::cout &lt;&lt; ""Stopping server..."" &lt;&lt; std::endl;
    freeaddrinfo(host_info_list);
    close(new_sd);
    close(socketfd);

return 0;
}

char* time_stamp() {
    time_t current_time;
    char* c_time_string;

    /* Obtain current time as seconds elapsed since the Epoch. */
    current_time = time(NULL);

    if (current_time == ((time_t)-1))
    {
        (void) fprintf(stderr, ""Failure to compute the current time."");
    }

    /* Convert to local time format. */
    c_time_string = asctime(gmtime(&amp;current_time));

    if (c_time_string == NULL)
    {
        (void) fprintf(stderr, ""Failure to convert the current time."");
    }

    c_time_string[strlen(c_time_string)-1] = ' ';

    return strcat(c_time_string, "" GMT\n"");
}
</code></pre>
"
"<p>I want to use the <code>select</code> function to work with different file descriptors. When the program  starts, it must start sending packets to other clients in accordance to an interval. My first question is how can I employ a timer in the main while loop without interrupting the while loop and the select function's functionality? That is because I need to take the user inputs while the timer is running.</p>

<p>The second question is that I don't now if I need to put the send function in my while loop. Do I need to write the send function as the program enters the while loop or I need to use it somewhere else?</p>

<p>Also, the program must detect the file descriptors that have not been active for a specific time. How can I detect which file descriptors have not been sending any packets to the server?</p>

<p>Below you can see the codes that I have written so far. Could you please help me fix it?
I have not employed any timer here yet. Also, the program is unable to detect which file descriptor has timed out.</p>

<pre><code>        FD_ZERO(&amp;masterfds);
        FD_SET(udp_con, &amp;masterfds);
        maxfds = udp_con;

        while(exit == false)
        { //Do I need to use the send function here?
            FD_ZERO(&amp;readfds);
            readfds = masterfds;

            selectFunc = select(maxfds+1, &amp;readfds, NULL, NULL, &amp;tv);
            if(selectFunc &lt; 0)
            {
                message(""error in select"");
                exit = true;
            }
            else if(selectFunc == 0)
            { //How can I detect which file descriptor is timed out?
                for(i = 0; i &lt;= maxfds; i++)
                {
                    if(FD_ISSET(i, &amp;readfds))
                    {
                        //Doesn't work
                        cout&lt;&lt;""The file descriptor ""&lt;&lt;i&lt;&lt;"" has timed out""&lt;&lt;endl;
                    }
                }
            }
            else
            { //The server has received something from a client

                for(i = 0; i &lt;= maxfds; i++)
                {

                }
            }
        }
</code></pre>
"
"<p><em>How do I best round down (i.e. ""floor"") the value of <code>now()</code> to the nearest hour?</em></p>

<p>This is in order to make the <a href=""http://dev.mysql.com/doc/refman/5.1/en/query-cache.html"" rel=""nofollow"">query cache</a> work efficiently with statements such as:</p>

<pre><code>SELECT SQL_CACHE * FROM table WHERE appointment_date &gt;= NOW()
</code></pre>
"
"<p>I'm trying to push Images created by OpenCV into the GStreamer-Pipeline in order to stream a video through the GStreamer-TCPServerSink.</p>

<p>My GStreamer-Pipeline looks as follows: <strong>AppSrc -> FFMpegColorSpace -> VP8Enc -> WebMMux -> TCPServerSink</strong>
The AppSrc is feed by creating OpenCV-Images and push them into Appsrc via <strong>gst_app_src_push_buffer</strong>.</p>

<p>I've written a little Testprogram called ""Sandbox"", that shows the Error that occurs in GStreamer, when the Program runs.</p>

<p>My Testsystem looks as follows:</p>

<ul>
<li>Gentoo</li>
<li>Kernel: 3.10.0-rc3</li>
<li>OpenCV: 2.4.5</li>
<li>GStreamer: 0.10.36</li>
</ul>

<h3>I want to understand why this Error occurs, what i'm doing wrong and how a working Solution might look like?</h3>

<p>I hope, that you can help me to solve the Problem.</p>

<p>I've set up a Mini-CMake Project containing the code the produces the Error. It consists of two Files, namely CMakeLists.txt and Sandbox.cpp. CMakeLists.txt is Configuration on howto build the Sandbox Program contained in Sandbox.cpp.
To build it just create a Directory e.g. ""Build"", change into it and start an Out-of-Source Build with:</p>

<pre><code>cmake ../
</code></pre>

<p>Now CMake creates all needed files, if you have the Dependencies installed, so you can just type:</p>

<pre><code>make
</code></pre>

<p>to build the Program.</p>

<pre><code>####################################################################################################
# Projectinformations
####################################################################################################
project( Sandbox CXX )
cmake_minimum_required( VERSION 2.8 )

####################################################################################################
# G++ Options
####################################################################################################
set( CMAKE_C_COMPILER ""gcc"" )
set( CMAKE_CXX_COMPILER ""g++"" )

set( CMAKE_CXX_FLAGS ""-g -O0 -std=c++11 -ggdb -Wall -W -Wunused-variable -Wunused-parameter -Wunused-function -Wunused -Woverloaded-virtual -Wwrite-strings --coverage"" )
set( CMAKE_C_FLAGS ${CMAKE_CXX_FLAGS} )

####################################################################################################
# Resolve Dependencies
####################################################################################################
set( Boost_DEBUG 1 )
set( Boost_USE_MULTITHREADED 1 )
find_package( Boost 1.53 REQUIRED system thread timer )

find_package( PkgConfig )
pkg_check_modules( GSTREAMER_0_10 gstreamer-0.10 )
pkg_check_modules( GSTREAMER_0_10_APP gstreamer-app-0.10 )
include_directories( ${GSTREAMER_0_10_INCLUDE_DIRS} )
include_directories( ${GSTREAMER_0_10_APP_INCLUDE_DIRS} )

find_package( OpenCV REQUIRED )

####################################################################################################
# Project
####################################################################################################
add_executable( Sandbox Sandbox.cpp )
</code></pre>

<p>The Program itself looks as follows:</p>

<pre><code>// Standard C++ Libraries
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

// Boost Libraries
#include &lt;boost/asio.hpp&gt;
#include &lt;boost/make_shared.hpp&gt;
#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;
#include &lt;boost/shared_ptr.hpp&gt;
#include &lt;boost/thread.hpp&gt;

// GStreamer
#include &lt;gstreamer-0.10/gst/gst.h&gt;
#include &lt;gstreamer-0.10/gst/gstelement.h&gt;
#include &lt;gstreamer-0.10/gst/gstpipeline.h&gt;
#include &lt;gstreamer-0.10/gst/gstutils.h&gt;
#include &lt;gstreamer-0.10/gst/app/gstappsrc.h&gt;

// OpenCV
// #include ""cv.h""
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;


GMainLoop *glib_MainLoop;
unsigned int heartbeat_Intervall; ///&lt; In Milliseconds
boost::shared_ptr&lt;boost::asio::deadline_timer&gt; heartbeat;

GstElement *source_OpenCV;
guint64 imagecounter;

void
GLib_MainLoop() {
    if( !g_main_loop_is_running( glib_MainLoop ) ) {
        std::cout &lt;&lt; ""Starting glib_MainLoop..."" &lt;&lt; std::endl;
        g_main_loop_run( glib_MainLoop );
        std::cout &lt;&lt; ""Starting glib_MainLoop stopped."" &lt;&lt; std::endl;
    }
};

/// Creates an Image with a red filled Circle and the current Time displayed in it.
cv::Mat
Create_Image() {
    cv::Size size = cv::Size( 640, 480 );
    cv::Mat image = cv::Mat::zeros( size, CV_8UC3 );
    cv::Point center = cv::Point( size.width / 2, size.height / 2 );
    int thickness = -1;
    int lineType = 8;

    cv::circle( image, center, size.width / 4.0, cv::Scalar( 0, 0, 255 ), thickness, lineType );

    std::stringstream current_Time;
    boost::posix_time::time_facet *facet = new boost::posix_time::time_facet( ""%Y.%m.%d %H:%M:%S.%f"" );
    current_Time.imbue( std::locale( current_Time.getloc(), facet ) );
    current_Time &lt;&lt; boost::posix_time::microsec_clock::universal_time();

    int font = cv::FONT_HERSHEY_SCRIPT_SIMPLEX;
    double fontsize = 1;
    int font_Thickness = 1;

    int baseline = 0;
    cv::Size textSize_01 = cv::getTextSize( current_Time.str(), font, fontsize, font_Thickness , &amp;baseline );
    baseline += font_Thickness;

    cv::Point textOrg_01( ( image.cols - textSize_01.width ) / 2, ( image.rows + textSize_01.height * 2 ) / 2 );
    cv::Scalar textcolour = cv::Scalar( 0, 255, 0 );
    cv::putText( image, current_Time.str(), textOrg_01, font, fontsize, textcolour , font_Thickness , 1 );

    return image;
}

/// Creates a Graph of the created Pipeline including the contained Elements. The environment variable ""GST_DEBUG_DUMP_DOT_DIR"" must be set, e.g to /tmp/ to actually create the Graph.
/// Furthermore GST_DEBUG needs to be activated, e.g. with ""GST_DEBUG=3"".
/// So ""GST_DEBUG=3 GST_DEBUG_DUMP_DOT_DIR=/tmp/"" ./Sandbox would work.
/// The .dot file can be converted to a e.g. svg-Graphic with the following command (Package GraphViz): dot -Tsvg -oPipelineGraph.svg PipelineGraph.dot
void
Create_PipelineGraph( GstElement *pipeline ) {
    bool debug_active = gst_debug_is_active();
    gst_debug_set_active( 1 );
    GST_DEBUG_BIN_TO_DOT_FILE( GST_BIN( pipeline ), GST_DEBUG_GRAPH_SHOW_ALL, ""PipelineGraph"" );
    gst_debug_set_active( debug_active );
}

void
Push_new_Image( const boost::system::error_code &amp;error ) {
    if( error != 0 ) {
        std::cout &lt;&lt; ""Error in Timer: "" &lt;&lt; error.message() &lt;&lt; std::endl;
        return;
    }

    cv::Mat image = Create_Image();

    /// OpenCV handles image in BGR, so to get RGB, Channels R and B needs to be swapped.
    cv::cvtColor( image, image, CV_CVTIMG_SWAP_RB );

    {
        /// How do i get the actual bpp and depth out of the cv::Mat?
        GstCaps *caps = gst_caps_new_simple( ""video/x-raw-rgb"", ""width"", G_TYPE_INT, image.cols, ""height"", G_TYPE_INT, image.rows, ""framerate"", GST_TYPE_FRACTION, 0, 1, NULL );
        g_object_set( G_OBJECT( source_OpenCV ), ""caps"", caps, NULL );
        gst_caps_unref( caps );

        IplImage* img = new IplImage( image );
        uchar *IMG_data = ( uchar* ) img-&gt;imageData;

        GstBuffer *buffer;
        {
            int bufferlength = image.cols * image.rows * image.channels();
            buffer = gst_buffer_new_and_alloc( bufferlength );

            /// Copy Data from OpenCV to GStreamer
            memcpy( GST_BUFFER_DATA( buffer ), IMG_data, GST_BUFFER_SIZE( buffer ) );

            GST_BUFFER_DURATION( buffer ) = gst_util_uint64_scale( bufferlength, GST_SECOND, 1 );
        }

        /// Setting the Metadata for the image to be pushed.
        {
            GstCaps *caps_Source = NULL;

            std::stringstream video_caps_text;
            video_caps_text &lt;&lt; ""video/x-raw-rgb,width=(int)"" &lt;&lt; image.cols &lt;&lt; "",height=(int)"" &lt;&lt; image.rows &lt;&lt; "",framerate=(fraction)0/1"";
            caps_Source = gst_caps_from_string( video_caps_text.str().c_str() );

            if( !GST_IS_CAPS( caps_Source ) ) {
                std::cout &lt;&lt; ""Error creating Caps for OpenCV-Source, exiting..."";
                exit( 1 );
            }

            gst_app_src_set_caps( GST_APP_SRC( source_OpenCV ), caps_Source );
            gst_buffer_set_caps( buffer, caps_Source );
            gst_caps_unref( caps_Source );
        }

        /// Setting a continues timestamp
        GST_BUFFER_TIMESTAMP( buffer ) = gst_util_uint64_scale( imagecounter * 20, GST_MSECOND, 1 );
        imagecounter += 1;

        /// Push Buffer into GStreamer-Pipeline
        GstFlowReturn rw;
        rw = gst_app_src_push_buffer( GST_APP_SRC( source_OpenCV ), buffer );

        if( rw != GST_FLOW_OK ) {
            std::cout &lt;&lt; ""Error push buffer to GStreamer-Pipeline, exiting..."";

            exit( 1 );
        } else {
            std::cout &lt;&lt; ""GST_FLOW_OK "" &lt;&lt; ""imagecounter: "" &lt;&lt; imagecounter &lt;&lt; std::endl;
        }

    }

    /// Renew the Heartbeat-Timer
    heartbeat-&gt;expires_from_now( boost::posix_time::milliseconds( heartbeat_Intervall ) );
    heartbeat-&gt;async_wait( Push_new_Image );
}

int
main( int argc, char **argv ) {
    std::cout &lt;&lt; ""Sandbox started."" &lt;&lt; std::endl;

    /// ####################
    /// Initialise Sandbox
    /// ####################
    boost::shared_ptr&lt;boost::asio::io_service&gt; io_service = boost::make_shared&lt;boost::asio::io_service&gt;();
    boost::shared_ptr&lt;boost::asio::io_service::work&gt; work = boost::make_shared&lt;boost::asio::io_service::work&gt;( *io_service );
    boost::shared_ptr&lt;boost::thread_group&gt; threadgroup = boost::make_shared&lt;boost::thread_group&gt;();

    /// io_service Callback for continuously feeding into the pipeline of GStreamer.
    /// I've using to push the Buffer into GStreamer as i come available instead of getting informed about an empty pipeline by GStreamer-Signals.
    heartbeat_Intervall = 1000; ///&lt; In Milliseconds
    heartbeat = boost::make_shared&lt;boost::asio::deadline_timer&gt;( ( *( io_service.get() ) ) );

    std::cout &lt;&lt; ""Initialise GStreamer..."" &lt;&lt; std::endl;
    gst_init( &amp;argc, &amp;argv );

    glib_MainLoop = g_main_loop_new( NULL, 0 );

    std::cout &lt;&lt; ""Start GLib_MainLoop..."" &lt;&lt; std::endl;
    io_service-&gt;post( GLib_MainLoop );

    /// Create some Workerthreads
    for( std::size_t i = 0; i &lt; 3; ++i )  {
        threadgroup-&gt;create_thread( boost::bind( &amp;boost::asio::io_service::run, &amp;( *io_service ) ) );
    }

    /// ####################
    /// Do the actual Work
    /// ####################
    GstElement *pipeline;
    GstElement *converter_FFMpegColorSpace;
    GstElement *converter_VP8_Encoder;
    GstElement *muxer_WebM;
    GstElement *sink_TCPServer;


    /// Create GStreamer Elements

    pipeline = gst_pipeline_new( ""OpenCV_to_TCPServer"" );

    if( !pipeline ) {
        std::cout &lt;&lt; ""Error creating Pipeline, exiting..."";
        return 1;
    }

    {
        source_OpenCV = gst_element_factory_make( ""appsrc"", ""Source_OpenCV"" );

        if( !source_OpenCV ) {
            std::cout &lt;&lt; ""Error creating OpenCV-Source, exiting..."";
            return 1;
        }

        gst_bin_add( GST_BIN( pipeline ), source_OpenCV );
    }

    {
        converter_FFMpegColorSpace = gst_element_factory_make( ""ffmpegcolorspace"", ""Converter_FFMpegColorSpace"" );

        if( !converter_FFMpegColorSpace ) {
            std::cout &lt;&lt; ""Error creating Converter_FFMpegColorSpace, exiting..."";
            return 1;
        }

        gst_bin_add( GST_BIN( pipeline ), converter_FFMpegColorSpace );
    }

    {
        converter_VP8_Encoder = gst_element_factory_make( ""vp8enc"", ""Converter_VP8_Encoder"" );

        if( !converter_VP8_Encoder ) {
            std::cout &lt;&lt; ""Error creating Converter_VP8_Encoder, exiting..."";
            return 1;
        }

        gst_bin_add( GST_BIN( pipeline ), converter_VP8_Encoder );
    }

    {
        muxer_WebM = gst_element_factory_make( ""webmmux"", ""Muxer_WebM"" );

        if( !muxer_WebM ) {
            std::cout &lt;&lt; ""Error creating Muxer_WebM, exiting..."";
            return 1;
        }

        gst_bin_add( GST_BIN( pipeline ), muxer_WebM );
    }

    {
        sink_TCPServer = gst_element_factory_make( ""tcpserversink"", ""Sink_TCPServer"" );

        if( !sink_TCPServer ) {
            std::cout &lt;&lt; ""Error creating Sink_TCPServer, exiting..."";
            return 1;
        }

        gst_bin_add( GST_BIN( pipeline ), sink_TCPServer );
    }


    /// Link GStreamer Elements

    if( !gst_element_link( source_OpenCV, converter_FFMpegColorSpace ) ) {
        std::cout &lt;&lt; ""Error linking creating source_OpenCV to converter_FFMpegColorSpace, exiting..."";
        return 2;
    }

    if( !gst_element_link( converter_FFMpegColorSpace, converter_VP8_Encoder ) ) {
        std::cout &lt;&lt; ""Error linking creating converter_FFMpegColorSpace to converter_VP8_Encoder, exiting..."";
        return 2;
    }

    if( !gst_element_link( converter_VP8_Encoder, muxer_WebM ) ) {
        std::cout &lt;&lt; ""Error linking creating converter_VP8_Encoder to muxer_WebM, exiting..."";
        return 2;
    }

    if( !gst_element_link( muxer_WebM, sink_TCPServer ) ) {
        std::cout &lt;&lt; ""Error linking creating muxer_WebM to sink_TCPServer, exiting..."";
        return 2;
    }


    /// Set State of the GStreamer Pipeline to Playing
    GstStateChangeReturn ret = gst_element_set_state( pipeline, GST_STATE_PLAYING );

    if( ret == GST_STATE_CHANGE_FAILURE ) {
        std::cout &lt;&lt; ""Error setting GStreamer-Pipeline to playing."";
        return 2;
    }

    Create_PipelineGraph( pipeline );


    /// Start the Heartbeat, that continously creates new Images
    heartbeat-&gt;expires_from_now( boost::posix_time::milliseconds( heartbeat_Intervall ) );
    heartbeat-&gt;async_wait( Push_new_Image );

    /// ####################
    /// Shutdown the Sandbox
    /// ####################
    std::cout &lt;&lt; ""Wait some Seconds before joining all Threads and shutdown the Sandbox..."" &lt;&lt; std::endl;
    boost::this_thread::sleep( boost::posix_time::seconds( 4 ) );

    std::cout &lt;&lt; ""Shutdown Sandbox..."" &lt;&lt; std::endl;
    g_main_loop_quit( glib_MainLoop );
    io_service-&gt;stop();

    while( !io_service-&gt;stopped() ) {
        boost::this_thread::sleep( boost::posix_time::seconds( 1 ) );
    }

    work.reset();
    threadgroup-&gt;join_all();

    g_main_loop_unref( glib_MainLoop );

    threadgroup.reset();
    work.reset();
    io_service.reset();

    std::cout &lt;&lt; ""Sandbox stopped"" &lt;&lt; std::endl;
}

target_link_libraries( Sandbox ${Boost_LIBRARIES} ${GSTREAMER_0_10_LIBRARIES} ${GSTREAMER_0_10_APP_LIBRARIES} ${OpenCV_LIBS} )

set_target_properties( Sandbox PROPERTIES LINKER_LANGUAGE CXX )
</code></pre>

<p>I'm starting the Sandbox-Program as follows:</p>

<pre><code>LC_ALL=""C"" GST_DEBUG=3 GST_DEBUG_DUMP_DOT_DIR=/tmp/ ./Sandbox
</code></pre>

<p>Then a Graph of the current Pipeline should be created in /tmp/. This .dot File can be converted into e.g. a svg-Graphic with:</p>

<pre><code>dot -Tsvg -oPipelineGraph.svg PipelineGraph.dot
</code></pre>

<p>Directly after the Error occurs. Here is the short Message, optained via GST_DEBUG=3:</p>

<pre><code>...
0:00:00.141888460 28057      0x2245d90 INFO                 basesrc gstbasesrc.c:2562:gst_base_src_loop:&lt;Source_OpenCV&gt; pausing after gst_pad_push() = not-negotiated
0:00:00.141924274 28057      0x2245d90 WARN                 basesrc gstbasesrc.c:2625:gst_base_src_loop:&lt;Source_OpenCV&gt; error: Internal data flow error.
0:00:00.141937917 28057      0x2245d90 WARN                 basesrc gstbasesrc.c:2625:gst_base_src_loop:&lt;Source_OpenCV&gt; error: streaming task paused, reason not-negotiated (-4)
0:00:00.141965714 28057      0x2245d90 INFO        GST_ERROR_SYSTEM gstelement.c:1964:gst_element_message_full:&lt;Source_OpenCV&gt; posting message: Internal data flow error.
0:00:00.141998959 28057      0x2245d90 INFO        GST_ERROR_SYSTEM gstelement.c:1987:gst_element_message_full:&lt;Source_OpenCV&gt; posted error message: Internal data flow error.
0:00:00.142018539 28057      0x2245d90 ERROR                 vp8enc gstvp8enc.c:1028:gst_vp8_enc_finish:&lt;Converter_VP8_Encoder&gt; encode returned 1 error
0:00:00.142053733 28057      0x2245d90 INFO             matroskamux matroska-mux.c:2226:gst_matroska_mux_start:&lt;ebmlwrite0&gt; DocType: webm, Version: 2
0:00:00.142082043 28057      0x2245d90 INFO               ebmlwrite ebml-write.c:218:gst_ebml_writer_send_new_segment_event: seeking to 0
0:00:00.142093688 28057      0x2245d90 INFO               GST_EVENT gstevent.c:606:gst_event_new_new_segment_full: creating newsegment update 0, rate 1.000000, format bytes, start 0, stop -1, position 0
...
</code></pre>

<p>With GST_DEBUG=4 it looks like:</p>

<pre><code>...
0:00:02.464122744 28483      0x24b8590 DEBUG               GST_CAPS gstpad.c:2925:gst_pad_get_allowed_caps:&lt;Converter_VP8_Encoder:src&gt; allowed caps video/x-vp8, width=(int)[ 16, 4096 ], height=(int)[ 16, 4096 ], framerate=(fraction)[ 0/1, 2147483647/1 ]
0:00:02.464152446 28483      0x24b8590 DEBUG               GST_CAPS gstpad.c:2263:gst_pad_get_caps_unlocked:&lt;Converter_VP8_Encoder:sink&gt; pad getcaps returned video/x-raw-yuv, width=(int)[ 16, 4096 ], height=(int)[ 16, 4096 ], framerate=(fraction)[ 0/1, 2147483647/1 ], format=(fourcc)I420
0:00:02.464174847 28483      0x24b8590 DEBUG               GST_PADS gstpad.c:2577:gst_pad_acceptcaps_default:&lt;Converter_VP8_Encoder:sink&gt; allowed caps video/x-raw-yuv, width=(int)[ 16, 4096 ], height=(int)[ 16, 4096 ], framerate=(fraction)[ 0/1, 2147483647/1 ], format=(fourcc)I420
0:00:02.464198411 28483      0x24b8590 DEBUG               GST_PADS gstpad.c:2629:gst_pad_accept_caps:&lt;Converter_VP8_Encoder:sink&gt; acceptfunc returned 1
0:00:02.464210382 28483      0x24b8590 DEBUG          basetransform gstbasetransform.c:1082:gst_base_transform_find_transform:&lt;Converter_FFMpegColorSpace&gt; Input caps were video/x-raw-rgb, width=(int)640, height=(int)480, framerate=(fraction)0/1, and got final caps video/x-raw-yuv, width=(int)640, height=(int)480, framerate=(fraction)0/1, format=(fourcc)I420
0:00:02.464236195 28483      0x24b8590 DEBUG          basetransform gstbasetransform.c:810:gst_base_transform_configure_caps:&lt;Converter_FFMpegColorSpace&gt; in caps:  video/x-raw-rgb, width=(int)640, height=(int)480, framerate=(fraction)0/1
0:00:02.464252757 28483      0x24b8590 DEBUG          basetransform gstbasetransform.c:811:gst_base_transform_configure_caps:&lt;Converter_FFMpegColorSpace&gt; out caps: video/x-raw-yuv, width=(int)640, height=(int)480, framerate=(fraction)0/1, format=(fourcc)I420
0:00:02.464271709 28483      0x24b8590 DEBUG          basetransform gstbasetransform.c:819:gst_base_transform_configure_caps:&lt;Converter_FFMpegColorSpace&gt; have_same_caps: 0
0:00:02.464282177 28483      0x24b8590 DEBUG          basetransform gstbasetransform.c:2921:gst_base_transform_set_in_place:&lt;Converter_FFMpegColorSpace&gt; setting in_place FALSE
0:00:02.464292338 28483      0x24b8590 DEBUG          basetransform gstbasetransform.c:2860:gst_base_transform_set_passthrough:&lt;Converter_FFMpegColorSpace&gt; set passthrough 0
0:00:02.464302369 28483      0x24b8590 DEBUG          basetransform gstbasetransform.c:834:gst_base_transform_configure_caps:&lt;Converter_FFMpegColorSpace&gt; Calling set_caps method to setup caps
0:00:02.464318339 28483      0x24b8590 DEBUG       ffmpegcolorspace gstffmpegcolorspace.c:320:gst_ffmpegcsp_set_caps:&lt;Converter_FFMpegColorSpace&gt; could not configure context for input format
0:00:02.464329667 28483      0x24b8590 WARN           basetransform gstbasetransform.c:1311:gst_base_transform_setcaps:&lt;Converter_FFMpegColorSpace&gt; FAILED to configure caps &lt;Converter_FFMpegColorSpace:src&gt; to accept video/x-raw-yuv, width=(int)640, height=(int)480, framerate=(fraction)0/1, format=(fourcc)I420
0:00:02.464352143 28483      0x24b8590 DEBUG               GST_CAPS gstpad.c:2773:gst_pad_set_caps:&lt;Converter_FFMpegColorSpace:sink&gt; caps video/x-raw-rgb, width=(int)640, height=(int)480, framerate=(fraction)0/1 could not be set
0:00:02.464504648 28483      0x24b8590 INFO                 basesrc gstbasesrc.c:2562:gst_base_src_loop:&lt;Source_OpenCV&gt; pausing after gst_pad_push() = not-negotiated
0:00:02.464517617 28483      0x24b8590 DEBUG                basesrc gstbasesrc.c:2588:gst_base_src_loop:&lt;Source_OpenCV&gt; pausing task, reason not-negotiated
0:00:02.464531137 28483      0x24b8590 DEBUG               GST_PADS gstpad.c:5646:gst_pad_pause_task:&lt;Source_OpenCV:src&gt; pause task
0:00:02.464543705 28483      0x24b8590 DEBUG                   task gsttask.c:698:gst_task_set_state:&lt;Source_OpenCV:src&gt; Changing task 0x24c9000 to state 2
0:00:02.464585246 28483      0x24b8590 DEBUG              GST_EVENT gstevent.c:269:gst_event_new: creating new event 0x24b8940 eos 86
0:00:02.464618078 28483      0x24b8590 WARN                 basesrc gstbasesrc.c:2625:gst_base_src_loop:&lt;Source_OpenCV&gt; error: Internal data flow error.
0:00:02.464631538 28483      0x24b8590 WARN                 basesrc gstbasesrc.c:2625:gst_base_src_loop:&lt;Source_OpenCV&gt; error: streaming task paused, reason not-negotiated (-4)
0:00:02.464645609 28483      0x24b8590 DEBUG            GST_MESSAGE gstelement.c:1933:gst_element_message_full:&lt;Source_OpenCV&gt; start
0:00:02.464672918 28483      0x24b8590 INFO        GST_ERROR_SYSTEM gstelement.c:1964:gst_element_message_full:&lt;Source_OpenCV&gt; posting message: Internal data flow error.
0:00:02.464697059 28483      0x24b8590 DEBUG                GST_BUS gstbus.c:308:gst_bus_post:&lt;bus0&gt; [msg 0x2325680] posting on bus, type error, GstMessageError, gerror=(GError)NULL, debug=(string)""gstbasesrc.c\(2625\):\ gst_base_src_loop\ \(\):\ /GstPipeline:OpenCV_to_TCPServer/GstAppSrc:Source_OpenCV:\012streaming\ task\ paused\,\ reason\ not-negotiated\ \(-4\)""; from source &lt;Source_OpenCV&gt;
0:00:02.464727109 28483      0x24b8590 DEBUG                    bin gstbin.c:3164:gst_bin_handle_message_func:&lt;OpenCV_to_TCPServer&gt; [msg 0x2325680] handling child Source_OpenCV message of type error
0:00:02.464739521 28483      0x24b8590 DEBUG                    bin gstbin.c:3171:gst_bin_handle_message_func:&lt;OpenCV_to_TCPServer&gt; got ERROR message, unlocking state change
0:00:02.464750463 28483      0x24b8590 DEBUG                    bin gstbin.c:3441:gst_bin_handle_message_func:&lt;OpenCV_to_TCPServer&gt; posting message upward
0:00:02.464770307 28483      0x24b8590 DEBUG                GST_BUS gstbus.c:308:gst_bus_post:&lt;bus1&gt; [msg 0x2325680] posting on bus, type error, GstMessageError, gerror=(GError)NULL, debug=(string)""gstbasesrc.c\(2625\):\ gst_base_src_loop\ \(\):\ /GstPipeline:OpenCV_to_TCPServer/GstAppSrc:Source_OpenCV:\012streaming\ task\ paused\,\ reason\ not-negotiated\ \(-4\)""; from source &lt;Source_OpenCV&gt;
0:00:02.464792364 28483      0x24b8590 DEBUG                GST_BUS gstbus.c:338:gst_bus_post:&lt;bus1&gt; [msg 0x2325680] pushing on async queue
0:00:02.464804471 28483      0x24b8590 DEBUG                GST_BUS gstbus.c:343:gst_bus_post:&lt;bus1&gt; [msg 0x2325680] pushed on async queue
0:00:02.464824022 28483      0x24b8590 DEBUG                GST_BUS gstbus.c:334:gst_bus_post:&lt;bus0&gt; [msg 0x2325680] dropped
0:00:02.464835553 28483      0x24b8590 INFO        GST_ERROR_SYSTEM gstelement.c:1987:gst_element_message_full:&lt;Source_OpenCV&gt; posted error message: Internal data flow error.
...
</code></pre>

<p>GST_DEBUG=5 would exceed the limit of this Post. :)</p>

<p>I'm reading the Log in that Way that there exists a problem with transfering the image from the Source_OpenCV to the Converter_FFMpegColorSpace Element? But why can't converter_FFMpegColorSpace handle the data? I thought i provided x-raw-rgb to Converter_FFMpegColorSpace, so it can convert it to x-raw-yuv for Converter_VP8_Encoder. Do i have specified the pushed image in a wrong Way?</p>

<p>If i'm missing some Information, i'm glad to get Hint, so i can add them.</p>

<p>Thanks in advance!</p>
"
"<p>I am having trouble removing spaces from a file name in php. The file does not upload to the server once the file is submitted. Here is the code:</p>

<pre><code>&lt;?php
session_start();

mysql_connect('localhost','root','') or die(mysql_error());
mysql_select_db('djmann1013');

if(!isset($_SESSION['username']) &amp;&amp; !isset($_SESSION['auth'])){
    header('Location: /');
}
$username = $_SESSION['username'];
echo $username;

$dirs = mysql_query(""SELECT * FROM `users` WHERE `usr_name` = '"" . $username . ""'"") or die(mysql_error());
$r = mysql_fetch_assoc($dirs);
$dir = $r['usr_directory'];

if(isset($_FILES['upload'])){
    $file = preg_replace('/\s+/', '_', $_FILES['upload']['name']);
    $current_time = date('n/j/Y ');

    mysql_query(""INSERT INTO `uploaded_files` (`username`,`file_name`,`time_updated`) VALUES('"" . $username . ""','"" . $file . ""','"" .  $current_time . ""')"") or die(mysql_error());
    move_uploaded_file($_FILES['upload']['tmp_name'], ""usr_files/$dir/$file"");
}

?&gt;

&lt;!DOCTYPE html PUBLIC ""-//W3C//DTD XHTML 1.0 Transitional//EN"" ""http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd""&gt;
&lt;html xmlns=""http://www.w3.org/1999/xhtml""&gt;
&lt;head&gt;
&lt;meta http-equiv=""Content-Type"" content=""text/html; charset=utf-8"" /&gt;
&lt;title&gt;Home - LAN File Upload&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;h1&gt;Upload a file&lt;/h1&gt;
&lt;form action="""" method=""post"" enctype=""multipart/form-data""&gt;
&lt;input type=""file"" name=""upload"" id=""file""&gt;&lt;br /&gt;
&lt;input type=""submit"" name=""submit"" value=""Upload""&gt;
&lt;/form&gt;
&lt;b&gt;Note: the larger the file, the longer it takes to upload.&lt;/b&gt;
&lt;h1&gt;Account Settings&lt;/h1&gt;
&lt;b&gt;&lt;a href=""/file_browser.php""&gt;Your Files&lt;/a&gt;&lt;/b&gt;
&lt;b&gt;&lt;a href=""settings.php""&gt;Account Settings&lt;/a&gt;&lt;/b&gt;
&lt;b&gt;&lt;a href=""/?action=logout""&gt;Logout&lt;/a&gt;&lt;/b&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>I don't know what is wrong with this code. Anyone have any ideas?</p>
"
"<p>So for part of my school assignment, I need to find the current time, and i used this as a reference:<a href=""http://www.cplusplus.com/reference/ctime/localtime/"" rel=""nofollow"">http://www.cplusplus.com/reference/ctime/localtime/</a>
I tried to copy what they did, but I keep getting this error:</p>

<pre><code>l8stat.c:33: error: called object '15552000' is not a function
</code></pre>

<p>This is the line:</p>

<pre><code>time(&amp;current_time);
</code></pre>

<p>I really don't understand why this is happening when I'm doing the same thing as the example. </p>

<p>Here's my code:</p>

<pre><code>#include &lt;errno.h&gt;
#include &lt;libgen.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;locale.h&gt;
#include &lt;time.h&gt;
#include &lt;limits.h&gt;

#define SEC_PER_DAY (24 * 60 * 60)
#define time (SEC_PER_DAY*180)

 void print_data(char *path ){
   setlocale (LC_NUMERIC, ""en_US"");
   struct stat *new=malloc(sizeof(struct stat));
   char linkname[PATH_MAX + 1];
   int status=lstat(path, new);
   if(status==0){
      printf(""%.6o  %9d "",new-&gt;st_mode,
         new-&gt;st_size );
  }
  else{
     fprintf (stderr, ""l8stat: %s: %s\n"",
           path, strerror (errno));
 }

 time_t current_time;
 struct tm *local_time;
 time(&amp;current_time);
 local_time=localtime(&amp;current_time);
 char buffer[50];


 if(current_time-new-&gt;st_mtime&lt;=time ){
    strftime(buffer,50,""%b %e %R"",new-&gt;st_mtime);
    puts(buffer);
 } else{
     strftime(buffer,50,""%b %e  %Y"",new-&gt;st_mtime);
     puts(buffer);
   }

 ssize_t retval = readlink (path, linkname, sizeof linkname);
   if(retval &gt;=0){
      linkname[retval &lt; PATH_MAX + 1 ? retval : PATH_MAX] = '\0';
      printf (""%s -&gt; \""%s\""\n"", path, linkname);
   }

 printf("" %s"",path);
}

int main (int argc, char **argv) {
  int exit_status=EXIT_SUCCESS;
  for(int argi = 1; argi &lt;argc; ++argi){
     if(argc!=2)  ;
     print_data(argv[argi]);
     printf(""\n"");
  }

  return exit_status;
 }
</code></pre>
"
"<p>We are building a HTML5 MMO that will leverage AJAX calls to a REST API written in Python for actions ( buy, sell, build, trade, send , attack). </p>

<p>Our second part of this project is a Java Server that updates the database with player stats every so often ( our server tick is every 5 seconds as of no because of performance)</p>

<pre><code>Update town SET ""currency"" = ""currency"" + ""currency_rate""
//each player can own an average of 100 towns and
//we are benchmarking with 50k for right now
</code></pre>

<p>That query will update their currency according to their rate.  This query takes 2.6 seconds to update currency with 50k, but we have several other fields, metal, ceramic, food and population. </p>

<p><strong>Question</strong> : With this technique we can only have a server tick every 3 seconds minimum. How do we solve this problem.  How do you go about updating thousands of entries constantly?</p>

<p>Our 2nd Solution : We load most of the towns into a Concurrent Hashmap and java will use it a a temp database and update the entire database every minute. ( API will be the Java server)</p>
"
"<p>I've a snippet here: <a href=""http://ideone.com/fywv3J"" rel=""nofollow"">http://ideone.com/fywv3J</a></p>

<p>Posting it here also :</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int gtime_to = 20131231;

int main() {
  time_t current_time, licence_expiry_time;
  struct tm licence_expiry_time_struct;
  memset(&amp;licence_expiry_time_struct, 0, sizeof(struct tm));
  licence_expiry_time_struct.tm_mday = gtime_to % 100;                  // get the day
  licence_expiry_time_struct.tm_mon = ((gtime_to % 10000) / 100) - 1;   // get the month
  licence_expiry_time_struct.tm_year = gtime_to / 10000;                // get the year
  licence_expiry_time_struct.tm_hour = 0;
  licence_expiry_time_struct.tm_min = 0;
  licence_expiry_time_struct.tm_sec = 0;
  licence_expiry_time_struct.tm_wday = 0;
  licence_expiry_time_struct.tm_yday = 0;
  licence_expiry_time_struct.tm_isdst = -1;
  licence_expiry_time = mktime(&amp;licence_expiry_time_struct);
  time(&amp;current_time);
  printf(""date = %d, month = %d, year = %d\n"", licence_expiry_time_struct.tm_mday, licence_expiry_time_struct.tm_mon, licence_expiry_time_struct.tm_year);
  printf(""cur = %d, expiry = %d, diff = %d"", current_time, licence_expiry_time, difftime(licence_expiry_time, current_time));
  return 0;
}
</code></pre>

<p>The output of <strong>mktime()</strong> is <strong>-1</strong> for every possible value I've tried with.</p>

<p>This is the line
<code>cur = 1386084345, expiry = -1, diff = -25165824</code>
where the value of <strong>expiry</strong> shouldn't be <strong>-1</strong>. Can anyone tell me where I'm doing wrong ?</p>
"
"<p>I posted this earlier on today but I realised I put up an old edition of my uncompiling code before, but this code compiles in gcc, I have to create a hotel wake-up call registry, which when a new alarm is generated it is printed out, placed correctly into the list (by order of the nearest alarm first) and then the time of the call occurs is printed out.</p>

<p>The problem is that when inserting nodes (insertNode()), the addedNode when added to the list overwrites the head, and writes into the next node, instead of just writing the alarmData into the head node.  </p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;
#include &lt;signal.h&gt;

#define ETIMEDOUT 110

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

const int MAX_ROOM_NUMBER = 1000;
const int MAX_SECOND = 100;
static int NotCancelled = 0;
int REGISTER = 0;

typedef struct wakeUp
{

  int room; //Structure that has the room to awake
  time_t alarm;//and the time that the room wishes to wake
}wakeUp;

typedef struct node
{

  wakeUp awake; // Nodes used as a list to hold the of alarms ordered earliest node first
  struct node* nextNode;// it contains the struct WakeUp and a pointer to the next node
}node;

node * AlarmData;
pthread_t insert,wakeRoom;


static void *
printAlarmsData(node* first)
{
  if (first == NULL )
  {
    printf(""This List Of Alarms is empty!\n"");
    return;
  }
  else
  {
    node* p = first;
    int count = 0;
    while (p != NULL )
    {
      printf(""%d %s, \n"", p-&gt;awake.room, ctime(&amp;p-&gt;awake.alarm));
      count++;
      if (p-&gt;nextNode == NULL || count == 10)
      {
        return;
      }

    }
  }
}

static int
removeAlarm(wakeUp * first)
{ //When the alarm occurs remove the first Node

  pthread_mutex_lock(&amp;lock); // Hold the lock

  time_t current_time;
  time(&amp;current_time);

  if (current_time &lt; first-&gt;alarm)
  {
    printf(""Waiting...\n"");
    pthread_cond_signal(&amp;cond);
    pthread_mutex_unlock(&amp;lock);
    return 0;
  }
  else
  {
    AlarmData = AlarmData-&gt;nextNode;
    pthread_cond_signal(&amp;cond);
    pthread_mutex_unlock(&amp;lock);
    return 1;
  }
}

int
length(node* first)
{ // Shows how many Alarms are left.
  node* p = first;
  int count = 0;

  while (p != NULL )
  {
    count++;
    p = p-&gt;nextNode;

  }
  return count;
}

// insert Node function

void
insertNode(node* addedNode)
{                 //this method here
  pthread_mutex_lock(&amp;lock);           // head keeps getting overwritten instead
  node *head, *temp, *prev, *next;             // of writing data into AlarmData
  temp = (node*) malloc(sizeof(node));
  head = AlarmData;
  temp = addedNode;
  temp-&gt;nextNode = NULL;
  if (!head)
  {
    printf(""Head is null\n"");
    head = temp;
  }
  else
  {
    printf(""Head is not null\n"");
    prev = NULL;
    next = head;
    printf(""Existing Data Showing Below\n"");
    while (next &amp;&amp; (next-&gt;awake.alarm) &lt;= (addedNode-&gt;awake.alarm))
    {
      printf(""----&gt; %d %s\n"", next-&gt;awake.room, ctime(&amp;next-&gt;awake.alarm));
      prev = next;
      next = next-&gt;nextNode;
    }
    if (!next)
    {
      prev-&gt;nextNode = temp;
    }
    else
    {
      if (prev)
      {
        temp-&gt;nextNode = prev-&gt;nextNode;
        prev-&gt;nextNode = temp;
      }
      else
      {
        temp-&gt;nextNode = head;
        head = temp;
      }
    }

  }
  AlarmData = (node*) malloc(sizeof(node));
  AlarmData = head;
  pthread_cond_signal(&amp;cond);
  pthread_mutex_unlock(&amp;lock);
}

static void
cancelHandler(int signo)
{
  printf(""\nAre you sure you want to exit this program Y/N:"");
  char input;
  scanf(""%c"", &amp;input);
  if (input == 'y')
  {
    NotCancelled = 1;
    wakeUp n = AlarmData-&gt;awake;
    while (AlarmData != NULL )
    {
      removeAlarm(&amp;n);
    }

    pthread_cancel(insert);

    pthread_cancel(wakeRoom);

    pthread_join(insert, NULL );
    printf(""Goodbye from insert thread"");
    pthread_join(wakeRoom, NULL );
    printf(""Goodbye from wakeUp thread"");
    printf(""Program Exited"");
    return;
  }
}

static void *
insertHandler()
{
  printf(""\nwent to insertHandler\n"");
  while (NotCancelled == 0)
  {
    sleep(rand() % 2);
    int roomId = rand() % MAX_ROOM_NUMBER + 1;

    time_t timeToWake = time(NULL ) + (rand() % MAX_SECOND + 1);
    wakeUp wake;
    wake.room = roomId;
    wake.alarm = timeToWake;

    node newAlarm;
    newAlarm.awake = wake;
    REGISTER++;
    insertNode(&amp;newAlarm);

    printf(""After Registering:\t%d\t%s\n\n"", roomId, ctime(&amp;timeToWake));
  }
  return;
}
static void *
wakeRoomHandler()
{
  printf(""\nwent to wakeRoomHandler\n"");
  while (NotCancelled == 0)
  {
    sleep(rand() % 15);

    if (AlarmData != NULL )
    {
      wakeUp wake = AlarmData-&gt;awake;
      time_t timeToWake = AlarmData-&gt;awake.alarm;
      int roomId = AlarmData-&gt;awake.room;
      printf(""Checking:\t%d\t%s\n\n"", roomId, ctime(&amp;timeToWake));
      int status = removeAlarm(&amp;wake);
      if (status == 1)
      {
        printf(""Wake Up:\t%d\t%s\n\n"", roomId, ctime(&amp;timeToWake));
      }
    }
  }
  return;
}

int
main(void)
{
  sigset_t set;
  sigemptyset(&amp;set);
  sigaddset(&amp;set, SIGINT);
  sigset(SIGINT, cancelHandler);
  pthread_create(&amp;insert, NULL, insertHandler, NULL );
  pthread_create(&amp;wakeRoom, NULL, wakeRoomHandler, NULL );
  while (1)
  {
  }

  return (0);

}
</code></pre>
"
"<p>I am running a timer to calculate the efficiency of my program and I need to output it to a hyperterminal.
So, I need to do a <code>sprintf</code> on a <code>uint32_t</code> hexidecimal to store it into a string.
But I keep getting an error on the <code>%08X</code>. So what should I use instead?
I have tried using <code>%ll</code>, <code>%lu</code> but the warning is still there.</p>

<pre><code>volatile char str_cycles=0;
volatile uint32_t total_cycles = 0x00ffffff - current_time;
sprintf(str_cycles, ""%08X"",total_cycles);
</code></pre>

<p>Can anyone help me with this?</p>
"
"<p>I am trying to study the details of this <a href=""http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/CUJ/2003/0311/0311roussel/cuj0311roussel.htm"" rel=""nofollow"">Generic object-oriented differential equations integrators class</a> but I have some problems to compile the simpler example. The idea is define  a main class of integrators  from which all the other integration-methods classes are derived via inheritance. Here is the code for the implementation of the Euler's method.</p>

<pre><code>//file integrator.hpp
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;math.h&gt;
#include &lt;complex&gt;
#include &lt;cmath&gt;


template &lt;class C /* a container */, class T&gt; class Integrator{
protected:
C statevector;
T t, h;

// a pointer to the function to be integrated
void (*return_derivs)(const C&amp; x, const T t, C&amp; deriv);//OK, I understand that a pointer to ODEs system is neede.

Integrator (const C&amp;, const T, const T,
        void (*)(const C&amp;, const T, C&amp;)); //Question: why use void(*) in place of void (*return_derivs)?

public:
virtual ~Integrator() { }
virtual void step(void) = 0;
virtual void set_step_size(T new_h) {h = new_h;}

T current_time(void) const {return(t);}
void get_state(C&amp;, T&amp;) const;
};


template &lt;class C, class T, class B /* base type of C */&gt;
class Euler : public Integrator&lt;C,T&gt;
{
private:
  C dxdt;

public:
  Euler (const C &amp;x0, const T t0, const T h_init,
     void (*dxdt_calc)(const C&amp;, const T, C&amp;))
    : Integrator &lt;C,T&gt; (x0, t0, h_init, dxdt_calc),
      dxdt(x0) { }

  void step(void);
};

template &lt;class C, class T, class B&gt;
void Euler&lt;C,T,B&gt;::step(void) // I guess, the resolution of the Integrator class variables id needed. Consequently I modify this part of the code.
{
  Integrator&lt;C,T&gt;::return_derivs(Integrator&lt;C,T&gt;::statevector,Integrator&lt;C,T&gt;::t,dxdt);
  Integrator&lt;C,T&gt;::statevector += B(Integrator&lt;C,T&gt;::h)*dxdt;
  Integrator&lt;C,T&gt;::t += Integrator&lt;C,T&gt;::h;
}
</code></pre>

<p>The main program in which the Euler integrator object is instantiated:</p>

<pre><code>#include &lt;complex&gt;
#include &lt;valarray&gt;
#include ""integrator.hpp""
using namespace std;

namespace discretization_data
{
  const complex&lt;double&gt; i(0,1);
  unsigned int nmesh = 10;
}

void discretized_odes(const valarray&lt;complex&lt;double&gt; &gt; &amp;psi,
              const double t, valarray&lt;complex&lt;double&gt; &gt; &amp;dpsidt)
{
  using namespace discretization_data;
  dpsidt[0] = i*(psi[1]-2.0*psi[0]);
  dpsidt[nmesh-1] = i*(psi[nmesh-2]-2.0*psi[nmesh-1]);
  for (int loop=1; loop&lt;nmesh-1; loop++)
    dpsidt[loop] = i*(psi[loop+1] - 2.0*psi[loop]
              + psi[loop-1]);
}

int main()
{
  using namespace discretization_data;
  // Initial conditions
  valarray&lt;complex&lt;double&gt; &gt;
    psi(complex&lt;double&gt;(1.0/nmesh), nmesh);

  Euler&lt;valarray&lt;complex&lt;double&gt; &gt;, double, complex&lt;double&gt; &gt;
    dSchrodinger(psi, 0.0, 0.01, discretized_odes ); //I guess the problem is here.

  while (dSchrodinger.current_time() &lt; 50)
    dSchrodinger.step();
  //Some output statements would be added to a real program...
}
</code></pre>

<p>The problem is that when I compile the example the compiller cannot find the reference to the integrator object. But I don't undertand where the problems are?</p>

<p>To compile I use the command:</p>

<pre><code>g++ integrator.hpp main.cpp -o main.x -lm
</code></pre>

<p>Obtaining the error messaje:</p>

<pre><code>/tmp/ccre01X7.o: In function `Euler&lt;std::valarray&lt;std::complex&lt;double&gt; &gt;, double, std::complex&lt;double&gt; &gt;::Euler(std::valarray&lt;std::complex&lt;double&gt; &gt; const&amp;, double, double, void (*)(std::valarray&lt;std::complex&lt;double&gt; &gt; const&amp;, double, std::valarray&lt;std::complex&lt;double&gt; &gt;&amp;))':
main.cpp:(.text._ZN5EulerISt8valarrayISt7complexIdEEdS2_EC2ERKS3_ddPFvS6_dRS3_E[_ZN5EulerISt8valarrayISt7complexIdEEdS2_EC5ERKS3_ddPFvS6_dRS3_E]+0x46): undefined reference to `Integrator&lt;std::valarray&lt;std::complex&lt;double&gt; &gt;, double&gt;::Integrator(std::valarray&lt;std::complex&lt;double&gt; &gt; const&amp;, double, double, void (*)(std::valarray&lt;std::complex&lt;double&gt; &gt; const&amp;, double, std::valarray&lt;std::complex&lt;double&gt; &gt;&amp;))'
collect2: error: ld returned 1 exit status
</code></pre>
"
"<p>I am trying to create a function that gets the current date, takes an individuals birthday, and calculates their age.  I got the current date.  Now I am trying to take the person's birthday(passed to the function through individual) and store the person's birthday values in a struct <code>tm</code> variable named str_bday.  The program compiles, but when I run it, i get this:   </p>

<pre><code>       Your last name is Smith
       Sat Feb  8 16:04:05 2014
       Your birthday is:  3/1/1940
       Wed Dec 31 18:59:59 1969
       v245-2%
</code></pre>

<p>I don't understand why it prints that their birthday is 1969 when I print out the str_bday struct <code>tm</code> variable.   Can somebody please help me.  Below is my code for this function:</p>

<pre><code>       char* calcage(char *individual, char *age)
         {

           time_t current_time;
           char *c_time_string;

           current_time = time(NULL);


           c_time_string = ctime(&amp;current_time);

           printf(c_time_string);



           char *birthday = (char *)malloc(50*sizeof(char));
           birthday = strrchr(individual, ',');
           birthday++;

           printf(""Your birthday is:  %s\n"", birthday);


           char *bmonth, *bday, *byear;
           int numbmonth, numbday,  numbyear;


           bmonth = strtok(birthday, ""/"");
           bday = strtok(NULL, ""/"");
           byear = strtok(NULL, ""/"");

           numbmonth = atoi(bmonth);
           numbday = atoi(bday);
           numbyear = atoi(byear);


           struct tm str_bday;
           time_t time_bday;

           str_bday.tm_year = 2012;

           time_bday = mktime(&amp;str_bday);
           printf(ctime(&amp;time_bday));



         }
</code></pre>
"
"<p>I am creating a function that takes an individuals record (stored in <code>*individual</code> in the function parameters), separates the record in order to get the persons birthday, and then the function calculates their age.  The problem I am encountering is when I use <code>strrchr</code> to search the record for the birthday, it changes the original value when I don't want it to.  So, instead of storing <code>Steven, Cortright, 3/1/1940</code> like it should, it stores <code>Steven, Cortright, 3</code></p>

<p>I have tried everything I can think of to fix this.  below is my code I appreciate any help/advice:  </p>

<pre><code>char* calcage(char *individual)
  {

    time_t current_time;
    char *c_time_string;
    char *birthday;
    char *bmonth, *bday, *byear;
    int numbmonth, numbday,  numbyear;
    struct tm str_bday;
    time_t time_bday;
    double diff;
    double years;

    double monthscalc;
    int monthsage;
    int yearsage;


    current_time = time(NULL);


    c_time_string = ctime(&amp;current_time);
    birthday = strrchr(individual, ',');
    birthday++;


    bmonth = strtok(birthday, ""/"");
    bday = strtok(NULL, ""/"");
    byear = strtok(NULL, ""/"");

    numbmonth = atoi(bmonth);
    numbday = atoi(bday);
    numbyear = atoi(byear);

    str_bday.tm_year = numbyear - 1900;
    str_bday.tm_mon = numbmonth - 1;
    str_bday.tm_mday = numbday;
    str_bday.tm_hour = 0;
    str_bday.tm_min = 0;
    str_bday.tm_sec = 1;
    time_bday = mktime(&amp;str_bday);

    diff = difftime(current_time, time_bday);
    years = diff / 60 / 60 / 24 / 365.242;

    yearsage = (int) years;


    int inpart = (int) years;
    double months = years - inpart;
    monthscalc = (365.242 * months) / 30.4368;

    monthsage = (int) monthscalc;

    char *calculatedAge = (char *)malloc(50*sizeof(char));
    snprintf(calculatedAge,100,  ""You are %d years and %d months old."", yearsage, \
    monthsage);

    return calculatedAge;
  }
</code></pre>
"
"<p>I am writing a program that simulates a round robin style cpu scheduler. After <code>timestamp</code> (variable input in the command line) number of time units, the scheduler should move that process down to the bottom of the queue and resume with the next node.</p>

<p>I am having trouble trying to calculate when I am at the end of a cycle, I tried with modulus first but I realized that was bad. I then tried using the literal calculation, and even threw in float casts but it still does not work. The statement is true when the worked attibute is 0, and is false at all other values of worked.</p>

<p>What I have tried:</p>

<pre><code>if ((queue-&gt;worked % timestamp) != 0)
if ((queue-&gt;worked - (timestamp * (queue-&gt;worked / timestamp))) == 0)
if ((float) (queue-&gt;worked - (float) (timestamp * (float) (queue-&gt;worked / timestamp))) == 0)
</code></pre>

<p>I would also like to know if there is a better way of doing this so that I can avoid the modulus altogether.</p>

<p>Below is some of the relevant code:</p>

<pre><code>struct node {
    double process_id;
    int arrival_time;
    int cpu_time;
    int worked;
    struct node *nextElement;
};

void round_robin(nodeptr firstNode, int timestamp) {
    nodeptr queue = firstNode;

    if ((queue-&gt;worked % timestamp) == 0) {
        queue-&gt;worked++;
        current_time++;
    }
    else {
        tmpptr = queue;
        queue = queue-&gt;nextElement;
        add_to_bottom(tmpptr, queue);
    }
}
</code></pre>

<p>Here is a set of samples. These are lines in a text file that are read in by the main function and are stored as a linked list of nodes.</p>

<pre><code> 2001  0  20
 2002  1  10
 2005  2  15
 2007  3   4
</code></pre>

<p>where the columns represent the process id, the arrival time, and time the process will take to calculate (in milliseconds).</p>

<p>A pointer to the first node (process 2001) is passed to the function as well as an integer that was passed as an argument (./main 10)</p>

<p>The function iterates over the list and simulates a round robin style cpu scheduler.</p>

<p>Step by step:
So if I input 10 for timestamp: (output is not important right now)</p>

<pre><code>Process 2001 should calculate for 10 milliseconds, then get send to the back of the list.
Process 2002 will calculate for 10 and finish.
Process 2005 will calculate for 10 milliseconds, get send to the back.
Process 2007 will calculate for 4 and be done.
Process 2001 was went to the back and now runs for 10 more and finishes.
Process 2005 calculates for the remaining 5 and the program is now done.
</code></pre>

<p>Edit:</p>

<p>I added a printf that said ""If!\n"" in the if and one that said ""Else!\n"" in the else and it prints out if once (worked is initialized to 0) and then else every other time that node is run. It only enters the if for a value of zero, after worked is incremented it does not enter again and gets stuck in an infinite loop of putting the first process to the end.</p>

<pre><code>If!
Else!
If!
Else!
If!
Else!
If!
Else!
Else!
Else!
Else!
...until it eventually segfaults after about 900 lines
</code></pre>
"
"<p>I have a batch file and within that batch file I need to run one of two commands depending on time of my server.</p>

<p>If the time is between 22:00:00 and 03:30:00 -- xcopy /Y a\1.txt c\1.txt</p>

<p>If the time is before or after this range -- -- xcopy /Y b\1.txt c\1.txt</p>

<p>This will use xcopy to switch a file back and forth depending on the time.</p>

<p>I know this is easy but my brain just won't work atm lol</p>

<p>Edit:</p>

<p>Went with 22:00 and 4:00... this is what I came up with but it doesn't seem like the best way...</p>

<p>set current_time=%time:~0,5% </p>

<p>if ""%current_time%"" lss ""22:00"" goto daycycle </p>

<p>if ""%current_time%"" gtr "" 4:00"" goto daycycle </p>

<p>echo Do this between 10pm and 4am</p>

<p>goto continue </p>

<p>:daycycle </p>

<p>echo Do this before 10pm and after 4am</p>

<p>:continue</p>
"
"<p>First of all, my knowledge of X++ is minimal, I just need to edit the code I've been given.
I have a C++ program which creates a text file and stores data in it. Right now the program is using:</p>

<pre><code>outfile.open(""C:/Users/Admin/Documents/MATLAB/datafile.txt"", std::ios::app);
</code></pre>

<p>But I need to change this code so each time i run this code, it will create a new file name. My suggestion is to somehow incorporate the time/date as the file name, but I am unsure how to do this. I've tried researching around, and it looks like using <code>time_t</code> is the way to go, but I'm unsure how to utilize it for my case.</p>

<p>Is it possible to save the time/date as a variable, then use:</p>

<pre><code>outfile.open(""C:/Users/td954/Documents/MATLAB/&lt;DEFINED VARIABLE&gt;"", std::ios::app);
//                                            ^^^^^^^^^^^^^^^^^^
</code></pre>

<p>if so, how would I go about this?</p>

<p>Thanks guys</p>
"
"<p>I'm trying to parse the system date by calling struct tm and getting the current time before parsing into separate day, month, year. Here is my code at hte moment: </p>

<pre><code>/* Parses a system date structure 'system_date' into a structure date 'parsed_date'.*/
int parse_system_date(struct tm system_date, date * parsed_date) {
     time_t ts;
     struct tm t;

     ts = time(NULL);
     t = localtime(&amp;ts);

     /* scan the year, month and year from the input string*/
     //printf(""Current Date: %d/%d/%d\n"",
         // current_time-&gt;tm_mday, current_time-&gt;tm_mon + 1, current_time-&gt;tm_year + 1900);

     const int ret = sscanf(system_date, ""%d/%d/%d"",
            &amp;parsed_date-&gt;(tm_mday),
            &amp;parsed_date-&gt;(tm_month + 1),
            &amp;parsed_date-&gt;(tm_year + 1900));
     return ret;

}
</code></pre>

<p>And it's being called from the main by: </p>

<pre><code>struct tm t;
char system_date[20];

fgets(system_date, 20, stdin);
    parse_system_date(system_date, &amp;t);
    printf(""Today's date is: %s\ndd = %d, mm = %d, yy = %d\n"", system_date, t.tm_mday, t.tm_mon, t.tm_year);
</code></pre>

<p>I'm getting the error:</p>

<pre><code>date.h:30: error: incompatible types in assignment
</code></pre>

<p>In the line: </p>

<pre><code>t = localtime(&amp;ts);
</code></pre>

<p>And: </p>

<pre><code>date.h:39: error: incompatible type for argument 1 of ?sscanf?
</code></pre>

<p>for the line: </p>

<pre><code>&amp;parsed_date-&gt;(tm_mday).
</code></pre>

<p>Any ideas? Thanks for the help! Just to note: I'm a beginner programmer but trying to immerse myself entirely as I just started  PhD that deals mainly in programming so I'm a total newbie.</p>
"
"<p>The below codes running on the shell has the error of Badly placed ()'s but I'm not able to figure out what's wrong with them. </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;

void current_time() {
    struct tm *current;
    time_t now;
    now = time(NULL);
    current = localtime(&amp;now);
    printf(""[%02i:%02i:%02i]  "", current-&gt;tm_hour, current-&gt;tm_min, current-&gt;tm_sec);
}

void gChild(int life,int input_data){
    time_t curtime;
    int pid = fork(); //fork() creating process and returning pid
    if (pid == 0) {
        current_time();
        printf(""  Grand-Child process started(process %d). The process will last for %d seconds.\n"", getpid(), life);
        sleep(life);
        current_time();
        input_data++;
        printf(""  Grand-Child process ended(process %d). iData is %d\n"", getpid(), input_data);
        exit(0);
    } else if (pid == -1) {
        perror(""Cannot start first-grandchild process.\n"");
        exit(0);
    }
}

void Child1(int life,int input_data){
    time_t curtime;
    int pid = fork();
    if (pid == 0) {
        current_time();
        printf("" ~First Child process started(process %d). The process will last for %d seconds.\n"", getpid(), life);
        sleep(life);
        current_time();
        input_data++;
        printf("" ~First Child process ended(process %d). iData is %d\n"", getpid(), input_data);
        exit(0);
    }
    else if (pid == -1) {
        perror(""Cannot start first-child process.\n"");
        exit(0);
    }
}

void Child2(int life, int gchildST, int ltgc, int input_data){
    time_t curtime;
    int pid = fork();
    if (pid == 0)
    {
        current_time();
        printf("" ~Second Child process started(process %d). The process will last for %d seconds.\n"", getpid(), life);
        gChild(ltgc, input_data);
        current_time();
        input_data++;
        printf("" Second Child process ended(process %d). iData is %d\n"", getpid(), input_data);
        exit(0);
    }
    else if (pid == -1)
    {
        perror(""Cannot start second-child process.\n"");
        exit(0);
    }
}

void parent_code()
{
    while(1)
    {
        pid_t wait_rv = wait(NULL);
        if (wait_rv == -1)
            return;
    }
}
int main(int argCount, char *arg[])
{
    time_t curtime;
    int input_data;
    int ltc1, ltc2; //life times of the two child processes after which the two child processes will terminate
    int ltgc; //life time of the grandchild process
    int child1ST, child2ST; //starting times of the two child processes
    int gchildST; //starting times of the grandchild process

    if (argCount != 8) {
        printf(""Invalid inputs.\n"");
        return 0;
    }

    sscanf(arg[1], ""%d"", &amp;input_data);  //%d for only accepting decimal values
    sscanf(arg[2], ""%d"", &amp;child1ST);
    sscanf(arg[3], ""%d"", &amp;child2ST);
    sscanf(arg[4], ""%d"", &amp;ltc1);
    sscanf(arg[5], ""%d"", &amp;ltc2);
    sscanf(arg[6], ""%d"", &amp;gchildST);
    sscanf(arg[7], ""%d"", &amp;ltgc);

    if (ltc1&lt;=0 || ltc2&lt;=0 || ltgc&lt;=0)
    {
        printf(""Invalid life time.\n"");
        return 0;
    }

    if (child1ST&lt;=0 || child2ST&lt;=0 || gchildST &lt;=0){
        printf(""Invalid start-time.\n"");
        return 0;
    }
    else if (ltc2 &lt;= gchildST || ltc2 &lt;= gchildST)
    {
        printf(""Cannot start all grandchild processes during second process.\n"");
        return 0;
    }

    current_time();
    printf(""Parent process started(process %d).\n"", getpid());

    if(child1ST&lt;child2ST){
        sleep(child1ST);
        Child1(ltc1,input_data);
        sleep(child2ST-child1ST);
        Child2(ltc2, gchildST, ltgc, input_data);
    }
    else
    {
        sleep(child2ST);
        Child2(ltc2, gchildST, ltgc, input_data);
        sleep(child1ST-child2ST);
        Child1(ltc1,input_data);
    }
    parent_code();
    current_time();
    input_data++;
    printf(""Parent process ended(process %d). iData is %d\n"", getpid(), input_data);
    return 0;
}
</code></pre>

<p>I have been trying to find out the error by using the command of <code>gcc -Wall</code> to see what happen with it shows the following:
In function 'gChild':</p>

<pre><code>warning: implicit declaration of function 'fork'

warning: implicit declaration of function 'getpid'

warning: implicit declaration of function 'sleep'

warning: unused variable 'curtime'

In function 'Child1':

warning: unused variable 'curtume'

In function 'parent_code':

warning: implicit declaration of function 'wait'

In function 'main':

warning: unused variable 'curtime'
</code></pre>

<p>New error messages after adding libraries:</p>

<pre><code>test.c: In function 'gChild':
test.c:23: warning: format '%d' expects type 'int', but argument 2 has
type 'pid
_t'

test.c:27: warning: format '%d' expects type 'int', but argument 2 has
type 'pid
_t'

test.c:19: warning: unused variable 'curtime'

test.c: In function 'Child1':
test.c:40: warning: format '%d' expects type 'int', but argument 2 has
type 'pid
_t'

test.c:44: warning: format '%d' expects type 'int', but argument 2 has
type 'pid
_t'

test.c:36: warning: unused variable 'curtime'
test.c: In function 'Child2':

test.c:59: warning: format '%d' expects type 'int', but argument 2 has
type 'pid
_t'

test.c:63: warning: format '%d' expects type 'int', but argument 2 has
type 'pid
_t'

test.c:54: warning: unused variable 'curtime'
test.c: In function 'parent_code':

test.c:77: warning: implicit declaration of function 'wait'
test.c: In function 'main':

test.c:121: warning: format '%d' expects type 'int', but argument 2 has
type 'pi
d_t'

test.c:139: warning: format '%d' expects type 'int', but argument 2 has
type 'pi
d_t'

test.c:84: warning: unused variable 'curtime'
</code></pre>
"
"<p>I well compiled/build the glfw library and after removed/replaced some functions in a file main.cc ( glfw 2 to version 3 ), it tells me this error</p>

<p>ld: library not found for -lglfw
clang: error: linker command failed with exit code 1 (use -v to see invocation)</p>

<p>This is the file : </p>

<pre><code>    /*
 * Poly2Tri Copyright (c) 2009-2010, Poly2Tri Contributors
 * http://code.google.com/p/poly2tri/
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * * Neither the name of Poly2Tri nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without specific
 *   prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include &lt;cstdlib&gt;
#include &lt;/usr/local/include/GLFW/glfw3.h&gt;
#include &lt;time.h&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;iostream&gt;
using namespace std;

#include ""../poly2tri/poly2tri.h""
using namespace p2t;

void Init();
void ShutDown(int return_code);
void MainLoop(const double zoom);
void Draw(const double zoom);
void DrawMap(const double zoom);
void ConstrainedColor(bool constrain);
double StringToDouble(const std::string&amp; s);
double Random(double (*fun)(double), double xmin, double xmax);
double Fun(double x);

/// Dude hole examples
vector&lt;Point*&gt; CreateHeadHole();
vector&lt;Point*&gt; CreateChestHole();

float rotate_y = 0,
      rotate_z = 0;
const float rotations_per_tick = .2;

/// Screen center x
double cx = 0.0;
/// Screen center y
double cy = 0.0;

/// Constrained triangles
vector&lt;Triangle*&gt; triangles;
/// Triangle map
list&lt;Triangle*&gt; map;
/// Polylines
vector&lt; vector&lt;Point*&gt; &gt; polylines;

/// Draw the entire triangle map?
bool draw_map = false;
/// Create a random distribution of points?
bool random_distribution = false;

template &lt;class C&gt; void FreeClear( C &amp; cntr ) {
    for ( typename C::iterator it = cntr.begin();
              it != cntr.end(); ++it ) {
        delete * it;
    }
    cntr.clear();
}

int main(int argc, char* argv[])
{

  int num_points = 0;
  double max, min;
  double zoom;

  if (argc != 5) {
    cout &lt;&lt; ""-== USAGE ==-"" &lt;&lt; endl;
    cout &lt;&lt; ""Load Data File: p2t filename center_x center_y zoom"" &lt;&lt; endl;
    cout &lt;&lt; ""Example: ./build/p2t testbed/data/dude.dat 500 500 1"" &lt;&lt; endl;
    return 1;
  }

  if(string(argv[1]) == ""random"") {
    num_points = atoi(argv[2]);
    random_distribution = true;
    char* pEnd;
    max = strtod(argv[3], &amp;pEnd);
    min = -max;
    cx = cy = 0;
    zoom = atof(argv[4]);
  } else {
    zoom = atof(argv[4]);
    cx = atof(argv[2]);
    cy = atof(argv[3]);
  }

  vector&lt;p2t::Point*&gt; polyline;

  if(random_distribution) {
    // Create a simple bounding box
    polyline.push_back(new Point(min,min));
    polyline.push_back(new Point(min,max));
    polyline.push_back(new Point(max,max));
    polyline.push_back(new Point(max,min));
  } else {
    // Load pointset from file

    // Parse and tokenize data file
    string line;
    ifstream myfile(argv[1]);
    if (myfile.is_open()) {
      while (!myfile.eof()) {
        getline(myfile, line);
        if (line.size() == 0) {
          break;
        }
        istringstream iss(line);
        vector&lt;string&gt; tokens;
        copy(istream_iterator&lt;string&gt;(iss), istream_iterator&lt;string&gt;(),
             back_inserter&lt;vector&lt;string&gt; &gt;(tokens));
        double x = StringToDouble(tokens[0]);
        double y = StringToDouble(tokens[1]);
        polyline.push_back(new Point(x, y));
        num_points++;
      }
      myfile.close();
    } else {
      cout &lt;&lt; ""File not opened"" &lt;&lt; endl;
    }
  }

  cout &lt;&lt; ""Number of constrained edges = "" &lt;&lt; polyline.size() &lt;&lt; endl;
  polylines.push_back(polyline);

  Init();

  /*
   * Perform triangulation!
   */

  double init_time = glfwGetTime();

  /*
   * STEP 1: Create CDT and add primary polyline
   * NOTE: polyline must be a simple polygon. The polyline's points
   * constitute constrained edges. No repeat points!!!
   */
  CDT* cdt = new CDT(polyline);

  /*
   * STEP 2: Add holes or Steiner points if necessary
   */

  string s(argv[1]);
  if(s.find(""dude.dat"", 0) != string::npos) {
    // Add head hole
    vector&lt;Point*&gt; head_hole = CreateHeadHole();
    num_points += head_hole.size();
    cdt-&gt;AddHole(head_hole);
    // Add chest hole
    vector&lt;Point*&gt; chest_hole = CreateChestHole();
    num_points += chest_hole.size();
    cdt-&gt;AddHole(chest_hole);
    polylines.push_back(head_hole);
    polylines.push_back(chest_hole);
  } else if (random_distribution) {
    max-=(1e-4);
    min+=(1e-4);
    for(int i = 0; i &lt; num_points; i++) {
      double x = Random(Fun, min, max);
      double y = Random(Fun, min, max);
      cdt-&gt;AddPoint(new Point(x, y));
    }
  }

  /*
   * STEP 3: Triangulate!
   */
  cdt-&gt;Triangulate();

  double dt = glfwGetTime() - init_time;

  triangles = cdt-&gt;GetTriangles();
  map = cdt-&gt;GetMap();

  cout &lt;&lt; ""Number of points = "" &lt;&lt; num_points &lt;&lt; endl;
  cout &lt;&lt; ""Number of triangles = "" &lt;&lt; triangles.size() &lt;&lt; endl;
  cout &lt;&lt; ""Elapsed time (ms) = "" &lt;&lt; dt*1000.0 &lt;&lt; endl;

  MainLoop(zoom);

  // Cleanup

  delete cdt;

  // Free points
  for(int i = 0; i &lt; polylines.size(); i++) {
    vector&lt;Point*&gt; poly = polylines[i];
    FreeClear(poly);
  }

  ShutDown(0);
  return 0;
}

void Init()
{
  const int window_width = 800,
            window_height = 600;

  if (glfwInit() != GL_TRUE)
    ShutDown(1);
  // 800 x 600, 16 bit color, no depth, alpha or stencil buffers, windowed
  if (glfwCreateWindow(window_width, window_height,""Poly2Tri - C++"", NULL, NULL))
    ShutDown(1);

  glfwSwapInterval(1);

  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glClearColor(0.0, 0.0, 0.0, 0.0);
  glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
}

void ShutDown(int return_code)
{
  glfwTerminate();
  exit(return_code);
}

void MainLoop(const double zoom)
{
  // the time of the previous frame
  double old_time = glfwGetTime();
  // this just loops as long as the program runs
  bool running = true;

  while (running) {
    // calculate time elapsed, and the amount by which stuff rotates
    double current_time = glfwGetTime(),
           delta_rotate = (current_time - old_time) * rotations_per_tick * 360;
    old_time = current_time;

    // escape to quit, arrow keys to rotate view
    // Check if ESC key was pressed or window was closed

    // z axis always rotates
    rotate_z += delta_rotate;

    // Draw the scene
    if (draw_map) {
      DrawMap(zoom);
    } else {
      Draw(zoom);
    }

    // swap back and front buffers
    glfwPollEvents();
  }
}

void ResetZoom(double zoom, double cx, double cy, double width, double height)
{
  double left = -width / zoom;
  double right = width / zoom;
  double bottom = -height / zoom;
  double top = height / zoom;

  // Reset viewport
  glLoadIdentity();
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  // Reset ortho view
  glOrtho(left, right, bottom, top, 1, -1);
  glTranslatef(-cx, -cy, 0);
  glMatrixMode(GL_MODELVIEW);
  glDisable(GL_DEPTH_TEST);
  glLoadIdentity();

  // Clear the screen
  glClear(GL_COLOR_BUFFER_BIT);
}

void Draw(const double zoom)
{
  // reset zoom
  Point center = Point(cx, cy);

  ResetZoom(zoom, center.x, center.y, 800, 600);

  for (int i = 0; i &lt; triangles.size(); i++) {
    Triangle&amp; t = *triangles[i];
    Point&amp; a = *t.GetPoint(0);
    Point&amp; b = *t.GetPoint(1);
    Point&amp; c = *t.GetPoint(2);

    // Red
    glColor3f(1, 0, 0);

    glBegin(GL_LINE_LOOP);
    glVertex2f(a.x, a.y);
    glVertex2f(b.x, b.y);
    glVertex2f(c.x, c.y);
    glEnd();
  }

  // green
  glColor3f(0, 1, 0);

  for(int i = 0; i &lt; polylines.size(); i++) {
    vector&lt;Point*&gt; poly = polylines[i];
    glBegin(GL_LINE_LOOP);
      for(int j = 0; j &lt; poly.size(); j++) {
        glVertex2f(poly[j]-&gt;x, poly[j]-&gt;y);
      }
    glEnd();
  }
}

void DrawMap(const double zoom)
{
  // reset zoom
  Point center = Point(cx, cy);

  ResetZoom(zoom, center.x, center.y, 800, 600);

  list&lt;Triangle*&gt;::iterator it;
  for (it = map.begin(); it != map.end(); it++) {
    Triangle&amp; t = **it;
    Point&amp; a = *t.GetPoint(0);
    Point&amp; b = *t.GetPoint(1);
    Point&amp; c = *t.GetPoint(2);

    ConstrainedColor(t.constrained_edge[2]);
    glBegin(GL_LINES);
    glVertex2f(a.x, a.y);
    glVertex2f(b.x, b.y);
    glEnd( );

    ConstrainedColor(t.constrained_edge[0]);
    glBegin(GL_LINES);
    glVertex2f(b.x, b.y);
    glVertex2f(c.x, c.y);
    glEnd( );

    ConstrainedColor(t.constrained_edge[1]);
    glBegin(GL_LINES);
    glVertex2f(c.x, c.y);
    glVertex2f(a.x, a.y);
    glEnd( );
  }
}

void ConstrainedColor(bool constrain)
{
  if (constrain) {
    // Green
    glColor3f(0, 1, 0);
  } else {
    // Red
    glColor3f(1, 0, 0);
  }
}

vector&lt;Point*&gt; CreateHeadHole() {

  vector&lt;Point*&gt; head_hole;
  head_hole.push_back(new Point(325, 437));
  head_hole.push_back(new Point(320, 423));
  head_hole.push_back(new Point(329, 413));
  head_hole.push_back(new Point(332, 423));

  return head_hole;
}

vector&lt;Point*&gt; CreateChestHole() {

  vector&lt;Point*&gt; chest_hole;
  chest_hole.push_back(new Point(320.72342,480));
  chest_hole.push_back(new Point(338.90617,465.96863));
  chest_hole.push_back(new Point(347.99754,480.61584));
  chest_hole.push_back(new Point(329.8148,510.41534));
  chest_hole.push_back(new Point(339.91632,480.11077));
  chest_hole.push_back(new Point(334.86556,478.09046));

  return chest_hole;

}



double StringToDouble(const std::string&amp; s)
{
  std::istringstream i(s);
  double x;
  if (!(i &gt;&gt; x))
    return 0;
  return x;
}

double Fun(double x)
{
  return 2.5 + sin(10 * x) / x;
}

double Random(double (*fun)(double), double xmin = 0, double xmax = 1)
{
  static double (*Fun)(double) = NULL, YMin, YMax;
  static bool First = true;

  // Initialises random generator for first call
  if (First)
  {
    First = false;
    srand((unsigned) time(NULL));
  }

  // Evaluates maximum of function
  if (fun != Fun)
  {
    Fun = fun;
    YMin = 0, YMax = Fun(xmin);
    for (int iX = 1; iX &lt; RAND_MAX; iX++)
    {
      double X = xmin + (xmax - xmin) * iX / RAND_MAX;
      double Y = Fun(X);
      YMax = Y &gt; YMax ? Y : YMax;
    }
  }

  // Gets random values for X &amp; Y
  double X = xmin + (xmax - xmin) * rand() / RAND_MAX;
  double Y = YMin + (YMax - YMin) * rand() / RAND_MAX;

  // Returns if valid and try again if not valid
  return Y &lt; fun(X) ? X : Random(Fun, xmin, xmax);
}
</code></pre>

<p>This is a file test of a library ( for triangulation in c++/opengl)</p>

<p>I used a lot a line compilation like : </p>

<p>cc -o main main.cc -lglfw -framework Cocoa -framework OpenGL -framework IOKit -framework CoreVideo
g++ main.cpp -o main -lglwf
etc..</p>

<p>Someone can help me ?</p>

<p>PS : I'm on MAC OS X</p>
"
"<p>I have an array stored in EEPROM</p>

<p>Starting with {0,0,0,0,1,1,1...} up to 54 elements from address '0'-address'53' and i have cross checked the value and everything is fine.</p>

<p>but when i employ a 'search function' and i have passed '0' as the argument as it searches from 0th address.</p>

<p>unsigned char search(char current_time)</p>

<pre><code>                    {
                        unsigned int    loopcnt = 0;
                        unsigned int   add ;
                        unsigned char   addr = 0;          //We will store start address of 1's here
                        unsigned char lastAddr =current_time;
                                            unsigned int x;
                    add = 0;
                              //If lastAddr is already overflowing, reset it
            if(lastAddr &gt;= 53)
            {
                    lastAddr = 0;
                    addr=53;
                    return(addr);
            }

                    for(loopcnt = lastAddr; loopcnt &lt; 54; loopcnt++)
                {

                    addr = loopcnt;
                                    x=eeread(add);
                                    //This is start location of our scanning
                                        while(x!= 0)
                            {
                                        x=eeread(add);
                    loopcnt++;
                                             add++;
                    //Count the 1's we got!
                    if(loopcnt==53)
                    {
                        addr=53;
                        break;
                    }
                }


                }

                    return (addr);

            }
</code></pre>

<p>But it has to return '4' as value since after the '4'th element is non zero.</p>

<blockquote>
  <p>But it returns 53 always.</p>
</blockquote>

<p>Why is it like that?</p>

<p>Im using c18 compiler..If there is any mistake in logic do correct me.</p>

<p>Regards</p>
"
"<p>I have an assignment to make a shell in C code, and I have a solution that works most of the time. My solution works if the program exists, and I can exit my shell with either <kbd>Control-D</kbd> or by typing exit. But when I try a command that I know doesn't exist, my shell will print an error message saying command not found but I will have to either type exit or press <kbd>Control-D</kbd> the same amount of times as a invalid command was entered i.e. if I type a wrong command 3 times, I then have to hit <kbd>Control-D</kbd> 3 times. I really don't know what is going on here. I checked all the variables and read is -1 when I press <kbd>Control-D</kbd> but the if statement seems to be skipped.</p>

<p>Here is the parts of my source code that I think the problem is in:</p>

<p>comp20200Shell.c</p>

<pre><code>#include ""comp20200Shell_header.h""
#include &lt;signal.h&gt;


/*
 * Name: ****
 * Student Number: ****
 * Email: ****
 *
 * This is the main function of my shell implementation.
 *
 */
int main(void)
{
    bool end_program = false;
    size_t length = 0;
    ssize_t read;
    char* current_directory = NULL;
    char* current_time = NULL;

    /* Sets up signal handler to catch SIGINT*/
    if(signal(SIGINT, sigintHandler) == SIG_ERR)
    {
        error(""An error occured while setting a signal handler\n"");
    }

    /* Infinitive loop, so after command or invalid comman will prompt again*/
    while(end_program != true)
    {
        char* input = NULL;

        /* Gets current working directory */
        current_directory = return_current_directory();

        /* Gets current date and time */
        current_time = return_time();

        /* Prints Prompt */
        printf(""%s\x5b%s\x5d %s%s %s%s%s"", MAGENTA_TEXT, current_time, GREEN_TEXT, current_directory, BLUE_TEXT, PROMPT, RESET_COLOUR);

        /* Frees the pointers returned by return_time() and return_current_directory() */
        free(current_time);
        free(current_directory);

        /* Reads one line from standard input */
        read = getline(&amp;input, &amp;length, stdin);

        /* Checks if ctrl d, i.e. end of file is found or exit is typed */
        if(strcmp(input, ""exit\n"") == 0 || read == -1)
        {
            if(read == -1)
            {
                putchar('\n');
            }
            /* Frees input */
            free(input);
            return(0);
        }

        /* Removes newline character that will be at the end */
        remove_trailing_newline(input);

        /* Passes input to process input, and the return value is passed in to process errors */
        process_errors(process_input(&amp;input));

        /* Frees input */
        free(input);
    }

    return(0);
}
</code></pre>

<p>process_input.c</p>

<pre><code>#include ""comp20200Shell_header.h""
#include &lt;sys/wait.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

/*
 * Name: ****
 * Student Number: ****
 * Email: ****
 *
 * This function is used to process the command entered by the user
 *
 * return: the error value or 0 when everything whent ok
 * arguments: the command entered by the user
 *
 */
int process_input(char** input)
{
    bool redirect_stdout = false;
    bool redirect_stderr = false;

    pid_t child_pid;
    int child_status;
    char** argument = malloc(sizeof(char*));
    int count = 0;

    char* temp = strtok(*input, "" "");
    while(temp != NULL)
    {
        argument[count] = temp;
        count ++;
        argument = realloc(argument, (count+2) * sizeof(char *));
        temp = strtok(NULL, "" "");
    }
    argument[count] = NULL;

    if(argument[0] == NULL)
    {
        return(0);
    }
    else if(strcmp(argument[0], ""cd"") == 0)
    {
        return(change_directory(argument[1]));
    }

    int index;
    for(index = 1; argument[index] != NULL; index++)
    {
        if(strcmp(argument[index], ""&gt;0"") == 0)
        {
            if(argument[index + 1] == NULL)
            {
                return(EINVAL);
            }
            redirect_stdout = true;
            break;
        }
        else if(strcmp(argument[index], ""&gt;2"") == 0)
        {
            if(argument[index + 1] == NULL)
            {
                return(EINVAL);
            }
            redirect_stderr = true;
            break;
        }
    }


    child_pid = fork();
    if(child_pid == 0)
    {
        int file;
        if(redirect_stdout == true)
        {
            file = open(argument[index + 1], O_WRONLY|O_CREAT|O_TRUNC, 0666);
            dup2(file, 1);
            edit_arguments(argument, index);
            execvp(argument[0], argument);
            return(-1);
        }
        else if(redirect_stderr == true)
        {
            file = open(argument[index + 1], O_WRONLY|O_CREAT|O_TRUNC, 0666);
            dup2(file, 2);
            edit_arguments(argument, index);
            execvp(argument[0], argument);
            return(-1);
        }

        execvp(argument[0], argument);
        return(-1);
    }
    else
    {
        wait(&amp;child_status);
    }

    return(child_status);
}
</code></pre>

<p>comp20200Shell_header.h</p>

<pre><code>/*
 * Name: ****
 * Student Number: ****
 * Email: ****
 *
 * This is my header file, It includes all common used headerfiles on the top.
 * Any specific header file that is only used once will be included with the .c file that needs it.
 *
 */

/* included headerfiles begin */
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;
#include &lt;stdbool.h&gt;
/* included headerfiles end */

/* defenitions begin */
#define PROMPT ""# ""
#define BUFFER_SIZE 1024
#define BLUE_TEXT ""\x1B[34m""
#define MAGENTA_TEXT ""\x1B[35m""
#define GREEN_TEXT ""\x1B[32m""
#define RESET_COLOUR ""\x1B[0m""
/* defenitions end */

/* Function prototypes begin */
void remove_trailing_newline(char *input);
void sigintHandler(int sig_num);
int process_input(char** input);
char* return_time(void);
void error(const char *fmt, ...);
int change_directory(char* path);
char* return_current_directory(void);
void process_errors(int return_value);
void edit_arguments(char** argument, int index);
/* Function prototypes end */
</code></pre>

<p>I have omitted the rest of the source code as I don't think the problem is there.</p>
"
"<p>I am trying to read the forces of some joints in gazebosim, but after i upgraded to version 2.2.2 from 1.9 it doesn't work anymore.</p>

<p>The SDF file:



        false</p>

<pre><code>     &lt;link name='left_foot'&gt;
       &lt;pose&gt;0 0.255502204764 0.04 0 0 0&lt;/pose&gt;
       &lt;inertial&gt;
         &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;
         &lt;inertia&gt;
           &lt;ixx&gt;0.0075&lt;/ixx&gt;
           &lt;ixy&gt;0&lt;/ixy&gt;
           &lt;ixz&gt;0&lt;/ixz&gt;
           &lt;iyy&gt;0.00&lt;/iyy&gt;
           &lt;iyz&gt;0&lt;/iyz&gt;
           &lt;izz&gt;0.00&lt;/izz&gt;
         &lt;/inertia&gt;
         &lt;mass&gt;2.25&lt;/mass&gt;
       &lt;/inertial&gt;
       &lt;collision name='left_foot_collision'&gt;
         &lt;geometry&gt;
           &lt;box&gt;
             &lt;size&gt;.1 .2 .08&lt;/size&gt;
           &lt;/box&gt;
         &lt;/geometry&gt;

       &lt;surface&gt;
         &lt;bounce&gt;
           &lt;restitution_coefficient&gt; 0.0 &lt;/restitution_coefficient&gt;
           &lt;threshold&gt; 1000000000 &lt;/threshold&gt;
         &lt;/bounce&gt;
       &lt;/surface&gt;

       &lt;/collision&gt;
       &lt;visual name='left_foot_visual'&gt;
         &lt;geometry&gt;
           &lt;box&gt;
             &lt;size&gt;.1 .2 .08&lt;/size&gt;
           &lt;/box&gt;
         &lt;/geometry&gt;
       &lt;/visual&gt;
     &lt;/link&gt;

     &lt;link name='leftlower_leg'&gt;
       &lt;pose&gt;0 0.294832856462 0.221086146856 6.01787954503 0 0&lt;/pose&gt;
       &lt;inertial&gt;
         &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;
         &lt;inertia&gt;
           &lt;ixx&gt;0.0225&lt;/ixx&gt;
           &lt;ixy&gt;0&lt;/ixy&gt;
           &lt;ixz&gt;0&lt;/ixz&gt;
           &lt;iyy&gt;0.0225&lt;/iyy&gt;
           &lt;iyz&gt;0&lt;/iyz&gt;
           &lt;izz&gt;0.0225&lt;/izz&gt;
         &lt;/inertia&gt;
         &lt;mass&gt;3.&lt;/mass&gt;
       &lt;/inertial&gt;
       &lt;collision name='leftlower_leg_collision'&gt;
         &lt;geometry&gt;
           &lt;box&gt;
             &lt;size&gt;.1 .1 .3&lt;/size&gt;
           &lt;/box&gt;
         &lt;/geometry&gt;

       &lt;surface&gt;
         &lt;bounce&gt;
           &lt;restitution_coefficient&gt; 0.0 &lt;/restitution_coefficient&gt;
           &lt;threshold&gt; 1000000000 &lt;/threshold&gt;
         &lt;/bounce&gt;
       &lt;/surface&gt;

       &lt;/collision&gt;
       &lt;visual name='leftlower_leg_visual'&gt;
         &lt;geometry&gt;
           &lt;box&gt;
             &lt;size&gt;.1 .1 .3&lt;/size&gt;
           &lt;/box&gt;
         &lt;/geometry&gt;
       &lt;/visual&gt;
     &lt;/link&gt;

     &lt;link name='leftupper_leg'&gt;
       &lt;pose&gt;0 0.241130401436 0.542882746013 6.76700690559 0 0&lt;/pose&gt;
       &lt;inertial&gt;
         &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;
         &lt;inertia&gt;
           &lt;ixx&gt;0.0533&lt;/ixx&gt;
           &lt;ixy&gt;0&lt;/ixy&gt;
           &lt;ixz&gt;0&lt;/ixz&gt;
           &lt;iyy&gt;0.0533&lt;/iyy&gt;
           &lt;iyz&gt;0&lt;/iyz&gt;
           &lt;izz&gt;0.0533&lt;/izz&gt;
         &lt;/inertia&gt;
         &lt;mass&gt;4.&lt;/mass&gt;
       &lt;/inertial&gt;
       &lt;collision name='leftupper_leg_collision'&gt;
         &lt;geometry&gt;
           &lt;box&gt;
             &lt;size&gt;.1 .1 .4&lt;/size&gt;
           &lt;/box&gt;
         &lt;/geometry&gt;

       &lt;surface&gt;
         &lt;bounce&gt;
           &lt;restitution_coefficient&gt; 0.0 &lt;/restitution_coefficient&gt;
           &lt;threshold&gt; 1000000000 &lt;/threshold&gt;
         &lt;/bounce&gt;
       &lt;/surface&gt;

       &lt;/collision&gt;
       &lt;visual name='leftupper_leg_visual'&gt;
         &lt;geometry&gt;
           &lt;box&gt;
             &lt;size&gt;.1 .1 .4&lt;/size&gt;
           &lt;/box&gt;
         &lt;/geometry&gt;
       &lt;/visual&gt;
     &lt;/link&gt;


     &lt;link name='right_foot'&gt;
       &lt;pose&gt;0 0.0 0.04 0 0 0&lt;/pose&gt;
       &lt;inertial&gt;
         &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;
         &lt;inertia&gt;
           &lt;ixx&gt;0.0075&lt;/ixx&gt;
           &lt;ixy&gt;0&lt;/ixy&gt;
           &lt;ixz&gt;0&lt;/ixz&gt;
           &lt;iyy&gt;0.0&lt;/iyy&gt;
           &lt;iyz&gt;0&lt;/iyz&gt;
           &lt;izz&gt;0.0&lt;/izz&gt;
         &lt;/inertia&gt;
         &lt;mass&gt;2.25&lt;/mass&gt;
       &lt;/inertial&gt;
       &lt;collision name='right_foot_collision'&gt;
         &lt;geometry&gt;
           &lt;box&gt;
             &lt;size&gt;.1 .2 .08&lt;/size&gt;
           &lt;/box&gt;
         &lt;/geometry&gt;

       &lt;surface&gt;
         &lt;bounce&gt;
           &lt;restitution_coefficient&gt; 0.0 &lt;/restitution_coefficient&gt;
           &lt;threshold&gt; 1000000000 &lt;/threshold&gt;
         &lt;/bounce&gt;
       &lt;/surface&gt;

       &lt;/collision&gt;
       &lt;visual name='right_foot_visual'&gt;
         &lt;geometry&gt;
           &lt;box&gt;
             &lt;size&gt;.5 .2 .08&lt;/size&gt;
           &lt;/box&gt;
         &lt;/geometry&gt;
       &lt;/visual&gt;
     &lt;/link&gt;

     &lt;link name='rightlower_leg'&gt;
       &lt;pose&gt;0 0.0892702896712 0.200543831788 2.50415869759 0 0&lt;/pose&gt;
       &lt;inertial&gt;
         &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;
         &lt;inertia&gt;
           &lt;ixx&gt;0.0225&lt;/ixx&gt;
           &lt;ixy&gt;0&lt;/ixy&gt;
           &lt;ixz&gt;0&lt;/ixz&gt;
           &lt;iyy&gt;0.0225&lt;/iyy&gt;
           &lt;iyz&gt;0&lt;/iyz&gt;
           &lt;izz&gt;0.0225&lt;/izz&gt;
         &lt;/inertia&gt;
         &lt;mass&gt;3.&lt;/mass&gt;
       &lt;/inertial&gt;
       &lt;collision name='rightlower_leg_collision'&gt;
         &lt;geometry&gt;
           &lt;box&gt;
             &lt;size&gt;.1 .1 .3&lt;/size&gt;
           &lt;/box&gt;
         &lt;/geometry&gt;

       &lt;surface&gt;
         &lt;bounce&gt;
           &lt;restitution_coefficient&gt; 0.0 &lt;/restitution_coefficient&gt;
           &lt;threshold&gt; 1000000000 &lt;/threshold&gt;
         &lt;/bounce&gt;
       &lt;/surface&gt;

       &lt;/collision&gt;
       &lt;visual name='rightlower_leg_visual'&gt;
         &lt;geometry&gt;
           &lt;box&gt;
             &lt;size&gt;.1 .1 .3&lt;/size&gt;
           &lt;/box&gt;
         &lt;/geometry&gt;
       &lt;/visual&gt;
     &lt;/link&gt;

     &lt;link name='rightupper_leg'&gt;
       &lt;pose&gt;0 0.163318937026 0.520507576335 3.21777453298 0 0&lt;/pose&gt;
       &lt;inertial&gt;
         &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;
         &lt;inertia&gt;
           &lt;ixx&gt;0.0533&lt;/ixx&gt;
           &lt;ixy&gt;0&lt;/ixy&gt;
           &lt;ixz&gt;0&lt;/ixz&gt;
           &lt;iyy&gt;0.0533&lt;/iyy&gt;
           &lt;iyz&gt;0&lt;/iyz&gt;
           &lt;izz&gt;0.0533&lt;/izz&gt;
         &lt;/inertia&gt;
         &lt;mass&gt;4.&lt;/mass&gt;
       &lt;/inertial&gt;
       &lt;collision name='rightupper_leg_collision'&gt;
         &lt;geometry&gt;
           &lt;box&gt;
             &lt;size&gt;.1 .1 .4&lt;/size&gt;
           &lt;/box&gt;
         &lt;/geometry&gt;

       &lt;surface&gt;
         &lt;bounce&gt;
           &lt;restitution_coefficient&gt; 0.0 &lt;/restitution_coefficient&gt;
           &lt;threshold&gt; 1000000000 &lt;/threshold&gt;
         &lt;/bounce&gt;
       &lt;/surface&gt;

       &lt;/collision&gt;
       &lt;visual name='rightupper_leg_visual'&gt;
         &lt;geometry&gt;
           &lt;box&gt;
             &lt;size&gt;.1 .1 .4&lt;/size&gt;
           &lt;/box&gt;
         &lt;/geometry&gt;
       &lt;/visual&gt;
     &lt;/link&gt;

  &lt;joint type=""revolute"" name=""right_ankle_hinge""&gt;
    &lt;physics&gt;
          &lt;ode&gt;
        &lt;provide_feedback&gt;true&lt;/provide_feedback&gt;
          &lt;/ode&gt;
    &lt;/physics&gt;
    &lt;pose&gt;0 0.0 0.15 0 0 0&lt;/pose&gt;
    &lt;child&gt;rightlower_leg&lt;/child&gt;
    &lt;parent&gt;right_foot&lt;/parent&gt;
    &lt;axis&gt;
     &lt;xyz&gt;1 0 0&lt;/xyz&gt;
    &lt;/axis&gt;
  &lt;/joint&gt;

  &lt;joint type=""revolute"" name=""right_knee_hinge""&gt;
    &lt;physics&gt;
          &lt;ode&gt;
        &lt;provide_feedback&gt;true&lt;/provide_feedback&gt;
          &lt;/ode&gt;
    &lt;/physics&gt;
    &lt;pose&gt;0 0 0.2 0 0 0&lt;/pose&gt;
    &lt;child&gt;rightupper_leg&lt;/child&gt;
    &lt;parent&gt;rightlower_leg&lt;/parent&gt;
    &lt;axis&gt;
     &lt;xyz&gt;1 0 0&lt;/xyz&gt;
    &lt;/axis&gt;
  &lt;/joint&gt;

  &lt;joint type=""revolute"" name=""hip_hinge""&gt;
    &lt;physics&gt;
          &lt;ode&gt;
        &lt;provide_feedback&gt;true&lt;/provide_feedback&gt;
          &lt;/ode&gt;
    &lt;/physics&gt;
    &lt;pose&gt;0 0 0.2 0 0 0&lt;/pose&gt;
    &lt;child&gt;leftupper_leg&lt;/child&gt;
    &lt;parent&gt;rightupper_leg&lt;/parent&gt;
    &lt;axis&gt;
     &lt;xyz&gt;1 0 0&lt;/xyz&gt;
    &lt;/axis&gt;
  &lt;/joint&gt;

  &lt;joint type=""revolute"" name=""left_knee_hinge""&gt;
    &lt;physics&gt;
          &lt;ode&gt;
        &lt;provide_feedback&gt;true&lt;/provide_feedback&gt;
          &lt;/ode&gt;
    &lt;/physics&gt;
    &lt;pose&gt;0 0 0.15 0 0 0&lt;/pose&gt;
    &lt;child&gt;leftlower_leg&lt;/child&gt;
    &lt;parent&gt;leftupper_leg&lt;/parent&gt;
    &lt;axis&gt;
     &lt;xyz&gt;1 0 0&lt;/xyz&gt;
    &lt;/axis&gt;
  &lt;/joint&gt;

  &lt;joint type=""revolute"" name=""left_ankle_hinge""&gt;
    &lt;physics&gt;
          &lt;ode&gt;
        &lt;provide_feedback&gt;true&lt;/provide_feedback&gt;
          &lt;/ode&gt;
    &lt;/physics&gt;
    &lt;pose&gt;0 0 0.04 0 0 0&lt;/pose&gt;
    &lt;child&gt;left_foot&lt;/child&gt;
    &lt;parent&gt;leftlower_leg&lt;/parent&gt;
    &lt;axis&gt;
     &lt;xyz&gt;1 0 0&lt;/xyz&gt;
    &lt;/axis&gt;
  &lt;/joint&gt;



    &lt;plugin name=""set_joints"" filename=""build/libmy_robot.so""/&gt;
  &lt;/model&gt;
&lt;/sdf&gt;
</code></pre>

<p>And the plugin:
    #include
    #include
    #include
    //#include  //denne er added for at bruge getsimtime
    #include
    #include
    #include  // sleep function you added yourself
    #include  //These two lines you added to use the function getforcetorque
    #include  //These two lines you added to use the function getforcetorque
    #include
    #include </p>

<pre><code>int a=0;
int b;
double angle;
double currenttime;
double PI = 3.141592654;
double pi=3.14159265359;



namespace gazebo
{

  class SetJoints : public ModelPlugin
  {
    public: void Load(physics::ModelPtr _parent, sdf::ElementPtr /*_sdf*/)
    {
     // Store the pointer to the model
     this-&gt;model = _parent;

     //this-&gt;j2_controller = new physics::JointController(model);



     this-&gt;jointleftankle_ = this-&gt;model-&gt;GetJoint(""left_ankle_hinge"");
     this-&gt;jointrightankle_ = this-&gt;model-&gt;GetJoint(""right_ankle_hinge"");
     this-&gt;jointleftknee_ = this-&gt;model-&gt;GetJoint(""left_knee_hinge"");
     this-&gt;jointrightknee_ = this-&gt;model-&gt;GetJoint(""right_knee_hinge"");
     this-&gt;jointhip_ = this-&gt;model-&gt;GetJoint(""hip_hinge"");

     //j2_controller-&gt;SetJointPosition(this-&gt;model-&gt;GetJoint(""hip_hinge""), 0.0);


     // Listen to the update event. This event is broadcast every
     // simulation iteration.






     this-&gt;updateConnection = event::Events::ConnectWorldUpdateBegin(
         boost::bind(&amp;SetJoints::OnUpdate, this, _1));
    }

    // Called by the world update start event
    public: void OnUpdate(const common::UpdateInfo &amp; /*_info*/)
    {

     common::Time current_time = this-&gt;model-&gt;GetWorld()-&gt;GetSimTime();//her henter du simtime


     double initialrightanklepos=0.93336237079397688;
     double initialrightkneepos=0.71361583539276363;
     double initialhippos=3.5492323726052324;
     double initialleftkneepos=0.82166896624278996-PI/2.;
     double initialleftanklepos=+(initialrightanklepos+initialrightkneepos+initialhippos+initialleftkneepos)-1.*PI;




     double dt    = current_time.Double()
                  - this-&gt;last_update_time_.Double();





     physics::JointWrench wrenchleftankle = this-&gt;jointleftankle_-&gt;GetForceTorque(0);
     physics::JointWrench wrenchrightankle = this-&gt;jointrightankle_-&gt;GetForceTorque(0);
     //physics::JointWrench wrenchleftknee = this-&gt;jointleftknee_-&gt;GetForceTorque(0);
     //physics::JointWrench wrenchrightknee = this-&gt;jointrightknee_-&gt;GetForceTorque(0);
     //physics::JointWrench wrenchhip = this-&gt;jointhip_-&gt;GetForceTorque(0);

     //double test1 = wrenchrightankle.body1Force.z;
     //double test2 = wrenchleftankle.body2Force.z;
     //printf(""right ankle z:%lf\t left ankle z:%lf\n"",test1, test2);



     this-&gt;last_update_time_ = current_time;


     a++;


    }

    common::Time last_update_time_;

    // Pointer to the model
    private: physics::ModelPtr model;

    // Pointer to the update event connection
    private: event::ConnectionPtr updateConnection;

    //private: physics::JointController * j2_controller;

    //common::Time last_update_time_; Denne er ikke n?dvendig.

    //ting til at gemme joint_ i
    physics::JointPtr jointleftankle_;
    physics::JointPtr jointrightankle_;
    physics::JointPtr jointleftknee_;
    physics::JointPtr jointrightknee_;
    physics::JointPtr jointhip_;
    //physics::JointPtr joint;

  };

  // Register this plugin with the simulator
  GZ_REGISTER_MODEL_PLUGIN(SetJoints)
}
</code></pre>

<p>I get the error: </p>

<p>Warning [ODEJoint.cc:1105] GetForceTorque: forgot to set ?</p>

<p>printed in the terminal.</p>
"
"<p>This is part of my code in visual studio 2010. However I'm getting the  ""IntelliSense: identifier ""GetTickCount"" is undefined"" from the compiler. I do not know how to fix it.  </p>

<pre><code>typedef enum {FALSE = 0, TRUE} BOOL;

int main(int argc, char* argv[]){
double current_Time;
current_Time = GetTickCount()/1000.0 - start/1000;
....
</code></pre>

<p>those are the includes I have in the code</p>

<pre><code> #include &lt;stdio.h&gt;
 #include &lt;time.h&gt;
 #include &lt;math.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;conio.h&gt;
</code></pre>
"
"<p>I have a function that uses difftime to detect the time in seconds since the communication heartbeat has stopped.  This function could run as fast as every 50 milliseconds.  The function seems to work except once in a while it returns 65535.  I can reduce the execution to once a second since the return of difftime is only in seconds.  But I don't know if it will fix the problem.  Is it the problem because I am not properly casting the difftime return back to uint16_t from double?  </p>

<p>This program runs in an ubuntu 64bit machine.</p>

<p>Please help.  Thanks. </p>

<pre><code>uint16_t commlost(uint16_t heartbeat_read_cur)
{
    time_t current_time;
    static time_t previous_time;
    static uint16_t commlost_secs_cur = 0;
    static uint16_t commlost_secs_prev = 0;
    static uint16_t heartbeat_read_prev = 0;
    static bool first_time = TRUE;
    if (first_time)
    {
        previous_time = time(NULL);
        first_time = FALSE;
    }

    time(&amp;current_time);

    commlost_secs_prev = commlost_secs_cur;

    if(heartbeat_read_prev == heartbeat_read_cur)
    {

        commlost_secs_cur += difftime(current_time, previous_time);
    }
    else
    {
        heartbeat_read_prev = heartbeat_read_cur;
        commlost_secs_cur = 0;
    }

    previous_time = current_time;

    return (commlost_secs_cur);
}
</code></pre>
"
"<p>I want to record a key-value in persistent mode but when I want to use 2 or more different stores it doesn't work.</p>

<p>Here's my script: </p>

<pre><code>    ...
    typedef struct{
       kv_t  *kv;
       char  *name;
    } kv_data;

    int main(int argc, char *argv[])
    {
       kv_data **data = (kv_data**)get_env(argv, US_SERVER_DATA);
       if(!data[0]){
          data[0] = (kv_data*)calloc(1, sizeof(kv_data));
          if(!data[0]){
             return 500;
          }
          kv_t users;
          kv_init(&amp;users, ""users"", 10, 0, 0, 0);
          data[0]-&gt;kv = &amp;users;

          kv_item item;
          item.key = ""pierre"";
          item.klen = sizeof(""pierre"") - 1;
          item.val = ""pierre@example.com"";
          item.flags = 0;
          kv_add(data[0]-&gt;kv, &amp;item);

          data[0]-&gt;name = strdup(""users"");
       }
    ...
</code></pre>

<p>This error is in line 15 with the kv_init() function.</p>

<p>My wish would be for example to use <strong>data[0]->kv</strong> to read and record value in ""<strong><em>users</em></strong>"" store and to use <strong>data[1]->kv</strong> to read and record value in <strong><em>other</em></strong> store...</p>
"
"<p>I'm working on the some kind of a system service (actually it's just a log parser) written in Python. This program should work continuously for a long time (hopefully I mean days and weeks without failures and needs of restart). That's why I am concerned about memory consumption.</p>

<p>I put together different information about process memory usage from different sites into one simple function:</p>

<pre><code>#!/usr/bin/env python
from pprint import pprint
from guppy import hpy
from datetime import datetime
import sys
import os
import resource
import re

def debug_memory_leak():
    #Getting virtual memory size
    pid = os.getpid()
    with open(os.path.join(""/proc"", str(pid), ""status"")) as f:
        lines = f.readlines()
    _vmsize = [l for l in lines if l.startswith(""VmSize"")][0]
    vmsize = int(_vmsize.split()[1])

    #Getting physical memory size
    pmsize = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss

    #Analyzing the dynamical memory segment - total number of objects in memory and heap size
    h = hpy().heap()
    if __debug__:
        print str(h)
    m = re.match(
        ""Partition of a set of ([0-9]+) objects. Total size = ([0-9]+) bytes(.*)"", str(h))
    objects = m.group(1)
    heap = int(m.group(2))/1024 #to Kb

    current_time = datetime.now().strftime(""%H:%M:%S"")
    data = (current_time, objects, heap, pmsize, vmsize)
    print(""\t"".join([str(d) for d in data]))
</code></pre>

<p>This function has been used to study the dynamics of the memory consumption of my long-playing process, and I still cannot explain its behavior. You can see that the heap size and total amount of the objects did not changed while the physical and virtual memory increased by 11% and 1% during these twenty minutes.</p>

<p><strong>UPD:</strong> The process has been working for almost 15 hours by this moment. The heap is still the same, but the physical memory increased sixfold and the virtual memory increased by 50%. The curve is seem to be linear excepting the strange outliers at 3:00 AM: </p>

<blockquote>
  <p>Time Obj      Heap    PhM    VM</p>

  <p>19:04:19  31424   3928    5460    143732</p>

  <p>19:04:29  30582   3704    10276   158240</p>

  <p>19:04:39  30582   3704    10372   157772</p>

  <p>19:04:50  30582   3709    10372   157772</p>

  <p>19:05:00  30582   3704    10372   157772</p>

  <p>(...)</p>

  <p>19:25:00  30583   3704    11524   159900</p>

  <p>09:53:23  30581   3704    62380   210756</p>
</blockquote>

<p>I wonder what is going on with the address space of my process. The constant size of heap suggests that all of the dynamical objects are deallocated correctly. But I have no doubt that growing memory consumption will affect the sustainability of this life-critical process in the long run.</p>

<p><img src=""https://i.stack.imgur.com/9gsGB.png"" alt=""enter image description here""></p>

<p>Could anyone clarify this issue please? Thank you.</p>

<p>(I use RHEL 6.4, kernel 2.6.32-358 with Python 2.6.6)</p>
"
"<p>i've found this piece of code and tested it.</p>

<pre><code>#include &lt;time.h&gt;

int main ()
{
  time_t start_time;
  time_t current_time;
  int TIMEOUT=5;
  start_time = time(NULL);
  current_time = time(NULL);

  while (current_time &lt; start_time + TIMEOUT)
  {
  //do everything here
  current_time = time(NULL);
  }

}
</code></pre>

<p>It works like a charm, but it takes completely one cpu off.
Is there a way to don't waste so much cpu?
Thanks</p>

<p>Edit, I can't use sleep, i must do other thing during waiting</p>
"
"<p>I am reading from a text file line by line, in each line is formated like</p>

<pre><code>05/20/2014 10:18:28 am

m/d/y h:m:s
</code></pre>

<p>How can I compare this with current date and select dates that are not less than one week?
This is what I have done so far but I'm wondered if there is any other easier way:</p>

<pre><code>$arr = explode(' ',trim($line));
$fword = explode(""/"", $fword);
$fword =  $arr[0];
list($m,$d,$y) = explode(""/"", $line);
mm= date('m');
dd = date('d');
</code></pre>

<p>By the way, I am writing to text file in this format:</p>

<pre><code>$date = date('m/d/Y h:i:s a', time());
</code></pre>
"
"<p>I'm using Fluent 14.5.7 and I have some programming error while using my UDF.
The simulation I'm trying to solve is a desulfurization process in an horizontal fixed bed reactor. It works perfectly before including the UDF with the reactions (between CaO and SO2).
I've tried changing some parameters, returning a constant value (replacing *rr=60*k*Beta*NSO2 with *rr=60), and some others things, but the same error appeared.</p>

<p>Here is my C code:</p>

<pre><code>/*********************************************************************/
#include ""udf.h""
#include ""sg_mphase.h""
DEFINE_HET_RXN_RATE(SO2_capture , c, t, hr, mw,yi, rr, rr_t)
{
Thread **pt = THREAD_SUB_THREADS(t);
Thread *tg = pt[0];
Thread *ts = pt[1];
real XCaO = C_YI(c,ts,0); /* Para checkear que hay sorbente*/
real XSO2 = C_YI(c,tg,0); /* Fraccion masica SO2 en la fase gas*/
real mwSO2 = 64.0638;
real DENS_Gas = C_R(c,tg); /* Si hay problemas se puede considerar que es constante*/
real VReac=6333.843; /* Volumen total del reactor en cm? */
real NSO2 = XSO2 / mwSO2 * DENS_Gas * VReac; /* Controla el valor de NSO2 */
real Time_min = CURRENT_TIME / 60;

/*valores de constantes a 400?C */

real EDiff = -49300; /*mejor sacar el negativo de la potencia*/
real aa1 = 2.10e-03;
real aa2 = 12.9e-02;
real aa3 = -0.66;  /*mejor sacar el negativo de la potencia*/
real kdiff = aa1 * exp (EDiff/(8.314 * C_T(c,t))) * (1 + aa2 * exp (aa3*Time_min));
real aa4 = 0.82;
real aa5 = -1;  /*mejor sacar el negativo de la potencia*/
real Beta = (1 - aa4 * exp (aa5*Time_min));
real k0 = 1.78e-02;
real Ea = -13900;  /*mejor sacar el negativo de la potencia*/
real ks = k0 * exp (Ea/(8.314 * C_T(c,t)));
real k = (ks * kdiff)/(ks + kdiff);
if (XCaO != 0)
{
     *rr = 60 * k * Beta * NSO2;
}
else
{
     *rr = 0;
}
/*return;*/
}

/****************************************************************/
</code></pre>

<p>When I run my simulation, it apperead the following error: </p>

<pre><code>===============================================================================
Stack backtrace generated for process id 27426 on signal 1 :
1000000: /usr/local/ansys_inc/v154/fluent/fluent14.5.7/lnamd64/2ddp/fluent.14.5.7 [0x166a164]
1000000: /usr/local/ansys_inc/v154/fluent/fluent14.5.7/lnamd64/2ddp/fluent.14.5.7 [0x166a8d3]
1000000: /lib64/libpthread.so.0 [0x3736e0eca0]
1000000: Kin_Sulp_3/lnamd64/2ddp/libudf.so(SO2_capture+0x9b) [0x2afee78f644f]
Check the file fluenterror.log for details.
Please include this information with any bug report you file on this issue!
===============================================================================

Error: fluent.14.5.7 received a fatal signal (SEGMENTATION VIOLATION).
Error Object: #f
</code></pre>

<p>The fluenterror.log file gives the following information:</p>

<pre><code>Received signal 1 [time 5/21/14 13:23:5]
1000000: /usr/local/ansys_inc/v145/fluent/fluent14.5.7/lnamd64/2ddp/fluent.14.5.7 [0x166a287]
1000000: /usr/local/ansys_inc/v145/fluent/fluent14.5.7/lnamd64/2ddp/fluent.14.5.7 [0x166a8d3]
1000000: /lib64/libpthread.so.0 [0x3736e0eca0]
1000000: Kin_Sulp_3/lnamd64/2ddp/libudf.so(SO2_capture+0x9b) [0x2afee78f644f]

Error [client] [time 5/21/14 13:23:6] fluent.14.5.7 received a fatal signal (SEGMENTATION VIOLATION).
999999:/usr/local/ansys_inc/v145/fluent/fluent14.5.7/lnamd64/2ddp/fluent.14.5.7(CX_Primitive_Error+0x204) [0x166a704]
999999: /usr/local/ansys_inc/v145/fluent/fluent14.5.7/lnamd64/2ddp/fluent.14.5.7 [0x166a91f]
999999: /lib64/libpthread.so.0 [0x3736e0eca0]
999999: Kin_Sulp_3/lnamd64/2ddp/libudf.so(SO2_capture+0x9b) [0x2afee78f644f]
</code></pre>

<p>Any suggestion will be appreciate and if you need any more information I'll be glad to give it.</p>

<p>Thanks!!</p>
"
"<p>I have dates in the following format for a set of past events:</p>

<pre><code>year-m-day hour:second

e.g. 2014-05-25 20:41
</code></pre>

<p>These dates are based on Brussels time (GMT + 1hr + (1hr summer time)).</p>

<p>I am attempting to calculate how much time has passed since an event started by taking this date/time and minusing it from current date/time as follows:</p>

<pre><code>$current_time = time();
$event_time = date('2014-05-25 20:41');

echo ($current_time - $event_time)
</code></pre>

<p>However, due to the timezone, the date is two hours ahead of Unix time.</p>

<p>Is there a simple way to accurately convert from Brussels summer time to Unix bearing in mind summer time kicks in each year on a different date?</p>
"
"<p>basically I need to implement a pause feature in my game (which is a simplified version of frogger) which stops the logs scrolling, and ignores any other input until the character p is pressed again). The way I've started to implement this in a while loop is to end it once another p Is pressed.</p>

<pre><code>if(serial_input == 'p' || serial_input == 'P') {
    while(1){

        //need to pause the game
        if(serial_input == 'p' || serial_input == 'P')
            break;
    }
</code></pre>

<p>This is how my logs are currently scrolling: </p>

<pre><code>/* The following statements change the scrolling speeds of the individual logs */
current_time = get_clock_ticks();

if(is_frog_alive() &amp;&amp; current_time &gt;= last_move_time1 + 1000) {
    scroll_lane(0, 1);
    last_move_time1 = current_time;
} else if(is_frog_alive() &amp;&amp; current_time &gt;= last_move_time2 + 600) {
            scroll_lane(1, -1);
            last_move_time2 = current_time;
} else if(is_frog_alive() &amp;&amp; current_time &gt;= last_move_time3 + 800) {
            scroll_lane(2, 1);
            last_move_time3 = current_time;
} else if(is_frog_alive() &amp;&amp; current_time &gt;= last_move_time4 + 900) {
            scroll_log_channel(0, -1);
            last_move_time4 = current_time;
} else if(is_frog_alive() &amp;&amp; current_time &gt;= last_move_time5 + 1200) {
            scroll_log_channel(1, 1);
            last_move_time5 = current_time;
</code></pre>

<p>And this is implemented by a timer as described:</p>

<pre><code>* We update a global clock tick variable - whose value
* can be retrieved using the get_clock_ticks() function.
*/
</code></pre>

<p>Any suggestions would be greatly appreciated</p>
"
"<p>So I am working on scheduling, including FCFS and Shortest Job First. I am really struggling with my Shortest Job First, I can't see my logic error. I have it print out, and some of the numbers are correct, but not all of them. The test file that I use has the following text:</p>

<pre><code>1   0   6
2   3   2
3   5   1
4   9   7
5   10  5
6   12  3
7   14  4
8   16  5
9   17  7
10  19  2
</code></pre>

<p>I use the &lt; command to just redirect the input to come from the file when testing, so something of the sort of <code>./a.out &lt; test.txt</code>.</p>

<p>Any help, pointers or code, would be much appreciated!</p>

<p><em>edit</em> I think that my problem is logic based in the sfj function. For the input, the first column is the process id, the second is the time of arrival and the third is the burst time or how long the process needs with the cpu. </p>

<p>The output I get is:</p>

<pre><code>Shortest Job First
PID     WAIT    TURNAROUND
1       0       6
2       15      17
3       3       4
4       0       7
5       6       11
6       9       12
7       10      14
8       12      17
9       16      23
10      21      23
Average Wait: 9 Average Turnaround 13
</code></pre>

<p>When I actually expect:</p>

<pre><code>Shortest Job First

Pid     Wait    Turnaround
1       0       6
2       4       6
3       1       2
4       0       7
5       15      20
6       4       7
7       7       11
8       14      19
9       18      25
10      0       2
Average wait: 6.3 Average turnaround: 10.5
</code></pre>

<hr>

<pre><code>//  File.c
//  Project6
//
//  Created by Chris on 6/19/14.

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;termios.h&gt;
#include &lt;signal.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;
#define LINELEN 512
#define MAX_PROCESS 100

typedef struct process
{
    int ID;
    int arrival_time;
    int time_to_completion;
    int wait_time;
    int turn_around;
    int active;

}process;
void fcfs(struct process[MAX_PROCESS], int);
void sjf (struct process[MAX_PROCESS], int);
void srtn(struct process[MAX_PROCESS], int);
void rr (struct process[MAX_PROCESS], int);
void rrc(struct process[MAX_PROCESS], int);
void print_info(struct process[MAX_PROCESS], int);
void sort_by_time(struct process array[MAX_PROCESS], int num_valid_pid);

int main(int ac,char *av[])
{
    int counter=0;
    int p1=0, p2=0, p3=0;
    process array[MAX_PROCESS];
    while ( scanf(""%d %d %d"", &amp;p1, &amp;p2, &amp;p3) != EOF ){//Get all the info available and put it in array of structs
        array[counter].ID = p1;
        array[counter].arrival_time = p2;
        array[counter].time_to_completion = p3;
        counter++;
    }
    fcfs(array, counter);
    sjf (array, counter);
    /*srtn(array, counter);
    rr (array, counter);
    rrc(array, counter);*/
    return 0;
}
void fcfs(struct process array[MAX_PROCESS], int num_pid){
    //for loop num_pid
    int i;
    int current_time = 0;
    for(i=0; i&lt;num_pid; i++){
    //if arrival is &lt; current time, wait time = current time - arrival
        if(array[i].arrival_time &lt; current_time)
            array[i].wait_time = current_time - array[i].arrival_time;
    //if arrival is &gt;= current time, wait time = 0;
        else if(array[i].arrival_time &gt;= current_time)
            array[i].wait_time = 0;
    //current time = current time + wait time + time to completion
        current_time= current_time + array[i].time_to_completion;
    //turnaround time = wait time + time to completion
        array[i].turn_around = array[i].wait_time + array[i].time_to_completion;
    }
    printf(""First Come First Serve\n"");
    print_info(array, num_pid);
}
void sjf (struct process array[MAX_PROCESS], int num_pid){
    printf(""Shortest Job First\n"");//for the output so we know what algorithm
    //create an array of pids that are valid to search.
    int num_valid_processes = 0, current_time=0, i,j, next_process, counter = 0;//declarations
    process to_sort[MAX_PROCESS];

    //we want to do this next loop for as many processes as we have, or num_pid
    for(j=0; j&lt;num_pid; j++){
        //adds all the available processes to the to sort array to be sorted
        //available means that it has arrived, which means it is &lt;= current_time
        //after it gets all the processes, it breaks out of the for loop
        for(i=counter; i&lt;num_pid; i++){
            if(array[i].arrival_time&lt;=current_time){
                to_sort[i]=array[i];
                num_valid_processes++;
                counter++;
            }
            else
                break;
        }
        //sort the to_sort array by the time_to_completion
        sort_by_time(to_sort,num_valid_processes);

        //set the wait time and turnaround time for the next process
        next_process = to_sort[0].ID;
        array[next_process].wait_time = current_time-array[next_process].arrival_time;
        array[next_process].turn_around = array[next_process].wait_time + array[next_process].time_to_completion;
        //change the current_time and continue
        //current time = current time + wait time + time to completion
        current_time= current_time + array[next_process].time_to_completion;

        //delete the process we just worked on so we don't get duplicates.
        num_valid_processes--;
        for(i=0;i&lt;num_valid_processes;i++){
            to_sort[i]=to_sort[i+1];
        }
    }
    //loop back up to get available processes
    //now all the info in out first array is filled out, print it out.
    print_info(array, num_pid);
}

void print_info(struct process array[MAX_PROCESS], int num_pid){
    int i;
    int tot_wait=0, tot_turn = 0;
    printf(""\x1b[04mPID\tWAIT\tTURNAROUND\n\x1b[24m"");
    for(i=0; i&lt;num_pid; i++){
        printf(""%d\t%d\t%d\n"", array[i].ID, array[i].wait_time, array[i].turn_around);
        tot_wait=tot_wait+array[i].wait_time;
        tot_turn = tot_turn +array[i].turn_around;
    }
    printf(""Average Wait: %d Average Turnaround %d\n"", tot_wait/num_pid, tot_turn/num_pid);
}

void sort_by_time(struct process array[MAX_PROCESS], int num_valid_pid)
{
    int i,j;
    for (i = 0; i &lt; num_valid_pid; i++)
    {
        int min = i;
        for (j = i+1; j &lt; num_valid_pid; j++)
            if (array[j].time_to_completion &lt; array[min].time_to_completion)
                min = j;
        process temp = array[i];
        array[i] = array[min];
        array[min] = temp;
    }
}
</code></pre>
"
"<p>I am working on Shortest Remaining Time Next Scheduling, where I must check every 1 time unit to see if there is another job that has a shorter time remaining left, if equal keep the current process. For the input I use:</p>

<pre><code>PID     ArrivalTime Burst/ExecutionTime
1       0           6
2       3           2
3       5           1
4       9           7
5       10          5
6       12          3
7       14          4
8       16          5
9       17          7
10      19          2
</code></pre>

<p>and my output: (on the left is what I am getting, the right is what it should be):</p>

<pre><code>PID     WAIT    TURNAROUND              PID     WAIT    TURNAROUND
1       0       9                       1       0       9
2       0       2                       2       0       2
3       0       1                       3       0       1
4       0       26                      4       0       26
5       0       14                      5       0       5
6       0       3                       6       3       6
7       1       5                       7       4       10
8       8       13                      8       8       13
9       18      25                      9       18      25
10      0       2                       10      0       2

Average Wait: 2.7 Ave Turnaround 10.0  Average Wait: 3.3 Average Turnaround 9.9
</code></pre>

<p>I have not been able to narrow down where the problem is in the srtn function, All but 3 of my outputs are correct, which is even more confusing! Any help would be appreciated!</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;termios.h&gt;
#include &lt;signal.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/types.h&gt;
#define LINELEN 512
#define MAX_PROCESS 100
#define TIME_QUANTUM 1
typedef struct process
{
    int ID;
    int arrival_time;
    int time_to_completion;
    double wait_time;
    double turn_around;
    double time_wait;
    int active;

}process;
void fcfs(struct process[MAX_PROCESS], int);
void sjf (struct process[MAX_PROCESS], int);
void srtn(struct process[MAX_PROCESS], int);
void rr (struct process[MAX_PROCESS], int);
void rrc(struct process[MAX_PROCESS], int);
void print_info(struct process[MAX_PROCESS], int);
void sort_by_time(struct process array[MAX_PROCESS], int num_valid_pid);

int main(int ac,char *av[])
{
    int counter=0;
    int p1=0, p2=0, p3=0;
    process array[MAX_PROCESS];
    while ( scanf(""%d %d %d"", &amp;p1, &amp;p2, &amp;p3) != EOF ){//Get all the info available and put it in array of structs
        array[counter].ID = p1;
        array[counter].arrival_time = p2;
        array[counter].time_to_completion = p3;
        array[counter].active = 0;
        counter++;
    }
    //fcfs(array, counter);
    //sjf (array, counter);
    srtn(array, counter);
    /*rr (array, counter);
    rrc(array, counter);*/
    return 0;
}
void srtn(struct process array[MAX_PROCESS], int num_pid){
    printf(""Shortest Remaining Time Next\n"");//for the output so we know what algorithm
    //create an array of pids that are valid to search.
    int num_valid_processes = 0, current_time=0, i,j, next_process, counter = 0, fin_pid = 0, keep_going=0;//declarations
    process to_sort[MAX_PROCESS];
    //we want to do this next loop for as many processes as we have, or num_pid
    while(keep_going!=1){
        //adds all the available processes to the to sort array to be sorted
        //available means that it has arrived, which means it is &lt;= current_time
        //after it gets all the processes, it breaks out of the for loop
        for(i=counter; i&lt;num_pid; i++){
            if(array[i].arrival_time&lt;=current_time){
                to_sort[num_valid_processes]=array[i];
                num_valid_processes++;
                counter++;
            }
            else
                break;
        }
        //sort the to_sort array by the time_to_completion
        sort_by_time(to_sort,num_valid_processes);
        //set the wait time and turnaround time for the next process
        next_process = to_sort[0].ID-1;
        if(array[next_process].active==0){//the id hasn't had the wait time calculated yet
            array[next_process].wait_time = current_time-array[next_process].arrival_time;
            array[next_process].active=1;
            array[next_process].time_wait = current_time;
        }
        if(array[next_process].time_to_completion &lt;= TIME_QUANTUM){
            array[next_process].turn_around = array[next_process].wait_time + (current_time-array[next_process].time_wait)+array[next_process].time_to_completion;
            fin_pid++;
            //delete the process we just worked on so we don't get duplicates.
            num_valid_processes--;
            for(i=0;i&lt;num_valid_processes;i++){
                to_sort[i]=to_sort[i+1];
            }
        }
        else{
            array[next_process].time_to_completion = array[next_process].time_to_completion - TIME_QUANTUM;
            //to_sort[0].time_to_completion = to_sort[next_process].time_to_completion - TIME_QUANTUM;
        }
        current_time = current_time+TIME_QUANTUM;
        if(fin_pid==num_pid)
            keep_going=1;
    }
    print_info(array, num_pid);
}


void print_info(struct process array[MAX_PROCESS], int num_pid){
    int i;
    double tot_wait=0, tot_turn = 0;
    printf(""\x1b[04mPID\tWAIT\tTURNAROUND\n\x1b[24m"");
    for(i=0; i&lt;num_pid; i++){
        printf(""%d\t%.0f\t%.0f\n"", array[i].ID, array[i].wait_time, array[i].turn_around);
        tot_wait=tot_wait+array[i].wait_time;
        tot_turn = tot_turn +array[i].turn_around;
    }
    printf(""Average Wait: %.1f Average Turnaround %.1f\n"", tot_wait/num_pid, tot_turn/num_pid);
}

void sort_by_time(struct process array[MAX_PROCESS], int num_valid_pid)
{
    int i,j;
    for (i = 0; i &lt; num_valid_pid; i++)
    {
        int min = i;
        for (j = i+1; j &lt; num_valid_pid; j++){
            if (array[j].time_to_completion &lt; array[min].time_to_completion)
                min = j;
            if (array[j].time_to_completion == array[min].time_to_completion){
                if(array[j].ID&lt;array[min].ID)
                    min = j;
            }
        }
        process temp = array[i];
        array[i] = array[min];
        array[min] = temp;
    }
}
</code></pre>
"
"<p>I need to write a perl script that executes a command at a specified time.</p>

<ol>
<li>use net::ssh::expect to login to a router</li>
<li>read the time from the router's clock (""show clock"" command displays the time.)</li>
<li>At the 17:30:00 execute a command.</li>
</ol>

<p>I tried writing script for it but it doesn't work. Any suggestions please ?</p>

<pre><code>use strict;
use warnings;
use autodie;
use feature qw/say/;
use Net::SSH::Expect;

my $Time;
my $ssh = Net::SSH::Expect-&gt;new(
    host     =&gt; ""ip"",
    password =&gt; 'pwd',
    user     =&gt; 'user name',
    raw_pty  =&gt; 1,
);

my $login_output = $ssh-&gt;login();

while(1) {
    $Time = localtime();
    if( $Time == 17:30:00 ) {
        my $cmd = $ssh-&gt;exec(""cmd"");
        print($cmd);
    } else {
        print"" Failed to execute the cmd \n"";
    }
}
</code></pre>
"
"<p>I have developed an application for dental offices which sends automatic email and sms reminders at preset time of the day. This will be a local php application installed on client's machine since the database is local. I want to make it a monthly subscription service. In order to implement the subscription logic, my idea is to keep a text file on my server which will have an expiration date. The local application will read the contents of the text file to make sure that the subscription is not expired. </p>

<p>Now the problem is, when I use file() or file_get_contents() function in my script to read the text file on my server (for example, www.abcde.com/expiration.txt), it keeps forever to read the text file. Now if I directly put the url of the text file in seperate browser window, it opens it right away. Once I do that, the php script works fine. Again after a while, same cycle starts.</p>

<ul>
<li>Am I missing something here?</li>
<li>Is there a better way to achieve the subscription logic? </li>
</ul>

<p>My php application is 'local' using wamp server.</p>
"
"<p>I am trying to create a subscription based licensing system, where if you buy a software for 1 year 1 user, you can use it only for a year in the machine you used to activate the software, after which you will have to renew your license key. This is pretty basic but implementing the same of your own is a total different scenario. </p>

<p>So let me discuss what I did so far: (Code not included let me know if you want me to paste them)</p>

<p>First I have a hosted MySQL DB, in which I have a database which stores all the license related information (Products , serial_keys, Plans etc.)</p>

<p>So, when you start the software for a the first time it checks for a few values in the registry (multiple locations) , if not found it shall ask you for a serial key.</p>

<p>Once you have entered the serial key, the software shall connect to the DB and validate your key and compute the following</p>

<ol>
<li>Validate the serial key</li>
<li>Compute a Unique machine ID - Fetch BIOS_SL , MB_SL , HDD_SL , add them into one string and MD5 it.</li>
<li>Compute License Validity - Get Internet Current time , Increment the year with the plan duration</li>
<li>Store the following information in the registry (Multiple Locations) - license_id , machine_id, valid_till, activation_date, last_updated &amp; license_status</li>
</ol>

<p>A few Logical steps skipped here like if the license is already activated, check and match the registered machine_id</p>

<p>So the software is registered. Now, I every time the software starts it will again look for those values in the registry and make a decision based on it, here is where I am stuck and need your expert advice.</p>

<ol>
<li>Software starts</li>
<li>Checks Registry values</li>
<li>Generates machine_id and matches it with the one stored</li>
<li>Reads valid_till value (expiry date) and matches it with the current time.</li>
</ol>

<p>Considering that the user has no internet and used it for one time activation or his internet plan expired, How can I make a legitimate check for the date? Can't use system time they are very much vulnerable. </p>

<p>At this moment I think of creating a service which will have a call back function to act whenever the user tries to change the system date. But this is tedious and I suppose not the best solution.</p>

<p>Or Record the system time at boot and depend on that, but then the user can change it via BIOS even before the system boots.</p>

<p>Sorry for such a long question, but had to explain the entire scenario.</p>

<p><strong>In a nutshell, user doesn't have internet connection how to maintain or fetch a legitimate source for date/time calls?</strong></p>
"
"<p>I have an application that starts up and processes queued items. The items are processed at a timer framed rate. This is implemented using the ACE_Reactor class.</p>

<p>The bit of code that kicks this off is:</p>

<pre><code>void start() {
  ACE_Reactor::instance()-&gt;schedule_timer( this, NULL, ACE_Time_Value(0,1000), ACE_Time_Value(0,1000) );
  ACE_Reactor::instance()-&gt;run_reactor_event_loop();
}

handle_timeout (const ACE_Time_Value &amp;current_time, const void *act) {
  &lt;Process item&gt;

  If (more items left)
    return 0;
  else
    return -1;
}
</code></pre>

<p>This causes the handle_timeout() method to be called which then processes one item off the queue. While there are more items in the queue the callback returns 0. When the queue is empty the callback returns -1 which stops the reactor loop.</p>

<p>The problem is that when the method returns -1 <code>run_reactor_event_loop();</code> is still blocking. I'd like the application to complete return a status code and exit. I am having a hard time finding good documentation w/ examples.</p>

<p>Am I missing something?</p>
"
"<p>I want to write a scrapper with python that crawl some urls and scrape and save datas.
I know how can I write it as a simple program. I'm looking for a way to deploy it on my virtual server (running ubuntu) as a service to make it non-stop crawling.
Could any one tell me How can I do this?</p>
"
"<p>I'm writing a shell script that has to find files.</p>

<p>In particular file names are like this one: some_text_years.month.day_hour
So for each day I have 24 files, my script has to find files dated one day before. </p>

<p>Files to be found are in the same directory where the script.sh is located.</p>

<p>Therefore if today is 20/08 my script has to find all the 24 files created the day before, ie. the 19.</p>

<p>So my script looks like:</p>

<pre><code>#!/bin/bash
base_name=""some_text_""
year_mounth=`date +%Y.%m.`
today=$(date +%d)
yestarday=`expr $today - 1`
foo_variable=$base_name$year_mounth$yestarday #concatenation
pattern=""$foo_variable*""#concatenation with *
find . -name ""$pattern"" -exec some commands ..
</code></pre>

<p>The script does not work.. I don't understand the reason..
.. maybe the problem is the <code>*</code> operator not well interpreted by the find ?</p>

<p>Instead the following command line, given in terminal, works fine</p>

<pre><code>find . -name 'some_text_2014.08.19*'
</code></pre>

<p>Example of file name:</p>

<ul>
<li>some_text_2014.08.19_00</li>
<li><p>some_text_2014.08.19_01
...</p></li>
<li><p>some_text_2014.08.19_23</p></li>
</ul>

<p>No output from script.. it does not given error..</p>

<p>Can anyone help me ?</p>

<p>Please comments your answer in order to let me (and the other who read the post) understand where i do a mistake.</p>

<p>Please help to improve my script. Don't post any other different script solution.</p>

<p>Thanks in advance</p>
"
"<p>I did not manage to find how can I create txt file in C , for example ""test.txt"" and then to append to the file name current date and time? Every time when program runs it will create test.txt but with different date and time?  this. For now I'm creating txt file simply using open function with flags, but I'm not sure how to append date and time ?</p>

<pre><code> fd = open(""test.txt"", O_RDWR | O_CREAT | O_APPEND, 0777);
</code></pre>

<p>Thx</p>
"
"<p>I'm having a bit of an issue with some code I'm writing for a Linux script.
Here's the code:</p>

<pre><code>report_home_space ()
{
if [[ $(id -u) -eq 0 ]]; then
        cat &lt;&lt; _eof_
                 &lt;H2&gt;Home Space Utilization (All Users)&lt;/H2&gt;
                 &lt;PRE&gt;$(du -sh /home/*)&lt;/PRE&gt;
               _eof_
else
        cat &lt;&lt; _eof_
                 &lt;H2&gt;Home Space Utilization ($USER)&lt;/H2&gt;
                 &lt;PRE&gt;$(du -sh $HOME)&lt;/PRE&gt;
               _eof_
fi
return
}
</code></pre>

<p>There are other functions in the script but they all work correctly. The script is pulling the error around an end of file token somewhere in this snippet of code but I can't find it. I have the fi statement for the if statement and my end of file tokens all match up. </p>

<p>Any help would be greatly appreciated. </p>

<p>After going through some of the answers that were provided I was able to get rid of the initial unexpected eof error but the same error is happening again but in a different location in my script. (line 58 to be exact, the last line of the script). I'll provide the entire script so it can be examined.</p>

<pre><code>#!/bin/bash


#Program is used to output sys info as a web page

TITLE=""System Information Report for $HOSTNAME""
CURRENT_TIME=$(date +""%x %r %Z"")
TIME_STAMP=""Generated $CURRENT_TIME, by $USER""

report_uptime ()
{
cat &lt;&lt;- _eof_
           &lt;H2&gt;System uptime&lt;/H2&gt;
           &lt;PRE&gt;$(uptime)&lt;/PRE&gt;
       _eof_
return
}

report_disk_space ()
{
cat &lt;&lt;- _eof_
           &lt;H2&gt;Disk space utilization&lt;/H2&gt;
           &lt;PRE&gt;$(df -h)&lt;/PRE&gt;
       _eof_
return
}

report_home_space () {
 if [[ $(id -u) -eq 0 ]]; then
                cat &lt;&lt;- _eof_
                           &lt;H2&gt;Home Space Ultilization (All Users)&lt;/H2&gt;
                           &lt;PRE&gt;$(du -sh /home/*)&lt;/PRE&gt;
                           _eof_
        else
                cat &lt;&lt;- _eof_
                           &lt;H2&gt;Home Space Ultilization ($USER)&lt;/H2&gt;
                           &lt;PRE&gt;$(du -sh $HOME)&lt;/PRE&gt;
                           _eof_
        fi
        return
}


cat &lt;&lt;- _eof_
      &lt;HTML&gt;
           &lt;HEAD&gt;
                     &lt;TITLE&gt;$TITLE&lt;/TITLE&gt;
           &lt;/HEAD&gt;
           &lt;BODY&gt;
                       &lt;H1&gt;$TITLE&lt;/H1&gt;
                       &lt;P1&gt;$TIME_STAMP&lt;/P1&gt;
                       $(report_uptime)
                       $(report_disk_space)
                       $(report_home_space)
           &lt;/BODY&gt;
      &lt;/HTML&gt;
_eof_
</code></pre>

<p>I tried moving the EOFs to the beginning of the lines and the didn't do much. This script is in a command line book that I'm reading and I copied the script exactly and it's throwing the EOF errors. I'm guessing because the book might be outdated. </p>

<p>Once again thanks for all of the help. </p>
"
"<p>Below is the part of my script.
The ""set -e"" will make the script exit whenever a negative return code comes from any of the commands.</p>

<p>But, when the below select statement returns no rows from the table, the script exits there itself (echo ""Get Eg names end""  is not executed). Which means the  below command is giving negative return code.</p>

<pre><code>db2 -x ""SELECT EG_NAME FROM MS.CFG_CACHE_REFRESH WHERE
EG_RELOAD_UPD_BK2_TS &lt; M_TABLE_UPD_TS AND CURRENT_TIME &gt;= EG_RELOAD_START_TIME AND
CURRENT_TIME &lt;= EG_RELOAD_END_TIME""
&gt; /home/DummyUser/gm4/logs/MP_CACHE_REFRESH_TEMP_BK2.txt
</code></pre>

<p>If the select statement returns some rows, it works fine. The script doesn't exit and runs till the end.</p>

<p>My requirement is to exit if a genuine error occurs, like unable to connect database, invalid syntax etc.
If no rows are returned from the table, it should not be considered as an error.</p>

<p>Why am I getting a -ve return code for the select query not returning rows and how can I handle this?</p>

<p>Below is the part of the script:</p>

<pre><code>#!/bin/ksh
set -e
brokername=$1

if [ ""$#"" -ne  ""1"" ]
  then
echo ""Invalid arugments supplied""
echo ""call the script using command:""
echo ""MP_CACHE_REFRESH_BRK2.ksh &lt;BrokerName&gt;""

exit -1
 fi

touch /home/DummyUser/gm4/logs/MP_CACHE_REFRESH_TEMP_BK2.txt
chmod 777 /home/DummyUser/gm4/logs/MP_CACHE_REFRESH_TEMP_BK2.txt
db2 CONNECT TO MSAPP USER DummyUser using paasss
db2 -x ""SELECT EG_NAME FROM MS.CFG_CACHE_REFRESH WHERE EG_RELOAD_UPD_BK2_TS &lt; M_TABLE_UPD_TS AND CURRENT_TIME &gt;= EG_RELOAD_START_TIME AND CURRENT_TIME &lt;= EG_RELOAD_END_TIME"" &gt; /home/DummyUser/gm4/logs/MP_CACHE_REFRESH_TEMP_BK2.txt
echo ""Get Eg names end""
</code></pre>
"
"<p>I am making a little project for streamers of Twitch.tv. This program will basically measure the amount of times the word ""Kappa"" is used, per minute, on the website's chat box. Now I was wondering, what kind of formula could I use to measure the average and the current amount of times the string ""Kappa"" is used per minute, given that I could test it using console input?</p>
"
"<p>I have a data set names jobs that are currently running. I want to monitor them to see if they are running longer then normal, defined by thresholds.</p>

<ul>
<li>Each job has a average run time. I know the current time and start
time. I have four conditions to evaluate and if true consider flag.
<ol>
<li>average &lt;5 min jobs = if they are running longer then 4x there average then flag.</li>
<li>average >5&lt;20 min job = running longer then 2x there average then flag</li>
<li>average >20&lt; 3 hours = running longer 1.5 there average then flag</li>
<li>average >3 hours = running longer .5 there average then flag </li>
</ol></li>
</ul>

<p>Finally send all messages for all flag Jobs</p>

<blockquote>
<pre><code> flaged_jobs = [];
    for job in job_bank:
        if job.average_time &lt; 5:
            if (current_time - start_time) == 4 * (current_time - start_time):
                flaged_jobs.append(job)
        elif job.average_time &gt;= 5 and job.average_time &lt; 20 :
            if (current_time - start_time) == 2 * (current_time - start_time):
                flaged_jobs.append(job)
        elif job.average_time &gt;= 5 and job.average_time &lt; 20 :
            if (current_time - start_time) == 1.5 * (current_time - start_time):
                flaged_jobs.append(job)
        else:
            if (current_time - start_time) == .5 * (current_time - start_time):
                flaged_jobs.append(job)

    for flaged in flaged_jobs:
         send_message(flaged)
</code></pre>
</blockquote>

<p>In regards to performance, what is the best way to handle this?  Is my pseudo code a good way to handle this?  Should incorporate a dict instead of list?  Jobs can range from a couple of hundred at one time to a couple of thousands. I'm limited to 2.6x python. What should I name this script as well, maybe runaway_jobs.py?</p>
"
"<p>I created a c program such that when a particular function is called it should create text file ,a path in c/ some foldername/log files. The time,date at which the function is called and terminated  is to be stored in to the text file. I have tried with the code below.</p>

<pre><code>function() {
    FILE *fp;
    char ch;
    time_t current_time;
    char* c_time_string;

    /* Obtain current time as seconds elapsed since the Epoch. */
    current_time = time(NULL);

    if (current_time == ((time_t)-1))
    {
        (void) fprintf(stderr, ""Failure to compute the current time."");
        return EXIT_FAILURE;
    }

    /* Convert to local time format. */
    c_time_string = ctime(&amp;current_time);

    if (c_time_string == NULL)
    {
        (void) fprintf(stderr, ""Failure to convert the current time."");
        return EXIT_FAILURE;
    }


    fp=fopen(""C:\\X2.6\\X_LogFiles\\file.txt"",""w""););

    /* Print to stdout. */

    while((ch=getchar())!=EOF)
    putc( c_time_string,fp);
    fclose(fp);

   return 0;
}
</code></pre>

<p>I am a new beginner in c. i explored but i could not able to find function to write time and the data text file got erased when i am calling the function again</p>

<p>Thanks for reply in advance</p>
"
"<p>I developed a server with c on linux using socket.</p>

<p>The server is runnig without problem. If I made a request from my web browser to the server, The server respond to the request without problem. </p>

<p>But I remarked in the capture traffic (using wireshark) that my server reurns some times (rarely) a tcp error [RST, ACK].</p>

<p>here after the tcp error packet as shown in the wireshark</p>

<p><img src=""https://i.stack.imgur.com/Jpo5x.png"" alt=""TCP error capture""></p>

<p>The 192.168.1.211 is the address of my server</p>

<p>I checked the ""follow tcp stream"", I found that it contains 2 requests (from the web browser). I think it should contains only one request in a given socket. Am I right?</p>

<p>Here after the follow tcp stream:</p>

<p><img src=""https://i.stack.imgur.com/NPPeI.png"" alt=""follow tcp stream""></p>

<p>I do not know if this is a normal error and could happen in the TCP stack? or it's a problem related to my code?</p>

<p><strong>Code:</strong></p>

<pre><code>static void http_cr_new_client(int client, bool service_available)
{
    FILE *fp;
    char buffer[BUFSIZ];
    int8_t auth_status = 0;

    fp = fdopen(client, ""r+"");

    while (fgets(buffer, sizeof(buffer), fp)) {
        if (!strncasecmp(buffer, ""Authorization: Digest "", strlen(""Authorization: Digest ""))) {
            char *username = conf.cpe_userid;
            char *password = conf.cpe_passwd;

            if (!username || !password) {
                // if we dont have username or password configured proceed with connecting to ACS
                service_available = false;
                goto http_end;
            }

            if (http_digest_auth_check(""GET"", ""/"", buffer + strlen(""Authorization: Digest ""), REALM, username, password, 300) == MHD_YES)
                auth_status = 1;
            else
                auth_status = 0;
        }

        if (buffer[0] == '\r' || buffer[0] == '\n') {
            /* end of http request (empty line) */
            goto http_end;
        }
    }
    if(!service_available) {
        goto http_end;
    }

http_error:
        /* here we are because of an error, e.g. timeout */
    goto http_done;

http_end:
    if (!service_available) {
        MY_LOG (INFO,""Receive Connection Request: Return 503 Service Unavailable"");
        fputs(""HTTP/1.1 503 Service Unavailable\r\n"", fp);
        fputs(""Connection: close\r\n"", fp);
    } else if (auth_status) {
        MY_LOG (INFO,""Receive Connection Request: success authentication"");
        fputs(""HTTP/1.1 200 OK\r\n"", fp);
        fputs(""Content-Length: 0\r\n"", fp);
        http_success_cr();
    } else {
        MY_LOG (INFO,""Receive Connection Request: Return 401 Unauthorized"");
        fputs(""HTTP/1.1 401 Unauthorized\r\n"", fp);
        fputs(""Connection: close\r\n"", fp);
        http_digest_auth_fail_response(fp, ""GET"", ""/"", REALM, OPAQUE);
        fputs(""\r\n"", fp);
    }
    fputs(""\r\n"", fp);
http_done:
    fclose(fp);
    close(client);
}

void http_server_init(void)
{
    int socket_desc , client_sock , c , *new_sock;
    struct sockaddr_in server , client;
    static int cr_request = 0;
    static time_t restrict_start_time = 0;
    time_t current_time;
    bool service_available;

    for(;;) {
        //Create socket
        socket_desc = socket(AF_INET , SOCK_STREAM , 0);
        if (socket_desc == -1)
        {
            MY_LOG (ERROR,""Could not open server socket for Connection Requests"");
            sleep(1);
            continue;
        }

        //Prepare the sockaddr_in structure
        server.sin_family = AF_INET;
        server.sin_addr.s_addr = INADDR_ANY;
        server.sin_port = htons(conf.connection_request_port);

        /* enable SO_REUSEADDR */
        int reusaddr = 1;
        if (setsockopt(socket_desc, SOL_SOCKET, SO_REUSEADDR, &amp;reusaddr, sizeof(int)) &lt; 0) {
            MY_LOG (WARNING,""setsockopt(SO_REUSEADDR) failed"");
        }

        //Bind
        if( bind(socket_desc,(struct sockaddr *)&amp;server , sizeof(server)) &lt; 0)
        {
            //print the error message
            MY_LOG (ERROR,""Could not bind server socket for Connection Requests"");
            sleep(1);
            continue;
        }
        break;
    }

    MY_LOG (INFO,""Connection Request server initiated"");

    //Listen
    listen(socket_desc , 3);

    //Accept and incoming connection
    c = sizeof(struct sockaddr_in);
    while( (client_sock = accept(socket_desc, (struct sockaddr *)&amp;client, (socklen_t*)&amp;c)) )
    {
        current_time = time(NULL);
        service_available = true;
        if ((restrict_start_time==0) ||
            ((current_time-restrict_start_time) &gt; CONNECTION_REQUEST_RESTRICT_PERIOD))
        {
            restrict_start_time = current_time;
            cr_request  = 1;
        }
        else
        {
            cr_request++;
            if (cr_request &gt; 70)
            {
                restrict_start_time = current_time;
                service_available = false;
            }
        }
        http_cr_new_client(client_sock, service_available);
    }

    if (client_sock &lt; 0)
    {
        MY_LOG(ERROR,""Could not accept connections for Connection Requests!"");
        return;
    }
}
</code></pre>

<p>Note: I launch the server in the main with <code>pthread_create()</code></p>
"
"<p>I program currently something with SDL2.
All works fine, but I have a problem with the <code>SDL_GetTicks()</code> method.
Normally it should return the total application time in milliseconds, but it always returns most of the time the value 0 and sometimes the value 1.</p>

<p>I initialized SDL with <code>SDL_INIT_EVERYTHING</code> flag.</p>

<p>The problem with the following code is the loop is too fast, so the delta time is smaller than 1 ms. Is there a method to achieve a higher precision?</p>

<pre><code>#include ""Application.hpp""

void Application::Initialize()
{
    int sdl_initialize_result = SDL_Init(SDL_INIT_EVERYTHING);
    if(sdl_initialize_result &lt; 0)
    {
        std::cerr &lt;&lt; ""Failed to initialize SDL !"" &lt;&lt; std::endl &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
    }

    window = SDL_CreateWindow(""Project Unknown"", 100, 100, 800, 600, SDL_WINDOW_SHOWN);
    if(window == nullptr)
    {
        std::cerr &lt;&lt; ""Failed to create  SDL window !"" &lt;&lt; std::endl &lt;&lt; SDL_GetError() &lt;&lt; std::endl;
    }

    last_update_time = SDL_GetTicks();
}

void Application::Dispose()
{
    SDL_DestroyWindow(window);
    SDL_Quit();
}

void Application::Render()
{
}

void Application::Update()
{
    Uint32  current_time = SDL_GetTicks();
    Uint32  delta_time = current_time - last_update_time;


    SDL_Event event;
    while(SDL_PollEvent(&amp;event))
    {
        switch(event.type)
        {
            case SDL_QUIT:
            {
                should_close = true;
            }
            break;

            default:
            {

            }
            break;
        }
    }

    // Update game objects with delta_time

    last_update_time = current_time;
}


void Application::Run()
{
    Initialize();

    should_close = false;
    do
    {
        Render();
        Update();
    }
    while(should_close == false);

    Dispose();
}
</code></pre>
"
"<p>Can anyone tell me why I have an infinite loop when reading from a pipe? I don't understand what I'm doing wrong. <code>message</code> is the name I defined in main top refer to it. MESSAGE is my struct name. It doesn't even print out test value. </p>

<pre><code>if(manager_pid == 0)
{
    printf(""Hello? \n"");
    if(close(pipe1[READING]) != 0)
    {
        printf(""Error in closing pipe1 \n"");
    }
    if(close(pipe2[READING]) != 0)
    {
        printf(""Error in closing pipe2 \n"");
    }
    if(close(pipe3[WRITING]) != 0)
    {
        printf(""Error in closing pipe \n"");
    }
}
i = 0;
printf(""work please \n"");
//test_value = read(pipe3[READING], &amp;boo, sizeof(echo));
//printf(""test_value is %d \n"", test_value);

while(i &lt; 10)
{
    printf(""In while \n"");
    //printf(""Hello?? \n"");
    //test_value = read(pipe3[READING], &amp;boo, sizeof(echo));
    //printf(""test_value is %d \n"", test_value);
    //printf(""Entering infinite loop \n"");
    //printf(""i is %d \n"", i);
    //nbytes = read(pipe3[0], array, 45);
    //printf(""nbytes is %d \n"", nbytes);
    //log_dat_fp = fopen(argv[2], ""a"");
    if(read(pipe3[READING], &amp;message, sizeof(struct MESSAGE)) != -1)
    {
        printf(""Entering if \n"");
        log_dat_fp = fopen(argv[2], ""a"");
        printf(""First if  \n"");
        time(&amp;current_time);
        //if(message.owner == 1 &amp;&amp; (message.instruction == 'r' || message.instruction == 'R'))
        if(message.instruction == 'r' || message.instruction == 'R')
        {
            if(message.owner == 1)
            {
                printf(""message.owner == 1 with r or R \n"");
                fprintf(log_dat_fp, ""Store Manager at time: %s received message %d %d %c %s"", strtok(ctime(&amp;current_time), ""\n""),
                message.owner, getpid(), message.instruction, message.id);
                pclose(log_dat_fp);
            }
            else if(message.owner == 2)
            {
                printf(""message.owner == 2 with r or R  \n"");
                fprintf(log_dat_fp, ""Store Manager at time: %s received message %d %d %c %s"", strtok(ctime(&amp;current_time), ""\n""),
                message.owner, getpid(), message.instruction, message.id);
                pclose(log_dat_fp);
            }
            else
            {
                printf(""You have junk  \n"");
            }
        }
        else if(message.instruction == 'u' || message.instruction == 'U')
        {
            if(message.owner == 1)
            {
                printf(""message.owner == 1 with u or U  \n"");
                fprintf(log_dat_fp, ""Store Manager at time: %s received message %d %d %c %s %d"", strtok(ctime(&amp;current_time), ""\n""),
                message.owner, getpid(), message.instruction, message.id, message.value);
                pclose(log_dat_fp);
            }
            else if(message.owner == 2)
            {
                printf(""message.owner == 2 with u or U  \n"");
                fprintf(log_dat_fp, ""Store Manager at time: %s received message %d %d %c %s %d"", strtok(ctime(&amp;current_time), ""\n""),
                message.owner, getpid(), message.instruction, message.id, message.value);
                pclose(log_dat_fp);
            }
            else
            {
                printf(""You have junk  \n"");
            }
        }
        else
        {
            printf(""manager can't read from pipe\n"");
            exit(1);
        } // read no good
        if(message.instruction == 'r' || message.instruction == 'R')
        {
            if(message.owner == 1)
            {
                for(i = 0; i &lt; 200; i++)
                {
                    if(strcmp(storage, table[i].id) == 0)
                    {
                        match_flag = 1;
                        value = table[i].value;
                    }
                }
                if(match_flag == 1)
                {
                    message.value = value;
                    message.owner = 0;
                    if(write(pipe1[WRITING], &amp;message, sizeof(struct MESSAGE)) == sizeof(struct MESSAGE))
                    {
                        log_dat_fp = fopen(argv[2], ""a"");
                        time(&amp;current_time);
                        fprintf(log_dat_fp, ""Store Manager at time: %s sent message: %c %d %s %d\n"", strtok(ctime(&amp;current_time), ""\n""),
                        message.instruction, message.owner, message.id, message.value);
                        fclose(log_dat_fp);
                    }
                    else
                    {
                        printf(""error returning message to process 1"");
                        exit(1);
                    }
                }
                else
                    message.owner = 1;
                    if(write(pipe1[WRITING], &amp;message, sizeof(struct MESSAGE)) == sizeof(struct MESSAGE))
                    {
                        log_dat_fp = fopen(argv[2], ""a"");
                        time(&amp;current_time);
                        fprintf(log_dat_fp, ""Store Manager at time: %s sent message: %c %d %s \n"", strtok(ctime(&amp;current_time), ""\n""),
                        message.instruction, message.owner, message.id);
                        fclose(log_dat_fp);
                    }

            }
            else if(message.owner == 2)
            {
                printf(""message.owner == 2 with u or U  \n"");
                fprintf(log_dat_fp, ""Store Manager at time: %s received message %d %d %c %s %d"", strtok(ctime(&amp;current_time), ""\n""),
                message.owner, getpid(), message.instruction, message.id, message.value);
                pclose(log_dat_fp);
            }
            else
            {
                printf(""You have junk  \n"");
            }

        }
    }
    else
    {
        printf(""manager had pipe issues.\n"");
        exit(1);
    }// read no good
    i++;
    //log_dat_fp = fopen(argv[2], ""a"");
    printf(""Each pass  \n"");
}
</code></pre>
"
"<p>I have a....unique problem. I'm making a game where I will dynamically draw points(representing cities) with flight paths between them. The user will then select these cities and perform further actions.</p>

<p>Also, the globe has to be able to rotate about one axis, so the user can easily see all the cities. </p>

<p>I've figured out a way to draw points and paths on the sphere. The points are tiny spheres, and the paths are bezier curves I've generated. I;ve enclosed them within a glpushmatrix() and glpopmatrix() along with a glrotate() call in the beginning so that all things(the globe, paths and vertices) rotate in unison</p>

<p>The only problem I'm facing is to figure out which vertex the user has clicked. glrotate modifies the model matrix, so do I have to calculate the new positions of the vertices at every rotation? I'm using glunproject to figure out where the user has clicked.
OR, is there any other way to solve this problem?</p>

<p>Here's my code:-</p>

<pre><code>float venusRotate;
vector&lt;vector3f&gt;cityVertices;

//bezier curve
GLfloat bezierCurve(float t, GLfloat P0,
                    GLfloat P1, GLfloat P2) {
    // Cubic bezier Curve
    GLfloat point = pow(t,2)*P0 + 2*P1*t*(1-t) + P2*pow(1-t, 2);
    return point;
}


vector3f randomSpherePoint()
{
    float u = static_cast &lt;float&gt; (rand()) / static_cast &lt;float&gt; (RAND_MAX);
    float v = static_cast &lt;float&gt; (rand()) / static_cast &lt;float&gt; (RAND_MAX);
    float theta = 2 * M_PI * u;
    float phi = acos(2*v-1);
    float x=(10*sin(phi)*cos(theta));
    float y=(10 * sin(phi) * sin(theta));
    float z=10*cos(phi);
    return vector3f(x, y, z);
}


void drawRandomSpherePoints()
{
    for (int i=0; i&lt;400; i++)
    {
        glPushMatrix();

        vector3f point=cityVertices.at(i);
        glTranslatef(point.x, point.y, point.z);
        glutSolidSphere(0.25, 10, 10);
        glPopMatrix();
    }

}
vector3f GetOGLPos(int x, int y)
{
    GLint viewport[4];
    GLdouble modelview[16];
    GLdouble projection[16];
    GLfloat winX, winY, winZ;
    GLdouble posX, posY, posZ;

    glGetDoublev( GL_MODELVIEW_MATRIX, modelview );
    glGetDoublev( GL_PROJECTION_MATRIX, projection );
    glGetIntegerv( GL_VIEWPORT, viewport );

    winX = (float)x;
    winY = (float)viewport[3] - (float)y;
    glReadPixels( x, int(winY), 1, 1, GL_DEPTH_COMPONENT, GL_FLOAT, &amp;winZ );

    gluUnProject( winX, winY, winZ, modelview, projection, viewport, &amp;posX, &amp;posY, &amp;posZ);
    return vector3f(posX, posY, posZ);
}

void mouseClick(int button,int state,int x, int y)
{
    vector3f Coord=GetOGLPos(x, y);
    cout&lt;&lt;Coord.x&lt;&lt;"" ""&lt;&lt;Coord.y&lt;&lt;"" ""&lt;&lt;Coord.z&lt;&lt;endl;
//    for (int i=0;i&lt;cityVertices.size();i++)
//    {
//        if (Coord.x-cityVertices.at(i).x&lt;CLICK_ACCURACY &amp;&amp; Coord.z-cityVertices.at(i).z&lt;CLICK_ACCURACY &amp;&amp; Coord.z-cityVertices.at(i).z&lt;CLICK_ACCURACY  ) {
//        }
//    }
}



void preProcessEvents()
{
    CURRENT_TIME=(float)glutGet(GLUT_ELAPSED_TIME);
    DELTA_TIME=CURRENT_TIME-LAST_TIME;
    LAST_TIME=CURRENT_TIME;


    mouse::update();
    //mouse processing
    Camera::rotationAngles.y+=(float)mouse::deltaX*MOUSE_SENSITIVITY;
    Camera::rotationAngles.x-=(float)mouse::deltaY*MOUSE_SENSITIVITY;

    if (Camera::rotationAngles.x&gt;MAX_TILT)
    {
        Camera::rotationAngles.x=MAX_TILT;
    }
    else if (Camera::rotationAngles.x&lt;-1*MAX_TILT)
    {
        Camera::rotationAngles.x=-1*MAX_TILT;
    }
    if (keyBoard::key['w'])
    {
        Camera::position.z-=WALKING_SPEED*DELTA_TIME*Math::sind(Camera::rotationAngles.y);
        Camera::position.x-=WALKING_SPEED*DELTA_TIME*Math::cosd(Camera::rotationAngles.y);
    }
    else if (keyBoard::key['s'])
    {
        Camera::position.z+=WALKING_SPEED*DELTA_TIME*Math::sind(Camera::rotationAngles.y);
        Camera::position.x+=WALKING_SPEED*DELTA_TIME*Math::cosd(Camera::rotationAngles.y);
    }
    else if (keyBoard::key['a'])
    {
        Camera::rotationAngles.y-=WALKING_SPEED*DELTA_TIME*3;
    }
    else if (keyBoard::key['d'])
    {
        Camera::rotationAngles.y+=WALKING_SPEED*DELTA_TIME*3;
    }
    else if (keyBoard::key['f'])
    {
        venusRotate++;
    }
    else if (keyBoard::key[' '])
    {
        glutDestroyWindow(subWindow);
    }

}
void reshape(int w, int h)
{
    float aspectRatio;
    if (h==0)
    {
        h=1;
    }
    aspectRatio=float(w)/float(h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glViewport(0, 0, w ,h);
    gluPerspective(45, aspectRatio, 0.01, 100000000);
    glMatrixMode(GL_MODELVIEW);
}


void display()
{
    preProcessEvents();
    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();
    gluLookAt(Camera::position.x, Camera::position.y, Camera::position.z,
              Camera::position.x+Math::sind(Camera::rotationAngles.x)*Math::cosd(Camera::rotationAngles.y),
              Camera::position.y+Math::cosd(Camera::rotationAngles.x),
              Camera::position.z+Math::sind(Camera::rotationAngles.x)*Math::sind(Camera::rotationAngles.y),
              0.0, 1.0, 0.0);
    glBegin(GL_TRIANGLES);
    glColor3f(1, 0, 0);
    glVertex3f(-1, 0,-3);
    glColor3f(0, 1, 0);
    glVertex3f(0.0f, 2.0f,-3);
    glColor3f(0, 0, 1);
    glVertex3f(1.0f, 0.0f,-3);
    glEnd();





    glBindTexture(GL_TEXTURE_2D, tex-&gt;textureID);

    glBegin(GL_QUADS);

    glColor3f(1, 1, 1);
    glTexCoord2f(100, 100);
    glVertex3f(100,0,100);

    glTexCoord2f(-100, 100);
    glVertex3f(-100,0,100);

    glTexCoord2f(-100,-100);
    glVertex3f(-100,0,-100);

    glTexCoord2f(100,-100);
    glVertex3f(100,0,-100);

    glEnd();
    glBindTexture(GL_TEXTURE_2D, 0);


    glPushMatrix();
    object1.draw();
    glPopMatrix();

    //globe
    glTranslatef(-10.0, 10.0, 0.0);
    glBindTexture(GL_TEXTURE_2D, tex2-&gt;textureID);
    gluQuadricTexture(quad,1);
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glRotatef(-90, 1.0f, 0.0f, 0.0f);
    glRotatef(venusRotate, 0.0, 0.0, 1.0);
    drawRandomSpherePoints();

    for (int i=0; i&lt;cityVertices.size()-1; i++)
    {
        vector3f start=cityVertices.at(i);
        vector3f end=cityVertices.at(i+1);
        vector3f perpBisectorDirection=vector3f((start.x+end.x)/2,(start.y+end.y)/2,(start.z+end.z)/2);
        vector3f tan1(perpBisectorDirection.x/10*15,perpBisectorDirection.y/10*15,perpBisectorDirection.z/10*15);
        glColor3f(1.0, 0.0, 0.0);
        glLineWidth(12.0);
        glBegin(GL_LINE_STRIP);

        int t = 30;
        for (int i = 0; i &lt;= t; i++) {
            float pos = (float) i / (float) t;
            GLfloat x = bezierCurve( pos,start.x, tan1.x, end.x);
            GLfloat y = bezierCurve( pos,start.y, tan1.y, end.y);
            // In our case, the z should always be empty
            GLfloat z = bezierCurve(pos,start.z, tan1.z, end.z);

            vector3f result(x, y, z);
            glVertex3f(x, y, z);
        }
        glEnd();

    }
    gluSphere(quad,10,20,20);
    glPopMatrix();
    glBindTexture(GL_TEXTURE_2D, 0);

    glutSwapBuffers();
}
</code></pre>
"
"<p>I am learning C program. When try to run the code I am getting error as : [Error] ld returned 1 exit status</p>

<pre><code>   #include &lt;stdio.h&gt;
   #include &lt;time.h&gt;

    void main()
     {

       time_t t;
       time(&amp;t);

       clrscr();

       printf(""Today's date and time : %s"",ctime(&amp;t));
       getch();

      }
</code></pre>

<p>Can someone explain me What I am doing wrong here?</p>

<p>I tried this code :</p>

<pre><code> int main()
   {

  printf(""Today's date and time : %s \n"", gettime());
  return 0;

   }

  char ** gettime() {

   char * result;

    time_t current_time;
    current_time = time(NULL);
   result = ctime(&amp;current_time);

     return &amp;result;

   }
</code></pre>

<p>but still shows me error as : error: called object ?1? is not a function
in current_time = time(NULL); line. What is wrong with the code</p>
"
"<p>When I press the up arrow key a star moves up 2 time but I want to add a delay between the star moving the 1st and 2nd time, this is the code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;windows.h&gt;

using namespace std;

char Map[10][20] = {""###################"",
                    ""####    #########!#"",
                    ""####  # ######### #"",
                    ""####* # ######### #"",
                    ""#     # ######### #"",
                    ""# ##### ######### #"",
                    ""# ##### ######### #"",
                    ""# ##### ######### #"",
                    ""#@#####           #"",
                    ""###################"" };

int Gamespeed = 100;
int Level = 1;
bool stopgame = false;
int Hp = 100;
int MaxHp = 100;

int main()
{
    while(stopgame == false &amp;&amp; Level == 1)
    {
        system(""cls"");
        for (int y = 0; y &lt; 10; y++)
        {
            cout &lt;&lt; Map[y] &lt;&lt; endl;
        }
        cout &lt;&lt; ""Hp: ""&lt;&lt; Hp &lt;&lt; ""/"" &lt;&lt; MaxHp &lt;&lt; endl;
        for (int y = 0; y&lt;10; y++)
        {
            for(int x = 0; x&lt;20; x++)
            {

                switch(Map[y][x])
                {
                    case '#':
                    {
                       Map[y][x] = 219;
                    }
                    break;
                    case '*':
                        {
                            if (GetAsyncKeyState(VK_UP) != 0)
                            {
                                if (y = 3)
                                {
                                    Map[y][x] = ' ';
                                    y -= 1;
                                    Map[y][x] = '*';
                                }
                                Sleep(1000);
                                if (y = 2)
                                {
                                    Map[y][x] = ' ';
                                    y -= 1;
                                    Map[y][x] = '*';
                                }

                            }
                        }
                        break;
                    case '@':
                    {

                        if (GetAsyncKeyState(VK_UP) != 0)
                        {
                            int y2 = (y-1);

                            switch(Map[y2][x])
                            {
                                case ' ':
                                {
                                    Map[y][x] = ' ';
                                    y -= 1;
                                    Map[y2][x] = '@';
                                }break;
                                case '!':
                                    {
                                        Level = 2;
                                    }break;
                                    case '*':
                                    {
                                        Hp -= 20;
                                        Map[y][x] = ' ';
                                        y -= 1;
                                        Map[y2][x] = '@';
                                    }break;
                            }
                        }

                        if (GetAsyncKeyState(VK_DOWN) != 0)
                        {
                            int y2 = (y + 1);

                            switch(Map[y2][x])
                            {
                            case ' ':
                                {
                                    Map[y][x] = ' ';
                                    y += 1;
                                    Map[y2][x] = '@';
                                }break;
                            case '!':
                                {
                                    Level = 2;
                                }break;
                                case '*':
                                    {
                                        Hp -= 20;
                                        Map[y][x] = ' ';
                                        y -= 1;
                                        Map[y2][x] = '@';
                                    }break;
                            }
                       }

                       if (GetAsyncKeyState(VK_RIGHT) != 0)
                       {
                           int x2 = (x + 1);

                           switch(Map[y][x2])
                           {
                           case ' ':
                            {
                                Map[y][x] = ' ';
                                x += 1;
                                Map[y][x2] = '@';
                            }break;
                           case '!':
                            {
                                Level = 2;
                            }break;
                            case '*':
                                    {
                                        Hp -= 20;
                                        Map[y][x] = ' ';
                                        x -= 1;
                                        Map[y][x2] = '@';
                                    }break;
                           }
                       }
                       if (GetAsyncKeyState(VK_LEFT) != 0)
                       {
                           int x2 = (x - 1);

                           switch(Map[y][x2])
                           {
                           case ' ':
                            {
                                Map[y][x] = ' ';
                                x -= 1;
                                Map[y][x2] = '@';
                            }break;
                           case '!':
                            {
                                Level = 2;
                            }break;
                            case '*':
                                    {
                                        Hp -= 20;
                                        Map[y][x] = ' ';
                                        x -= 1;
                                        Map[y][x2] = '@';
                                    }break;
                           }
                       }
                    }
                }
            }
        }
        Sleep(Gamespeed);
    }
</code></pre>

<p>this is the code that makes the star move</p>

<pre><code>case '*':
    {
        if (GetAsyncKeyState(VK_UP) != 0)
        {
            if (y = 3)
            {
                Map[y][x] = ' ';
                y -= 1;
                Map[y][x] = '*';
            }
            Sleep(1000);
            if (y = 2)
            {
                Map[y][x] = ' ';
                y -= 1;
                Map[y][x] = '*';
            }

        }
    }
  break;
</code></pre>

<p>the problem is the Sleep is pausing the whole programme not the star moving</p>

<p>Edward Alejandro Medina's solution:</p>

<pre><code>    #include &lt;iostream&gt;
    #include &lt;windows.h&gt;
    #include &lt;chrono&gt;

    using namespace std;

    char Map[10][20] = {""###################"",
                        ""####    #########!#"",
                        ""####  # ######### #"",
                        ""####* # ######### #"",
                        ""#     # ######### #"",
                        ""# ##### ######### #"",
                        ""# ##### ######### #"",
                        ""# ##### ######### #"",
                        ""#@#####           #"",
                        ""###################"" };

    int Gamespeed = 100;
    int Level = 1;
    bool stopgame = false;
    int Hp = 100;
    int MaxHp = 100;

    int main()
    {
    chrono::time_point&lt;chrono::system_clock&gt; current_time,last_time;
    float delta_time,star_delay=0;
    current_time=chrono::system_clock::now();
    last_time=current_time;
    while(stopgame == false &amp;&amp; Level == 6)
    {
           current_time=chrono::system_clock::now();
           delta_time=chrono::duration_cast&lt;chrono::duration&lt;float&gt;&gt;(current_time-last_time).count();
           last_time=current_time;
        system(""cls"");
        cout &lt;&lt; ""Well done you made it to level 6\n\n"";
    for (int y = 0; y &lt; 10; y++)
        {
            cout &lt;&lt; Map6[y] &lt;&lt; endl;
        }
        cout &lt;&lt; ""Hp: ""&lt;&lt; Hp &lt;&lt; ""/"" &lt;&lt; MaxHp &lt;&lt; endl;
        for (int y = 0; y&lt;10; y++)
        {
            for(int x = 0; x&lt;20; x++)
            {

                switch(Map6[y][x])
                {
                    case '#':
                    {
                       Map6[y][x] = 219;
                    }
                    break;
                    case '*':
                        {
                                if (y == 8 &amp;&amp; x == 12)
                                {
                                    Map6[y][x] = ' ';
                                    y -= 1;
                                    Map6[y][x] = '*';
                                    star_delay=0;
                                }
                                if (y == 7 &amp;&amp; x == 12)
                                {
                                    Map6[y][x] = ' ';
                                    y -= 1;
                                    Map6[y][x] = '*';
                                    star_delay=0;
                                }
                                if (y == 6 &amp;&amp; x == 12)
                                {
                                    Map6[y][x] = ' ';
                                    x += 1;
                                    Map6[y][x] = '*';
                                    star_delay=0;
                                }
                                if (y == 6 &amp;&amp; x == 13)
                                {
                                    Map6[y][x] = ' ';
                                    y += 1;
                                    Map6[y][x] = '*';
                                    star_delay=0;
                                }
                                if (y == 7 &amp;&amp; x == 13)
                                {
                                    Map6[y][x] = ' ';
                                    y += 1;
                                    Map6[y][x] = '*';
                                    star_delay=0;
                                }
                                if (y == 8 &amp;&amp; x == 13)
                                {
                                    if(star_delay&gt;1){
                                    Map6[y][x] = ' ';
                                    x -= 1;
                                    Map6[y][x] = '*';
                                    }else{
                                        star_delay+=delta_time;
                                    }
                                }
                        }
                        break;
                    case '@':
                    {
                        if (GetAsyncKeyState(VK_UP) != 0)
                        {
                            int y4 = (y-1);

                            switch(Map6[y4][x])
                            {
                                case ' ':
                                {
                                    Map6[y][x] = ' ';
                                    y -= 1;
                                    Map6[y4][x] = '@';
                                }break;
                                case '!':
                                    {
                                        Level = 7;
                                    }break;
                                    case '*':
                                    {
                                        Hp -= 20;
                                        Map6[y][x] = ' ';
                                        y -= 1;
                                        Map6[y4][x] = '@';
                                    }break;
                            }

                        }

                        if (GetAsyncKeyState(VK_DOWN) != 0)
                        {
                            int y4 = (y + 1);

                            switch(Map6[y4][x])
                            {
                            case ' ':
                                {
                                    Map6[y][x] = ' ';
                                    y += 1;
                                    Map6[y4][x] = '@';
                                }break;
                            case '!':
                                {
                                    Level = 7;
                                }break;
                                case '*':
                                    {
                                        Hp -= 20;
                                        Map6[y][x] = ' ';
                                        y -= 1;
                                        Map6[y4][x] = '@';
                                    }break;
                            }
                       }

                       if (GetAsyncKeyState(VK_RIGHT) != 0)
                       {
                           int x5 = (x + 1);

                           switch(Map6[y][x5])
                           {
                           case ' ':
                            {
                                Map6[y][x] = ' ';
                                x += 1;
                                Map6[y][x5] = '@';
                            }break;
                           case '!':
                            {
                                Level = 7;
                            }break;
                            case '*':
                                    {
                                        Hp -= 20;
                                        Map6[y][x] = ' ';
                                        x -= 1;
                                        Map6[y][x5] = '@';
                                    }break;
                           }
                       }
                       if (GetAsyncKeyState(VK_LEFT) != 0)
                       {
                           int x5 = (x - 1);

                           switch(Map6[y][x5])
                           {
                           case ' ':
                            {
                                Map6[y][x] = ' ';
                                x -= 1;
                                Map6[y][x5] = '@';
                            }break;
                           case '!':
                            {
                                Level = 7;
                            }break;
                            case '*':
                                    {
                                        Hp -= 20;
                                        Map6[y][x] = ' ';
                                        x -= 1;
                                        Map6[y][x5] = '@';
                                    }break;
                           }
                       }
                    }
                }
            }
        }
        Sleep(Gamespeed);
        while(Hp == 0)
            {
                system(""cls"");
                cout &lt;&lt; ""\n\n\n\n\n\n\n\n\n\n                              you died on level "" &lt;&lt; Level &lt;&lt; ""\n\n                             better luck next time."";
            }
    }

    return 0;
}
     }
                    }
                }
            }
            Sleep(Gamespeed);
        }
</code></pre>
"
"<p>I am a researcher looking into vehicle parking behaviour and parking occupancy patterns. I am trying to write an efficient and robust algorithm to calculate parking occupancy over time. </p>

<p>Here is my story: </p>

<p>I have the parking data recorded using in-ground parking sensors from across the city of Melbourne, Australia. You can view the data here: <a href=""https://data.melbourne.vic.gov.au/Transport/Parking-Events-From-Parking-Bays-With-Sensors/8nfq-mtcn"" rel=""nofollow"">https://data.melbourne.vic.gov.au/Transport/Parking-Events-From-Parking-Bays-With-Sensors/8nfq-mtcn</a>?. </p>

<p>My initial task is to plot this data as a time series plot so I can visually analyse trends in parking occupancy over different periods of time (day, week, month etc).</p>

<p>There are 7,112 sensors installed in various streets of the city. Each sensor records data when a car arrives and departs the parking spot (lets call it an ?event?). From 2011 to 2012, they have recorded 12,208,417 events. Every event is a row in the database and has the following columns that interest me:</p>

<ul>
<li>sensor ID</li>
<li>arrival time</li>
<li>departure time</li>
<li>duration of parking</li>
<li>the street where this sensor is located</li>
</ul>

<p>Now, I don't want to plot data from every sensor separately but the group of sensors that belong to a street over fixed intervals of time (seconds, minutes, hours, etc). So, street ?A? might have 10 parking spots (= 10 sensors), street ?B? = 12 sensors and so on. </p>

<p>For a 24 hour time series plot between (10/10/2011 12:00:00 AM) to (11/10/2011 12:00:00 AM) for a given street ?A?, here is what I have done:</p>

<p><b>USING SQL</b></p>

<ol>
<li>Retrieve all events by the sensors located in street ""A"" between the given dates by running SQL query</li>
</ol>

<p><b>USING PHP</b></p>

<ol start=""2"">
<li>Iterate over a time loop from (10/10/2011 12:00:00 AM) to (11/10/2011 12:00:00 AM) with a 1 minute offset over every iteration. </li>
<li>Begin parsing data: </li>
</ol>

<p>? Foreach minute (time sample):</p>

<p>?? foreach sensor in street ?A?</p>

<p>??? foreach event</p>

<p>???? if this event was recorded by the current sensor AND time sample lies between car arrival AND departure time, THEN add +1 to occupancy for this minute</p>

<hr>

<p>Stats about runtime:</p>

<ul>
<li>SQL query time: ~260ms</li>
<li>PHP exec time: 33.1s</li>
<li>Number of time samples: 1,440 (i.e. the number of minutes in a 24 hour cycle)</li>
<li>Number of sensors the algorithm had to deal with: 49</li>
<li>Number of events the algorithm had to deal with: 508</li>
</ul>

<p>I was able to get info on how many cars were parked on a street at a given minute so I can easily plot it using a line chart. </p>

<p>I have a feeling that my algorithm is not very efficient/smart. I understand that for a larger time bracket, I need to decrease the number of time samples. However, I would like to know if there is any possible way of achieving this without compromising on time samples?</p>

<hr>

<p><b>SQL QUERY REFERENCE</b></p>

<pre><code>SELECT sensors.device_id, events.arrival_time, events.departure_time, events.duration
FROM events, sensors
WHERE
    STR_TO_DATE(arrival_time, '%d/%m/%Y %r') &gt;= STR_TO_DATE(:start_time,'%d/%m/%Y %r') &amp;&amp;
    STR_TO_DATE(arrival_time, '%d/%m/%Y %r') &lt;= STR_TO_DATE(:end_time,'%d/%m/%Y %r') &amp;&amp;
    events.device_id = sensors.device_id &amp;&amp;
    sensors.street_name= :street_name &amp;&amp;
    sensors.street_1 = :street_1 &amp;&amp;
    sensors.street_2 = :street_2
</code></pre>

<p><b>PHP CODE REFERENCE</b></p>

<pre><code>//TIME RANGE
$start_time = ""10/10/2011 12:00:00 AM"";
$end_time = ""11/10/2011 12:00:00 AM"";

//SETUP ARRAYS FOR PLOTTING
$x_time = array();
$y_occupancy = array();

//ITERATE THROUGH TIME
for($i=strtotime($start_time); $i&lt;=strtotime($end_time);$i+=60) {

    $current_time =  date(""d/m/Y h:i:s A"",$i); echo ""&lt;br&gt;"";

    $current_occupancy = 0;

    //ITERATE THROUGH SENSORS
    foreach($sensors as $sensor) {

        //ITERATIVE THROUGH EVENTS
        foreach($events as $event) {

            //CHECK IF THIS SENSOR IS ACTIVE AT THIS EVENT
            if (($sensor-&gt;device_id == $event-&gt;device_id) &amp;&amp; (strtotime($current_time) &gt;= strtotime($event-&gt;arrival_time) &amp;&amp; strtotime($current_time) &lt;= strtotime($event-&gt;departure_time))) {
                $current_occupancy++;
            }

        }//end event iterations

    }// end sensor iterations

    $x_time[] = $current_time;
    $y_occupancy[] = $current_occupancy;

}// end time iterationS



//SHOW TIME VS OCCUPANCY
for($i=0; $i&lt;count($x_time);$i++) {
    echo $x_time[$i]; echo "" ""; echo $y_occupancy[$i]; echo ""&lt;br&gt;"";
}
</code></pre>
"
"<p>I read whole info about boost::chrono and still didn`t get how to convert boost::chrono::system_clock to string in easy way. For example, I want to get current time and convert it to string in next format: hh:mm:ss. For example I wan receive smth like this - 24:55:03.
I can receive current time in next way:</p>

<pre><code>auto current_time = boost::chrono::system_clock::now()
</code></pre>

<p>How simply to format current_time to string.
It sad but I can`t find any help in boost documentation and in google.</p>
"
"<p>I'm trying to convert a date string to a <code>time_t</code>, but mktime() is returning seemingly random dates:</p>

<pre><code>string datetime = ""2014-12-10 10:30"";
struct tm tmInfo;
strptime(datetime.c_str(), ""%Y-%m-%d %H:%M"", &amp;tmInfo);
tmInfo.tm_isdst = 0;
time_t eventTime = mktime(&amp;tmInfo);
</code></pre>

<p>eventTime ranges wildly from the 1970s to the 2030s. The tmInfo struct holds the correct date, so the error must be happening in mktime(). Any ideas of what's going wrong?</p>
"
"<p>I am using the <code>select(2)</code> function to watch for changes on file descriptor obtained by <code>pcap_get_selectable_fd</code>. When <code>select(2)</code> returns after what appears to be amount of time specified as a timeout, value equal to number of file descriptors in fdset is returned. Subsequent call to <code>pcap_next_ex</code> returns 0 (meaning no packets were available). I checked if some packets were dropped using <code>pcap_stats</code> but both 'drop' and 'ifdrop' counters were empty.</p>

<p>I also apply Berkeley Packet Filter on pcap resource handle, which according to documentation for <code>pcap_get_selectable_fd</code> caused some issues on BSD and Mac OS X. Could it be somehow related even that I am running Linux?</p>

<p>My test machine runs Linux kernel 3.13.3-1-ARCH and uses libpcap-1.6.2. On my development machine everything runs as I would expect (kernel 3.17.7-200.fc20.x86_64, libpcap-1.5.3).</p>

<h3>Excerpt from packet capture initialization</h3>

<pre><code>for ( i = 0; i &lt; etherpoke_conf-&gt;filter_cnt; i++ ){
    struct bpf_program bpf_prog;

    session_data_init (&amp;(pcap_session[i]));

    pcap_session[i].handle = pcap_create (etherpoke_conf-&gt;filter[i].interface, pcap_errbuff);

    rval = pcap_set_promisc (pcap_session[i].handle, !etherpoke_conf-&gt;filter[i].rfmon);

    if ( etherpoke_conf-&gt;filter[i].rfmon ){
        rval = pcap_can_set_rfmon (pcap_session[i].handle);

        if ( rval == 1 ){
            rval = pcap_set_rfmon (pcap_session[i].handle, 1);
        } else {
            fprintf (stderr, ""%s: cannot enable monitor mode on interface '%s': %s\n"", argv[0], etherpoke_conf-&gt;filter[i].interface, pcap_geterr (pcap_session[i].handle));
            exitno = EXIT_FAILURE;
            goto cleanup;
        }
    }

    rval = pcap_set_timeout (pcap_session[i].handle, SELECT_TIMEOUT_MS);

    rval = pcap_setnonblock (pcap_session[i].handle, 1, pcap_errbuff);

    rval = pcap_activate (pcap_session[i].handle);

    rval = pcap_compile (pcap_session[i].handle, &amp;bpf_prog, etherpoke_conf-&gt;filter[i].match, 0, PCAP_NETMASK_UNKNOWN);

    rval = pcap_setfilter (pcap_session[i].handle, &amp;bpf_prog);

    pcap_freecode (&amp;bpf_prog);

    pcap_session[i].fd = pcap_get_selectable_fd (pcap_session[i].handle);
}
</code></pre>

<h3>Excerpt from the main loop</h3>

<pre><code>while ( main_loop ){
    time_t current_time;
    struct pcap_pkthdr *pkt_header;
    const u_char *pkt_data;
    struct timeval timeout;
    fd_set fdset_read;
    int last_fd;

    FD_ZERO (&amp;fdset_read);
    last_fd = 0;
    timeout.tv_sec = 0;
    timeout.tv_usec = SELECT_TIMEOUT_MS * 1000;

    for ( i = 0; i &lt; etherpoke_conf-&gt;filter_cnt; i++ ){
        if ( pcap_session[i].fd == -1 )
            continue;

        FD_SET (pcap_session[i].fd, &amp;fdset_read);
        last_fd = pcap_session[i].fd;
    }

    if ( last_fd == 0 ){
        syslog (LOG_ERR, ""no more applicable filters left to use. Dying!"");
        break;
    }

    rval = select (last_fd + 1, &amp;fdset_read, NULL, NULL, &amp;timeout);

    if ( rval == -1 ){
        if ( errno != EINTR )
            syslog (LOG_ERR, ""select system call failed: %s"", strerror (errno));
        break;
    }

    time (&amp;current_time);

    for ( i = 0; i &lt; etherpoke_conf-&gt;filter_cnt; i++ ){
        if ( FD_ISSET (pcap_session[i].fd, &amp;fdset_read) ){
            rval = pcap_next_ex (pcap_session[i].handle, &amp;pkt_header, &amp;pkt_data);

            if ( rval &lt; 0 ){
                syslog (LOG_ERR, ""could not obtain packet from the queue: %s"", pcap_geterr (pcap_session[i].handle));
                main_loop = 0;
                break;
            } else if ( rval == 0 ){
                continue;
            }
        }

        if ( (pcap_session[i].ts &gt; 0)
                &amp;&amp; (difftime (current_time, pcap_session[i].ts) &gt;= etherpoke_conf-&gt;filter[i].session_timeout) ){
            pcap_session[i].evt_flag = FILTER_EVENT_END;
        }
    }
}
</code></pre>
"
"<p>I'm currently stuck on figuring out how to efficiently calculate the number of active users on any given ""page"" on an app. I'm using PostgreSQL and have a table like this:</p>

<pre><code>CREATE TABLE user_is_viewing_page (
  user_id BIGINT,
  page_id BIGINT,
  timestamp TIMESTAMP
);
</code></pre>

<p>Each user is going to POST to a server every 10 seconds or so with the id of the page they are viewing and a new row will be inserted into the database.</p>

<p>The current query I have to count the number of ""active"" users on any given page is:</p>

<pre><code>SELECT COUNT(DISTINCT user_id)
FROM user_is_viewing_page WHERE page_id = 1
                          AND timestamp &gt; CURRENT_TIMESTAMP - INTERVAL '10 seconds';
</code></pre>

<p>I'm wondering what the most efficient way to use this query is. Keep in mind that I need to access this count fairly often (every 5-10 seconds per page).</p>

<ul>
<li>Should I create a materialized view using the query? (Knowing that I have to access it often)</li>
<li>Should I just run the query by itself every time I need it?</li>
<li>What is the best way to index my table to allow quick lookups?</li>
</ul>
"
"<p>I am a programmer with a strong Java for Android background. I am very new to C and am only learning it to write companion apps for Pebble. <strong>EDIT:</strong> I am using cloudpebble, so I have no control over libraries.</p>

<p>This is a summary of the part of my code where I think the problem is:</p>

<pre><code>#include &lt;pebble.h&gt;

static int s_time_a_min;
static int s_time_a_h;
static int s_time_b_min = 0;
static int s_time_b_h = 0;
static int s_time_b_total;
char* c_time_string_min;
char* c_time_string_h;

int str_cut(char *str, int begin, int len){ //I got this method from the internet
    int l = strlen(str);

    if (len &lt; 0) len = l - begin;
    if (begin + len &gt; l) len = l - begin;
    memmove(str + begin, str + begin + len, l - len + 1);

    return len;
}

static void update_text(){
    time_t current_time;

    c_time_string_min = ctime(&amp;current_time); //set these two strings the same: current time
    c_time_string_h = ctime(&amp;current_time); //they are only strings so that they can be substringed

    c_time_string_min = str_cut(c_time_string_min, 14, 16); //substring so that the each string has either min or h
    c_time_string_h = str_cut(c_time_string_h, 11, 13);

    s_si_h = atoi(c_time_string_h); //make the strings integers so that I can do math with them
    s_si_min = atoi(c_time_string_min);

    s_time_b_total = (((s_si_h) * 3600) + ((s_si_min) * 60)) * (123/99); //do some math. Don't ask what it's for.

    do{
        s_time_b_total = s_time_b_total - 10000; //do some more math. Also don't ask what it's for.
        s_time_b_h = s_time_b_h + 1;
    }while(s_ra_all &gt; 10000);

    do{
        s_time_b_total = s_time_b_total - 100;
        s_time_b_min = s_time_b_min + 1;
    }while(s_ra_all &gt; 100);

    //Here is where I think the problem lies.
    const char* buf = (char)(((int)0)+s_time_b_h) + "":"" + (char)(((int)0)+s_time_b_min); //create a string that merges the two integers together and puts a colon in the middle

    text_layer_set_text(s_time_layer, buf); //Set text
}
</code></pre>

<p>And then there's the usual Window_load, main, init, etc.</p>

<p>Please tell me what I am doing wrong. Thanks.</p>
"
"<p>I asked this question before but some guys divert me on wrong direction and I didn't get the right answer yet.
I Know how to rename the file but I am struggle to add date and time with the new name of file.
Can you plz guide me that how Can I do that?</p>

<pre><code>import os
os.rename('mark.txt', 'steve.txt')
</code></pre>
"
"<p>Well, I wasn't sure if that's for code review or for this site, but it has a problem, so I suppose I'm in the right place. I'm trying to create a game using C and SDL. Here's the code(explanation below):</p>

<pre><code>//Includes
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;SDL.h&gt;
#include &lt;SDL_image.h&gt;
#include &lt;SDL_ttf.h&gt;
#include &lt;SDL2_gfxPrimitives.h&gt;


//Create some global variables(is there some other way to do that?)
SDL_Window *screen;
SDL_Renderer *renderer;
SDL_Texture *tardis;
SDL_Surface *tardis_surface;
SDL_Texture *gallifrey;
SDL_Surface *gallifrey_surface;
SDL_Surface *pillar_surface;
SDL_Rect tardis_dest;


//Some variables I want to keep throughout the game
float speed = 0;
int pillars = 0;
int pause = 0;


//Those two could change in the future
int WIDTH = 640;
int HEIGHT = 480;


//Define a struct to express the pillars in a better way
typedef struct{
    SDL_Rect pillar_up;
    SDL_Rect pillar_down;
    SDL_Texture *pillar_texture;
}pillar;


//OK, that might be silly, but I create a list of pointers so
//that I can keep track of them afterwards. Is that bad?
pillar *list_dest[4];


//Generate a pillar
void create_pillar(int pillars_no, int xpos)
{
    //Generate random height
    int height = rand() % 200;
    if(height &lt; 50)
        height += 50;
    pillar pillar_dest;

    //Set the coordinates for the upper pillar
    pillar_dest.pillar_up.x = xpos;
    pillar_dest.pillar_up.y = 0;
    pillar_dest.pillar_up.w = 70;
    pillar_dest.pillar_up.h = HEIGHT - (height + 180);

    //Set the coordinates for the pillar on the ground
    pillar_dest.pillar_down.x = xpos;
    pillar_dest.pillar_down.y = HEIGHT - height;
    pillar_dest.pillar_down.w = 70;
    pillar_dest.pillar_down.h = 200;

    //Set the pillar texture
    pillar_dest.pillar_texture = SDL_CreateTextureFromSurface(
                                renderer, pillar_surface);

    //Allocate space for the pillar and save the address
    //in the list_dest
    pillar *pillar_destp = malloc(sizeof(pillar_dest));
    *pillar_destp = pillar_dest;
    list_dest[pillars_no % 3] = pillar_destp;
}


//Check if the Tardis collides with a pillar
int check_collision(SDL_Rect A, SDL_Rect B)
{
    //The sides of the rectangles
    int leftA, leftB;
    int rightA, rightB;
    int topA, topB;
    int bottomA, bottomB;

    //Calculate the sides of rect A
    leftA = A.x;
    rightA = A.x + A.w;
    topA = A.y;
    bottomA = A.y + A.h;

    //Calculate the sides of rect B
    leftB = B.x;
    rightB = B.x + B.w;
    topB = B.y;
    bottomB = B.y + B.h;

    //If any of the sides from A are outside of B
    if(bottomA &lt; topB)
    {
        return 0;
    }

    if(topA &gt; bottomB)
    {
        return 0;
    }
    if(rightA &lt; leftB)
    {
        return 0;
    }
    if(leftA &gt; rightB)
    {
        return 0;
    }
    //Else
    return 1;
}


//Render the pillars(shitty function name, whatever...)
void draw_ground()
{
    //I always create 3 pillars, no more
    if(pillars &lt; 3)
    {
        create_pillar(pillars, WIDTH + pillars * 240);
        pillars += 1;
    }
    else
    {
        int i;
        for(i = 0; i &lt; 3; i++)
        {
            //Free the previous pillars
            pillar *current_pillar;
            current_pillar = list_dest[i];
            if(current_pillar-&gt;pillar_up.x &lt; -70)
            {
                free(current_pillar-&gt;pillar_texture);
                free(current_pillar);
                create_pillar(pillars, WIDTH);
                pillars += 1;
            }
            else
            {
                //Check if the Tardis has collided with a pillar and
                //display a ""game over"" message.
                if(check_collision(current_pillar-&gt;pillar_up, tardis_dest) ||
                    check_collision(current_pillar-&gt;pillar_down, tardis_dest))
                {
                    SDL_Rect target;
                    target.x = (WIDTH / 2) - 100;
                    target.y = (HEIGHT / 2) - 50;
                    target.w = 200;
                    target.h = 100;
                    TTF_Font *font;
                    font = TTF_OpenFont(""DALEK.ttf"", 40);
                    SDL_Surface *text;
                    SDL_Color text_color = {255, 255, 0};
                    text = TTF_RenderText_Solid(font,
                    ""GAME OVER"",
                    text_color);
                    SDL_Texture *game_over;
                    game_over = SDL_CreateTextureFromSurface(renderer, text);
                    SDL_RenderCopy(renderer, game_over, NULL, &amp;target);
                    pause = 1;
                    int j;
                    for(j = 0; j &lt; 3; j++)
                    {
                        free(list_dest[j]);
                    }
                    pillars = 0;
                    break;

                }
                //Render the pillars
                double angle = 180.0;
                current_pillar-&gt;pillar_up.x -= 10;
                current_pillar-&gt;pillar_down.x -= 10;
                SDL_RenderCopyEx(renderer, current_pillar-&gt;pillar_texture,
                    NULL, &amp;current_pillar-&gt;pillar_up, angle = 0.0,
                    NULL, SDL_FLIP_VERTICAL);
                SDL_RenderCopy(renderer, current_pillar-&gt;pillar_texture,
                    NULL, &amp;current_pillar-&gt;pillar_down);
            }
        }
    }
}


//Render the pillar counter
void draw_counter()
{
    SDL_Rect counter;
    counter.x = WIDTH - 50;
    counter.y = 10;
    counter.w = 40;
    counter.h = 50;

    TTF_Font *font;
    font = TTF_OpenFont(""DALEK.ttf"", 40);

    SDL_Surface *count;
    SDL_Color text_color = {0, 255, 255};

    char count_text[3];
    if(pillars &gt;= 3)
        sprintf(count_text, ""%d"", pillars - 3);
    else
        sprintf(count_text, ""%d"", pillars);

    count = TTF_RenderText_Solid(font,
    count_text,
    text_color);

    SDL_Texture *pillar_counter;
    pillar_counter = SDL_CreateTextureFromSurface(renderer, count);

    SDL_RenderCopy(renderer, pillar_counter, NULL, &amp;counter);
    //This is the last function of the game loop, so I suppose it's a good
    //place for the SDL_RenderPresent
    SDL_RenderPresent(renderer);
}


//Load the images used in the game
void load_images()
{
    tardis_surface = IMG_Load(""files/tardis.bmp"");
    gallifrey_surface = IMG_Load(""files/gallifrey.bmp"");
    pillar_surface = IMG_Load(""files/pipe.bmp"");
}


//Create the background and the Tardis in it's initial place
void create_sprites()
{
    //Create area for the TARDIS
    tardis_dest.x=50;
    tardis_dest.y=100;
    tardis_dest.w=50;
    tardis_dest.h=80;

    //Color key the TARDIS and create texture
    Uint32 colorkey = SDL_MapRGB(tardis_surface-&gt;format,0,0,0);
    //SDL_DisplayFormat(tardis_surface);
    SDL_SetColorKey(tardis_surface, SDL_SRCCOLORKEY, colorkey); // That doesn't work!!!!!
    //Why? Any ideas?

    tardis = SDL_CreateTextureFromSurface(renderer, tardis_surface);

    //Create texture for the Gallifreyan background
    gallifrey = SDL_CreateTextureFromSurface(renderer, gallifrey_surface);

    //Clear the renderer
    SDL_RenderClear(renderer);

    //Add textures to renderer
    SDL_RenderCopy(renderer, gallifrey, NULL, NULL);
    SDL_RenderCopy(renderer, tardis, NULL, &amp;tardis_dest);

    //Update renderer
    //SDL_RenderPresent(renderer);
}


//Update the Tardis' position
void update_sprites(float time)
{
    speed += time * 28;
    if(tardis_dest.y &gt; 460)
    {
        tardis_dest.y = 460;
        speed = 0;
    }
    else if(tardis_dest.y &lt; 0)
    {
        tardis_dest.y = 0;
        speed = 0;
    }
    else
    {
        tardis_dest.y += speed;
        SDL_RenderCopy(renderer, gallifrey, NULL, NULL);
        SDL_RenderCopy(renderer, tardis, NULL, &amp;tardis_dest);
        //SDL_RenderPresent(renderer);
    }
}


//Change the speed when clicked
void ignite()
{
    if(speed &gt; 0)
        speed = -10;
    else
        speed -= 10;
}


//The main function
int main(int argc, char *argv[])
{

    SDL_Event ev;
    int active = 1;

    if(SDL_Init(SDL_INIT_EVERYTHING) != 0)
        fprintf(stderr, ""Could not initialize SDL. SDL Error: %s\n"", SDL_GetError());
    else
        printf(""SDL initialized.\n"");

    if(TTF_Init() == 0)
        fprintf(stderr, ""TTF initialized.\n"");
    else
        fprintf(stderr, ""Could not initialize TTF.\n"");

    //Open main window
    screen = SDL_CreateWindow
    (
        ""First Game"", SDL_WINDOWPOS_UNDEFINED,
        SDL_WINDOWPOS_UNDEFINED,
        WIDTH,
        HEIGHT,
        SDL_WINDOW_SHOWN
    );

    if(!screen)
        fprintf(stderr, ""Could not set video mode: SDL Error: %s\n"", SDL_GetError());

    renderer = SDL_CreateRenderer(screen, 0, SDL_RENDERER_ACCELERATED);

    //Draw the environment
    load_images();
    create_sprites();

    //Set time
    Uint32 current_time, old_time;
    float time_passed;
    current_time = SDL_GetTicks();

    while(active)
    {
        //Update time
        old_time = current_time;
        current_time = SDL_GetTicks();
        time_passed = (current_time - old_time) / 1000.0f;

        //Handle Events
        while(SDL_PollEvent(&amp;ev))
        {

            if(ev.type == SDL_QUIT)
                active = 0;
            if(ev.type == SDL_MOUSEBUTTONDOWN)
            {
                if(pause)
                {
                    pause = 0;
                }
                else
                    ignite();
            }
        }
        if(pause)
            continue;
        update_sprites(time_passed);
        draw_ground();
        draw_counter();
        SDL_Delay(40);
    }

    //Exit
    SDL_FreeSurface(tardis_surface);
    SDL_FreeSurface(gallifrey_surface);
    SDL_Quit();
    printf(""SDL terminated. Have a nice day...\n"");
    return 0;
}
</code></pre>

<p>Quite a read, huh? It probably has many flaws, as it's my first try in game programming, but my main problem is that after some time of playing it I get a segmentation fault. With gdb, I found that it's the following command that's causing the problem:</p>

<pre><code>count = TTF_RenderText_Solid(font,
    count_text,
    text_color);
</code></pre>

<p>Located in the draw_counter() function, at line 214(somewhere in the middle). The question is: why? I suppose it has to do with the memory allocation that I'm doing (I'm still learning C and that's a very tricky part, coming from Python). If anyone could give some useful info? Thanks
And BTW, please don't respond with the usual ""don't use C, learn C++ or Java"" or even ""just use Unity"", I want to learn C, and maybe learn some game programming along the way.</p>
"
"<p>I have a large dataset of images, taken at specific times where each image capture <code>start_time</code> and <code>stop_time</code> are known and encoded as doubles.
I want to load each consecutive image into my simulation based on the simulation time, ie - check when the current simulation time falls within the start/stop interval. </p>

<p>I want to use a map for this, where the key is a <code>std::pair&lt;double, double&gt;</code> of start &amp; stop time and the value is the full path to the image. </p>

<pre><code>std::map&lt;std::pair&lt;double, double&gt;, std::string&gt; _sequence; // t1, t2 and full path
</code></pre>

<p><strong>My question:</strong>
How can I search such a map to find if _currentTime is within an interval pair?</p>
"
"<p>I am trying to receive UDP messages in my main.cxx. I have created a UDP server method getUdp(char *buffer) to listen for incoming UDP messages in my while(true) infinite loop.</p>

<p>Here is the problem that I am facing. This UDP server is able to listen for one message at one time. When two or more UDP messages come at the <em>same</em> time, it is not queued into the buffer. I figured it is because the socket is everytime the method is called in the infinite loop, the getUdp() method opens a socket, gets the message and closes the socket, resulting in the server not being able to queue the messages.</p>

<p>How am I able to tweak this code to receive 2 or more UDP messages?
Appreciate any advice.</p>

<p>Thanks.</p>

<p>UdpServer.cpp</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;winsock.h&gt;
#include &lt;time.h&gt;

#include ""UdpServer.h""
#include ""stdafx.h""

using namespace std;

#pragma comment(lib, ""ws2_32.lib"")
#define BUFFER_SIZE 4096

void getUDP(char *buffer);

void UDPServer::MyUDP::getUDP(char *buffer)
{
    WSADATA w;                          /* Used to open windows connection */
    int client_length;                  /* Length of client struct */
    int bytes_received;                 /* Bytes received from client */
    SOCKET sd;                          /* Socket descriptor of server */
    struct sockaddr_in server;          /* Information about the server */
    struct sockaddr_in client;          /* Information about the client */
    struct hostent *hp;                 /* Information about this computer */
    char host_name[256];                /* Name of the server */
    time_t current_time;                /* Current time */

    /* Open windows connection */
    if (WSAStartup(0x0101, &amp;w) != 0)
    {
        fprintf(stderr, ""Could not open Windows connection.\n"");
    }

    /* Open a datagram socket */
    sd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sd == INVALID_SOCKET)
    {
        fprintf(stderr, ""Could not create socket.\n"");
        WSACleanup();
    }

    /* Clear out server struct */
    memset((void *)&amp;server, '\0', sizeof(struct sockaddr_in));

    /* Set family and port */
    server.sin_family = AF_INET;
    server.sin_port = htons(11000);

    /* Set address automatically if desired */
    /* Get host name of this computer */
    gethostname(host_name, sizeof(host_name));
    hp = gethostbyname(host_name);

    /* Check for NULL pointer */
    if (hp == NULL)
    {
        fprintf(stderr, ""Could not get host name.\n"");
        closesocket(sd);
        WSACleanup();
    }

    unsigned int a = 127;
    unsigned int b = 0;
    unsigned int c = 0;
    unsigned int d = 1;

    /* Assign the address */
    server.sin_addr.S_un.S_un_b.s_b1 = a;
    server.sin_addr.S_un.S_un_b.s_b2 = b;
    server.sin_addr.S_un.S_un_b.s_b3 = c;
    server.sin_addr.S_un.S_un_b.s_b4 = d;

    /* Bind address to socket */
    if (bind(sd, (struct sockaddr *)&amp;server, sizeof(struct sockaddr_in)) == -1)
    {
        fprintf(stderr, ""Could not bind name to socket.\n"");
        closesocket(sd);
        WSACleanup();
    }

    /* Print out server information */
    printf(""Server running on %u.%u.%u.%u\n"", (unsigned char)server.sin_addr.S_un.S_un_b.s_b1,
                                                (unsigned char)server.sin_addr.S_un.S_un_b.s_b2,
                                                (unsigned char)server.sin_addr.S_un.S_un_b.s_b3,
                                                (unsigned char)server.sin_addr.S_un.S_un_b.s_b4);
    printf(""Press CTRL + C to quit\n"");

    /* Loop and get data from clients */
    client_length = (int)sizeof(struct sockaddr_in);

    /* Receive bytes from client */
    bytes_received = recvfrom(sd, buffer, BUFFER_SIZE, 0, (struct sockaddr *)&amp;client, &amp;client_length);

    if (bytes_received &lt; 0)
    {
        fprintf(stderr, ""Could not receive datagram.\n"");
        closesocket(sd);
        WSACleanup();
    }

    current_time = time(NULL);
    closesocket(sd);
    WSACleanup();
}
</code></pre>

<p>main.cxx</p>

<pre><code>int main(int argc, char** argv)
{
    while(true)
    {
        //! wait for UDP message
        UDPServer::MyUDP myudp;
        myudp.getUDP(buffer);

        if(buffer[0] != 0)
        {
            string udpMsg(buffer);

            if(udpMsg == ""ProcessThisMessage"")
            {
                memset(&amp;buffer[0], 0, sizeof(buffer));

                cout &lt;&lt; ""UDP Message: "" + udpMsg;
            }

            ...
        }
    }
}
</code></pre>
"
"<p>I try to debug issue which is due to the use of timer and syslog function in my program. Here i attach sample program code and logs of terminal and syslog to debug it appropriately.</p>

<p>I don't understand why this program get hangs after a while.
So here i have 2 issues,
1. Sleep is getting break when timer expires as it generates SIGPROF
2. syslog is get hanged after a while or some time in first trial</p>

<p><strong>Code:</strong></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;syslog.h&gt;

#define get_curr_date_time(date_time) \
{ \
   time_t t; \
   time(&amp;t); \
   char *strtime = ctime(&amp;t); \
   strncpy(date_time, strtime, strlen(strtime) - 1); \
}

#define DEBUG_INFO(p,x,arg...) \
{\
   printf(""%s:%d,1\n"", __func__, __LINE__);\
   char current_time[32] = {0}; \
   printf(""%s:%d,2\n"", __func__, __LINE__);\
   get_curr_date_time(current_time); \
   printf(""%s:%d,3\n"", __func__, __LINE__);\
   syslog(LOG_INFO,""[%s] : "" p "" : ""#x""\n"", current_time, ##arg);\
   printf(""%s:%d,4\n"", __func__, __LINE__);\
}

char exit_flag = 0;

typedef struct _test_ctx_
{
   char     timer_init;
   timer_t  timerid;

}test_ctx;

void Timer_Handler(int sig, siginfo_t *si, void *uc)
{
   printf(""Timer handler is start\n"");
   DEBUG_INFO(""timer_hang"", ""Timer handler is running\n"");
   printf(""Timer handler is stop\n"");
}

int InitTimer(test_ctx *tst_ctx)
{
   int                  status   = 0;
   struct sigaction     sa;
   struct sigevent      sig;

   memset(&amp;sig, 0x00, sizeof(struct sigevent));
   memset(&amp;sa, 0x00, sizeof(struct sigaction));

   do
   {
      sa.sa_flags = SA_SIGINFO;
      sa.sa_sigaction = Timer_Handler;
      sigemptyset(&amp;sa.sa_mask);
      if (0 != (status = sigaction(SIGPROF, &amp;sa, NULL)))
      {
         printf(""Fail to register SIGPROF signal for timer, ret: %d\n"", status);
         break;
      }

      sig.sigev_notify = SIGEV_SIGNAL;
      sig.sigev_signo = SIGPROF;
      sig.sigev_value.sival_ptr = &amp;tst_ctx-&gt;timerid;
      if (0 != (status = timer_create(CLOCK_REALTIME, &amp;sig, &amp;(tst_ctx-&gt;timerid))))
      {
         printf(""Failed to create timer, ret: %d\n"", status);
         break;
      }

      //Timer inited sucessfully
      tst_ctx-&gt;timer_init = 1;

   }while(0);

   return status;
}

void DeInitTimer(test_ctx *tst_ctx)
{
   int   status   = 0;

   if (0 != tst_ctx-&gt;timer_init)
   {
      //Delete timer
      if (0 != (status = timer_delete(tst_ctx-&gt;timerid)))
      {
         printf(""Fail to delete timer, ret: %d\n"", status);
      }
      tst_ctx-&gt;timer_init = 0;
   }
}

int SetTimer(test_ctx *tst_ctx)
{
   int   status   = 0;
   struct itimerspec in;
   memset(&amp;in, 0x00, sizeof(struct itimerspec));

   do
   {
      in.it_value.tv_sec = 0;
      in.it_value.tv_nsec = 1;
      in.it_interval.tv_sec = 0;
      in.it_interval.tv_nsec = 0;

      if (0 != (status = timer_settime(tst_ctx-&gt;timerid, 0, &amp;in, NULL)))
      {
         printf(""Fail to set timer, ret: %d\n"", status);
         break;
      }

   }while(0);

   return status;
}

void terminate_app(int sig)
{
   exit_flag = 1;
   printf(""signal %d received exiting application\n"", sig);
   DEBUG_INFO(""timer_hang"", ""signal %d received exiting application\n"", sig);
}

int main(int argc, char *argv[])
{
   int            status   = 0;
   test_ctx       tst_ctx;
   memset(&amp;tst_ctx, 0x00, sizeof(tst_ctx));

   do
   {
      //Register signal handler
      signal(SIGTERM, terminate_app);
      signal(SIGINT,  terminate_app);

      //Init timer
      status = InitTimer(&amp;tst_ctx);
      if (0 != status)
      {
         break;
      }

      while(0 == exit_flag)
      {
         printf(""Setting timer\n"");
         DEBUG_INFO(""timer_hang"", ""Setting timer"");

         //Set Timer
         SetTimer(&amp;tst_ctx);

         printf(""Hello!!!\n"");
         DEBUG_INFO(""timer_hang"", ""Hello!!!"");
         printf(""Say!!!\n"");

         sleep(5);
      }

   }while(0);

   //De init timer
   DeInitTimer(&amp;tst_ctx);

   return status;
}
</code></pre>

<p><strong>Teminal Logs:</strong></p>

<pre><code>root@AHMCPU0085:/home/ravi/work/test_app/timer_hang# ./hang_issue
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!



Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,3
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
main:154,4
Say!!!




Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
main:154,4
Say!!!
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3
Timer_Handler:39,4
Timer handler is stop
Setting timer
main:148,1
main:148,2
main:148,3
main:148,4
Hello!!!
main:154,1
main:154,2
main:154,3
Timer handler is start
Timer_Handler:39,1
Timer_Handler:39,2
Timer_Handler:39,3



^Csignal 2 received exiting application
terminate_app:123,1
terminate_app:123,2
terminate_app:123,3

^Z
[1]+  Stopped                 ./hang_issue
root@AHMCPU0085:/home/ravi/work/test_app/timer_hang#
root@AHMCPU0085:/home/ravi/work/test_app/timer_hang# killall -s 9 hang_issue
[1]+  Killed                  ./hang_issue
root@AHMCPU0085:/home/ravi/work/test_app/timer_hang#
root@AHMCPU0085:/home/ravi/work/test_app/timer_hang#
</code></pre>

<p><strong>Syslog messages:</strong></p>

<pre><code>root@AHMCPU0085:/home/ravi/work/test_app/timer_hang# tail -f /var/log/messages
...

Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:15 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:15 2015] : timer_hang : ""Hello!!!""



Jan 21 10:52:20 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:20 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:20 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:20 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:20 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:20 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:20 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:20 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:20 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:20 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:20 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:20 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:20 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:20 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:20 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:20 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:20 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:20 2015] : timer_hang : ""Hello!!!""



Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Setting timer""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Hello!!!""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Timer handler is running\n""
Jan 21 10:52:25 AHMCPU0085 hang_issue: [Wed Jan 21 10:52:25 2015] : timer_hang : ""Setting timer""


^C
root@AHMCPU0085:/home/ravi/work/test_app/timer_hang#
</code></pre>

<p>You will run this test app at your linux machine by doing below steps:</p>

<pre><code># gcc -o hang_issue timer_hang.c -Wall -lrt
# ./hang_issue
... &lt;You will get logs&gt; ...
</code></pre>

<p>Any help will be greatly appreciated.</p>

<p>Regards,
Ravi</p>
"
"<p>Aight so, I'm in the process of making a simple terrain program, not exactly a game, but hey maybe someday. I'll start with describing the basics of how my program works. I'm using an two-dimension array to store the coordinates of the vertexes which make up a grid of triangles. The x and z values are assigned in the follow code:</p>

<pre><code>    //Sets up the array for the vertexes

int e = 0;
int p = 0;
for (int r = 0; r &lt; 10; r++)    {
    for (int x = 0; x &lt; 5; x++) {
        grid[p][0] = x * 2;
        grid[p][2] = e;
        p++;
    }
    e += 2;
}
</code></pre>

<p>Okay, so the grid array is the one I use for storing the values of all the vertexes in the program, the first argument (the value in the first set of []) is used to choose a point, the second set of [] is the x, y, and z values, the code snippet above only sets values for the x and z coordinates.
The y value, height, is randomised at the start of the program using the following code:</p>

<pre><code>    //Random heights for the terrain

if (fir == true)    {

    for (int h = 0; h &lt; 64; h++)    {
        grid[h][1] = rand() % 3;
    }

    fir = false;
}
</code></pre>

<p>And the code for drawing the triangles:</p>

<pre><code>        for (int q = 0; q &lt; 11; q++)    {

        a = q * 5;
        b = a + 1;
        c = a + 5;

        glBegin(GL_TRIANGLE_STRIP);

        for (int dw = 0; dw &lt; 8; dw++)  {

            //a
            glColor3f(grid[a][1], grid[a][1], grid[a][1]);
            glVertex3f(grid[a][0], grid[a][1], grid[a][2]);

            //b
            glColor3f(grid[b][1], grid[b][1], grid[b][1]);
            glVertex3f(grid[b][0], grid[b][1], grid[b][2]);

            //c
            glColor3f(1, 0, 0);
            glVertex3f(grid[c][0], grid[c][1], grid[c][2]);

            a = c;
            t = b;
            b = a + 1;
            c = t;

        }
        glEnd();
    }
glutSwapBuffers();
}
</code></pre>

<p>The problem I'm having is that I can't make the size of the grid bigger without the program breaking, I would like to be able to change the size of the grid of triangles to whatever I like. when I try to change the for loop which goes through the x values (first code snippet) the program breaks, my movement speed drastically increases, moving the mouse has no effect on the camera rotation. When I do manage to find a set of values to work the grid of triangles is messed up, any points after the 5th row are all set to 0, I'll post the whole program, I don't know if it will run for everyone, but I think the problem is something that requires the whole program to be looked at in order to solve.
I think the problem may be due to variables being shared by different parts of the program, I have looked and looked but can't seem to find any cause. This is my last resort to solving this nightmare of a problem...</p>

<h2>main.cpp</h2>

<pre><code>    /*








*/


#include &lt;iostream&gt;
#include &lt;glut.h&gt;
#include &lt;gl\GL.h&gt;
#define _USE_MATH_DEFINES
#include &lt;math.h&gt;
#include &lt;cstdlib&gt;

#include ""vector3f.h""

using namespace std;

//Variables
const int WINDOW_WIDTH = 1280;
const int WINDOW_HEIGHT = 720;
const char* WINDOW_TITLE = ""Terrain"";

const float WALKING_SPEED = 5.0;
const float MOUSE_SENSITIVITY = 0.3;
const float MAX_TILT = 90.0;

float grid[200][3];

float LAST_TIME;
float CURRENT_TIME;
float DELTA_TIME;

bool KEY[256];

int a;
int b;
int c;
int t;

int MOUSE_LAST_X;
int MOUSE_LAST_Y;

int MOUSE_CURRENT_X;
int MOUSE_CURRENT_Y;

int MOUSE_DELTA_X;
int MOUSE_DELTA_Y;

float red;
float green;
float blue;



bool fir = true;

//Object
vector3f CAMERA_POSITION;
vector3f CAMERA_ROTATION;

//Functions
void initialize();
void display();
void reshape(int w, int h);
void keyboardDown(unsigned char key, int x, int y);
void keyboardUp(unsigned char key, int x, int y);
void mouseMove(int x, int y);
void movement();
double degreesToRadians(double degrees);
double dsin(double theta);
double dcos(double theta);
double dtan(double theta);

void display() {



    //cout &lt;&lt; KEY[' '] &lt;&lt; endl;

    movement();

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    //Camera transformations
    glRotatef(CAMERA_ROTATION.x, 1, 0, 0);
    glRotatef(CAMERA_ROTATION.y, 0, 1, 0);
    glRotatef(CAMERA_ROTATION.z, 0, 0, 1);
    glTranslatef(-CAMERA_POSITION.x, -CAMERA_POSITION.y, CAMERA_POSITION.z);

    //Draw the basic triangle
    glBegin(GL_TRIANGLES);

        glColor3f(0.0, 0.0, 1.0);
        glVertex3f(-1.0, -1.0, -3.0);

        glColor3f(0.0, 1.0, 0.0);
        glVertex3f(0.0, 1.0, -3.0);

        glColor3f(1.0, 0.0, 0.0);
        glVertex3f(10.0, -1.0, -3.0);
    glEnd();

    /*

    1  0,0,0
    2  2,0,0
    3  4,0,0
    4  6,0,0

    5  0,0,2
    6  2,0,2
    7  4,0,2
    8  6,0,2

    9  0,0,4
    10 2,0,4
    11 4,0,4
    12 6,0,4

    13 0,0,6
    14 2,0,6
    15 4,0,6
    16 6,0,6

    */



    /*//Option 1 (2 for loops, four if statements)
    for (int p = 0; p &lt; 16; p++)    {
        for (int x = 0; x &lt; 7; x += 2)  {
            grid[p][0] = x;
        }
        grid[p][1] = 0;
        if (p &lt; 4)  {
            grid[p][2] = 0;
        }
        if (p &lt; 8 &amp;&amp; p &gt;= 4)    {
            grid[p][2] = 2;
        }
        if (p &lt; 12 &amp;&amp; p &gt;= 8)   {
            grid[p][2] = 4;
        }
        if (p &lt; 16 &amp;&amp; p &gt;= 12)  {
            grid[p][2] = 6;
        }
    }
    */
    //Option 2 (three for loops)


    //Sets up the array for the vertexes

    int e = 0;
    int p = 0;
    for (int r = 0; r &lt; 10; r++)    {
        for (int x = 0; x &lt; 5; x++) {
            grid[p][0] = x * 2;
            grid[p][2] = e;
            p++;
        }
        e += 2;
    }


    //Random heights for the terrain

    if (fir == true)    {

        for (int h = 0; h &lt; 64; h++)    {
            grid[h][1] = rand() % 3;
        }

        fir = false;
    }




    //cout &lt;&lt; ""point 0: "" &lt;&lt; grid[0][0] &lt;&lt; "", "" &lt;&lt; grid[0][1] &lt;&lt; "", "" &lt;&lt; grid[0][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 1: "" &lt;&lt; grid[1][0] &lt;&lt; "", "" &lt;&lt; grid[1][1] &lt;&lt; "", "" &lt;&lt; grid[1][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 2: "" &lt;&lt; grid[2][0] &lt;&lt; "", "" &lt;&lt; grid[2][1] &lt;&lt; "", "" &lt;&lt; grid[2][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 3: "" &lt;&lt; grid[3][0] &lt;&lt; "", "" &lt;&lt; grid[3][1] &lt;&lt; "", "" &lt;&lt; grid[3][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 4: "" &lt;&lt; grid[4][0] &lt;&lt; "", "" &lt;&lt; grid[4][1] &lt;&lt; "", "" &lt;&lt; grid[4][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 5: "" &lt;&lt; grid[5][0] &lt;&lt; "", "" &lt;&lt; grid[5][1] &lt;&lt; "", "" &lt;&lt; grid[5][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 6: "" &lt;&lt; grid[6][0] &lt;&lt; "", "" &lt;&lt; grid[6][1] &lt;&lt; "", "" &lt;&lt; grid[6][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 7: "" &lt;&lt; grid[7][0] &lt;&lt; "", "" &lt;&lt; grid[7][1] &lt;&lt; "", "" &lt;&lt; grid[7][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 8: "" &lt;&lt; grid[8][0] &lt;&lt; "", "" &lt;&lt; grid[8][1] &lt;&lt; "", "" &lt;&lt; grid[8][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 9: "" &lt;&lt; grid[9][0] &lt;&lt; "", "" &lt;&lt; grid[9][1] &lt;&lt; "", "" &lt;&lt; grid[9][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 10: "" &lt;&lt; grid[10][0] &lt;&lt; "", "" &lt;&lt; grid[10][1] &lt;&lt; "", "" &lt;&lt; grid[10][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 11: "" &lt;&lt; grid[11][0] &lt;&lt; "", "" &lt;&lt; grid[11][1] &lt;&lt; "", "" &lt;&lt; grid[11][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 12: "" &lt;&lt; grid[12][0] &lt;&lt; "", "" &lt;&lt; grid[12][1] &lt;&lt; "", "" &lt;&lt; grid[12][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 13: "" &lt;&lt; grid[13][0] &lt;&lt; "", "" &lt;&lt; grid[13][1] &lt;&lt; "", "" &lt;&lt; grid[13][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 14: "" &lt;&lt; grid[14][0] &lt;&lt; "", "" &lt;&lt; grid[14][1] &lt;&lt; "", "" &lt;&lt; grid[14][2] &lt;&lt; endl;
    //cout &lt;&lt; ""point 15: "" &lt;&lt; grid[15][0] &lt;&lt; "", "" &lt;&lt; grid[15][1] &lt;&lt; "", "" &lt;&lt; grid[15][2] &lt;&lt; endl;





        for (int q = 0; q &lt; 11; q++)    {

            a = q * 5;
            b = a + 1;
            c = a + 5;

            glBegin(GL_TRIANGLE_STRIP);

            for (int dw = 0; dw &lt; 8; dw++)  {

                //a
                glColor3f(grid[a][1], grid[a][1], grid[a][1]);
                glVertex3f(grid[a][0], grid[a][1], grid[a][2]);

                //b
                glColor3f(grid[b][1], grid[b][1], grid[b][1]);
                glVertex3f(grid[b][0], grid[b][1], grid[b][2]);

                //c
                glColor3f(1, 0, 0);
                glVertex3f(grid[c][0], grid[c][1], grid[c][2]);

                a = c;
                t = b;
                b = a + 1;
                c = t;

            }
            glEnd();
        }
    glutSwapBuffers();
}

void keyboardDown(unsigned char key, int x, int y)  {

    KEY[key] = true;

}

void keyboardUp(unsigned char key, int x, int y)    {

    KEY[key] = false;

}

void movement() {

    CURRENT_TIME = ((float)glutGet(GLUT_ELAPSED_TIME) / 1000);
    DELTA_TIME = CURRENT_TIME - LAST_TIME;
    LAST_TIME = CURRENT_TIME;

    MOUSE_DELTA_X = MOUSE_CURRENT_X - MOUSE_LAST_X;
    MOUSE_DELTA_Y = MOUSE_CURRENT_Y - MOUSE_LAST_Y;

    MOUSE_LAST_X = MOUSE_CURRENT_X;
    MOUSE_LAST_Y = MOUSE_CURRENT_Y;

    CAMERA_ROTATION.y += (float)MOUSE_DELTA_X * MOUSE_SENSITIVITY;
    CAMERA_ROTATION.x += (float)MOUSE_DELTA_Y * MOUSE_SENSITIVITY;

    if (CAMERA_ROTATION.x &gt; MAX_TILT)   {
        CAMERA_ROTATION.x = MAX_TILT;
    }
    if (CAMERA_ROTATION.x &lt; -MAX_TILT)  {
        CAMERA_ROTATION.x = -MAX_TILT;
    }


    if (KEY['w'] == true)   {
        CAMERA_POSITION.x += (WALKING_SPEED * DELTA_TIME) * dsin(CAMERA_ROTATION.y);
        CAMERA_POSITION.z += (WALKING_SPEED * DELTA_TIME) * dcos(CAMERA_ROTATION.y);
        CAMERA_POSITION.y += (WALKING_SPEED * DELTA_TIME) * dsin(CAMERA_ROTATION.x + 180);
    }
    if (KEY['s'] == true)   {
        CAMERA_POSITION.x += (WALKING_SPEED * DELTA_TIME) * dsin(CAMERA_ROTATION.y + 180);
        CAMERA_POSITION.z += (WALKING_SPEED * DELTA_TIME) * dcos(CAMERA_ROTATION.y + 180);
        CAMERA_POSITION.y += (WALKING_SPEED * DELTA_TIME) * dsin(CAMERA_ROTATION.x);
    }
    if (KEY['a'] == true)   {
        CAMERA_POSITION.x += (WALKING_SPEED * DELTA_TIME) * dsin(CAMERA_ROTATION.y + 270);
        CAMERA_POSITION.z += (WALKING_SPEED * DELTA_TIME) * dcos(CAMERA_ROTATION.y + 270);
    }
    if (KEY['d'] == true)   {
        CAMERA_POSITION.x += (WALKING_SPEED * DELTA_TIME) * dsin(CAMERA_ROTATION.y + 90);
        CAMERA_POSITION.z += (WALKING_SPEED * DELTA_TIME) * dcos(CAMERA_ROTATION.y + 90);
    }
    if (KEY[' '] == true)   {
        CAMERA_POSITION.y += (WALKING_SPEED * DELTA_TIME);
    }
    if (KEY['e'] == true)   {
        exit(1);
    }

}

void mouseMove(int x, int y)    {

    MOUSE_CURRENT_X = x;
    MOUSE_CURRENT_Y = y;



}

double degreesToRadians(double degrees){

    return degrees * M_PI / 180;

}

double dsin(double theta)   {

    return sin(degreesToRadians(theta));

}
double dcos(double theta)   {

    return cos(degreesToRadians(theta));

}
double dtan(double theta)   {

    return tan(degreesToRadians(theta));

}


void reshape(int w, int h)  {

    //Stops the ratio from dividing by 0
    if (h == 0) {
        h = 1;
    }

    float fRatio = (float)w / h;

    glMatrixMode(GL_PROJECTION);

    glLoadIdentity();

    glViewport(0, 0, w, h);
    gluPerspective(60, fRatio, 0.1, 1000);

    glMatrixMode(GL_MODELVIEW);

}

void initialize() {

    glClearColor(0.0, 0.0, 102.0 / 255.0, 0.0);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);
}

int main(int iArgc, char** cArgv) {

    //Initialise OpenGL and GLUT
    glutInit(&amp;iArgc, cArgv);
    glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH);

    //Setup window
    glutInitWindowPosition(0, 0);
    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);
    glutCreateWindow(WINDOW_TITLE);

    //Setup GLUT callback functions
    initialize();
    glutReshapeFunc(reshape);
    glutDisplayFunc(display);
    glutIdleFunc(display);
    glutKeyboardFunc(keyboardDown);
    glutKeyboardUpFunc(keyboardUp);
    glutMotionFunc(mouseMove);
    glutPassiveMotionFunc(mouseMove);

    glEnable(GL_DEPTH_TEST);

    //Enter main loop
    glutMainLoop();

    return 0;
}
</code></pre>
"
"<p>I have a character array of some size in C++ program</p>

<pre><code>char current_time[30];
</code></pre>

<p>The value of the character array is 2015-02-24T21:39:02.xxx+0800 </p>

<p>The ""xxx"" in the character array must be replaced with a three digit number which is stored in a integer.</p>

<p>How can I replace efficiently without using for loop in C++? The position of the XXX is also known in the character array. </p>
"
"<p>I would like to calculate the the current time and add 2 minutes to it and print the output in the following format. HH:MM . I searched online and came to know that  there are lot of CPAN modules that can be used to implement this. But I'd like to do it without cpan modules.</p>

<pre><code>  $current_time = time();

  $new_time  = $current_time + (2*60); // adding  two minutes

  print( ' the time is ' .  $ new_time  ) ;

 Output : the time is 1424906904
</code></pre>

<p>I searched online and came to know that we need to use POSIX perl interface to print the time in the appropriate format.  However i'd like to know if there is a way to do this without using any cpan modules.</p>
"
"<p>being a big fan of learning the basics before tackling more advanced projects, I ask this question with a sigh and a shake of my head...I like to monitor incoming/outgoing connections in realtime ( netstat -natuec ) but sometimes I get caught up in what I'm doing...So I would like to create a script that would append any <strong>NEW</strong> ip address that shows up from the netstat command to a txt file for review later.  I'm not asking for an easy answer, just a clue as to where I would start.  THANKS!</p>
"
"<p>I use Raspian on the Raspberry B+ to get 1700 nsec (+- 10%) pulses on a GPIO output. Thus, I need a high-resolution wallclock timer. There are several references to <code>clock_gettime</code> for high-resolution timing (e.g. <a href=""https://stackoverflow.com/questions/538609/high-resolution-timer-with-c-and-linux"">1</a>, <a href=""https://stackoverflow.com/questions/6749621/high-resolution-timer-in-linux"">2</a>). However, I get 1. only a microsecond resolution and 2. not sufficient minimum time with this short code:</p>

<pre><code>int start_time, current_time, elapsed_time;
struct timespec resolution;

clock_gettime(CLOCK_MONOTONIC, &amp;resolution);
start_time = Resolution.tv_nsec;

clock_gettime(CLOCK_MONOTONIC, &amp;resolution);
current_time = resolution.tv_nsec;

elapsed_time = current_time - start_time;
if(elapsed_time &lt; 0) {
  elapsed_time = elapsed_time + 1000000000; //in case clock_gettime wraps around
}

printf(""%i\n"", elapsed_time);
</code></pre>

<p>The result is 3000 (nanoseconds), i.e. even this shortest possible piece of code takes too much time. If I add some time-consuming code, the next greater result is 4000.</p>

<p>How I can I get a wallclock timer that will result in at least 100 nsec resolution and a smallest possible time of less than 1700 nsec? That the Raspberry Pi can do faster (100 nsec pulses with WiringPi) shows the <a href=""http://codeandlife.com/2012/07/03/benchmarking-raspberry-pi-gpio-speed/"" rel=""nofollow noreferrer"">GPIO Benchmark</a>. I am aware that additional electronics (monoflop) can help me but I hope to solve the problem in a simpler way. Thank you.</p>
"
"<p><strong>EDIT:</strong> Lesson learned, always use optimizations when doing benchmarks...</p>

<p>I decided to look at <code>std::unique_ptr</code> as an alternative for my program, the reasons as to why are not important.</p>

<p><strong>EDIT:</strong> After using compiler optimizations, they seems to take equivalent amounts of time.</p>

<p><strong>How I tested:</strong></p>

<pre><code>time_t current_time;
time(&amp;current_time);
srand((int)current_time);
//int* p0 = new int[NUM_TESTS];
//int* p1 = new int[NUM_TESTS];
std::unique_ptr&lt;int[]&gt; u_p0{ new int[NUM_TESTS] };
std::unique_ptr&lt;int[]&gt; u_p1{ new int[NUM_TESTS] };
for (unsigned i = 0; i &lt; NUM_TESTS; ++i){
    u_p0[i] = rand(); // use p0 and p1 for the standard ptr test
    u_p1[i] = rand();
}
int result;
auto start = std::chrono::steady_clock::now();
for (unsigned index = 0; index &lt; NUM_TESTS; ++index){
    result = u_p0[index] + u_p1[index]; // use p0 and p1 for standard ptr test
}
auto end = std::chrono::steady_clock::now();
double duration = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(end - start).count();
printf(""time: %f\n"", duration);
</code></pre>

<p><strong>My Environment:</strong></p>

<ul>
<li>Windows 8.1 64bit</li>
<li>MSVC compiler in VS2013 <strong>EDIT: Using Release</strong></li>
<li>Intel 4790k (standard clock)</li>
<li>1600MHz RAM</li>
</ul>

<p><strong>My Results (EDITED: using optimized compilation):</strong></p>

<pre><code>// NUM_TESTS = 1,000,000

/*
STD:
    0.001005
    0.001001
    0.001000
    0.001000
    0.001015
*/
/*
unique_ptr:
    0.001000
    0.001000
    0.000997
    0.001000
    0.001017
*/
</code></pre>
"
"<p><strong>EDIT:</strong> This question was originally titled ""Using <code>std::bind</code> to create inline function,"" but that's not really what I'm after: I just want a simple way to alias functions.</p>

<p>I would like to expose <code>std::chrono::high_resolution_clock::now</code> as a standalone function. That is, I would like to do the following:</p>

<pre><code>auto current_time = std::bind(std::chrono::high_resolution_clock::now);
</code></pre>

<p>Unfortunately, since this is in a header file, it results in multiple definitions of <code>current_time</code> at link-time. Is there a way to return an <em>inline function</em> from <code>std::bind</code>?</p>
"
"<p>I have a ?Upcoming Events? page, and a ?Past Events? page. Each event has a custom field called ?event_date?.</p>

<p>I want to create a loop that displays all of the events greater than today. I've taken a look through these articles, but couldn't get it to work:
<a href=""http://support.advancedcustomfields.com/forums/topic/how-do-i-filter-and-sort-event-posts-with-start-and-end-date/"" rel=""nofollow noreferrer"">http://support.advancedcustomfields.com/forums/topic/how-do-i-filter-and-sort-event-posts-with-start-and-end-date/</a></p>

<p><a href=""https://wordpress.org/support/topic/plugin-advanced-custom-fields-sorting-by-date-picker"" rel=""nofollow noreferrer"">https://wordpress.org/support/topic/plugin-advanced-custom-fields-sorting-by-date-picker</a></p>

<p><a href=""https://stackoverflow.com/questions/18576092/wordpress-advanced-custom-fields-order-posts-by-date-picker"">wordpress advanced custom fields order posts by date-picker</a></p>

<p>From what I?ve gathered in the three links above, I would put this in my functions.php file:</p>

<pre><code>    // CREATE UNIX TIME STAMP FROM DATE PICKER
function custom_unixtimesamp ( $post_id ) {
    if ( get_post_type( $post_id ) == 'event_type' ) {
    $event_date = get_post_meta($post_id, 'event_date', true);

        if($event_date) {
            $dateparts = explode('/', $event_date);
            $newdate1 = strtotime(date('d.m.Y H:i:s', strtotime($dateparts[1].'/'.$dateparts[0].'/'.$dateparts[2])));
            update_post_meta($post_id, 'unixstartdate', $newdate1  );
        }
    }
}
add_action( 'save_post', 'custom_unixtimesamp', 100, 2);
</code></pre>

<p>Then I would add something like this to my page template:</p>

<pre><code>&lt;?php
$today = time();
$args = array(
        'post_type' =&gt; 'event_type',
        'posts_per_page' =&gt; 5,
        'meta_query' =&gt; array(
            array(
            'key' =&gt; 'unixstartdate',
            'compare' =&gt; '&gt;=',
            'value' =&gt; $today,
            )
        ),
        'meta_key' =&gt; 'event_date',
        'orderby' =&gt; 'meta_value',
        'order' =&gt; 'ASC',
    );

$query = new WP_Query( $args );
$event_type = $query-&gt;posts;
?&gt;

&lt;?php if ( have_posts() ) : while ( have_posts() ) : the_post(); ?&gt;
</code></pre>

<p>Right now that?s not turning up any results. My post-type is called ?event_type?, and the key is ?event_date?.</p>

<p>Any thoughts on where I?m going wrong?</p>
"
"<p>I'm trying to build a simple log system, but I've met a problem with my concept:</p>

<pre><code>class logger_instance
{
    std::string log_file;
    std::string log_type;
    std::ofstream log;

public:
    logger_instance(std::string log_type) : log_type(log_type), log_file(""logs\\"" + log_type + "".log""), log(log_file)
    {
        operator &lt;&lt; (""logger_instance("" + log_type + "") init.\n"");
    }

    std::string get_log_type() const
    {
        return log_type;
    }

    std::string get_log_file() const
    {
        return log_file;
    }


    logger_instance&amp; operator &lt;&lt; (std::string message)
    {
        time_t current_time;
        time(&amp;current_time);

        log &lt;&lt; ctime(&amp;current_time);
        log &lt;&lt; "" : "";
        log &lt;&lt; message;
        log &lt;&lt; ""\n"";
    }
};

class logger_manager
{
    std::map &lt; std::string, logger_instance &gt; loggers;

public:
    void add_logger(std::string logger)
    {
        auto it = loggers.find(logger);

        if (it == loggers.end())
        {
            loggers.emplace(logger, logger);
        }
    }

    logger_instance&amp; operator[](std::string logger)
    {
        return loggers[logger];
    }
};
</code></pre>

<p>Compiler : Visual Studio 2013 Update 4</p>

<p>The problem which I'm encountering is that the emplace function doesn't seem to understand that I want the logger_instance object to be built on-the-spot, in the map container. Given the fact that I'm not smarter than a compiler, the problem is in my concept, but I'm unable to find a solution.</p>
"
"<p>How would I capture the time down the second into a variable using a batch file. My script right now looks like this.</p>

<pre><code>CLS
@ECHO OFF

set yy=%date:~-4%
set mm=%date:~-7,2%
set dd=%date:~-10,2%
set newdate=%dd%%mm%%yy%

echo %newdate%
</code></pre>

<p>I've captured the date, and it prints exactly what I need, but now I need to append the time to the variable. How would I do it?</p>
"
"<p>I am doing a project which involves a bit of video recording and editing and I am struggling to find a good C++ library to use. I am using QT as my framework and their video player is not working properly for me to use (seeking crashes some times, e.g.). Also, I need to record video and audio from my camera and QCamera does not work in windows (for recording).</p>

<p>On my program the user can draw on top of the video and I need to store the start frame and the end frame of those drawings. </p>

<p>Right now I've been testing Libvlc which almost does what I want. From what I can see they don't have a way to just jump to a certain frame as this can only be done by time or position.</p>

<p>The first solution that I came up with was to capture the time change event and then calculate the frame using the FPS. The problem is that, as far as I can tell, the interval of this event is around 250ms, which for a 15fps video is almost 4 frames. </p>

<p>So, the second solution was to use libvlc_video_set_callbacks to make my own ""lock, unlock and display"" and count the frames there. This works for recording from the camera, as there is no going back and the frames go from 0 until the video stops. The problem is when playing a video. Since there is no timestamp, as far as I can tell, there is no way for me to know in which frame number I am (the user can be seeking for example). My ""hacky"" solution was to have a ""lastTime"" and ""numTimes"" on the struct I pass into these callbacks and this is what I do:</p>

<p>lastTime represents the ""last new time"" received and numTimes represents the number of times lastTime was received.</p>

<pre><code>get_the_current_time
calculate_frame_num_with_fps
if current_time is equal to lastTime:
     frameNum += numTimes
     numTimes++
else
     lastTime = current_time
     numTimes = 1
</code></pre>

<p>This kinda works but I hate the solution. I'm not sure if when doing seeking the time changes if the difference is less than 250ms. That would maybe be kinda hard for a user to do but I'd prefer not to implement it like that.</p>

<p>So my question is if there is another, better solution for this? </p>

<p>Thank you for your time.</p>

<p>EDIT:
I just realized that my solution does not work quite well because even if the video is paused the handlers are all being called, resulting in ""current_time == lastTime"", which will keep increasing frames when in reality is the same one. I also don't see a way to check if it's the same frame or not. I'm completely out of ideas. </p>
"
"<p>I am using NS2 to simulate a modified routing protocol. This is how it works in brief:</p>

<p>I create some nodes using a .tcl file. For every node, a routing agent is created by the following:</p>

<pre><code>static class WFRPclass : public TclClass {
public:
WFRPclass() : TclClass(""Agent/WFRP"") {}
TclObject* create(int argc, const char*const* argv) {
    assert(argc == 5);
    return (new WFRP((nsaddr_t) Address::instance().str2addr(argv[4])));
}
} class_rtProtoWFRP;
</code></pre>

<p>The new <code>WFRP(nsaddr_t)</code> is the constructor. This is the constructor code:</p>

<pre><code>WFRP::WFRP(nsaddr_t id) : Agent(PT_WFRP),bcnTimer(this), rtcTimer(this){

index = id;
seqno = 0;
dest=0;
rand=371+(id*2);
nod++;


printf(""N (%.6f): Routing agent is initialized for node %d ,Random Number   is %d\n"", CURRENT_TIME, id,rand);
LIST_INIT(&amp;rthead);
posx = 0;
posy = 0;

logtarget = 0;
ifqueue = 0;

}
</code></pre>

<p>The above code runs in a .cc file.Lot of packet forwarding functions are defined here,and every node that forwards a packet increases it seq no by one.
The constructor and it's class are defined in a .h file</p>

<p>The class in .h are as follows</p>

<pre><code>class WFRP : public Agent {
friend class RouteCacheTimer;

public:
WFRP(nsaddr_t id);
.....
/lot of functions defined here
}
</code></pre>

<p>Can one constructor of the class say WFRP(5) [nsaddr_t are just simple int numbers,ranging from 0 to number of nodes I create.They are sequential]</p>

<p>Can WFRP(5) access WFRP(8)'s seqno? Both these constructors will increase the values seqno independently of each other, so can I?</p>

<p><strong>EDIT</strong>
The code is used in NS2.It uses a combination of tcl(front end) and c++(back end).This statement in tcl</p>

<pre><code>$ns at 1.0 ""[$mnode_(0) set ragent_] sink""
</code></pre>

<p>shifts the control to this line of c++ code</p>

<pre><code>if(strncasecmp(argv[1], ""sink"", 4) == 0) {
        bcnTimer.handle((Event*) 0);
    printf(""N (%.6f): sink node is set to %d, start beaconing ,Random Number set to %d \n"", CURRENT_TIME, index,rand);
        return TCL_OK;
    }
</code></pre>

<p>Notice in the tcl line it is  [mnode_(0)]..so right now the control flow is in WFRP(0) i.e. nsaddr_t =0.
Can WFRP(0) access WFRP(5) variable values.</p>

<p>Apologies,if the question is unclear.</p>
"
"<p>I'm currently programming my Raspberry Pi (model B) with a DHT11 temperature &amp; humidity sensor and lcd display. I have written a C script which logs values obtained from the temperature sensor to a status file which is then added to a log file. The script is as follows:</p>

<pre><code>#include &lt;time.h&gt;

#define LOGFILE ""/var/log/temp.log""
#define CURRENTFILE ""/var/temp.data""



/* Saves the date time and humidity to a log file and current file */


void write_value (int temp, int humidity) {

    time_t current_time;
    current_time = time(NULL);

    /* Write to log file */
    FILE *logfd;
    logfd = fopen (LOGFILE, ""a"");
    fprintf (logfd, ""%ld %d %d\n"", current_time, temp, humidity);
    fclose (logfd);

    /* Write to current file */
    FILE *currfd;
    currfd = fopen(CURRENTFILE, ""w"");
    fprintf (currfd, ""%ld %d %d\n"", current_time, temp, humidity);
    fclose (currfd);

}
</code></pre>

<p>It works, however; the output I get in the log file is as follows:</p>

<pre><code>1428539174 16 41
1428539232 17 40
1428539257 18 40
1428539304 19 39
1428539319 19 39
</code></pre>

<p>With the first row intended to be the date &amp; time stamp, the temperature, and the humidity.</p>

<p>Do you have any suggestions as to how I could fix the date &amp; time, as well as changing it to a DD/MM/YYYY HH:MM:SS (Day/Month/Year Hour:Min:Sec) format?</p>

<p>Based on suggestions from @pmg the script was changed to:</p>

<pre><code>#include &lt;time.h&gt;

#define LOGFILE ""/var/log/temp.log""
#define CURRENTFILE ""/var/temp.data""



/* Saves the date time and humidity to a log file and current file */


void write_value (int temp, int humidity) {

    char dt[20]; // space enough for YYYY-MM-DD HH:MM:SS and terminator
    struct tm tm;
    time_t current_time;
    current_time = time(NULL);
    tm = *localtime(&amp;current_time); // convert time_t to struct tm
    strftime(dt, sizeof dt, ""%Y-%m-%d %H:%M:%S"", &amp;tm); // format

    /* Write to log file */
    FILE *logfd;
    logfd = fopen (LOGFILE, ""a"");
    fprintf (logfd, ""%s %d %d/n"", dt, temp, humidity);
    fclose (logfd);

    /* Write to current file */
    FILE *currfd;
    currfd = fopen(CURRENTFILE, ""w"");
    fprintf (currfd, ""%s %d %d/n"", dt, temp, humidity);
    fclose (currfd);

}
</code></pre>
"
"<p>I'm curious, in the first place, why <code>std::list</code> and <code>std::forward_list</code> include sorting functions as member functions, unlike every other standard library container. But what's more interesting to me is that both <a href=""http://en.cppreference.com/w/cpp/container/forward_list/sort"" rel=""nofollow noreferrer"">CPPReference</a> and <a href=""http://www.cplusplus.com/reference/forward_list/forward_list/sort/"" rel=""nofollow noreferrer"">CPlusPlus</a> claim that this sorting is done in O(<em>n</em> log <em>n</em>) time.</p>

<p>I can't even imagine how one would sort a container without random access to elements. So I threw together a test, using <code>forward_list</code> to make it as difficult as possible.</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;cstdint&gt;
#include &lt;deque&gt;
#include &lt;forward_list&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;

using std::endl;
using namespace std::chrono;

typedef nanoseconds::rep length_of_time;
constexpr int TEST_SIZE = 25000;


class Stopwatch
{
    public:
        void start_timing();
        void end_timing();
        length_of_time get_elapsed_time() const;
    private:
        time_point&lt;high_resolution_clock&gt; start;
        time_point&lt;high_resolution_clock&gt; end;
        length_of_time elapsed_time = 0;
};


void Stopwatch::start_timing()
{
    start = high_resolution_clock::now();
}


void Stopwatch::end_timing()
{
    end = high_resolution_clock::now();
    auto elapsed = end - start;
    auto elapsed_nanoseconds = duration_cast&lt;nanoseconds&gt;(elapsed);
    elapsed_time = elapsed_nanoseconds.count();
}


length_of_time Stopwatch::get_elapsed_time() const
{
    return elapsed_time;
}


std::mt19937_64 make_random_generator()
{
    using namespace std::chrono;
    auto random_generator = std::mt19937_64();
    auto current_time = high_resolution_clock::now();
    auto nanos = duration_cast&lt;nanoseconds&gt;(
            current_time.time_since_epoch()).count();
    random_generator.seed(nanos);
    return random_generator;
}


int main()
{
    Stopwatch timer;
    std::deque&lt;length_of_time&gt; times;
    auto generator = make_random_generator();
    for (int i = 1; i &lt;= TEST_SIZE; i++) {
        std::forward_list&lt;uint64_t&gt; container;
        for (int j = 1; j &lt;= i; j++) {
            container.push_front(generator());
        }
        timer.start_timing();
        container.sort();
        timer.end_timing();
        times.push_back(timer.get_elapsed_time());
        container.clear();
    }

    for (const auto&amp; time: times) {
        std::cout &lt;&lt; time &lt;&lt; endl;
    }
}
</code></pre>

<p>The numbers this program output gave the following graph:</p>

<p><img src=""https://i.stack.imgur.com/fWNPV.png"" alt=""forward list sorting time""></p>

<p>Which does indeed look like O(<em>n</em> log <em>n</em>) growth (although the spikes at each third of the way across are interesting). How does the library do this? Perhaps copy to a container that supports sorting, sort that, and copy back?</p>
"
"<p>I'm trying to print out the date, in a human readable format, for the maximum time_t value possible.
The following code seems to work just fine on 32bits machines (initializing m_time with 0x7fffffff), but it outputs null for the theoretically highest value on a 64bits machine. Is that a ctime limitation or am I missing something?</p>

<p>compilation : gcc -Wall -g3 main.c -o time_test<br>
host machine: x86_64.  </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;stddef.h&gt;

int main(int argc, char** argv) {
  time_t m_time = 0x7fffffffffffffff;
  time_t current_time;
  time(&amp;current_time);

  printf(""time_t info: sizeof [%ld] bytes or [%ld] bits.\n"", sizeof(time_t), sizeof(time_t) *8 );
  printf(""m_time val: [%ld]-&gt; %s\n"", m_time, ctime(&amp;m_time));
  printf(""current_time val: [%ld]-&gt; %s\n"", current_time, ctime(&amp;current_time));
  return 0;
}
</code></pre>

<p>Output:  </p>

<pre><code>time_t info: sizeof [8] bytes or [64] bits.
m_time val: [9223372036854775807]-&gt; (null)
current_time val: [1430678274]-&gt; Sun May  3 15:37:54 2015
</code></pre>

<p>tks.</p>
"
"<p>I've been looking at this for a while in the debugger while Googling around, but I think I've stumbled upon some C++ behavior that I'm not familiar with. I'm going to give a quick outline on what I'm doing and what/where the problem is. I'll put code block below.</p>

<p>The rough outline of what's happening is:</p>

<ol>
<li>Created a custom class (LogReader) to handle a single log file.</li>
<li>LogReader contains a pointer to an ifstream (ifstream *log_file)</li>
<li>The ifstream is used with getline() in the constructor, this works fine.</li>
<li>The LogReader is placed in a vector.
<ul>
<li>The code below for main.cpp is using the LogReader directly (without the vector). The segfault occurs in both cases.</li>
</ul></li>
<li>LogReader.advance() is called. getline() is used in this function. The segfault occurs here (commented in LogReader.cpp). </li>
</ol>

<p>Thanks for any help on what C++ behaviors I'm missing that might be causing this!</p>

<p>EDIT: Not placing the <code>LogReader</code> into a vector removes the segfault (failing elsewhere now, but not a problem). The change is commenting the following line out in main.cpp</p>

<pre><code>readers.push_back(&amp;label_reader);
</code></pre>

<p>I guess now the question is why using std::vector is causing this problem.</p>

<hr>

<p>LogReader.h</p>

<pre><code>#ifndef LOGREADER
#define LOGREADER

using namespace std;

class LogReader {
     private:
         LogReader(){} // private default constructor

     public:
         ifstream *log_file; // file the log is read from
         vector&lt;int&gt; val_locations; // offsets in line for values
         string next_line; // next line from the file

         int current_time; // time for most recent reading
         string current_line;
         int next_time; // what is the next time in the file
         vector&lt;string&gt; current_vals; // what the current vals are

         LogReader(string log_loc, vector&lt;int&gt; offsets); // given a file to start on

         bool advance(int new_time); // advance the log reader, return true if advanced
         bool has_more(); // is there more in the log
 };

 #endif
</code></pre>

<hr>

<p>LogReader.cpp</p>

<pre><code>// c++ imports
#include &lt;boost/algorithm/string.hpp&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

// my imports
#include ""LogReader.h""
#include ""functions.h""

using namespace std;

LogReader::LogReader(string log_loc, vector&lt;int&gt; offsets){
    // make the file reader
    ifstream lf(log_loc);
    log_file = &amp;lf;
    // pull out the first line
    getline(*log_file, current_line);
    cout &lt;&lt; current_line &lt;&lt; endl;

    // get the set of current values
    val_locations = offsets;
    for(int i = 0; i &lt; val_locations.size(); i++) {
        current_vals.push_back(get_line_part(current_line,
                    val_locations.at(i)));
    }
    // get the current time
    current_time = stoi(get_line_part(current_line, 0));

    // pull down the next line
    getline(*log_file, next_line);
    cout &lt;&lt; next_line &lt;&lt; endl;
    // get the next time
    next_time = stoi(get_line_part(next_line, 0));
}

bool LogReader::advance(int new_time){
    if(new_time &lt; next_time)
        return false; // nothing to do, current still good

    cout &lt;&lt; ""can check time"" &lt;&lt; endl;

    // update the time and values
    current_time = next_time;
    current_line = next_line;
    current_vals.clear();

    cout &lt;&lt; ""can do housekeeping"" &lt;&lt; endl;

    for(int i = 0; i &lt; val_locations.size(); i++) {
        current_vals.push_back(get_line_part(next_line,
                    val_locations.at(i)));
    }

    cout &lt;&lt; ""can push in new values"" &lt;&lt; endl;

    // move the line
    next_line.clear();
    if(!getline(*log_file, next_line)) {  // **SEGFAULT**
        // no more lines
        cout &lt;&lt; ""no more lines"" &lt;&lt; endl;
        next_line.clear();
        next_time = -1;
        return true;
    }
    cout &lt;&lt; ""got the line"" &lt;&lt; endl;
    // update the time as well
    next_time = stoi(get_line_part(next_line, 0));
    return true;
}

bool LogReader::has_more(){
    return next_time != -1;
}
</code></pre>

<hr>

<p>main.cpp</p>

<pre><code>// c imports
#include &lt;time.h&gt;

// c++ imports
#include &lt;algorithm&gt;
#include &lt;boost/algorithm/string.hpp&gt;
#include &lt;boost/date_time.hpp&gt;
#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;
#include &lt;boost/filesystem.hpp&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;

// my imports
#include ""LogReader.h""
#include ""functions.h""

// custom shorter namespaces
namespace bfs = boost::filesystem;

// used namespaces
using namespace std;

void update_line(int *current_time, string *current_line,
        ifstream *current_file){
    if(!getline(*current_file, *current_line)){
        *current_time = -1;
        current_line-&gt;clear();
        return;
    }

    try {
        *current_time = stoi(get_line_part(*current_line, 0));
    } catch (int e) {
        cout &lt;&lt; ""update line, bad stoi on time"" &lt;&lt; endl;
        cout &lt;&lt; *current_line &lt;&lt; endl;
        throw e;
    }
}

void update_vals(vector&lt;float*&gt; vals, string line) {
    for(int i = 0; i &lt; vals.size(); i++) {
        // offset for fact that first two are time and sensor
        try {
            *(vals.at(i)) = stof(get_line_part(line, 2 + i));
        } catch (int e) {
            cout &lt;&lt; ""update_vals, bad stof for "" &lt;&lt; i &lt;&lt; endl;
            cout &lt;&lt; line &lt;&lt; endl;
            throw e;
        }
    }
}

string get_correct_file(string name, vector&lt;string&gt; options) {
    for(int i =0; i &lt; options.size(); i++) {
        string option = options.at(i);
        if(boost::algorithm::contains(option, name)){
            return option;
        }
    }

    return string("""");
}

int main(int argc, char* argv[]) {
    // open the base dir
    bfs::path base_dir(""log/"");
    if(!bfs::exists(base_dir) &amp;&amp; !bfs::is_directory(base_dir)){
        cout &lt;&lt; ""Bad base directory"" &lt;&lt; endl;
        return 1;
    }

    // create a vector of the possible traces
    vector&lt;string&gt; traces;
    for(bfs::directory_iterator iter(base_dir);
            iter != bfs::directory_iterator(); iter++) {
        stringstream trace_path;
        trace_path &lt;&lt; iter-&gt;path().string();
        traces.push_back(trace_path.str());
    }

    int trace_index = user_choose_option(traces);

    // load that directory
    bfs::path trace_dir(traces.at(trace_index));
    if(!bfs::exists(base_dir) &amp;&amp; !bfs::is_directory(base_dir)){
        cout &lt;&lt; ""Selected a bad trace directory"" &lt;&lt; endl;
        return 1;
    }

    // get the image directory
    cout &lt;&lt; ""loading image directory"" &lt;&lt; endl;
    string img_path_string = trace_dir.string();
    stringstream img_path_stream;
    img_path_stream &lt;&lt; img_path_string &lt;&lt; ""/img/"";
    bfs::path img_dir(img_path_stream.str());
    if(!bfs::exists(img_dir) &amp;&amp; !bfs::is_directory(img_dir)){
        cout &lt;&lt; ""no image directory"" &lt;&lt; endl;
        return 1;
    }

    // get image list, ends up in sorted order from naming conventions
    cout &lt;&lt; ""getting image paths"" &lt;&lt; endl;
    vector&lt;string&gt; image_paths;
    for(bfs::directory_iterator iter(img_dir);
            iter != bfs::directory_iterator(); iter++) {
        stringstream image_path;
        image_path &lt;&lt; iter-&gt;path().string();
        image_paths.push_back(image_path.str());
    }

    // get the data traces
    cout &lt;&lt; ""loading data traces"" &lt;&lt; endl;
    vector&lt;string&gt; log_paths;
    vector&lt;string&gt; label_paths;
    string trace_path_string = trace_dir.string();
    for(bfs::directory_iterator iter(trace_path_string);
            iter != bfs::directory_iterator(); iter++) {
        string cur_file = iter-&gt;path().string();
        cout &lt;&lt; cur_file &lt;&lt; endl;
        if(boost::algorithm::contains(cur_file, ""label-"")) {
            label_paths.push_back(cur_file);
        } else if(boost::algorithm::contains(cur_file, ""log-"")) {
            log_paths.push_back(cur_file);
        }
    }
    cout &lt;&lt; endl;

    // temp for reading in line parts
    // istringstream temp;

    cout &lt;&lt; ""getting log readers"" &lt;&lt; endl;
    // choose the label file to use, get first line
    int label_index = user_choose_option(label_paths);
    vector&lt;int&gt; label_offsets;
    label_offsets.push_back(1);
    LogReader label_reader(label_paths.at(label_index), label_offsets);
    /*
    ifstream label_file(label_paths.at(label_index));
    string label_line;
    getline(label_file, label_line);
    int label_time;
    temp.clear();
    temp.str(get_line_part(label_line, 0));
    temp &gt;&gt; label_time;
    string label_current = get_line_part(label_line, 1);
    */

    /*
    // get the accel
    string accel_path = get_correct_file(""accel"", log_paths);
    vector&lt;int&gt; accel_offsets;
    accel_offsets.push_back(2);
    accel_offsets.push_back(3);
    accel_offsets.push_back(4);
    LogReader accel_reader(accel_path, accel_offsets);
    */

    vector&lt;LogReader*&gt; readers;
    vector&lt;bool&gt; updated;
    readers.push_back(&amp;label_reader);
    updated.push_back(true);
//    readers.push_back(&amp;accel_reader);
//    updated.push_back(true);

    int l_time = current_time_min(readers);
    while(label_reader.has_more() ){ // || accel_reader.has_more()) {
        // figure out what time to advance to
        int n_time;
        cout &lt;&lt; label_reader.has_more() &lt;&lt; endl;
        if(same_current_time(readers)) {
            n_time = next_time_min(readers);
        } else {
            n_time = current_time_nextmin(readers);
        }
        cout &lt;&lt; n_time &lt;&lt; endl;

        label_reader.advance(n_time);
        cout &lt;&lt; label_reader.current_line &lt;&lt; endl;
        /*
        // advance all the readers
        for(int i = 0; i &lt; readers.size(); i++) {
            cout &lt;&lt; ""loop "" &lt;&lt; i &lt;&lt; endl;
            // keep track of which values updated
            readers.at(i);
            cout &lt;&lt; ""can get from vector"" &lt;&lt; endl;
            bool advanced = readers.at(i)-&gt;advance(n_time);
            cout &lt;&lt; advanced &lt;&lt; endl;
            if(advanced) {
                updated.at(i) = true;
            } else {
                updated.at(i) = false;
            }
        }

        // sanity check printing
        for(int i = 0; i &lt; readers.size(); i++) {
            cout &lt;&lt; readers.at(i)-&gt;current_line &lt;&lt; endl;
        }
        */

        // deal with statistics here

    }

    /*
    ifstream accel_file(accel_path);
    string accel_line;
    getline(accel_file, accel_line);
    int accel_time;
    temp.clear();
    temp.str(get_line_part(accel_line, 0));
    temp &gt;&gt; accel_time;
    float accel_current_x = stof(get_line_part(accel_line, 2));
    float accel_current_y = stof(get_line_part(accel_line, 3));
    float accel_current_z = stof(get_line_part(accel_line, 4));
    vector&lt;float*&gt; accel_vals;
    accel_vals.push_back(&amp;accel_current_x);
    accel_vals.push_back(&amp;accel_current_y);
    accel_vals.push_back(&amp;accel_current_z);

    // get the sprox
    string sprox_path = get_correct_file(""sprox"", log_paths);
    ifstream sprox_file(sprox_path);
    string sprox_line;
    getline(sprox_file, sprox_line);
    int sprox_time;
    temp.clear();
    temp.str(get_line_part(sprox_line, 0));
    temp &gt;&gt; sprox_time;
    float sprox_current = stof(get_line_part(sprox_line, 2));
    vector&lt;float*&gt; sprox_vals;
    sprox_vals.push_back(&amp;sprox_current);

    // get the lprox
    string lprox_path = get_correct_file(""lprox"", log_paths);
    ifstream lprox_file(lprox_path);
    string lprox_line;
    getline(lprox_file, lprox_line);
    int lprox_time;
    temp.clear();
    temp.str(get_line_part(lprox_line, 0));
    temp &gt;&gt; lprox_time;
    float lprox_current = stof(get_line_part(lprox_line, 2));
    vector&lt;float*&gt; lprox_vals;
    lprox_vals.push_back(&amp;lprox_current);

    // get the light
    string light_path = get_correct_file(""light"", log_paths);
    ifstream light_file(light_path);
    string light_line;
    getline(light_file, light_line);
    int light_time;
    temp.clear();
    temp.str(get_line_part(light_line, 0));
    temp &gt;&gt; light_time;
    float light_current = stof(get_line_part(light_line, 2));
    vector&lt;float*&gt; light_vals;
    light_vals.push_back(&amp;light_current);
    */

//    int time_current = min(label_time, min(sprox_time,
//                min(lprox_time, min(accel_time,
//                light_time))));

    /*
    // variables for processing here
    int total_time = 0;
    map&lt;string, int&gt; label_counts;

    while(label_time != -1 || accel_time != -1 || sprox_time != -1
            || lprox_time != -1 || light_time != -1) {
        time_current++;
        if(label_time != -1 &amp;&amp; time_current &gt; label_time) {
            update_line(&amp;label_time, &amp;label_line, &amp;label_file);
            if(label_line.size() &gt; 0) // if last label, don't overwrite
                label_current = get_line_part(label_line, 1);
        }
        if(accel_time != -1 &amp;&amp; time_current &gt; accel_time) {
            update_line(&amp;accel_time, &amp;accel_line, &amp;accel_file);
            if(accel_line.size() &gt; 0) // if last line, don't overwrite
                update_vals(accel_vals, accel_line);
        }
        if(sprox_time != -1 &amp;&amp; time_current &gt; sprox_time) {
            update_line(&amp;sprox_time, &amp;sprox_line, &amp;sprox_file);
            if(sprox_line.size() &gt; 0) // if last line, don't overwrite
                update_vals(sprox_vals, sprox_line);
        }
        if(lprox_time != -1 &amp;&amp; time_current &gt; lprox_time) {
            update_line(&amp;lprox_time, &amp;lprox_line, &amp;lprox_file);
            if(lprox_line.size() &gt; 0) // if last line, don't overwrite
                update_vals(lprox_vals, lprox_line);
        }
        if(light_time != -1 &amp;&amp; time_current &gt; light_time) {
            update_line(&amp;light_time, &amp;light_line, &amp;light_file);
            if(light_line.size() &gt; 0) // if last line, don't overwrite
                update_vals(light_vals, light_line);
        }

        // Processing happens here
        total_time++;
        if(label_counts.count(label_current) == 0)
            // not in map
            label_counts[label_current] = 0;
        label_counts[label_current]++;
    }

    // post processing happens here
    cout &lt;&lt; ""Labels Counts:"" &lt;&lt; endl;
    for(map&lt;string, int&gt;::iterator it = label_counts.begin();
            it != label_counts.end(); it++) {
        cout &lt;&lt; it-&gt;first &lt;&lt; "" -&gt; "" &lt;&lt; it-&gt;second &lt;&lt; "" -&gt; "";
        cout &lt;&lt; 1.0 * it-&gt;second / total_time &lt;&lt; endl;
    }
    */
}
</code></pre>
"
"<p>I recently asked a question on <a href=""https://softwareengineering.stackexchange.com/questions/284160/is-there-any-advantage-to-c-style-bit-manipulation-over-stdbitset"">Programmers</a> regarding reasons to use manual bit manipulation of primitive types over <code>std::bitset</code>.</p>

<p>From that discussion I have concluded that the main reason is performance, although I'm not aware of any measured basis for this opinion. So my next question is; <strong>what <em>is</em> the performance hit, if any, likely to be incurred by using <code>std::bitset</code> over a primitive?</strong></p>

<p>The question is intentionally broad, because after looking online I haven't been able to find anything, so I'll take what I can get. Basically I'm after a resource that provides some profiling of <code>std::bitset</code> vs 'pre-bitset' alternatives to the same problems on some common machine architecture using GCC, Clang and/or VC++. There is a very comprehensive paper which attemtps to answer this question for bit vectors:</p>

<p><a href=""http://www.cs.up.ac.za/cs/vpieterse/pub/PieterseEtAl_SAICSIT2010.pdf"" rel=""noreferrer"">http://www.cs.up.ac.za/cs/vpieterse/pub/PieterseEtAl_SAICSIT2010.pdf</a></p>

<p>Unfortunately it either predates or considered out of scope <code>std::bitset</code>, so it focuses on vectors/dynamic array implementations instead.</p>

<p>I really just want to know whether <code>std::bitset</code> is <em>better</em> than the alternatives for the use cases it is intended to solve. I already know that it is <em>easier</em> and <em>clearer</em> than bit-fiddling on an integer, but is it as <em>fast</em>?</p>
"
"<p>I have a small Python script which sends POST requests to a server and gets their response.</p>

<p>It iterates 10000 times, and I managed to print the current progress in command prompt using:</p>

<pre><code>code=current_requestnumber
print('{0}/{1}'.format(str(code),""10000""),end=""\r"")
</code></pre>

<p>at the end of each loop.</p>

<p>Because this involves interaction with a webserver, I would like to show the current average speed next to this too (updated like every 2 seconds).</p>

<p>An example at the bottom of the command prompt would then be like this:</p>

<p>(1245/10000), 6.3 requests/second</p>

<p>How do I achieve this?</p>
"
"<p>I'm currently trying to figure out the best way to see if X seconds have elapsed. The basic implementation I have in mind is as follows:</p>

<pre><code>wait_for = 5;   // 5 seconds

ready_at = current_time() + wait_for;    // might wrap around! :(


...

/* There is no sleep call; there will be processing happening. */

...


if (current_time() &gt;= ready_at)     // might also have wrapped around!
    do_stuff()
</code></pre>

<p>Pretty simple, right? The catch is that the process itself will be very long running, and although the <code>wait_for</code> time will be very brief in comparison, I worry that <code>current_time</code> will wrap around and the event won't fire. For obvious reasons, this code is rather annoying to test.</p>

<p>So my questions are:</p>

<ol>
<li><p>What is the best time resolution method to use? I prefer something that is in posix, but linux-compatible is good enough. Tenth-of-a-second resolution is good enough. (That said, the check might not be executed for over an hour in particularly bad cases!)</p></li>
<li><p>How to properly deal with time wrapping around for both
a) the calculation of ready_at, and
b) the check whether or not it is ready?</p></li>
</ol>

<p>Firing <code>do_stuff()</code> early is not really an option.</p>

<p>I'm well aware the logic of this should not be too difficult on its own, but I'm reasoning myself in circles on this one. My mind simply won't cooperate with me.</p>
"
"<p>Python is not able update the time according to selected timezone in inux.</p>

<p>I have python code which just trying to print time in ISO format using python date time module as in below code.</p>

<pre><code>{

import datetime

current_time = datetime.datetime.now().isoformat()

print current_time

}
</code></pre>

<p>I am trying to run this code in the startup script of linux.
I have set the time zone in the linux as <code>UTC-05:30</code>. But still I am getting ""current_time"" as in UTC and not in <code>UTC-05:30</code>. The ""current_time"" is lags behind the system time by <code>05:30</code> hours.
I am really sure why python is not able to use the system time during the boot up.
Please let me know anybody know about this issue.</p>

<p>My problem has to do something about the starting python script at bootup. I think Linux is not able to set its time according to timezone at bootup . I have printed system time at boot up which is in UTC and not in UTC-05:30 though my timezone is UTC-05:30. Since my script is starting at bootup,it took system time which is set according to UTC and not UTC-05:30. Once the system boots up, system time is set correctly according to timezone.I will get correct output for date command. But some how my python application is not able get the time according to timezone.</p>

<p>Please help!
Thanks in advance.</p>
"
"<p>I wrote a simple fragment shader that renders a mandelbrot set. I am doing this in c and with opengl using glsl.</p>

<pre><code>#version 330 core
in vec2 fCoord; //position.x position.y which is -1 to 1 on both axis
uniform int maxIterations;
uniform sampler1D mandiTexture;

out vec4 color;

void main()
{
   vec2 c, z;

    c.x = fCoord.x;
    c.y = fCoord.y;

        int i;
        z = vec2(0.0f, 0.0f);
        for(i=0; i&lt;maxIterations; i++) {
            float x = (z.x * z.x - z.y * z.y) + c.x;
            float y = (z.y * z.x + z.x * z.y) + c.y;

            if((x * x + y * y) &gt; 4.0) break;
            z.x = x;
            z.y = y;
        }

    vec4 tcolor;

    if (i == maxIterations)
    {
       tcolor = vec4(0.0f, 0.0f, 0.0f, 1.0f);
    }
       else
    {
       tcolor = texture(mandiTexture, float(i) / float(maxIterations));
    }
    color =  tcolor;
}
</code></pre>

<p>i've noticed playing around with the initial z value I get some different results but mostly they extend outside of my quad. With z as 0, 0 I get this result.
<a href=""https://i.stack.imgur.com/9HlLB.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9HlLB.png"" alt=""enter image description here""></a></p>

<p>as you can see the left side of the set is not being rendered on the quad.</p>

<p>The c value is coming from the vertex shader so i assume it goes for -1 to 1 on both x and y axis and being interpolated in between.</p>

<p>My questions are:</p>

<ul>
<li>1) How can I center the image on the quad? I am not really sure of
that.</li>
<li>2) How can I say zoom in on some in on the mandelbrot set and a
follow up, lets say I want to zoom in on a specific part of the set?</li>
<li>2B) Let's say I click the screen and get the position in NDC?</li>
<li>3) If I set my max iterations higher the set seems to get really
jaggy, is that normal behavior?</li>
</ul>

<p>I think if I can understand how to zoom in on the set I can figure out how to zoom in on a specific part but I am unsure.</p>

<p><strong>edit, making sure that my code is</strong></p>

<p>main.c</p>

<pre><code>int maxIterations = 70;
int iterAmount = 1;

char* vshad, *fshad;

GLuint verticesBuffer, colorBuffer, vao, texCoordBuffer, indicesBuffer;
GLuint mandiTextureID, sp;

mat4_s vm, pm, opm, tm;
GLint viewMat = -1;
GLint projMat = -1;
GLint modelMat = -1;

GLint mandiTexture = -1;
GLint maxIterLoc = -1;



void initShaders(void)
{

    char* vertexShaderSource = getResource(""vert.shad"");
    char* fragmentShaderSource = getResource(""frag.shad"");

    vshad = readFile(vertexShaderSource);
    fshad = readFile(fragmentShaderSource);

    free(vertexShaderSource);
    free(fragmentShaderSource);
}

int run_game()
{
    current_utc_time(&amp;start_time);
    while(game_running)
    {
        current_utc_time(&amp;current_time);
        double frameTime = (diff(start_time,current_time).tv_sec + diff(start_time,current_time).tv_nsec) * .00000001;
        //printf(""float time: %0.8f\n"",frameTime);
        if ( frameTime &gt; 0.25 )
        {
            frameTime = 0.25;
        }
        current_utc_time(&amp;start_time);
        current_time = start_time;

        accumulator += frameTime;

        while ( accumulator &gt;= dt )
        {
            accumulator -= dt;
            t += dt;
            //printf(""fixed update dt: %0.8f\n"",dt);
        }
        //render_state = currentState * alpha +  previousState * ( 1.0 - alpha );
        const double alpha = accumulator / dt;
        render();

        if(game_running &lt; 1) { break; }
        while (SDL_PollEvent(&amp;event))
        {
            switch (event.type) {
                case SDL_QUIT:
                    game_running = -1;
                    break;
                case SDL_KEYDOWN:
                    switch (event.key.keysym.sym)
                    {
                        case SDLK_ESCAPE:
                            game_running = -1;
                            break;
                    }
                    break;
            }
        }
    }
    return -1;
}

int main(int argc, char const *argv[]) {
    initShaders();

    mat4_identity(&amp;vm);
    vec3_s eye    = {0, 0, 0};
    vec3_s center = {0, 0, -1};
    vec3_s up     = {0, 1, 0};

    mat4_lookAt(&amp;vm, &amp;eye, &amp;center, &amp;up);

    mat4_identity(&amp;opm);
    mat4_ortho(&amp;opm, 0, 200, 0, 200, 1, 100);

    mat4_identity(&amp;tm);
    mat4_scalex(&amp;tm, &amp;tm, 100, 100, 0);
    mat4_translatex(&amp;tm, &amp;tm, 100.0f, 100.0f, -20);

    SDL_Surface* mandiSurface = loadPNG(getResource(""mandi.png""));

    if(!mandiSurface) {
        printf(""IMG_Load: %s\n"", IMG_GetError());
        // handle error
    }

    GLenum Mode1 = GL_RGB;

    if(4 == mandiSurface-&gt;format-&gt;BytesPerPixel)
    {
        Mode1 = GL_RGBA;
        printf(""mode change"");
    }

    sp = getShaderProgram(vshad, fshad);
    r = newRenderable2d();

    glGenVertexArrays(1, &amp;vao);
    glGenBuffers(1, &amp;verticesBuffer);
    glGenBuffers(1, &amp;colorBuffer);
    glGenBuffers(1, &amp;indicesBuffer);
    glGenBuffers(1, &amp;texCoordBuffer);

    glBindVertexArray(vao); //bind vertex array buffer

    glBindBuffer(GL_ARRAY_BUFFER, verticesBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(r-&gt;vertices), r-&gt;vertices, GL_STATIC_DRAW);

    //bind n setup indices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, indicesBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(r-&gt;indices), r-&gt;indices, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);
    glEnableVertexAttribArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, 0); //unbind indices

    //bind n setup colors
    glBindBuffer(GL_ARRAY_BUFFER, colorBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(r-&gt;colors), r-&gt;colors, GL_STATIC_DRAW);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);
    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, 0); //unbind colors

    //bind n setup texture coords
    glBindBuffer(GL_ARRAY_BUFFER, texCoordBuffer);
    glBufferData(GL_ARRAY_BUFFER, sizeof(r-&gt;texCoords), r-&gt;texCoords, GL_STATIC_DRAW);
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(GLfloat), (GLvoid*)0);
    glEnableVertexAttribArray(2);
    glBindBuffer(GL_ARRAY_BUFFER, 0); //unbind texture coords

    glBindVertexArray(0); //unbind vertex array buffer

    //mandi 1d texture
    glGenTextures(1, &amp;mandiTextureID);
    glBindTexture(GL_TEXTURE_1D, mandiTextureID);

    glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_WRAP_T, GL_REPEAT);

    glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

    glTexImage1D(GL_TEXTURE_1D, 0, Mode1, mandiSurface-&gt;w, 0, Mode1, GL_UNSIGNED_BYTE, mandiSurface-&gt;pixels);
    glBindTexture(GL_TEXTURE_1D, 0);
    free(mandiSurface);


    while(run_game() &gt;= 0);
    free(r);
    IMG_Quit();
    SDL_GL_DeleteContext(maincontext);
    SDL_DestroyWindow(window);
    return 0;
}

void render()
{
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    glUseProgram(sp);

    glActiveTexture(GL_TEXTURE0);
    glBindTexture(GL_TEXTURE_1D, mandiTextureID);//mandiTexture
    mandiTexture = getUniformLocation(sp, ""mandiTexture"");
    glUniform1i(mandiTexture, 0);


    glBindVertexArray(verticesBuffer);
    viewMat = getUniformLocation(sp, ""viewMat"");
    modelMat = getUniformLocation(sp, ""modelMat"");
    projMat = getUniformLocation(sp, ""projMat"");

    maxIterLoc = getUniformLocation(sp, ""maxIterations"");

    glUniformMatrix4fv(viewMat, 1, GL_FALSE, vm.m);
    glUniformMatrix4fv(projMat, 1, GL_FALSE, opm.m);
    glUniformMatrix4fv(modelMat, 1, GL_FALSE, tm.m);

    glUniform1i(maxIterLoc, maxIterations);

    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
    glBindVertexArray(0);

    SDL_GL_SwapWindow(window);
}

int init_sdl(int width, int height, char* title, double fps)
{

if (SDL_Init(SDL_INIT_EVERYTHING) != 0)
  {
    SDL_Log(""sdl failed to init"");
    SDL_Quit();
    return -1;
  }

    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);

    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);


  window = SDL_CreateWindow(title, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, width, height, SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN);
  if(window == NULL)
  {
    SDL_Log(""sdl failed to create window"");
    SDL_Quit();
    return -1;
  }

  maincontext = SDL_GL_CreateContext(window);
  if(maincontext == NULL)
  {
    SDL_Log(""sdl failed to create opengl context"");
    SDL_Quit();
    return -1;
  }
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    SDL_GL_SetSwapInterval(1);


  return 1;
}
</code></pre>

<p>vertex shader</p>

<pre><code>#version 330 core

layout (location = 0) in vec3 position;
layout (location = 1) in vec3 icolor;
layout (location = 2) in vec2 vTexCoord;

uniform mat4 modelMat;
uniform mat4 viewMat;
uniform mat4 projMat;

out vec4 fcolor;
out vec2 fTexCoord;
out vec2 fCoord;

void main()
{
    gl_Position =  projMat * viewMat * modelMat * vec4(position, 1.0);

    fCoord = vec2(position);
    fTexCoord = vTexCoord;
    fcolor = vec4(icolor, 1.0f);
}
</code></pre>

<p>thanks to @samgak I was able to fixed the issues that I was having and now I am adding some shots of the Mandelbrot set.</p>

<p><a href=""https://i.stack.imgur.com/YfzcV.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/YfzcV.jpg"" alt=""enter image description here""></a></p>

<p><a href=""https://i.stack.imgur.com/CF7dH.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CF7dH.png"" alt=""enter image description here""></a></p>

<p><a href=""https://i.stack.imgur.com/2Uxuy.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/2Uxuy.png"" alt=""enter image description here""></a></p>
"
"<p>The framerate limiter for this game I'm doing some coding on is having some pretty irritating accuracy issues at certain framerates. I've been scratching my head trying to think of a better way to write this, but the best I've came up with is still fairly inaccurate. I was wondering if someone could give me a couple ideas on how to rewrite this short portion to be more accurate.</p>

<pre><code>        //g_dwLastfps &amp; currenttime are equal to timeGetTime()
        float fFrameLimit = 0;
        if (g_nFrameLimitValue &gt; 0) //g_nFrameLimitValue = user defined
            fFrameLimit = 1000 / g_nFrameLimitValue;
        while ((currentTime - g_dwLastTime) &lt; fFrameLimit)
        {
            // -1 = wait an extra ms. seemed to help accuracy some
            Sleep((float)fFrameLimit - ((currentTime - g_dwLastTime)) - 1);
            currentTime = timeGetTime();
        }
        g_dwLastTime = currentTime;
</code></pre>
"
"<p>I've written a small program that uses a button on an STM32 Discovery board to act as a counter in either Binary/Decimal/Hexadecimal mode (screen cycles through the 3 options and once pressed, counts up to 16 for each press before resetting to cycling through options).</p>

<p>I'm encountering one small ""bug"" (read, not really) that has me a little confused. If I count up in Decimal/Hexadecimal, it returns to cycling through the options immediately but if I have counted up in Binary it takes ~1sec or so before doing so (a noticeable delay).</p>

<pre><code>int main(void)
{
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);
    lcd_init();
    button_init();

    while (1)
    {
        while (!counting) {
            standard_output();
        }
    }

}

void standard_output(void) {
    state = 0;
    lcd_command(0x01);
    delay_microsec(2000);
    lcd_putstring(""Binary"");
    for (i=0; i&lt;40; i++) delay_microsec(50000);     // keep display for 2 secs
    if (counting) return;                           // if we have pressed the button, want to exit this loop
    state = 1;
    lcd_command(0x01);
    delay_microsec(2000);
    lcd_putstring(""Decimal"");
    for (i=0; i&lt;40; i++) delay_microsec(50000);     // keep display for 2 secs
    if (counting) return;                           // if we have pressed the button, want to exit this loop
    state = 2;
    lcd_command(0x01);
    delay_microsec(2000);
    lcd_putstring(""Hexadecimal"");
    for (i=0; i&lt;40; i++) delay_microsec(50000);     // keep display for 2 secs
    if (counting) return;                           // if we have pressed the button, want to exit this loop

}

void EXTI0_IRQHandler(void) {
    if (EXTI_GetITStatus(EXTI_Line0) != RESET) {
        if (!stillBouncing) {                               // a button press is only registered if stillBouncing == 0
            if (!counting) {                                // if we weren't already counting, a valid button press means we are now
                counting = 1;
                count = 0;                                  // starting count from 0
            }
            else {
                count++;
            }
            if (count &lt; 16) {
                lcd_command(0x01);
                delay_microsec(2000);
                format_int(count);
            }
            else {
                counting = 0;                               // we are no longer counting if count &gt;= 16
            }
        }
        stillBouncing = 10;                                 // every time a button press is registered, we set this to 10
        while (stillBouncing &gt; 0) {                         // and check that it hasn't been pressed for 10 consecutive 1000microsec intervals
            if (!delay_millisec_or_user_pushed(1000)) {
                stillBouncing--;
            }
        }
    }
    EXTI_ClearITPendingBit(EXTI_Line0);
}

void format_int(unsigned int n) {
    if (state == 0) {                                       // if we selected binary
        for (i=0;i&lt;4;++i) {
            num[i] = (n &gt;&gt; i) &amp; 1;                          // generate array of bit values for the 4 least significant bits
        }
        i = 4;
        while (i&gt;0) {
            i--;
            lcd_putint(num[i]);                             // put ints from array to lcd in reverse order to display correctly
        }
    }
    else if (state == 1) {                                  // if we selected decimal
        lcd_putint(n);                                      // lcd_putint is enough for decimal
    }
    else {                                                  // if we selected hex
        snprintf(hex, 4, ""%x"", n);                          // format string such that integer is represented as hex in string
        lcd_putstring(hex);                                 // put string to lcd
    }
}

int delay_millisec_or_user_pushed(unsigned int n)
{
    delay_microsec(n);
    if (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)) {
        return 0;
    }
    return 1;
}
</code></pre>

<p>I really have no idea why it is doing this and have played around with it now but still unable to figure it out. It's fine as is but I would like to know <em>why</em> it is doing this.</p>
"
"<p>Here's a simple script to play a sound every few minutes:</p>

<pre><code>import pyglet
import time
from random import randint

music = pyglet.resource.media('input.wav', streaming=False)

def playSound():
    music.play()

counter = 0
random = randint(300,900)
prevTime = 0

while True:
    counter += time.time() - prevTime
    prevTime = time.time()
    if (counter&gt;random):
        playSound()
        counter = 0
        random = randint(300,900)
</code></pre>

<p>Works as expected, but it uses 100% CPU. Is there a way I can make it more efficient? Is the way I've done it here the 'python' way of doing things?</p>
"
"<p>I'm trying to implement FPS and DeltaTime for my program (C++ Win32). Below is the current code that I have. FPS and DeltaTime should have been implemented in the right manner. If not, please tell me how I may fix my problem.</p>

<p>The current problem I am facing is how I should use DeltaTime. That is to Update and Render. And yes I did use a wrapper class.
Before I implemented this, I was using WindowProcedure to handle my messages and I no problem with that. But now, trying to implement this is tilting me. So before I was using a back buffer and WM_PAINT to draw and I had to take in hwnd in order to draw. And updated is via input from WindowProcedure which had to take in arguments like LPARAM and WPARAM But after reading articles and forums on this topic. Update and Render is needed but they didnt have to take in hwnd for the Render Method. As for update they didnt have to take that in.</p>

<p>So basically I just want to know how do I write the Update and Render Method?</p>

<pre><code>bool BaseWindow::HandleMessages() {

    // Counts Per Second
    INT64 counts_per_sec = 0;
    QueryPerformanceFrequency( ( LARGE_INTEGER* ) &amp;counts_per_sec );
    // Seconds Per Count
    float sec_per_count = 1.0f / ( float ) counts_per_sec;
    // Pervious Time
    INT64 prev_time = 0;
    QueryPerformanceCounter( ( LARGE_INTEGER* ) &amp;prev_time );

    MSG message = { 0 };

    if ( PeekMessage( &amp;message, NULL, 0, 0, PM_REMOVE )) {
        TranslateMessage( &amp;message );
        DispatchMessage( &amp;message );

        if ( message.message == WM_QUIT ) {
            OnDestroy();
            return false;
        }
    }
    else {
        // Get current count
        INT64 current_time = 0;
        QueryPerformanceCounter( ( LARGE_INTEGER* ) &amp;current_time );
        // DeltaTime
        float delta_time = ( current_time - prev_time ) * sec_per_count;

        // Update

        // Render
    }
    return true;
}
</code></pre>

<p><strong>Update</strong>
<strong>Main.cpp</strong></p>

<pre><code>#include ""BaseWindow.h""
#include ""ChildWindow.h""

int APIENTRY WinMain( HINSTANCE h_instance, HINSTANCE h_prev_instance, LPSTR lp_cmd_line, int n_cmd_show ) {

    ChildWindow child_window( h_instance, TEXT( ""Child Window"" ) );
    BaseWindow base_window( TEXT( ""Base Window"" ), child_window.ClassName() );

    while ( base_window.HandleMessages() );
    return 0;
}
</code></pre>

<p><strong>AbstractWindow.h</strong></p>

<pre><code>#ifndef __ABSTRACTWINDOW_H__
#define __ABSTRACTWINDOW_H__
#pragma once

#include &lt;Windows.h&gt;

class AbstractWindow {

    #pragma region Methods
        public:
            AbstractWindow();
            ~AbstractWindow();

            virtual bool Create();
                static LRESULT CALLBACK MessageHandler( HWND, UINT, WPARAM, LPARAM );
            protected:
                virtual LRESULT CALLBACK WindowProcedure( HWND, UINT, WPARAM, LPARAM ) = 0;
    #pragma endregion

    #pragma region Variables
        protected:
            HWND hwnd_;
            DWORD style_ex_;
            LPCTSTR class_name_;
            LPCTSTR window_name_;
            DWORD style_;
            int x_;
            int y_;
            int width_;
            int height_;
            HWND parent_;
            HMENU menu_;
            HINSTANCE instance_;

    #pragma endregion

};
#endif // !__ABSTRACTWINDOW_H__
</code></pre>

<p><strong>AbstractWindow.cpp</strong></p>

<pre><code>#include ""AbstractWindow.h""

AbstractWindow::AbstractWindow() {}

AbstractWindow::~AbstractWindow() {}

bool AbstractWindow::Create() {
    // Default Create Method

    hwnd_ = CreateWindowEx(
        style_ex_,
        class_name_,
        window_name_,
        style_,
        x_,
        y_,
        width_,
        height_,
        parent_,
        menu_,
        instance_,
        this
        );

    return ( hwnd_ ? true : false );

}

LRESULT CALLBACK AbstractWindow::MessageHandler( HWND hwnd, UINT message, WPARAM w_param, LPARAM l_param ) {

    AbstractWindow* abstract_window = 0;

    if ( message == WM_NCCREATE ) {
        abstract_window = ( AbstractWindow* ) ( ( LPCREATESTRUCT( l_param ) )-&gt;lpCreateParams );
        SetWindowLong( hwnd, GWL_USERDATA, long( abstract_window ) );
    }

    abstract_window = ( AbstractWindow * ) ( GetWindowLong( hwnd, GWL_USERDATA ) );

    if ( abstract_window ) {
        return abstract_window-&gt;WindowProcedure( hwnd, message, w_param, l_param );
    }
    else {
        return DefWindowProc( hwnd, message, w_param, l_param );
    }

}
</code></pre>

<p><strong>BaseWindow.h</strong></p>

<pre><code>#ifndef __BASEWINDOW_H__
#define __BASEWINDOW_H__
#pragma once

#include ""AbstractWindow.h""
#include ""ChildWindow.h""

class BaseWindow : public AbstractWindow {

    #pragma region Test Methods
        private:
            void Update();
            void Render();
    #pragma endregion

    #pragma region Methods
        public:
            BaseWindow();
            ~BaseWindow();

            bool HandleMessages();
            BaseWindow( const TCHAR*, const TCHAR* );
            void Show();
            virtual LRESULT CALLBACK WindowProcedure( HWND, UINT, WPARAM, LPARAM );
            #pragma region Handles
                private:
                    bool CreateBackBuffer( HWND );
                    bool OnPaint( HWND );
                    bool PaintManager();
                    bool OnDestroy();
            #pragma endregion
    #pragma endregion

    #pragma region Variables
        private:
            RECT window_rect_;              // Structure for window width and height
            int client_width_;
            int client_height_;
            POINT mouse_pos_;
            #pragma region Back Buffer
                    HDC hdc_;                   // Handle to Device Context
                    HDC back_buffer_;           // Back Buffer
                    HBITMAP bitmap_;                // Current bitmap
            #pragma endregion
    #pragma endregion

};
#endif // !__BASEWINDOW_H__
</code></pre>

<p><strong>BaseWindow.cpp</strong></p>

<pre><code>#include ""BaseWindow.h""

BaseWindow::BaseWindow() {}

BaseWindow::~BaseWindow() {}

BaseWindow::BaseWindow( const TCHAR* window_name, const TCHAR* class_name ) {

    style_ex_ = NULL;
    class_name_ = class_name;
    window_name_ = window_name;
    style_ = WS_OVERLAPPEDWINDOW | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
    x_ = CW_USEDEFAULT;
    y_ = CW_USEDEFAULT; CW_USEDEFAULT;
    width_ = CW_USEDEFAULT;
    height_ = CW_USEDEFAULT;
    parent_ = NULL;
    menu_ = NULL;
    instance_ = GetModuleHandle( NULL );

    Create();
    Show();

}

void BaseWindow::Show() {
    ShowWindow( hwnd_, SW_SHOW );
    UpdateWindow( hwnd_ );
}

LRESULT CALLBACK BaseWindow::WindowProcedure( HWND hwnd, UINT message, WPARAM w_param, LPARAM l_param ) {

    switch ( message ) {
        case WM_CREATE:
            CreateBackBuffer(hwnd);
            return true;
        case WM_ERASEBKGND:
            return true;
        case WM_DESTROY:
            return OnDestroy();
        default:
            return DefWindowProc( hwnd, message, w_param, l_param );
    }
}

bool BaseWindow::HandleMessages() {

    // Counts Per Second
    INT64 counts_per_sec = 0;
    QueryPerformanceFrequency( ( LARGE_INTEGER* ) &amp;counts_per_sec );
    // Seconds Per Count
    float sec_per_count = 1.0f / ( float ) counts_per_sec;
    // Pervious Time
    INT64 prev_time = 0;
    QueryPerformanceCounter( ( LARGE_INTEGER* ) &amp;prev_time );

    MSG message = { 0 };

    if ( PeekMessage( &amp;message, NULL, 0, 0, PM_REMOVE ) ) {
        TranslateMessage( &amp;message );
        DispatchMessage( &amp;message );

        if ( message.message == WM_QUIT ) {
            OnDestroy();
            return false;
        }
    }
    else {
        // Get current count
        INT64 current_time = 0;
        QueryPerformanceCounter( ( LARGE_INTEGER* ) &amp;current_time );
        // DeltaTime
        float delta_time = ( current_time - prev_time ) * sec_per_count;

        // Update

        // Render
        // I need to call for OnPaint()
        // I need to take in hwnd
        // But how ?
        // Or do i not take in hwnd ?
        // But hoe ?

    }
    return true;
}

#pragma region Handles

bool BaseWindow::CreateBackBuffer( HWND hwnd ) {

    GetClientRect( hwnd, &amp;window_rect_ );
    client_width_ = window_rect_.right;
    client_height_ = window_rect_.bottom;

    back_buffer_ = CreateCompatibleDC( NULL );  // Create Back Buffer
    hdc_ = GetDC( hwnd );   // Get the Device Context
    bitmap_ = CreateCompatibleBitmap( hdc_, client_width_, client_height_ );    // Create Bitmap
    SelectObject( back_buffer_, bitmap_ );  // Select Bitmap

    ReleaseDC( hwnd, hdc_ );    // Release

    return true;
}

bool BaseWindow::OnPaint( HWND hwnd ) {

    PAINTSTRUCT paint_struct;

    hdc_ = BeginPaint( hwnd_, &amp;paint_struct );      // Get the Device Context

    BitBlt( back_buffer_, 0, 0, client_width_, client_height_, NULL, NULL, NULL, WHITENESS );

    // Paint
    PaintManager();

    BitBlt( hdc_, 0, 0, client_width_, client_height_, back_buffer_, 0, 0, SRCCOPY );       // Display the back buff
    InvalidateRect( hwnd, NULL, true );     // Repaint the screen

    EndPaint( hwnd, &amp;paint_struct );

    return true;
}

bool BaseWindow::PaintManager() {

    HBRUSH brush = ( HBRUSH ) ( GetStockObject( WHITE_BRUSH ) );
    SelectObject( back_buffer_, brush );        // Select Brush

    Rectangle( back_buffer_, 200, 200, 500, 500 );

    DeleteObject( brush );

    return true;

}

bool BaseWindow::OnDestroy() {
    PostQuitMessage( 0 );
    return true;
}

#pragma endregion
</code></pre>

<p><strong>ChildWindow.h</strong></p>

<pre><code>#ifndef __CHILDWINDOW_H__
#define __CHILDWINDOW_H__
#pragma once

#include ""AbstractWindow.h""
#include ""BaseWindow.h""

class ChildWindow : protected WNDCLASSEX {

    #pragma region Methods
        public:
            ChildWindow();
            ~ChildWindow();

            ChildWindow( HINSTANCE, const TCHAR* );
            bool Register();
            const TCHAR* ClassName() const;
    #pragma endregion

};
#endif // !__CHILDWINDOW_H__
</code></pre>

<p><strong>ChildWindow.cpp</strong></p>

<pre><code>#include ""ChildWindow.h""

ChildWindow::ChildWindow() {}

ChildWindow::~ChildWindow() {}

ChildWindow::ChildWindow( HINSTANCE h_instance, const TCHAR* class_name ) {

    cbSize = sizeof( WNDCLASSEX );
    style = NULL;
    lpfnWndProc = AbstractWindow::MessageHandler;
    cbClsExtra = NULL;
    cbWndExtra = NULL;
    hInstance = h_instance;
    hIcon = LoadIcon( NULL, IDI_APPLICATION );
    hCursor = LoadCursor( NULL, IDC_ARROW );
    //hbrBackground = ( HBRUSH ) ( GetStockObject( DKGRAY_BRUSH ) );
    hbrBackground = ( HBRUSH ) NULL;
    lpszMenuName = NULL;
    lpszClassName = class_name;
    hIconSm = LoadIcon( NULL, IDI_APPLICATION );

    Register();

}

bool ChildWindow::Register() {
    return ( ( RegisterClassEx( this ) ) ? true : false );
}

const TCHAR* ChildWindow::ClassName() const {
    return lpszClassName;
}
</code></pre>
"
"<p>I have a 32-bit integer size</p>

<p>if I have an arithmetic expression like</p>

<pre><code>unsigned short current_time, last_time
if((current_time - last_time) &gt; timeout)
</code></pre>

<p>I believe current_time and last_time will both be converted to signed int 32 before the subtraction. There are no problems with a 16-bit integer size system, but with this 32-bit integer size system will there be potential for a negative value because of the integer promotion?</p>
"
"<p>I installed and configured hadoop recently on my ubuntu 12.04 operated machine. The installation was successful and I am able to start all services successfully.
I am facing problem with hadoop fs . I think I have set it up correctly since hadoop fs is not giving any error like command not found. I am facing error while doing any operation with hadoop fs like ls, put, copyFromLocal.</p>

<p>Every operation ends up in showing <code>No such file or directory</code> error though being provided with valid path.
Please help me solve this.</p>

<p>Output by hdfs</p>

<pre><code>recmach@chetan-HP-ENVY-15-Notebook-PC:~/hadoop/hadoop-2.6.1/sbin$ hadoop fs -ls /home/recmach
ls: `/home/recmach': No such file or directory
</code></pre>

<p>Output by ls for same directory</p>

<pre><code>recmach@chetan-HP-ENVY-15-Notebook-PC:~/hadoop/hadoop-2.6.1/sbin$ ls -l /home/recmach
total 52
drwxr-xr-x 2 recmach hadoop 4096 Oct 21 13:57 Desktop
drwxr-xr-x 2 recmach hadoop 4096 Oct 21 13:57 Documents
drwxr-xr-x 2 recmach hadoop 4096 Oct 21 15:27 Downloads
-rw-r--r-- 1 recmach hadoop 8445 Oct 21 11:56 examples.desktop
drwxrwxr-x 3 recmach hadoop 4096 Oct 21 13:10 hadoop
drwxr-xr-x 2 recmach hadoop 4096 Oct 21 13:57 Music
drwxr-xr-x 2 recmach hadoop 4096 Oct 21 13:57 Pictures
drwxr-xr-x 3 recmach hadoop 4096 Oct 21 15:58 Public
drwxr-xr-x 2 recmach hadoop 4096 Oct 21 13:57 Templates
drwxr-xr-x 4 recmach hadoop 4096 Oct 21 14:50 tmp
drwxr-xr-x 2 recmach hadoop 4096 Oct 21 13:57 Videos
</code></pre>
"
"<p>I want to solve a stiff ode with odeint. I was following <a href=""http://www.boost.org/doc/libs/1_57_0/libs/numeric/odeint/doc/html/boost_numeric_odeint/tutorial/stiff_systems.html"" rel=""nofollow noreferrer"">this</a> (rosenbrock4_dense_output stepper) but, my function can grow pretty quickly so I want to stop the integration if x(t)>xMAX.</p>

<p>In this <a href=""https://stackoverflow.com/questions/14586059/bound-an-odeint-variable/14588283#14588283"">question</a>, they have a solution for it but since I'm new with c++ I don't know how to implement this when using a rosenbrock4_dense_output stepper.</p>

<p>I would like to see how to write this specifically for rosenbrock4_dense_output stepper.</p>
"
"<p>For example if i was to make a complex calculation using several function where each function does a part of the job, is it possible for example to make the following:</p>

<pre><code>void initialize_equations() {

    int t_constant;
    time_t times;
    double *current_time;
    times= time(NULL);

    t_constant = 365*24*60*60;


    *current_time =times/t_constant;

    printf(""%Lf"", current_time);
}

int year_day(time_t *crntT, int *constant) {

    int year, month;
    float year_l, month_l;

    year_l=(&amp;current_time)/365; //trying to call crntT from previous function
    year=year_l+1970; //time starts at 1970 therefore turned it from float to int then summed time
    month=((year_l-year)*12)+1; // Month starts at Jan therefore +1

}
</code></pre>
"
"<p>I'm creating a table calendar, that works on the weekly basis. The calendar looks like this</p>

<p><a href=""https://i.stack.imgur.com/hXaCP.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/hXaCP.png"" alt=""enter image description here""></a></p>

<p>I used code I found <a href=""https://stackoverflow.com/a/18936417/629127"">here</a> to set up my header dates. The code I have looks like this:</p>

<pre><code>$dt = new DateTime;
$dt-&gt;setISODate($dt-&gt;format('o'), $dt-&gt;format('W'));
$year = $dt-&gt;format('o');
$week = $dt-&gt;format('W');
$current_time = time();

$return .= '&lt;table class=""reservation_time_table""&gt;
                &lt;tr&gt;&lt;th&gt;'.esc_html__('Hours', 'time_reservation').'&lt;/th&gt;';
do {
    $return .= '&lt;th&gt;' . $dt-&gt;format('l') . '&lt;br&gt;' . $dt-&gt;format('d M Y') . '&lt;/th&gt;';
    $dt-&gt;modify('+1 day');
} while ($week == $dt-&gt;format('W'));
$return .= '&lt;/tr&gt;';
for ($hour=8; $hour &lt; 23 ; $hour++) {
    $return .= '&lt;tr&gt;';
        $return .= '&lt;th&gt;'.$hour.':00&lt;/th&gt;';
        for ($i=0; $i &lt;7 ; $i++) {
            $return .= '&lt;td data-reservation_time=""""&gt;&lt;/td&gt;';
        }
    $return .= '&lt;/tr&gt;';
}

$return .= '&lt;/table&gt;';
</code></pre>

<p>Now, I need to put in my <code>data-reservation_time</code> the date in <code>Unix</code> format (that's why there is <code>$current_time</code> variable), of that cell. So for instance in the cell for Friday 20 in 8:00 there should be <code>1448006400</code> in that cell. I'll use this later on to store in the database.</p>

<p>But how do I do that? I'm stuck at this point. Any help is appreciated.</p>

<p><strong>EDIT</strong></p>

<p>Found the answer. It's below :)</p>
"
"<p>I am trying to make some improvements on AODV routing protocol using NS 2.35. I have made some changes in AODV.cc and AODV.h file. For making the changes effective, I have made the following three commands from the terminal inside NS 2.35 folder:</p>

<ol>
<li>sudo su</li>
</ol>

<p>2.make clean</p>

<p>3.make</p>

<p>Now I am having the following error:</p>

<pre><code>trace/cmu-trace.o: In function `CMUTrace::format_aodv(Packet*, int)':
cmu-trace.cc:(.text+0x18b7): undefined reference to `hdr_aodv::offset_'
</code></pre>

<p>What is the solutions of this?</p>

<p>For more clarification I am providing the .cc file link here:</p>

<p><a href=""https://drive.google.com/file/d/0B1OEPsG0ILELWkcxQ254TEpoN3M/view?usp=sharing"" rel=""nofollow"">https://drive.google.com/file/d/0B1OEPsG0ILELWkcxQ254TEpoN3M/view?usp=sharing</a></p>
"
"<p>I'm doing some socket programming with a UDP connection. I have my server written (which also takes an offset for a NTP server), but when I unit test it, it fails at the recvfrom function. I'm new to winsock programming, and network programming in general, so I'm not sure exactly where to go from here. Here is my code: </p>

<pre><code>NtpServer::NtpServer(u_short portnum, const std::chrono::nanoseconds desiredOffset) : portnum(0), client_length(0), bytes_received(0), current_time(0), desiredOffset(0)
{
    WORD wVersionRequested;
    wVersionRequested = MAKEWORD(2, 2);
    WSADATA wsaData;

    int iResult = WSAStartup(MAKEWORD(2, 2), &amp;wsaData);
    if (WSAStartup(wVersionRequested, &amp;wsaData) != 0)
    {

        std::cerr &lt;&lt; ""Could not open Windows connection"" &lt;&lt; std::endl;
        exit(0);
    }

    sd = socket(AF_INET, SOCK_DGRAM, 0);
    if (sd == INVALID_SOCKET)
    {
        std::cerr &lt;&lt; ""Could not create socket."" &lt;&lt; std::endl;
        WSACleanup();
        exit(0);
    }

    //blocking enabled
    u_long iMode = 0;

    iResult = ioctlsocket(sd, FIONBIO, &amp;iMode);
    if (iResult != NO_ERROR)
        std::cerr &lt;&lt; ""ioctlsocket failed with error: "" &lt;&lt; iResult &lt;&lt; std::endl;


    memset((void *)&amp;server, '\0', sizeof(struct sockaddr_in));
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = htonl(INADDR_ANY);
    server.sin_port = htons(portnum);


    if (bind(sd, reinterpret_cast&lt;SOCKADDR *&gt;(&amp;server),
        sizeof(server)) == -1)
    {
        std::cerr &lt;&lt; ""Could not bind name to socket"" &lt;&lt; std::endl;
        closesocket(sd);
        WSACleanup();
        exit(0);
    }
    getResult(desiredOffset);
}
</code></pre>

<p>and the getResult function: </p>

<pre><code>void NtpServer::getResult(const std::chrono::nanoseconds desiredOffset)
{
    ntp_data ntpData = ntp_data();
    //struct for timeout
    struct timeval tv;
    tv.tv_sec = 10;  // 10 Secs Timeout
    setsockopt(sd, SOL_SOCKET, SO_RCVTIMEO, (char *)&amp;tv, sizeof(struct timeval));

    while (1)
    {
        client_length = (int)sizeof(struct sockaddr_in);

        /* Receive bytes from client */
        bytes_received = recvfrom(sd, sendBuffer, NTP_PACKET_MAX, 0, (struct sockaddr *)&amp;client, &amp;client_length);
        if (bytes_received &lt; NTP_PACKET_MIN)
        {
            std::cerr &lt;&lt; ""Could not receive datagram."" &lt;&lt; std::endl;
            closesocket(sd);
            WSACleanup();
            exit(0);
        }



        /* Check for time request */
        if (strcmp(readBuffer, ""GET TIME\r\n"") == 0)
        {
            /* Get current time */
            system_clock::time_point now = std::chrono::system_clock::now();
            auto timepointoffset = (now + desiredOffset).time_since_epoch();
            double current_value = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(timepointoffset).count();

            unpack_ntp(&amp;ntpData, (unsigned char*)readBuffer, bytes_received);
            make_packet(&amp;ntpData, NTP_CLIENT, current_value);
            pack_ntp((unsigned char *)sendBuffer, NTP_PACKET_MIN, &amp;ntpData);


            /* Send data back */
            if (sendto(sd, sendBuffer,
                (int)sizeof(sendBuffer), 0,
                (struct sockaddr *)&amp;client, client_length) !=
                (int)sizeof(current_time))
            {
                std::cerr &lt;&lt; ""Error sending datagram."" &lt;&lt; std::endl;
                closesocket(sd);
                WSACleanup();
                exit(0);
            }
        }
    }
        closesocket(sd);
        WSACleanup();


}
</code></pre>
"
"<p>I'm troubled by conflict between two definitions of <code>operator&lt;&lt;</code>.</p>

<p>Suppose that I've been a great fan of ACE library and been using <a href=""http://www.dre.vanderbilt.edu/Doxygen/6.3.1/html/libace-doc/a00699.html"" rel=""nofollow"">ACE_Time_Value</a> in my code.  One day I noticed ACE 6.x was out and tried to migrate my code from ACE 5.x to 6.x.  Then I got a problem: ACE 6.x newly introduced <code>operator&lt;&lt;(std::ostream &amp;, const ACE_Time_Value &amp;)</code> in the global namespace, but my code had implemented my own version of <code>operator&lt;&lt;</code> since 5.x era, and two <code>operator&lt;&lt;</code> conflicted.  Unfortunately the output from the ""official"" <code>operator&lt;&lt;</code> is unsatisfactory and I need to keep using my own version.  How can I pretend there's no ""official"" <code>operator&lt;&lt;</code> in the global namespace?  Luckily(?) all my code is under my own namespace.</p>

<p>Conceptually my problem can be summarized as:</p>

<pre><code>#include &lt;iostream&gt;
using namespace std;

struct ACE_Time_Value { };
ostream &amp;operator&lt;&lt;(ostream &amp;os, const ACE_Time_Value &amp;) { os &lt;&lt; ""Apple"" ; }
void foo(const ACE_Time_Value &amp;) { cout &lt;&lt; ""Cherry"" &lt;&lt; endl; }

namespace mine {
    ostream &amp;operator&lt;&lt;(ostream &amp;os, const ACE_Time_Value &amp;) { os &lt;&lt; ""Banana"" ; }
    void foo(const ACE_Time_Value &amp;) { cout &lt;&lt; ""Durian"" &lt;&lt; endl; }

    void bar() {
        ACE_Time_Value t;
        ::mine::foo(t); // OK
        // cout &lt;&lt; ""The current time is "" &lt;&lt;
        //   t &lt;&lt; endl; // error: ambiguous overload for 'operator&lt;&lt;'
    }
}

int main() {
    mine::bar();
}
</code></pre>

<ul>
<li><a href=""http://ideone.com/NJXIz9"" rel=""nofollow"">http://ideone.com/NJXIz9</a></li>
</ul>
"
"<p>I am using Raspbian on a Raspberry Pi 2 B with a build-from-source libusb (version 1.0.18 if you're curious).  I am trying to build <a href=""https://github.com/ToadKing/wii-u-gc-adapter"" rel=""nofollow"">this</a> program on the Pi, but it gives the follow error:</p>

<pre><code>cc -c -o wii-u-gc-adapter.o wii-u-gc-adapter.c -Wall -Wextra -pedantic -Wno-format -std=c99 -I/usr/local/include/libusb-1.0     -O2
wii-u-gc-adapter.c:44:4: error: ?BTN_SOUTH? undeclared here (not in a function)
wii-u-gc-adapter.c:45:4: error: ?BTN_WEST? undeclared here (not in a function)
wii-u-gc-adapter.c:46:4: error: ?BTN_EAST? undeclared here (not in a function)
wii-u-gc-adapter.c:47:4: error: ?BTN_NORTH? undeclared here (not in a function)
wii-u-gc-adapter.c:48:4: error: ?BTN_DPAD_LEFT? undeclared here (not in a function)
wii-u-gc-adapter.c:49:4: error: ?BTN_DPAD_RIGHT? undeclared here (not in a function)
wii-u-gc-adapter.c:50:4: error: ?BTN_DPAD_DOWN? undeclared here (not in a function)
wii-u-gc-adapter.c:51:4: error: ?BTN_DPAD_UP? undeclared here (not in a function)
wii-u-gc-adapter.c: In function ?handle_payload?:
wii-u-gc-adapter.c:367:23: warning: missing initializer [-Wmissing-field-initializers]
wii-u-gc-adapter.c:367:23: warning: (near initialization for ?upload.retval?) [-Wmissing-field-initializers]
wii-u-gc-adapter.c:386:23: warning: missing initializer [-Wmissing-field-initializers]
wii-u-gc-adapter.c:386:23: warning: (near initialization for ?erase.retval?) [-Wmissing-field-initializers]
wii-u-gc-adapter.c: In function ?adapter_thread?:
wii-u-gc-adapter.c:421:14: warning: missing initializer [-Wmissing-field-initializers]
wii-u-gc-adapter.c:421:14: warning: (near initialization for ?current_time.tv_nsec?) [-Wmissing-field-initializers]
Makefile:16: recipe for target 'wii-u-gc-adapter.o' failed
make: *** [wii-u-gc-adapter.o] Error 1
</code></pre>

<p>If you need any other information, I'll provide it.</p>

<p><b>Edit</b>: Also added the top line for the <code>make</code> details.</p>
"
"<p>I implemented the gaffer on <a href=""http://gafferongames.com/game-physics/fix-your-timestep/"" rel=""nofollow"">games fixed timestep</a> As you can see from here.</p>

<pre><code>static int ce_run_game() {
    start_time = SDL_GetTicks();

    while (game_running &gt; 0) {
        current_time = SDL_GetTicks();
        frame_time = (current_time - start_time) * 0.0001;
        if (frame_time &gt;= 0.25) frame_time = 0.25;

        start_time = current_time;

        accum += frame_time;
        while (accum &gt;= delta_time) {
            accum -= delta_time;

            ce_fixed_update();
            ce_fixed_render();
            //SDL_Log(""accum %f delta %f\n"", accum, delta_time);
        }

        const double alpha = accum / delta_time;
        // state = current_state * alpha + prev_state * (1.0 - alpha);
        ce_var_update(alpha);
        ce_var_render(alpha);

        while (SDL_PollEvent(&amp;event)) {
            ce_handle_events(&amp;event);
            if (event.type == SDL_APP_WILLENTERBACKGROUND) {
                ce_pause();
            }
            if (event.type == SDL_APP_WILLENTERFOREGROUND) {
                ce_resume();
            }
            if (event.type == SDL_WINDOWEVENT) {
                switch (event.window.event) {
                    case SDL_WINDOWEVENT_RESIZED:
                        screen_width = event.window.data1;
                        screen_height = event.window.data2;
                        cam_2d_resize(screen_width, screen_height,
                                      default_camera);
                        ce_resize_window(screen_width, screen_height);
                        break;
                }
            }
            if (event.type == SDL_QUIT) {
                ce_quit();
            }
        }
    }

    return -1;
}
</code></pre>

<p>so now I have two update and two render functions. I have a fixed and variable update. I plan to do all my non essential things in variable update/ render functions.</p>

<p>The variable functions pass in the apha value that I can use to calculate the interpolation, like this</p>

<pre><code>state = current_state * alpha + prev_state * (1.0 - alpha);
</code></pre>

<p>as described in the article above.</p>

<p>I am running into some issues with interpolation now though. In my fixed update function I'll do something like this pseudo code.</p>

<pre><code>if(move_righ) {
     previous_x = x;
     x += 10;
}
</code></pre>

<p>then in the render function set the matrix translation values to the calculated interpolated values.</p>

<p>ex:</p>

<pre><code>float inter_x = prev_x * alpha + prev_x * (1.0f - alpha);
float inter_y = prev_y * alpha + prev_y * (1.0f - alpha);

matrix-&gt;col3.x = inter_x;
matrix-&gt;col3.y = inter_y;
</code></pre>

<p>The issue could just be that I cannot use interpolated values like this for matrix in which case I'll have to switch to quaternion which does support interpolation but currently not implemented.</p>

<p>Is the problem that I cannot do interpolation like this with matrix components, I am doing opengles 2.0 and shaders.</p>
"
"<p>I have a very simple application currently, it's basically the core loop that I'm trying to get sorted out properly before moving on.</p>

<p>I'm following gaffer's fix your timestep article but I must be doing something wrong because rendering a quad rotating around all three axis I am already dropping frames. Basically hitting the <code>if(frame_time &gt; 0.025)..</code> line of code, which leads me to believe that I am doing something terribly wrong. What's worse I'm only rendering to a 320x480 viewport clearing only the background color.</p>

<p>Here's the core function. I have some variables</p>

<pre><code>double delta_time = 1.0f/60.0f;
double frame_time;
double start_time;
double current_time;
double accum;
static int ce_run_game() {
while (game_running &gt; 0) {
    current_time = SDL_GetTicks();
    frame_time = (current_time - start_time) * 0.001f; //convert from 250ms to 0.025

    printf(""ft: %f\n"",frame_time);

    if (frame_time &gt;= 0.025){
        frame_time = 0.025;
        printf(""slowdown\n"");
    }

    start_time = current_time;


    while (SDL_PollEvent(&amp;event)) {
        ce_handle_events(&amp;event);
        }
        if (event.type == SDL_QUIT) {
            ce_quit();
        }
    }

    accum += frame_time;
    while (accum &gt;= delta_time) {
        accum -= delta_time;
        ce_fixed_update();
        ce_fixed_render();
    }

    double alpha = accum / delta_time;
    // state = current_state * alpha + prev_state * (1.0 - alpha);
    ce_var_update(alpha);
    ce_var_render(alpha);
}

    return -1;
}
</code></pre>

<p>with this simple loop I seem to be dropping frames. The other part of the code that is relevant is the movement code. While it's nothing amazing, it shouldn't cause so much slowdown. </p>

<p>Typically the frame time print statement is hovering around 0.016 - 0.017</p>

<p>but sometimes it will just raise a lot even up to 0.85 or higher. Adding in the <code>if(frame_time &gt; 0.025)</code> above things seem to stick right around 0.16 0.17 but I am unsure of why the frame time will spike and they just get so out of control, especially since I am only moving around one thing on screen.</p>

<p>movement code:</p>

<pre><code>static void handle_event(SDL_Event* e) {
    switch (e-&gt;type) {
        case SDL_KEYUP:
            left = right = up = down = 0;
            break;
        case SDL_KEYDOWN:
            switch (e-&gt;key.keysym.sym) {
                case SDLK_AC_BACK:
                case SDLK_ESCAPE:
                    ce_quit();
                    break;
                case SDLK_LEFT:
                    left = 1;
                    break;
                case SDLK_RIGHT:
                    right = 1;
                    break;
                case SDLK_UP:
                    up = 1;
                    break;
                case SDLK_DOWN:
                    down = 1;
                    break;
            }
    }
}


static void variable_render(double alpha) {
    glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT);

    glUseProgram(ce_get_default_shader()-&gt;shader_program);
    glBindVertexArray(vao);

    vvv = vec3_new(1, 1, 1);
    angle += 0.0015f * alpha;
    if (angle &gt;= 360.0) angle = 0.0f;
    mat4_rotate(model_mat, model_mat, angle, vvv);

    ce_get_view_matrices(&amp;vview_mat, &amp;pproj_mat, &amp;mmvp_mat);

    mat4_multi(&amp;mmvp_mat, &amp;vview_mat, model_mat);
    mat4_multi(&amp;mmvp_mat, &amp;pproj_mat, &amp;mmvp_mat);
    glUniformMatrix4fv(mvp_matrix_loc, 1, GL_FALSE, mat4_get_data(&amp;mmvp_mat));

    glUniformMatrix4fv(model_mat_loc, 1, GL_FALSE, mat4_get_data(model_mat));
    glUniformMatrix4fv(view_mat_loc, 1, GL_FALSE, mat4_get_data(&amp;vview_mat));
    glUniformMatrix4fv(proj_matrix_loc, 1, GL_FALSE, mat4_get_data(&amp;pproj_mat));

    glDrawElements(GL_TRIANGLES, quad-&gt;vertex_count, GL_UNSIGNED_SHORT, 0);
    glBindVertexArray(0);

}
</code></pre>
"
"<p>I am trying to program a udp client and server that will return the offset between the ntp time and boxtime. I cannot get my server to correctly receive data. I am testing it with Microsoft Unit tests, and when I try and test the server and client the test actually fails. If I run the test I just get the error message: </p>

<blockquote>
  <p>""The active Test Run was aborted because the execution process exited unexpectedly. To investigate further, enable local crash dumps either at the machine level or for process vstest.executionengine.x86.exe. Go to more details: <a href=""http://go.microsoft.com/fwlink/?linkid=232477"" rel=""nofollow"">http://go.microsoft.com/fwlink/?linkid=232477</a>""</p>
</blockquote>

<p>If I debug I find that recvfrom function in the server returns 0, so it just exits. </p>

<p>Here is my code for the server: </p>

<pre><code>#pragma once
#include &lt;iostream&gt;
#include ""NtpServer.h""
#include ""stdafx.h""
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;winsock.h&gt;
#include &lt;errno.h&gt;


using std::chrono::system_clock;

namespace ntp
{


struct sockaddr_in server;
struct sockaddr_storage client;



//constructor to create ntp server
 NtpServer::NtpServer(u_short portnum, const std::chrono::nanoseconds                 desiredOffset) : portnum(0), client_length(0), bytes_received(0), current_time(0), desiredOffset(0)
{

    WSADATA wsaData;

    int iResult = WSAStartup(MAKEWORD(2, 2), &amp;wsaData);

    if (iResult != 0)
    {
        std::cerr &lt;&lt; ""Could not open Windows connection."" &lt;&lt; std::endl;
        exit(0);
    }

    memset((void *)&amp;server, '\0', sizeof(struct sockaddr_in));
    server.sin_family = AF_INET;
    server.sin_port = htons(portnum);
    server.sin_addr.s_addr = htonl(INADDR_ANY);


    sd = WSASocket(AF_INET, SOCK_DGRAM, 17, NULL, 0, NULL);

    if (sd == INVALID_SOCKET)
    {
        std::cerr &lt;&lt; ""Could not create socket."" &lt;&lt; std::endl;
        WSACleanup();
        exit(0);
    }



if (bind(sd, reinterpret_cast&lt;SOCKADDR *&gt;(&amp;server),
        sizeof(server)) == -1)
    {
        std::cerr &lt;&lt; ""Could not bind name to socket"" &lt;&lt; std::endl;
        closesocket(sd);
        WSACleanup();
        exit(0);
    }



    getResult(desiredOffset);
}

NtpServer::~NtpServer()
{
    closesocket(sd);
    WSACleanup();

}

void NtpServer::getResult(const std::chrono::nanoseconds desiredOffset)
{
    ntp_data ntpData = ntp_data();

    //set up timeout with blocking
    fd_set fds;
    int n;
    struct timeval tv;
    FD_ZERO(&amp;fds);
    FD_SET(sd, &amp;fds);
    tv.tv_sec = 10;  // 10 Secs Timeout
    tv.tv_usec = 0;
    n = select(sd, &amp;fds, NULL, NULL, &amp;tv);
    if (n == 0)
    {
        exit(0);
    }

    while (1)
    {
        //client_length = sizeof(client);
        int len = (int)sizeof(struct sockaddr_in);

        /* Receive bytes from client */
        bytes_received = recvfrom(sd, sendBuffer, NTP_PACKET_MAX, 0, (struct sockaddr *)&amp;client, &amp;len);

        if (bytes_received == SOCKET_ERROR)
        {
            std::cerr &lt;&lt; ""Could not receive datagram."" &lt;&lt; std::endl;
            closesocket(sd);
            WSACleanup();
            exit(0);
        }
        if (bytes_received &lt; NTP_PACKET_MIN)
        {
            continue;
        }



        /* Check for time request */
        if (strcmp(readBuffer, ""GET TIME\r\n"") == 0)
        {
            /* Get current time */
            system_clock::time_point now = std::chrono::system_clock::now();
            auto timepointoffset = (now + desiredOffset).time_since_epoch();
            double current_value = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(timepointoffset).count();

            unpack_ntp(&amp;ntpData, (unsigned char *)readBuffer, bytes_received);
            make_packet(&amp;ntpData, NTP_CLIENT, current_value);
            pack_ntp((unsigned char *)sendBuffer, NTP_PACKET_MIN, &amp;ntpData);


            /* Send data back */
            if (sendto(sd, sendBuffer,
                (int)sizeof(sendBuffer), 0,
                (struct sockaddr *)&amp;client, client_length) !=
                (int)sizeof(current_time))
            {
                std::cerr &lt;&lt; ""Error sending datagram."" &lt;&lt; std::endl;
                closesocket(sd);
                WSACleanup();
                exit(0);
            }
        }
    }
    closesocket(sd);
    WSACleanup();

}



}
</code></pre>

<p>Edit: I changed the way I did the timeout with a select statement, and recvfrom ""if"" statements. </p>
"
"<p>I am using winsock and c++ to program a client and server to return the offset from the NTP time and box time. My problem when I debug is that the client is failing to send the request to the server. The specific function that fails is my <code>sendto</code>function in my <code>NtpClientThread.cpp</code>Here is my server: </p>

<pre><code>#pragma once
#include &lt;iostream&gt;
#include ""NtpServer.h""
#include ""stdafx.h""
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;winsock.h&gt;
#include &lt;errno.h&gt;


using std::chrono::system_clock;

namespace ntp
{


struct sockaddr_in server;
struct sockaddr_storage client;



//constructor to create ntp server
NtpServer::NtpServer(u_short portnum, const std::chrono::nanoseconds desiredOffset) : portnum(0), client_length(0), bytes_received(0), current_time(0), desiredOffset(0)
{

    WSADATA wsaData;

    int iResult = WSAStartup(MAKEWORD(2, 2), &amp;wsaData);

    if (iResult != 0)
    {
        throw std::runtime_error(""Could not start windows connections."");

    }

    memset((void *)&amp;server, '\0', sizeof(struct sockaddr_in));
    server.sin_family = AF_INET;
    server.sin_port = htons(portnum);
    server.sin_addr.s_addr = htonl(INADDR_ANY);


    sd = WSASocket(AF_INET, SOCK_DGRAM, 17, NULL, 0, NULL);

    if (sd == INVALID_SOCKET)
    {
        throw std::runtime_error(""Could not create socket."");
        WSACleanup();

    }



if (bind(sd, reinterpret_cast&lt;SOCKADDR *&gt;(&amp;server),
        sizeof(server)) == -1)
    {
        throw std::runtime_error(""Could not bind name to socket."");
        closesocket(sd);
        WSACleanup();

    }




}

NtpServer::~NtpServer()
{
    closesocket(sd);
    WSACleanup();

}

void NtpServer::getResult()
{
    ntp_data ntpData = ntp_data();

    //set up timeout with blocking
    fd_set fds;
    int n;
    struct timeval tv;
    FD_ZERO(&amp;fds);
    FD_SET(sd, &amp;fds);
    tv.tv_sec = 10;  // 10 Secs Timeout
    tv.tv_usec = 0;
    n = select(sd, &amp;fds, NULL, NULL, &amp;tv);
    if (n == 0)
    {
        exit(0);
    }

    while (1)
    {
        //client_length = sizeof(client);
        int len = (int)sizeof(struct sockaddr_in);

        /* Receive bytes from client */
        bytes_received = recvfrom(sd, sendBuffer, NTP_PACKET_MAX, 0, (struct sockaddr *)&amp;client, &amp;len);

        if (bytes_received == SOCKET_ERROR)
        {
            throw std::runtime_error(""Could not receive datagram."");
            closesocket(sd);
            WSACleanup();

        }
        if (bytes_received &lt; NTP_PACKET_MIN)
        {
            continue;
        }



        /* Check for time request */
        if (strcmp(readBuffer, ""GET TIME\r\n"") == 0)
        {
            /* Get current time */
            system_clock::time_point now = std::chrono::system_clock::now();
            auto timepointoffset = (now + desiredOffset).time_since_epoch();
            double current_value = std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(timepointoffset).count();

            unpack_ntp(&amp;ntpData, (unsigned char *)readBuffer, bytes_received);
            make_packet(&amp;ntpData, NTP_CLIENT, current_value);
            pack_ntp((unsigned char *)sendBuffer, NTP_PACKET_MIN, &amp;ntpData);


            /* Send data back */
            if (sendto(sd, sendBuffer,
                (int)sizeof(sendBuffer), 0,
                (struct sockaddr *)&amp;client, client_length) !=
                SOCKET_ERROR)
            {
                throw std::runtime_error(""Error sending datagram."");
                closesocket(sd);
                WSACleanup();

            }
        }
    }
    closesocket(sd);
    WSACleanup();

}



}
</code></pre>

<p>Here is my client code: </p>

<pre><code>NTPClientThread::NTPClientThread(Config config) : stopRequested(false), currentOffset((nanoseconds)0), time_point(NULL) {

    WORD wVersionRequested;
    wVersionRequested = MAKEWORD(2, 2);
    WSADATA wsaData;
    //INT hp;



    try
    {
        if (WSAStartup(wVersionRequested, &amp;wsaData) != 0)
        {
            throw std::runtime_error(""Could not open Windows connection."");
        }

        /* Open a datagram socket */
        sd = WSASocket(AF_INET, SOCK_DGRAM, 17, NULL, 0, NULL);
        if (sd == INVALID_SOCKET)
        {

            WSACleanup();
            throw std::runtime_error(""Failed to create socket."");
        }

        /* Clear out server struct */
        memset((void *)&amp;server, '\0', sizeof(struct sockaddr_in));


        /* Set family and port */
        server.sin_family = AF_INET;
        inet_pton(AF_INET, config.getValue(""NtpHost"").c_str(), &amp;(server.sin_addr));
        server.sin_port = htons(boost::lexical_cast&lt;u_short&gt;(config.getValue(""NtpPort"")));


        //clear out client struct
        memset((void *)&amp;client, '\0', sizeof(struct sockaddr_in));

        /* Set family and port */
        client.sin_family = AF_INET;
        //inet_pton(AF_INET, config.getValue(""NtpHost"").c_str(), &amp;(client.sin_addr));
        client.sin_addr.s_addr = htonl(INADDR_ANY);
        client.sin_port = htons(0);



        if (bind(sd, reinterpret_cast&lt;SOCKADDR *&gt;(&amp;client)/*result-&gt;ai_addr*/,/* result-&gt;ai_addrlen*/sizeof(client)) == -1)
        {
            closesocket(sd);
            WSACleanup();
            throw std::runtime_error(""Failed to bind socket."");

        }
         ntp_data ntpData = ntp_data();
        make_packet(&amp;ntpData, NTP_CLIENT, 0);
        pack_ntp((unsigned char *)sendBuffer, NTP_PACKET_MIN, &amp;ntpData);


        /* Tranmsit data to get time */
        server_length = sizeof(struct sockaddr_in);
        if (sendto(sd, (const char *)sendBuffer, sizeof(sendBuffer), 0, (struct sockaddr *)&amp;server/*result-&gt;ai_addr*/, server_length/*result-&gt;ai_addrlen*/) == -1)
        {
            throw std::runtime_error(""Failed to send request to server."");

        }

        int bytes_received = recvfrom(sd, (char *)&amp;current_time, (int)sizeof(current_time), 0, (struct sockaddr *)&amp;server, &amp;server_length);
        /* Receive time */
        if (bytes_received &lt; 0)
        {
            throw std::runtime_error(""Failed to recieve data from server."");

        }
        if (bytes_received &lt; NTP_PACKET_MIN)
        {
            throw std::runtime_error(""Received bad responde from server."");
        }



        unpack_ntp(&amp;ntpData, current_time, server_length);




        typedef duration&lt;double, std::ratio&lt;1&gt;&gt;d_seconds;
        d_seconds since_epoch_full(ntpData.transmit);
        auto since_epoch = duration_cast&lt;system_clock::duration&gt; (since_epoch_full);

        system_clock::time_point ntpTime(since_epoch);
        system_clock::time_point boxTime = system_clock::now();

        currentOffset = ntpTime - boxTime;

    }
    catch (std::exception&amp; e)
    {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}
</code></pre>
"
"<p>I am a Python and OpenCV newbie. I was dealing with OpenCV optimization and I found <a href=""http://docs.opencv.org/master/dc/d71/tutorial_py_optimization.html#gsc.tab=0"" rel=""nofollow"">Measuring Performance with OpenCV</a> website. I saw <code>cv2.getTickCount</code> and <code>cv2.getTickFrequency</code> and tried on a blank Video Capture code: </p>

<pre><code>import cv2

cap = cv2.VideoCapture(0)
time1 = 0

while True:
    e1 = cv2.getTickCount()
    ret, frame = cap.read()
    cv2.imshow(""cam"", frame)
    e2 = cv2.getTickCount()
    time1 = (e2 - e1) / cv2.getTickFrequency() + time1
    print time1

    k = cv2.waitKey(1) &amp; 0xFF

    if k == ord('q'):
        break
</code></pre>

<p>At the same time, I tried <code>time.time()</code> for performance measuring:</p>

<pre><code>import cv2
import time

cap = cv2.VideoCapture(0)

t_start = time.time()
time1 = 0

while True:
    e1 = cv2.getTickCount()
    ret, frame = cap.read()
    cv2.imshow(""cam"", frame)
    e2 = cv2.getTickCount()
    time1 = (e2 - e1) / cv2.getTickFrequency() + time1
    elapsedTime = time.time()-t_start
    print [time1, elapsedTime]

    k = cv2.waitKey(1) &amp; 0xFF

    if k == ord('q'):
        break
</code></pre>

<p>There is a huge difference between <code>elapsedTime</code> and <code>time1</code>, like:</p>

<pre><code>[23.544186313842033, 29.413000106811523]
[23.588920849343307, 29.460999965667725]
[23.636793986833897, 29.51200008392334]
[23.669538024648435, 29.558000087738037]
[23.701628712445952, 29.605000019073486]
[23.737225731551163, 29.65499997138977]
[23.775527056696312, 29.703999996185303]
[23.82555789141547, 29.765000104904175]
[23.864218735017026, 29.813999891281128]
[23.901782255564854, 29.861000061035156]
</code></pre>

<p>I checked both outputs and my phone's chronometer is with <code>time.time()</code>'s side.</p>

<p>My questions are:</p>

<ol>
<li>Why I have this difference? How and why <code>cv2.getTickCount</code> and
<code>cv2.getTickFrequency</code> differs from <code>time.time()</code></li>
<li>To do the performance measurement, which one should I use?</li>
</ol>
"
"<p>Why I see nothing when I run my code ?
I use DOSBox.</p>

<pre><code>#include &lt;graphics.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &lt;conio.h&gt;
#include &lt;bios.h&gt;
#include &lt;ctype.h&gt;
#include &lt;math.h&gt;

int main() {
    int gdriver = DETECT,gmode = 0;
    initgraph(&amp;gdriver,&amp;gmode,""C:\\TC\\BGI"");
    struct time t;
    moveto(5,10);
    outtext(""Hello"");
    moveto(6,11);
    outtext(""World**strong text**"");
    moveto(1,24);
    outtext(""Press: 1-About_Author, 2-Current_Time,ESC to EXIT"");
    closegraph();
    return 0;
}
</code></pre>
"
"<pre><code>#include &lt;iostream&gt;
#include ""current_time.h""
#include &lt;time.h&gt;
#include &lt;future&gt;
#include &lt;chrono&gt;
#include &lt;Windows.h&gt;
using namespace std;
current_time mytimer;

void timer()
{
    while(true)
    {
        mytimer.operator++(); //incerements seconds
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}

int main()
{
    void(*foo)(void);
    foo = &amp;timer;
    auto future = async(foo);
    while (1)
    {
        Sleep(50);
        system(""cls"");
        mytimer.disp_time();
    }
}
</code></pre>

<p>My background timer isn't accurate. After waiting some time I noticed that it was slowly getting more and more late. I know it's because mytimer.operation++() takes some time to run. I was looking for a fix, but I cant't find any. I am currently using VS15.</p>
"
"<p>Let's say a process is started at 12:00:00 and the only thing it does is to sleep for 120 seconds (sleep(120)). It should normally be woken up at 12:02:00.
Imagine now that after 60 seconds the system suspends it (12:01:00) for 300 seconds (5 minutes). What happens is that at 12:06:00, the process is resumed and it immediately wakes because, as far I could understand, the sleep instruction uses the machine time to determine when it should wake up. But what I'm looking for is a solution where the process continues to sleep for the remaining 60 seconds.</p>

<p>A simple solution would be a ""busy"" sleep:</p>

<p><code>for (i = 0; i &lt; 120; i++) sleep(1);</code></p>

<p>but I am looking for a solution like:</p>

<pre><code>sleeping_time = 120;
do {
    start_time = current_time();
    sleep(sleeping_time);
    sleeping_time = sleeping_time - (current_time() - start_time - suspended_time());
} while ( sleeping_time &gt; 0 );
</code></pre>

<p>In this case, the suspended_time() function would return the total time the process was suspended.</p>

<p>Thanks! Claudio</p>
"
"<p>Let's say I have a list <code>l</code> where each element has an attribute <code>time</code> that stores a float representing how many seconds past from some benchmark point. Whenever some event happens, I would like to remove from this list all elements that happened more than <code>T</code> seconds before this event, so currently what I do is</p>

<pre><code>l = [x in l if x.time &gt; current_time - T]
</code></pre>

<p>which seems to be a slow way to do things. How can this be done faster? Elements are ordered here by time, so I thought of finding the first element that does not satisfy this condition, e.g. </p>

<pre><code>for i, x in enumerate(l):
    if x.time &gt; current_time - T:
         break
l = l[i:]
</code></pre>

<p>Perhaps there is a beter way?</p>
"
"<p>What is the state of the art way to get date and time as string in c++11? </p>

<p>I know about <code>std::put_time</code>, but the reference says I shall use it only in streams.</p>

<p>There is <code>std::chrono::system_clock</code> which provides <code>to_time_t</code> returning the time as <code>time_t</code> and lacking the date, doesn't it?</p>

<p>I could use a stringstream like bames53: <a href=""https://stackoverflow.com/questions/17223096/outputting-date-and-time-in-c-using-stdchrono"">Outputting Date and Time in C++ using std::chrono</a> but that seems to be a workaround. </p>
"
"<p>I am trying to send variable length message in TCP but the message length that<br>
    is printed is always 0. I am using beej guide code for send and receive and pack and unpack to send the header length.Can someone please point out the mistake.</p>

<p>server code</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#define MAX_SIZE 50

void error(const char *msg)
{
    perror(msg);
    exit(1);
}


void packi32(unsigned char *buf, unsigned long i)//from beej guide
{
     *buf++ = i&gt;&gt;24; *buf++ = i&gt;&gt;16;
     *buf++ = i&gt;&gt;8; *buf++ = i;
}

/* sends all data - thanks to Beej's Guide to Network Programming */
int sendall(int s, char *buf, int *len)
{
   int total=0;
   int bytesleft=*len;
   int n=0;

   /* send all the data */
   while(total&lt;*len){

    /* send some data */
    n=send(s,buf+total,bytesleft,0);

    /* break on error */
    if(n==-1)
        break;

    /* apply bytes we sent */
    total+=n;
    bytesleft-=n;
        }

/* return number of bytes actually send here */
*len=total;

/* return -1 on failure, 0 on success */
return n==-1?-1:0;
}

int sendus(int s,char *msg)
{
    char buf[4];//here 4 is header length
    int len = strlen(msg);
    packi32(buf,len);
    int ll = 4;// ll is header length containing message length
    int x;
    if((x = sendall(s,buf,&amp;ll))&lt; 0)
        printf(""value of sent x %d\n"",x);

    int y = sendall(s,msg,&amp;len);
    return y;
}

int main(int argc, char *argv[])
{
    int sockfd, newsockfd, portno;
    socklen_t clilen;
    char buffer[256];
    struct sockaddr_in serv_addr, cli_addr;
    int n;

    if (argc &lt; 2)
   {
        fprintf(stderr,""ERROR, no port provided\n"");
        exit(1);
    }

sockfd = socket(AF_INET, SOCK_STREAM, 0);

if (sockfd &lt; 0)
        error(""ERROR opening socket"");
    bzero((char *) &amp;serv_addr, sizeof(serv_addr));
    portno = atoi(argv[1]);
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(portno);

if (bind(sockfd, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0)
          error(""ERROR on binding"");

listen(sockfd,5);
    clilen = sizeof(cli_addr);
    newsockfd = accept(sockfd, (struct sockaddr *) &amp;cli_addr, &amp;clilen);


if (newsockfd &lt; 0)
        error(""ERROR on accept"");

char msg[1024] = ""hello"";
int xx = sendus(sockfd,(char*)msg);


   close(newsockfd);

    close(sockfd);
    return 0;
}
</code></pre>

<p>client code</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include&lt;errno.h&gt;
void error(const char *msg)
{
   perror(msg);
   exit(0);
}

/** unpacki32() -- unpack a 32-bit int from a char buffer (like ntohl())
*/
unsigned long unpacki32(unsigned char *buf)
{
  return (buf[0]&lt;&lt;24) | (buf[1]&lt;&lt;16) | (buf[2]&lt;&lt;8) | buf[3];
}

/* receives all data - modelled after sendall() */
int recvall(int s, char *buf, int *len, int timeout){
int total=0;
int bytesleft=*len;
int n=0;
time_t start_time;
time_t current_time;

/* clear the receive buffer */
bzero(buf,*len);

time(&amp;start_time);

/* receive all data */
while(total&lt;*len){

    /* receive some data */
    n=recv(s,buf+total,bytesleft,0);

    /* no data has arrived yet (non-blocking socket) */
    if(n==-1 &amp;&amp; errno==EAGAIN){
        time(&amp;current_time);
        if(current_time-start_time&gt;timeout)
            break;
        sleep(1);
        continue;
            }

    /* receive error or client disconnect */
    else if(n&lt;=0)
        break;

    /* apply bytes we received */
    total+=n;
    bytesleft-=n;
        }

/* return number of bytes actually received here */
*len=total;

/* return &lt;=0 on failure, bytes received on success */
return (n&lt;=0)?n:total;
    }

int recvme(int s, char *buf)
{
    char len[4];
    int l = 4;
    int n = recvall(s,len,&amp;l,10);
    int msg_len = unpacki32(len);
    printf(""msg_length :%d"",msg_len);

    int z ;
    z = recvall(s,buf,&amp;msg_len,10);

    return z;
}

int main(int argc, char *argv[])
{
    int sockfd, portno, n;
    struct sockaddr_in serv_addr;
    struct hostent *server;

    char buffer[1024];
    if (argc &lt; 3)
{
    fprintf(stderr,""usage %s hostname port\n"", argv[0]);
    exit(0);
    }
    portno = atoi(argv[2]);
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd &lt; 0)
        error(""ERROR opening socket"");

server = gethostbyname(argv[1]);
    if (server == NULL)
{
        fprintf(stderr,""ERROR, no such host\n"");
        exit(0);
    }
    bzero((char *) &amp;serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    bcopy((char *)server-&gt;h_addr,
        (char *)&amp;serv_addr.sin_addr.s_addr,
        server-&gt;h_length);

serv_addr.sin_port = htons(portno);
    if (connect(sockfd,(struct sockaddr *) &amp;serv_addr,sizeof(serv_addr)) &lt; 0)
        error(""ERROR connecting"");
        n = recvme(sockfd, buffer);
        if (n &lt; 0)
            error(""ERROR reading from socket"");


    printf(""%s\n"",buffer);

    close(sockfd);
    return 0;
}
</code></pre>
"
"<p>i am not able to understand why the code is not working. sendall and revcall are taken from beej guide. Their is no output when i send the data from server to client. Can someone please explain the error in code. It is mostly from beej guide.One of the problems in broken pipe i.e reading when port is closed but when the port is closed i am not able to understand.</p>

<p>server code</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

#define MAX_SIZE 50

void error(const char *msg)
{
   perror(msg);
   exit(1);
}


/* sends all data - thanks to Beej's Guide to Network Programming */
int sendall(int s, char *buf, int *len)
{
   int total=0;
   int bytesleft=*len;
   int n=0;

  /* send all the data */
  while(total&lt;*len)
  {

    /* send some data */
    n=send(s,buf+total,bytesleft,0);

   /* break on error */
   if(n==-1)
     break;

   /* apply bytes we sent */
   total+=n;
   bytesleft-=n;
  }

  /* return number of bytes actually send here */
  *len=total;

  /* return -1 on failure, 0 on success */
  return n==-1?-1:0;
}



int main(int argc, char *argv[])
{
    int sockfd, newsockfd, portno;
    socklen_t clilen;
    char buffer[256];
    struct sockaddr_in serv_addr, cli_addr;
    int n;

   if (argc &lt; 2)
   {
      fprintf(stderr,""ERROR, no port provided\n"");
      exit(1);
   }

  sockfd = socket(AF_INET, SOCK_STREAM, 0);

  printf(""sockfd : %d"",sockfd);

  if (sockfd &lt; 0)
        error(""ERROR opening socket"");
  bzero((char *) &amp;serv_addr, sizeof(serv_addr));
  portno = atoi(argv[1]);
  serv_addr.sin_family = AF_INET;
  serv_addr.sin_addr.s_addr = INADDR_ANY;
  serv_addr.sin_port = htons(portno);

  if(bind(sockfd, (struct sockaddr *) &amp;serv_addr, sizeof(serv_addr)) &lt; 0)
      error(""ERROR on binding"");

  listen(sockfd,5);
  clilen = sizeof(cli_addr);
  newsockfd = accept(sockfd, (struct sockaddr *) &amp;cli_addr, &amp;clilen);


  if (newsockfd &lt; 0)
        error(""ERROR on accept"");

  char msg[1024] = ""hello"";
  int len = sizeof(msg);
  int xx = sendall(sockfd,(char*)msg,&amp;len);

   close(newsockfd);
   close(sockfd);
  return 0;
}
</code></pre>

<p>client code </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include&lt;errno.h&gt;

void error(const char *msg)
{
   perror(msg);
   exit(0);
}

/* receives all data - modelled after sendall() */
int recvall(int s, char *buf, int *len, int timeout)
{
  int total=0;
  int bytesleft=*len;
  int n=0;
  time_t start_time;
  time_t current_time;

  /* clear the receive buffer */
  bzero(buf,*len);

  time(&amp;start_time);

  /* receive all data */
  while(total&lt;*len)
  {

      /* receive some data */
      n=recv(s,buf+total,bytesleft,0);

      /* no data has arrived yet (non-blocking socket) */
      if(n==-1 &amp;&amp; errno==EAGAIN)
      {
         time(&amp;current_time);

         if(current_time-start_time&gt;timeout)
            break;
         sleep(1);
         continue;
      }

/* receive error or client disconnect */
  else if(n&lt;=0)
      break;

  /* apply bytes we received */
    total+=n;
    bytesleft-=n;
  }

 /* return number of bytes actually received here */
 *len=total;

 /* return &lt;=0 on failure, bytes received on success */
  return (n&lt;=0)?n:total;
}

int main(int argc, char *argv[])
{
  int sockfd, portno, n;
  struct sockaddr_in serv_addr;
  struct hostent *server;

  char buffer[1024];

  if (argc &lt; 3)
  {
    fprintf(stderr,""usage %s hostname port\n"", argv[0]);
     exit(0);
  }
  portno = atoi(argv[2]);

  sockfd = socket(AF_INET, SOCK_STREAM, 0);

   if (sockfd &lt; 0)
     error(""ERROR opening socket"");

  serv_addr.sin_family = AF_INET;
  serv_addr.sin_addr.s_addr = inet_addr(""127.0.0.1"");;
  serv_addr.sin_port = htons(portno);

  if (connect(sockfd,(struct sockaddr *) &amp;serv_addr,sizeof(serv_addr)) &lt; 0)
    error(""ERROR connecting"");

   int m = 1024;
    n = recvall(sockfd, buffer,&amp;m,10);
    if (n &lt; 0)
        error(""ERROR reading from socket"");


  printf(""%s\n"",buffer);

  close(sockfd);
  return 0;
}
</code></pre>
"
"<p>I have one issue to do with handling input to rotate the object on screen.</p>

<p>I coded everything on my desktop where it rotates as it should and you can manipulate the object in 3D space.</p>

<p>On my laptop however, when I try to rotate the object, it actually rotates so fast you can barely even see it. I'm talking like dozens of rotations per second.</p>

<p>My question is... Why? Why does it rotate at normal speed on my PC but at crazy high speed on my laptop? </p>

<p>The rotation I used for each key press is 0.1... On my PC it rotates fast enough to be able to control or, but on my Laptop (and tablet, I tested it on a tablet as well) it just rotates way too fast! I was able to fix it on my laptop by changing the rotation amount to glm::radians(1.0f) and it rotates at normal speed... But on my PC it is rather slower than I would like.</p>

<p>The only thing I can think of has something to do with delta time and the render speed (which I factored in to my camera controls). </p>

<p>Here is my rotation function for reference...</p>

<p>keyboard callback function (NOTE: I have an global array of Booleans called keys[], which I use to see if a key is being pressed)</p>

<pre><code>// Handle the keyboard input
void keyPressed(GLFWwindow *_window, int key, int scancode, int action, int mods) {

// Close window with escape
if (key == GLFW_KEY_ESCAPE &amp;&amp; action == GLFW_PRESS)
    glfwSetWindowShouldClose(window, GL_TRUE);
// Change render to show points only with P
if (key == GLFW_KEY_P &amp;&amp; action == GLFW_PRESS)
    glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
// Change render to show filled in texture with T
if (key == GLFW_KEY_T &amp;&amp; action == GLFW_PRESS)
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
// Change render to show ""wirefram"" mesh with W
if (key == GLFW_KEY_W &amp;&amp; action == GLFW_PRESS)
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

// Array of keys, if key is being held down, sets index corresponding to appropriate integer related to key to true, and false when key is released
if (key &gt;= 0 &amp;&amp; key &lt; 1024)
{
    if (action == GLFW_PRESS)
        keys[key] = true;
    else if (action == GLFW_RELEASE)
        keys[key] = false;
}
return;
}
</code></pre>

<p>And the rotation function (NOTE: clicks[0] is another array of Booleans I use to see if left mouse button is being pushed):</p>

<pre><code>// rotate object based on keyboard input
// Left mouse button must not be held down for this to work
// Creates a matrix containing the appriopriate transformation, and this is later multipled to the model matrix
void rotate_object(glm::mat4 &amp;transform)
{
 // Rotate along z axis (left and right, like a barrel roll)
if (!click[0] &amp;&amp; keys[GLFW_KEY_LEFT])
    transform = glm::rotate(transform, glm::radians(1.0f), glm::vec3(0.0f, 0.0f, 1.0f));
if (!click[0] &amp;&amp; keys[GLFW_KEY_RIGHT])
    transform = glm::rotate(transform, glm::radians(-1.0f), glm::vec3(0.0f, 0.0f, 1.0f));
// Rotate along x axis (up and down, like a flip)
if (!click[0] &amp;&amp; keys[GLFW_KEY_UP])
    transform = glm::rotate(transform, glm::radians(1.0f), glm::vec3(1.0f, 0.0f, 0.0f));
if (!click[0] &amp;&amp; keys[GLFW_KEY_DOWN])
    transform = glm::rotate(transform, glm::radians(-1.0f), glm::vec3(1.0f, 0.0f, 0.0f));
// Rotate along y axes (make object spin)
if (!click[0] &amp;&amp; keys[GLFW_KEY_K])
    transform = glm::rotate(transform, glm::radians(1.0f), glm::vec3(0.0f, 1.0f, 0.0f));
if (!click[0] &amp;&amp; keys[GLFW_KEY_L])
    transform = glm::rotate(transform, glm::radians(-1.0f), glm::vec3(0.0f, 1.0f, 0.0f));
}
</code></pre>

<p>I appreciate your input!</p>

<p>Thanks,</p>
"
"<p>Can anyone explain the output of the lines below:</p>

<pre><code>sprintf(tempStr,""%s%2s%s"",year_str,month_str,day_str);
count=sscanf(tempStr,""%ld%s"",&amp;tempout,other);
</code></pre>

<p>It creates a numeric date, using day, month and year values.</p>

<p>But, how does it convert the <strong>numeric value</strong> to a <strong>long integer</strong>?</p>

<p>For e.g.: Can you tell me, if the <strong>year</strong>, <strong>month</strong> and <strong>day</strong> are <strong><code>2016</code></strong>, <strong><code>02</code></strong>, and <strong><code>08</code></strong>, then what would be the output value in <strong><code>tempout</code></strong>.</p>

<p>Here, is how the input is taken:</p>

<pre><code>    char date_str[20];

    char day_str[2];
    char month_str[2];
    char year_str[2];

    time_t now;
    struct tm* current_time;

    /* get current time */
    now = time(0);

    /* convert time to tm structure */
    current_time = localtime(&amp;now);

    /* format day string */
    sprintf(day_str,""%02d"",current_time-&gt;tm_mday);

    /* format month string */
    sprintf(month_str,""%02d"",current_time-&gt;tm_mon + 1);

    /* format year string */
    sprintf(year_str,""%d"",current_time-&gt;tm_year);

    /* assemble date string */
    sprintf(date_str,""%s%2s%s"",year_str,month_str,day_str);
</code></pre>

<p>The output of this when I run it (using <a href=""http://cpp.sh/"" rel=""nofollow"">http://cpp.sh/</a>), I get is:</p>

<blockquote>
  <p><strong>1160208</strong></p>
</blockquote>

<p>whereas I thought it should be:</p>

<blockquote>
  <p><strong>20160208</strong>. </p>
</blockquote>

<p>In some other context, there is a line below, Which is also <strong><code>116</code></strong> if the year is <strong><code>2016</code></strong>:</p>

<p><code>sprintf(year_str,""%02d"",options.year - 1900);</code></p>

<p>Here, <strong><code>date_str</code></strong> is the <code>tempStr</code> mentioned above, hence, the input is: <strong><code>1160208</code></strong></p>
"
"<p>I am studying OpenGL using OpenGL superbible 7th edition. However, when I tried to run the example in Chapter 2, I found a problem that the color is not changing over time as intended.</p>

<p>Here is the main program:</p>

<pre><code>int main(int argc, char** argv) {
    if (!glfwInit())
    {
        fprintf(stderr, ""Failed to initialize GLFW\n"");
        return 1;
    }

    GLFWwindow* window;
    window = glfwCreateWindow(800, 600, ""My First OpenGL Project"", NULL, NULL);
    if (!window)
    {
        fprintf(stderr, ""Failed to open window\n"");
        return 1;
    }
    glfwMakeContextCurrent(window);

    gl3wInit();

    bool running = true;

    do
    {
        double current_time = glfwGetTime();
        static const GLfloat color[] = {
            (float)sin(current_time) * 0.5f + 0.5f,
            (float)cos(current_time) * 0.5f + 0.5f,
            0.0f,
            1.0f };
        std::cout &lt;&lt; current_time &lt;&lt; std::endl;
        std::cout &lt;&lt; color[0] &lt;&lt; std::endl;
        glClearBufferfv(GL_COLOR, 0, color);

        glfwSwapBuffers(window);
        glfwPollEvents();

        running &amp;= (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_RELEASE);
        running &amp;= (glfwWindowShouldClose(window) != GL_TRUE);
    } while (running);

    glfwDestroyWindow(window);
    glfwTerminate();
    return 0;
}
</code></pre>

<p>It appears that the value of current_time is changing over time but the value of color[0] is not. Why is that?</p>
"
"<p>i'm trying to create a def for log file and this is my script:</p>

<pre><code>import sys
import time
path= 'pc_path'
file = path + '\\' + 'test.txt'

files = open(file, 'w')
files.close()

def log(msg):
    time = time.time()
    filess = open(file, 'a')
    filess.write(msg)
    filess.close()

val = 10
val1 = 32
try:
    operazione = val + val1
    print('ok')
    print(operazione)
    msg = operazione
    log(msg)
except:
    sys.exit()
</code></pre>

<p>the script create a txt file but does not write a def() function into txt
Thanks</p>
"
"<p>I am trying to do a linear interpolation between two know positions. Previous position and current position.</p>

<pre><code>float x,y, p_x, p_y;
</code></pre>

<p>i call this update function at fixed intervals.</p>

<pre><code>update(float _x, float _y) {
    p_x = x;
    p_y = y;
    x += _x;
    y += _y;
}
</code></pre>

<p>the interpolation function looks like this</p>

<pre><code>interpolate(float delta) {
     float tx, ty;
     tx = (x * delta) + (p_x * (1.0 - delta));
     ty = (y * delta) + (p_y * (1.0 - delta));
     p_x = tx;
     p_y = ty;
}
</code></pre>

<p>I've also tried doing something like this where instead of using a tx and ty variable I just update x and y.</p>

<pre><code>interpolate(float delta) {
     x = (x * delta) + (p_x * (1.0 - delta));
     y = (y * delta) + (p_y * (1.0 - delta));
     p_x = x;
     p_y = y;
}
</code></pre>

<p>This one seems to move a lot slower but the shaking is mostly although there's still the problem of really fast movement on horizontals, for example if I update both x and y at the same time.</p>

<p>this seems to work okay but if I move only along the x or y axis. If I move horizontally there's a lot of jitters. The problem isn't really visible when  updating at a high delta time 60fps </p>

<p>at 30fps or lower horizontal movement becomes really jerky. Is my interpolation code incorrect? How can I fix it?</p>

<p><strong>edit</strong></p>

<p>adding a minimal working example.</p>

<pre><code>static double start_time, current_time, new_time;
static double delta_time = 0.01;
static double accum = 0.0;
static double frame_time;

static int ce_run_game() {
    while (game_running &gt; 0) {
        if (glfwWindowShouldClose(main_window)) game_running = -1;

        new_time = glfwGetTime();
        frame_time = new_time - current_time;

        if (frame_time &gt; 0.025) {
            frame_time = 0.025;
        }

        current_time = new_time;
        accum += frame_time;

        while (accum &gt;= delta_time) {
            ce_tick();
            accum -= delta_time;
        }

        double alpha = accum / delta_time;
        // state = current_state_x * alpha + prev_state_x * (1.0 - alpha);
        ce_interpolate(alpha);

        glfwSwapBuffers(main_window);
        glfwPollEvents();
    }

    return -1;
}
</code></pre>

<p>inside of I update the variables.</p>

<pre><code>float x, y, previous_x, previous_y;

ce_tick() {
     if(left_pressed) {
          update(-10, 0);
     }
     if(right_pressed) {
          update(10, 0);
     }
     if(up_pressed) {
          update(0, 10);
     }
     if(down_pressed) {
          update(0, -10);
     }
}
</code></pre>

<p>the update function looks like this:</p>

<pre><code>    update(float _x, float _y) {
        previous_x = x;
        previous_y = y;
        x += _x;
        y += _y;
    }

ce_interpolate(double alpha) {
     float interpolated_x, interpolated_y;
     interpolated_x = (x * delta) + (previous_x * (1.0 - delta));
     interpolated_y = (y * delta) + (previous_y * (1.0 - delta));
     previous_x = tx;
     previous_y = ty;
}
</code></pre>

<p>the update code saves the current x and y to previous_x previous_y then adds some values to the current x and y.</p>

<p>Then in the interpolation call I try to do the interpolation.</p>
"
"<p>I'm developing a game that has a word falling to the bottom of the screen and the user typing that word before it hits the bottom. So you'll be able to type input while the word is falling. Right now I have a timer that waits 5 seconds, prints the word, runs timer again, clears the screen, and prints the word down 10 units. </p>

<pre><code>int main()
{
for (int i = 0; i &lt; 6; i++)
   {
    movexy(x, y);
    cout &lt;&lt; ""hello\n"";
    y = y + 10;
    wordTimer();
   }
}
</code></pre>

<p>Very basic I know. Which is why I thought multithreading would be a good idea so that way I could have the word falling while I still type input at the bottom. This is my attempt at that so far:</p>

<pre><code>    vector&lt;std::thread&gt; threads;

for (int i = 0; i &lt; 5; ++i) {
    threads.push_back(std::thread(task1, ""hello\n""));
    threads.push_back(std::thread(wordTimer));

}

for (auto&amp; thread : threads) {
    thread.join();
}
</code></pre>

<p>However this only prints hello 4 times to the screen, then prints 55, then prints hello again, then counts-down 3 more times. So any advice on how to correctly do this? I've already done research. Just a few of the links I checked out that didn't help:</p>

<p><a href=""https://stackoverflow.com/questions/22313033/multithreaded-console-i-o?lq=1"">Multithreaded console I/O</a></p>

<p><a href=""https://stackoverflow.com/questions/18870549/c11-multithreading-display-to-console"">C++11 Multithreading: Display to console</a></p>

<p><a href=""https://stackoverflow.com/questions/10036527/render-buffer-on-screen-in-windows"">Render Buffer on Screen in Windows</a></p>

<p><a href=""https://stackoverflow.com/questions/16178332/threading-console-application-in-c"">Threading console application in c++</a></p>

<p><a href=""https://stackoverflow.com/questions/18787124/create-new-console-from-console-app-c"">Create new console from console app? C++</a></p>

<p><a href=""https://stackoverflow.com/questions/19052143/console-output-from-thread"">Console output from thread</a></p>

<p><a href=""https://msdn.microsoft.com/en-us/library/975t8ks0.aspx?f=255&amp;MSPPError=-2147217396"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/975t8ks0.aspx?f=255&amp;MSPPError=-2147217396</a></p>

<p><a href=""http://www.tutorialspoint.com/cplusplus/cpp_multithreading.htm"" rel=""nofollow noreferrer"">http://www.tutorialspoint.com/cplusplus/cpp_multithreading.htm</a></p>

<p>So I'd really appreciate a unique answer to this question. Thank you!</p>

<p>EDIT:
Here is wordTimer()</p>

<pre><code>    int wordTimer()
{
    _timeb start_time;
    _timeb current_time;

    _ftime_s(&amp;start_time);
    int i = 5;
    for (; i &gt; 0; i--)
    {
        cout &lt;&lt; i &lt;&lt; endl;

        current_time = start_time;
        while (elapsed_ms(&amp;start_time, &amp;current_time) &lt; 1000)
        {
            _ftime_s(&amp;current_time);
        }

        start_time = current_time;
    }
    cout &lt;&lt; "" 5 seconds have passed."" &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>this is also necessary for wordTimer()</p>

<pre><code>    unsigned int elapsed_ms(_timeb* start, _timeb* end)
{

        return (end-&gt;millitm - start-&gt;millitm) + 1000 * (end-&gt;time - start-&gt;time);
    }
</code></pre>

<p>and task1</p>

<pre><code>    void task1(string msg)
{

    movexy(x, y);
    cout &lt;&lt; msg;
    y = y + 10;

}
</code></pre>

<p>and void movexy(int x, int y)</p>

<pre><code>void movexy(int column, int line)
{
    COORD coord;
    coord.X = column;
    coord.Y = line;
    SetConsoleCursorPosition(
        GetStdHandle(STD_OUTPUT_HANDLE),
        coord
        );
}
</code></pre>
"
"<p>I have implemented a task queue with priority from <a href=""http://www.boost.org/doc/libs/1_48_0/doc/html/boost_asio/example/invocation/prioritised_handlers.cpp"" rel=""nofollow"">asio examples</a> and a timer class which use this queue. Here is the code:</p>

<h3>priority_task_queue.h</h3>

<pre><code>class handler_priority_queue
{
private:
    class queued_handler{
    private:
        size_t _priority;
        std::function&lt;void()&gt; _function;
    public:
        queued_handler(size_t p, std::function&lt;void()&gt; f): _priority(p), _function(f){}
        friend bool operator&lt;(const queued_handler&amp; a, const queued_handler&amp; b){
            return a._priority &lt; b._priority;
        }
        void operator()() {
            _function();
        }
    };
    std::priority_queue&lt;queued_handler&gt; _handlers;

public:
    // A generic wrapper class for handlers to allow the invocation to be hooked.
    template &lt;typename Handler&gt; class wrapped_handler
    {
        private:
            handler_priority_queue&amp; _queue;
            size_t _priority;
            Handler _handler;

        public:
            handler_priority_queue&amp; queue() {return _queue;}
            size_t priority() {return _priority;}

            wrapped_handler(handler_priority_queue&amp; q, size_t p, Handler h)
                : _queue(q), _priority(p), _handler(h){}


            template &lt;typename ...Args&gt;
            void operator()(Args&amp;&amp;... args){
                _handler(std::forward&lt;Args&gt;(args)...);
            }
    };
    template &lt;typename Handler&gt; wrapped_handler&lt;Handler&gt; wrap(size_t priority, Handler handler){
        return wrapped_handler&lt;Handler&gt;(*this, priority, handler);
    }
    void add(size_t priority, std::function&lt;void()&gt; function);
    void execute_all();
    void execute_one();
    bool empty();
};

// Custom invocation hook for wrapped handlers.
template &lt;typename Function, typename Handler&gt;
void asio_handler_invoke(Function f, handler_priority_queue::wrapped_handler&lt;Handler&gt;* h){
    h-&gt;queue().add(h-&gt;priority(), f);
    std::cout&lt;&lt;""LLAMANDO AL INVOKE""&lt;&lt;std::endl; //BORRAR!!
}

class C_priority_task_queue{

    private:
        asio::io_service&amp; _io;
        handler_priority_queue _pri_queue;

    public:
        template &lt;typename Handler&gt; handler_priority_queue::wrapped_handler&lt;Handler&gt; wrap(int priority, Handler handler){
            return _pri_queue.wrap(priority, handler);
        }

        explicit C_priority_task_queue(asio::io_service&amp; io): _io(io){}
        C_priority_task_queue(C_priority_task_queue const&amp;) = delete;
        C_priority_task_queue&amp; operator =(C_priority_task_queue const&amp;) = delete;

        asio::io_service&amp; io() {return _io;}
        void run();
};
</code></pre>

<h3>priority_task_queue.cpp</h3>

<pre><code>void handler_priority_queue::add(size_t priority, std::function&lt;void()&gt; function){
    _handlers.push(queued_handler(priority, function));
}

void handler_priority_queue::execute_one(){
    if(!_handlers.empty()){
        queued_handler handler = _handlers.top();
        handler();
        _handlers.pop();
    }
}

bool handler_priority_queue::empty(){
    return _handlers.empty();
}

void C_priority_task_queue::run(){
    while (_io.run_one())
    {
        _io.poll();
        while(!_pri_queue.empty())
        {
            _io.poll();
            _pri_queue.execute_one();
        }
    }
}
</code></pre>

<h2>base_timer.h</h2>

<pre><code>class C_timer {
    private:
        asio::high_resolution_timer _timer;
        uint8_t _timer_id;
        C_priority_task_queue&amp; _prio_queue;


    void timer_handler_internal(const asio::error_code&amp; e, uint8_t timer_id, const uint64_t sched_time);
    virtual void timer_handler(const uint64_t sched_time)=0;

    public:
        size_t _priority;
        explicit C_timer(C_priority_task_queue&amp; prio_queue, size_t priority);
        virtual ~C_timer();

        void set_timer(uint64_t sched_time);
        int cancel();
};
</code></pre>

<h2>base_timer.cpp</h2>

<pre><code>C_timer::C_timer(C_priority_task_queue&amp; prio_queue, size_t priority):
        _timer(prio_queue.io()), _timer_id(0), _prio_queue(prio_queue), _priority(priority){}

C_timer::~C_timer(){}

void C_timer::set_timer(uint64_t sched_time){
    ++_timer_id;

    _timer.expires_at(std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt;(std::chrono::milliseconds(sched_time)));
    _timer.async_wait(_prio_queue.wrap(_priority, std::bind(&amp;C_timer::timer_handler_internal, this,
                      std::placeholders::_1/*error*/, _timer_id, sched_time)));
}

int C_timer::cancel(){
    ++_timer_id;
    return _timer.cancel();
}

void C_timer::timer_handler_internal(const asio::error_code&amp; e, uint8_t timer_id,
                                               const uint64_t sched_time){
    if(e==asio::error::operation_aborted || timer_id != _timer_id){
        return;
    }
    timer_handler(sched_time);
}
</code></pre>

<h2>test class</h2>

<pre><code>class C_timer_test: public C_timer{
    private:
        int _period;

        virtual void timer_handler(const uint64_t sched_time) override{
            std::cout&lt;&lt;""timer fired""&lt;&lt;std::endl;

            uint64_t current_time = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
            set_timer(current_time + _period);
        }

    public:
        C_timer_test(C_priority_task_queue&amp; prio_queue, int priority, int period):C_timer(prio_queue, priority), _periodo(period){}
        virtual ~C_timer_test(){}
        void run(uint64_t delay=0){
            uint64_t time = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(std::chrono::high_resolution_clock::now().time_since_epoch()).count();
            set_timer(time + delay);
        }
};
</code></pre>

<p>The problem is if I execute this :</p>

<pre><code>int main()
{
    asio::io_service io;
    C_priority_task_queue prio_queue(io);
    asio::io_service::work w(io);

  C_timer_test ti1(prio_queue, 0, 2000);
  ti1.run();
  prio_queue.run();

  return 0;
}
</code></pre>

<p>I get a segmentation fault.</p>

<p>However, if I execute the following code it works fine:</p>

<pre><code>int main()
{
    asio::io_service io;
    C_priority_task_queue prio_queue(io);
    asio::high_resolution_timer _timer1(io);
    asio::io_service::work w(io);

  C_timer_test ti1(prio_queue, 0, 2000);
  ti1.run();
  prio_queue.run();

  return 0;
}
</code></pre>

<p>The only diference between both piece of code is in the second main I have added the following line <code>asio::high_resolution_timer _timer1(io);</code> that I haven't use in any place.</p>

<p>Debugging the program I have found that the signal is raising in this line:
<code>func_(&amp;owner, this, ec, bytes_transferred);</code> in file <code>task_io_service_operation.hpp</code></p>

<p>I am using asio version 1.10.6.</p>

<p>Any suggestion that what could be happening?</p>

<p>The backtrace from gdb:</p>

<pre><code>gdb ./main
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.2) 7.7.1
This GDB was configured as ""i686-linux-gnu"".
(gdb) r
[libthread_db enabled]
Using host libthread_db library ""/lib/i386-linux-gnu/libthread_db.so.1"".

Program received signal SIGSEGV, Segmentation fault.
0x0805f0d4 in ?? ()
(gdb) backtrace
#0  0x0805f0d4 in ?? ()
#1  0x080529fb in asio::detail::task_io_service::do_run_one (this=0x805f030, lock=..., this_thread=..., ec=...) at /src/cpp/external_lib/asio/include/asio/detail/impl/task_io_service.ipp:371
#2  0x080526ce in asio::detail::task_io_service::run_one (this=0x805f030, ec=...) at /src/cpp/external_lib/asio/include/asio/detail/impl/task_io_service.ipp:169
#3  0x08052c68 in asio::io_service::run_one (this=0xbffff08c) at /src/cpp/external_lib/asio/include/asio/impl/io_service.ipp:71
#4  0x08051f32 in C_priority_task_queue::run (this=0xbffff094) at priority_task_queue.cpp:19
#5  0x08049ac3 in main () at main.cpp:46
</code></pre>

<p>And here there is the MakeFile:</p>

<pre><code>TARGET=main
SOURCES=  main.cpp base_timer.cpp  priority_task_queue.cpp
SOURCE_DIR=.
INCLUDE_LIB= -L/src/cpp/libcore
INCLUDE_DIR=-I/src/cpp/external_lib/asio/include \
             -I/src/cpp/libcore/include
INSTALL_DIR=.
LIB=-pthread
CXX=g++
CFLAGS=-Wall -fexceptions -fpermissive -std=c++11 -DASIO_STANDALONE
CFLAGS_DEBUG = -g3 -DDEBUG
OBJDIR_DEBUG=obj
BINDIR_DEBUG=.
OBJECTS_DEBUG:= $(addprefix $(OBJDIR_DEBUG)/,$(SOURCES:.cpp=.o))

all: debug

$(OBJDIR_DEBUG)/%.o: $(SOURCE_DIR)/%.cpp
    @test -d $(OBJDIR_DEBUG) || mkdir -p $(OBJDIR_DEBUG)
    $(CXX) $(CFLAGS) $(CFLAGS_DEBUG) $(INCLUDE_DIR) -c $&lt; -o $@

debug: $(OBJECTS_DEBUG)
    @test -d $(BINDIR_DEBUG) || mkdir -p $(BINDIR_DEBUG)
    $(CXX) -o $(BINDIR_DEBUG)/$(TARGET) $^ $(INCLUDE_LIB) $(LIB)
</code></pre>

<h2>UPDATE</h2>

<p>I my investigation, I have found that if I define the base_timer members (basically asio::high_resolution_timer) initializations in the .h, the code runs ok, but if I do this in the .cpp, the code crash.</p>

<p>I mean,</p>

<pre><code>explicit C_timer(C_priority_task_queue&amp; prio_queue, size_t priority):
        _timer(prio_queue.io()), _timer_id(0), _prio_queue(prio_queue), _priority(priority){}
</code></pre>

<p>in .h works, but </p>

<pre><code>C_timer::C_timer(C_priority_task_queue&amp; prio_queue, size_t priority):
   _timer(prio_queue.io()), _timer_id(0), _prio_queue(prio_queue), _priority(priority){}
</code></pre>

<p>in .cpp fails</p>
"
"<p>I'm trying to troubleshoot some warnings in my C code compiled with -std=gnuc99.</p>

<pre><code>void function.. (char *argument)
{
  int hour;

  hour = (int) (struct tm *)localtime(&amp;current_time)-&gt;tm_hour;

  if(hour &lt; 12)
  {
      do...something...
  }
}
</code></pre>

<p>The warning</p>

<pre><code> warning: cast to pointer from integer of different size [-Wint-to-pointer-cast]
 hour = (int) (struct tm *)localtime(&amp;current_time)-&gt;tm_hour;
              ^
</code></pre>

<p>What I assume is happning here is that localtime is not a pointer and it's not the same size as int?</p>
"
"<p>I am creating a function which outputs the current system time in a certain format. </p>

<pre><code>char *get_time() {
    char *current_time;
    time_t rawtime;
    struct tm *timeinfo;

    time(&amp;rawtime);
    timeinfo = localtime(&amp;rawtime);

    sprintf(current_time, ""[%d/%d %d:%d] # "", timeinfo-&gt;tm_mday, timeinfo-&gt;tm_mon + 1, timeinfo-&gt;tm_hour, timeinfo-&gt;tm_min);

    return current_time;
}
</code></pre>

<p><code>char *current_time</code> needs to be initialised before it is used in <code>sprintf()</code>. How can I do this?</p>
"
"<p>The goal of this server is to transfer small files, in a relatively simple manner.  I have finished the code and it all compiles without error, and when I try to run it, the server side has no  problems, but the client side gives an error in the socket binding and a segmentation fault.  I was wondering what in the code was causing these problems. </p>

<p>Server: </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;crypt.h&gt;
#include &lt;time.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
#include &lt;netinet/ip.h&gt;
void timestamp_ss()
{
  time_t current_time;
  char* log_time;

  log_time = ctime(&amp;current_time);
  log_file_ss(log_time);
}
send_data(int sockfd, char info_to_send)
{
  char eof_buffer[4] = ""\EOF"";
  int sent_data, data_to_send;
  data_to_send = strlen(&amp;info_to_send);

  while(data_to_send &gt; 0)
  {
  sent_data = send(sockfd, &amp;info_to_send, data_to_send, 0);
  if(sent_data == -1)
    perror(""There was a problem in the sending of data!"");
  data_to_send -= sent_data;
  info_to_send += sent_data;
  }
  send(sockfd, eof_buffer, 4, 0);
}
int recv_data(int sockfd, char *dest_buffer)
{
  #define EoF ""\EOF""
  unsigned char *buffer;
  int eof_match = 0, eof_size = 2;

  buffer = dest_buffer;
  while(recv(sockfd, buffer, 1, 0) == 1)
  {
    if(*buffer == EoF[eof_match])
    {
      eof_match++;
      if(eof_match = eof_size)
        {
          *(buffer+1-eof_size) = '\0';
          return strlen(dest_buffer);
        }
        else
        {
          eof_match = 0;
        }
    }
    buffer++;
  }
  return 0;
}
int password_ss(char *password_attempt, char *password_actual)
{
  char key[] = { ""ZjQXStSi"" };
  char ivec[] = {""7eNP3U1b"" };
  char des_dec[] = { ""DES_DECRYPT"" };
  char des_hw[] = { ""DES_HW"" };
  int l, i;

  l = strlen(password_attempt);
  i = cbc_crypt(key, password_attempt, l, *des_dec | *des_hw, ivec);
  if(i &lt; 0)
    error_escape(""In decryption"");

  if(password_attempt == password_actual)
    return 1;
  else
    return 0;
}
int log_file_ss(char *log_message)
{
  char logfile[]= ""/Server/log/C-File-Transfer-Server-Log"";
  int log_fd, len;

  log_fd = open(logfile, O_WRONLY | O_APPEND | O_CREAT);
  len = strlen(log_message);
  write(log_fd, log_message, len);
}
void file_to_client_ss(int sockfd, struct sockaddr_in *client_addr_ptr)
{
  char file_req_c[128];
  char buffer[10000];
  char files[256];
  char pass_attempt[128];
  char *error_403[20] = { ""Error 403: Forbidden"" };
  char *error_404[25] = { ""Error 404: File Not Found"" };
  char *pass_path[20] = { ""/server/log/PASSWORD"" };
  char *pass_req[50] = { ""This File Requires A Password, Please Enter It Now"" };
  char *no_pass[37] = { ""This File Does Not Require A Password"" };
  char *username;
  char *file_s;
  char *string;
  char *file1_path[26] = { ""/server/received_files/r_w"" };
  char *file2_path[24] = { ""/server/received_files/r"" };
  char *file3_path[24] = { ""/server/received_files/n"" };
  char file_data;
  FILE *cs, *ps;
  int file1, file2, file3, file_test, pass;

  cs = fopen(file_req_c, ""r"");
  recv_data(sockfd, username);
  chdir(""/server/log/PASSWORD"");
  ps = fopen(username, ""r"");
  fread(files, 1, file_size(ps), ps);
  chdir(""/server"");
  recv_data(sockfd, file_req_c);
  file_test = file_exist(file1_path, file_req_c);
  if(file_test = -1)
  {
    file_test = file_exist(file2_path, file_req_c);
    if(file_test = -1)
    {
        file_test = file_exist(file3_path, file_req_c);
            if(file_test = -1)
            {
                error_escape(""Opening file request from client"");
            }
            else
            {
                    send_data(sockfd, **pass_req);
                    recv_data(sockfd, pass_attempt);
                    pass = password_ss(pass_attempt, files);
                        if(pass == 0)
                {
                            send_data(sockfd, **error_403);
                            error_escape(""Wrong Password"");
                }
                    else
                    {
                             if(file_exist(pass_path, username) == 0)
                                send_data(sockfd, *file_req_c);
                    else
                        errror_escape(""Error in sending file"");
                        }
            }
       }
      else
      {
        chdir(*file2_path);
        file_data = fread(buffer, 1, file_size(cs), cs);
        send_data(sockfd, **no_pass);
        send_data(sockfd, file_data);
      }
  }
  else
  {
    chdir(*file1_path);
    file_data = fread(buffer, 1, file_size(cs), cs);
    send_data(sockfd, **no_pass);
    send_data(sockfd, file_data);
  }
}
int file_size(FILE *stream)
{
  off_t file_len;

  fseek(stream, 0, SEEK_END);
  file_len = ftell(stream);
  fclose(stream);
  return file_len;
}
int file_exist(char *file_path, char *file_name)
{
  DIR *dp;
  FILE *fc;
  struct dirent *ep;

 dp = opendir(file_path);

  if(dp == NULL)
    perror(""Opening path"");
  else
    chdir(file_path);
closedir(dp);

fc = fopen(file_name, ""r"");
  if(fc == NULL)
  {
    perror(""Opening file"");
    return(-1);
  }
  else {
    return(0);
}
}
error_escape(char *problem)
{
  char error_message[256];

  strcpy(error_message, ""! There Has Been An Error !"");
  strncat(error_message, problem, 173);
  perror(""Error: "");
  log_file_ss(error_message);
  timestamp_ss();
  exit(-1);
}
void file_accept_ss(int sockfd, struct sockaddr_in *client_addr_ptr)
{
  char client_request[512], username[256], file_content[8192], buf[8192];
  char *client_r_w[26]  = { ""/server/received_files/r_w"" };
  char *client_r[24] = { ""/server/received_files/r"" };
  char *client_n[24] = { ""/server/received_files/n"" };
  char *search_string_read[6] = { ""O_READ"" };
  char *search_string_w[14] = { ""O_READANDWRITE"" };
  char *password_path[20] = { ""/server/log/PASSWORD"" };
  char *mkdir[37] = { ""/server/log/PASSWORD"" };
  char *ret;
  char file_data, recv_i;
  char password[256];
  int change_dir_test, recv_check;
  FILE *fn, *Ps;

  recv_data(sockfd, username);
  recv_data(sockfd, password);
  strcat(*mkdir, username);
  strcat(*mkdir, password);
  fn = fopen(*mkdir, ""a"");
  chdir(*password_path);
  Ps = fopen(*mkdir, ""a"");
  chdir(""/server"");
  recv_i = fread(buf, 1, file_size(fn), fn);
  recv_check = recv_data(sockfd, &amp;recv_i);
  if(recv_check = -1)
    error_escape(""! There Was An Error In The Receiving Of The File From The Client !"");
  fread(file_content, 8, file_size(fn), fn);
  ret = strstr(file_content, *search_string_read);
  if(ret = NULL)
    {
    change_dir_test = chdir(*client_n);
      if(change_dir_test = -1)
        error_escape(""! There Was An Error In The Changing Of Directories !"");
       else
       {
    file_data = fread(buf, 1, file_size(Ps), Ps);
        recv_data(sockfd, &amp;file_data);
        chdir(*client_n);
    strcat(*client_n, username);
        rename(username, *client_n);
       }
    }
  if(ret = *search_string_read)
    {
    change_dir_test = chdir(*client_r);
      if(change_dir_test = -1)
        error_escape(""! There Was An Error In The Changing Of Directories !"");
       else
       {
        chdir(*client_r);
        rename(username, *client_r);
       }
    }
  if(ret = *search_string_w)
    {
    change_dir_test = chdir(*client_r_w);
      if(change_dir_test = -1)
        error_escape(""! There Was An Error In The Changing Of Directories !"");
       else
       {
        chdir(*client_r_w);
        rename(username, *client_r_w);
    }
    }
  log_file_ss(""Client:"");
  log_file_ss(username);
  timestamp_ss();
}
int main(void)
{
  struct sockaddr_in server, client;
  int sockfd, bind_test, listen_test, client_sockfd, sin_size;

  sockfd = socket(PF_INET, SOCK_STREAM, 0);
  if(sockfd == -1)
    error_escape(""Making Socket"");

  server.sin_family = AF_INET;
  server.sin_port = htons(80);
  server.sin_addr.s_addr = INADDR_ANY;

  bind_test = bind(sockfd, (struct sockaddr *)&amp;server, sizeof(server));
  if(bind_test &lt; 0)
    error_escape(""Binding Socket"");
  listen_test = listen(sockfd, 20);
  if(listen_test &lt; 0)
    error_escape(""Listening"");
  while(1)
  {
    sin_size = sizeof(struct sockaddr_in);
    client_sockfd = accept(sockfd, (struct sockaddr *)&amp;client, &amp;sin_size);
    file_accept_ss(client_sockfd, &amp;client);
    file_to_client_ss(client_sockfd, &amp;client);
  }
shutdown(client_sockfd, SHUT_RDWR);
return 0;
}
</code></pre>

<p>Client: </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;dirent.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;crypt.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/ip.h&gt;



send_data(int sockfd, char info_to_send)
{
  char eof_buffer[4] = ""\EOF"";
  int sent_data, data_to_send;
  data_to_send = strlen(&amp;info_to_send);

  while(data_to_send &gt; 0)
  {
  sent_data = send(sockfd, &amp;info_to_send, data_to_send, 0);
  if(sent_data == -1)
    perror(""There was a problem in the sending of data!"");
  data_to_send -= sent_data;
  info_to_send += sent_data;
  }
  send(sockfd, eof_buffer, 4, 0);
}
send_file_cs(int sockfd)
{
  char file_buffer[4096], file_name[256];
  char name, username, password;
  char *search_st, file_data, *file_location;
  int perm_choice, password_max = 20, ch;
  off_t size_of_file;
  FILE *fp;

  printf(""%s\n"", ""Please enter the path to file you would like to move to server:"");
  scanf(""%s"", &amp;file_location);
  ch = chdir(file_location);
  if(ch == -1)
    perror(""! There Has Been An Error In The Directory Path !"");
  else
    chdir(file_location);
  printf(""%s\n"", ""Now Enter The Name Of The File You Would Like To Transfer:"");
  printf(""%s\n"", ""! Warning, The File May Not Exceed 4 kilobytes !"");
  scanf(""%s"", &amp;name);
  printf(""%s"", ""What would you like the username for this file to be?"");
  name = *file_name;
  size_of_file = file_size(fp);
  if(size_of_file &gt; 4096)
    printf(""! The File Is Greater Than 4 Kilobytes !"");
  fp = fopen(file_name, ""r+"");
  printf(""%s\n"", ""What Permissions Would You Like The File To Have?\n (1) For Other Clients To See The File\n (2) For Other CLients To See But Not Be Able To Access\n (3) Other Clients Cannot See Or Access The File"");
  scanf(""%d"", &amp;perm_choice);
  if(perm_choice &gt; 3 || perm_choice &lt; 1)
    perror(""! Incorrect Permissions !"");
  if(perm_choice = 1)
    {
    search_st = ""O_READ"";
    fopen(file_name, ""a"");
    fwrite(search_st, 1, strlen(search_st), fp);
    }
  if(perm_choice = 2)
    {
    search_st = ""O_READANDWRITE"";
    fopen(file_name, ""a"");
    fwrite(search_st, 1, strlen(search_st), fp);
    }
  if(perm_choice = 3)
    {
    search_st = ""O_NOACCESS"";
    fopen(file_name, ""a"");
    fwrite(search_st, 1, strlen(search_st), fp);
    printf(""%s"", ""Please enter a password"");
    scanf(""%s"", &amp;password);
    send_data(sockfd, password);
    }
  file_data = fread(file_buffer, 1, 4096, fp);
  send_data(sockfd, file_data);
}
int recv_data(int sockfd, char *dest_buffer)
{
  #define EoF ""\EOF""
  unsigned char *buffer;
  int eof_match = 0, eof_size = 2;

  buffer = dest_buffer;
  while(recv(sockfd, buffer, 1, 0) == 1)
  {
    if(*buffer == EoF[eof_match])
    {
      eof_match++;
      if(eof_match = eof_size)
        {
          *(buffer+1-eof_size) = '\0';
          return strlen(dest_buffer);
        }
        else
        {
          eof_match = 0;
        }
    }
    buffer++;
  }
  return 0;
}
int password_cs(int max_length, int sockfd)
{
  char salt[] = { ""ZjQXStSi"" };
  char ivec[] = { ""7eNP3U1b"" };
  char des_enc[] = { ""DES_ENCRYPT"" };
  char des_hw[] = { ""DES_HW"" };
  char password;
  char *ret, *ret2;
  int l, i;

  printf(""%s"", ""Please set your password:"");
  scanf(""%s"", &amp;password);
  l = strlen(&amp;password);
  if(l &gt; max_length)
    printf(""%s : %d"", ""Password must be less than"", max_length);

  i = cbc_crypt(salt, password, l, *des_enc | *des_hw, ivec);
  if(i &lt; 0)
    perror(""In erncryption"");

  send_data(sockfd, password);
  return 0;
}
int file_size(FILE *stream)
{
  off_t file_len;

  fseek(stream, 0, SEEK_END);
  file_len = ftell(stream);
  fclose(stream);
  return file_len;
}
int file_exist(char *file_path, char *file_name)
{
  DIR *dp;
  FILE *fc;
  struct dirent *ep;

 dp = opendir(file_path);

  if(dp == NULL)
    perror(""Opening path"");
  else
    chdir(file_path);
closedir(dp);

fc = fopen(file_name, ""r"");
  if(fc == NULL)
  {
    perror(""Opening file"");
    return(-1);
  }
  else {
    return(0);
}
}
void client_request_file_cs(int sockfd)
{
  char password_buf[128], file[4096], recv_file[256];
  char *requires[16] = { ""Requires"" };
  char *str, *restr, *file_contents, *name2, *path, *rebuf;
  char file_req, password, name, username;
  int test;
  FILE *re;

  printf(""%s\n"", ""What file would you like from the server?"");
  scanf(""%s"", &amp;file_req);
  printf(""%s"", ""What is the user name associated with the file?"");
  scanf(""%s"", &amp;username);
  send_data(sockfd, username);
  printf(""%s\n"", ""Where Would You Like The File To Be Put, Please Enter The Path:"");
  scanf(""%s"", &amp;path);
  test = chdir(path);
  if(test == -1)
    printf(""%s\n"", ""Invalid Path"");
  printf(""%s\n"", ""What Would You Like To Call The File?"");
  scanf(""%s"", &amp;name);
  name2 = &amp;name;
  re = fopen(name2, ""w"");
  fread(file_contents, 1, file_size(re), re);
  send_data(sockfd, file_req);
  recv_data(sockfd, password_buf);
  printf(""%s\n"", password_buf);
  str = strstr(password_buf, *requires);
  if(str == NULL)
    recv_data(sockfd, file);
  else
  {
    scanf(""%s"", &amp;password);
    send_data(sockfd, password);
  }
  recv_data(sockfd, rebuf);
  fwrite(rebuf, 1, sizeof(rebuf), re);
  fclose(re);
  restr = strstr(file_contents, ""error_"");
  if(restr != NULL)
    printf(""%s\n"", re);
}
int main(void)
{
struct sockaddr_in client, server_addr;
int sockfd, connected;

server_addr.sin_family = AF_INET;
server_addr.sin_port = htons(80);

sockfd = socket(AF_INET, SOCK_STREAM, 0);
if(sockfd == -1)
  printf(""%s"", ""Error opening socket"");

connected = connect(sockfd, (struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr));
if(connected == -1)
  printf(""%s"", ""Error binding socket"");

send_file_cs(sockfd);
client_request_file_cs(sockfd);
shutdown(sockfd, SHUT_RDWR);
return 0;
}
</code></pre>

<p>Thank you in advance for any help.</p>
"
"<pre><code>int file_write(struct m_inode * inode, struct file * filp, char * buf, int count){

off_t pos;
int block,c;
struct buffer_head * bh;
char * p;
int i=0;

.......

if (!(filp-&gt;f_flags &amp; O_APPEND)) {

    filp-&gt;f_pos = pos;
    inode-&gt;i_ctime = CURRENT_TIME;
}

}
</code></pre>

<p>I think:</p>

<pre><code>int file_write(struct m_inode * inode, struct file * filp, char * buf, int count){

off_t pos, tmp;
int block,c;
struct buffer_head * bh;
char * p;
int i=0;


if (filp-&gt;f_flags &amp; O_APPEND)
    pos = inode-&gt;i_size;
else
    pos = filp-&gt;f_pos;
    tmp = pos;

.......

if (!(filp-&gt;f_flags &amp; O_APPEND)) {

    filp-&gt;f_pos = tmp;
    inode-&gt;i_ctime = CURRENT_TIME;
}

}
</code></pre>

<p>otherwise  int the file_read filp->pos is error.
please Verify my ideas!
Thank you!</p>
"
"<p>I am making an ecosystem in C++ where <strong>every</strong> <code>ANIMAL</code> on my <code>playing_field</code> will <code>grow_older()</code> at the end of the year.</p>

<pre><code>class ANIMAL
{
private:
    int age;

public:

    ANIMAL()
    {
     age=0;
    }

    static void grow_older(){ age++; }
};
</code></pre>

<p>I know that <a href=""https://softwareengineering.stackexchange.com/questions/211137/why-can-static-methods-only-use-static-data"">static methods can only use static data</a>, but is there any elegant way to have something similar to an <code>ANIMAL.grow_older();</code>? I could iterate through my <code>playing_field</code> and call <code>grow_older();</code> on each animal, but I was hoping there is some concept out there that I'm not aware of that avoids iterating through every instance of <code>ANIMAL</code> explicitly.  </p>
"
"<p>What I want the code to do is:
printing ""Hello"",
waiting 2 seconds, and
printing ""world"".</p>

<p>What happens:
    Once I run the program, it waits two seconds, then prints ""helloWorld""</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main(void)
{

time_t current_time = 0; //A variable to save the time

printf(""Hello"");

current_time = clock();
//wating 2 seconds
for ( ; (clock() - current_time) &lt; (2 * CLOCKS_PER_SEC); );

printf(""Wolrd"");
return 0;
}
</code></pre>

<p>As if the wait command is before the two printing commands?!</p>
"
"<p>I am trying to make some code in c++ using some features of c++11. I am using vectors, lists and so on...</p>

<p>The contentious part of my code is being presented below:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
//#include &lt;Winbase.h&gt;

using namespace std;

// A struct describing a product.
typedef struct Products
{
    string category;
    string name;
    float price;
} Product;

inline void scenario1(int num_cashiers)
{
    vector&lt;Product&gt; products; // It is a vector(a pseudo-second dimension) of products which will be used for each customer
    vector&lt;vector&lt;Product&gt;&gt; customers; // A vector containing all customers
    vector&lt;vector&lt;vector&lt;Product&gt;&gt;&gt; cashiers(num_cashiers); // A vector describing the supermarket cashiers declaring a queue of customers for each cashier
    double start = GetTickCount(); // It will be used for counting 10 secs until next update
    vector&lt;int&gt; total_products(num_cashiers); // A vector keeping the total number of products of each queue
    list&lt;string&gt; categories; // A list containing all the categories of the products
list&lt;float&gt; categories_prices; // A list containing all category prices
map&lt;string,float&gt; statistics; // A map that keeps the statistical report of the supermarket. It keeps the name of each category and the total amount having been paid by customers for products of this category
string want_new_customers;
short number_new_customers;
short number_products;
string new_answer;
short pos_min_cashier;
string seeQueue;
int select_cashier;
string seeAvgTime;
string seeStatistics;

while (true)
{
    double current_time = GetTickCount() - start; // We are taking each and every second.

    // Update every 10 secs (=10000msecs)
    if (current_time &gt;= 10000) //
    {
        cout &lt;&lt; ""Would you like to add some customers?(Y or N)"" &lt;&lt; endl;
        cin &gt;&gt; want_new_customers;
        if (want_new_customers == ""Y"" || want_new_customers == ""y"")
        {
            cout &lt;&lt; ""How many customers would you like to add?"" &lt;&lt; endl;
            cin &gt;&gt; number_new_customers;
            customers.reserve(number_new_customers);
            for (int &amp;i : customers) //HERE IS THE FIRST LINE I AM GETTING THE ERROR
            {
                cout &lt;&lt; ""Give some necessary information about customer no. "" &lt;&lt; i &lt;&lt; endl;
                cout &lt;&lt; ""Give the number of products he/she bought"" &lt;&lt; endl;
                cin &gt;&gt; number_products;
                customers[i].reserve(number_products);
                Products products[number_new_customers][number_products];
                for (int &amp;j : products) //HERE IS THE SECOND ONE
                {
                    cout &lt;&lt; ""Give the category of the product no. "" &lt;&lt; j &lt;&lt; endl;
                    cin &gt;&gt; products[i][j].category;
                    cout &lt;&lt; ""Give the name of the product no. "" &lt;&lt; j &lt;&lt; endl;
                    cin &gt;&gt; products[i][j].name;
                    cout &lt;&lt; ""Give the price of the product no. "" &lt;&lt; j &lt;&lt; endl;
                    cin &gt;&gt; products[i][j].price;
                }
            }
        }//AND THE CODE GOES ON
</code></pre>

<p>I have to make clear that customers and products are vectors which have been declared beforehand. <strong>Also, the something name is 'std::vector' for the first line the error occurs and 'Products*'
for the second one.</strong></p>

<p>I am afraid of something being wrong with my for-loop method. I tried to do a for_each loop or a range for-loop in my way as far as I can understand. Something may be wrong with referencing of i through the size of the vector customers(of j through the size of products vector respectively).</p>

<p>What is wrong with my loops and how could I fix it?</p>
"
"<p>I am writing a C++ code and I am getting the above on the title mentioned error at some lines. I do not know why this is happening.</p>

<p><strong>CODE:</strong></p>

<pre><code>#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;
#include &lt;list&gt;
//#include &lt;Winbase.h&gt;

using namespace std;

// A struct describing a product.
typedef struct Products
{
    string category;
    string name;
    float price;
} Product;

inline void scenario1(int num_cashiers)
{
    vector&lt;Product&gt; products; // It is a vector(a pseudo-second dimension) of products which will be used for each customer
    vector&lt;vector&lt;Product&gt;&gt; customers; // A vector containing all customers
    vector&lt;vector&lt;vector&lt;Product&gt;&gt;&gt; cashiers; // A vector describing the supermarket cashiers declaring a queue of customers for each cashier
    cashiers.reserve(num_cashiers); // I create as many cashiers as the user wants.
    double start = GetTickCount(); // It will be used for counting 10 secs until next update
    vector&lt;int&gt; total_products(num_cashiers); // A vector keeping the total number of products of each queue
    list&lt;string&gt; categories; // A list containing all the categories of the products
    list&lt;float&gt; categories_prices; // A list containing all category prices
    map&lt;string,float&gt; statistics; // A map that keeps the statistical report of the supermarket. It keeps the name of each category and the total amount having been paid by customers for products of this category
    string want_new_customers;
    int number_new_customers;
    int number_products;
    string new_answer;
    int pos_min_cashier;
    string seeQueue;
    int select_cashier;
    string seeAvgTime;
    string seeStatistics;

    while (true)
    {
        double current_time = GetTickCount() - start; // We are taking each and every second.

        // Update every 10 secs (=10000msecs)
        if (current_time &gt;= 10000) //
        {
         ...



        // Creation of the list with the totally paid amount for each category by the customers
        //for (int &amp;i : categories_prices) categories_prices[i] = 0;
        for (int i = 0; i &lt; customers.size(); i++)
        {
            for (int j = 0; j &lt; products.size(); j++)
            {
                Products products[i][j];
                if (products[i][j].category == categories[i]) // HERE I AM GETTING THE ERROR
                    categories_prices = categories_prices + products[i][j].price; // HERE I AM GETTING AN NO MATCH FOR OPERATOR + ERROR
            }
        }

        // Statistical mapping
        for (int i = 0; i &lt; categories.size(); i++) statistics[categories[i]] = categories_prices[i]; // HERE I AM GETTING THE ERROR

         ...

  }
</code></pre>

<p>One thought crossed my mind was to create a function of the following form:</p>

<pre><code>int* operator[](int index)
{
   return arr[index]; // where arr could be the name of any vector of mine
}
</code></pre>

<p>So, was my thought correct? What should I change in my code?</p>

<p>How can I fix the errors I referred to?</p>

<p>Thank you in advance!</p>
"
"<p>My book is attempting to familiarize me with concepts such as pointer dereferencing concerning structures and some weird ways of accessing structures. I am a newbie, and find the following confusing about the code below.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
void dump_time_struct_bytes(struct tm *time_ptr, int size) {
    int i;
    unsigned char *raw_ptr;

    printf(""bytes of struct located at 0x%08x\n"", time_ptr);
    raw_ptr = (unsigned char *)time_ptr;
    for (i = 0; i &lt; size; i++)
    {
        printf(""%02x "", raw_ptr[i]);
        if (i % 16 == 15) // Print a newline every 16 bytes.
            printf(""\n"");
    }
    printf(""\n"");
}
int main() {

    long int seconds_since_epoch;
    struct tm current_time, *time_ptr;
    int hour, minute, second, i, *int_ptr;

    seconds_since_epoch = time(0); // Pass time a null pointer as argument.
    printf(""time() - seconds since epoch: %ld\n"", seconds_since_epoch);
    time_ptr = &amp;current_time; // Set time_ptr to the address of
                              // the current_time struct.
    localtime_r(&amp;seconds_since_epoch, time_ptr);

    // Three different ways to access struct elements:
    hour = current_time.tm_hour; // Direct access
    minute = time_ptr-&gt;tm_min; // Access via pointer
    second = *((int *)time_ptr); // Hacky pointer access
    printf(""Current time is: %02d:%02d:%02d\n"", hour, minute, second);
    dump_time_struct_bytes(time_ptr, sizeof(struct tm));

    minute = hour = 0; // Clear out minute and hour.

    int_ptr = (int *)time_ptr;
    for (i = 0; i &lt; 3; i++) {
        printf(""int_ptr @ 0x%08x : %d\n"", int_ptr, *int_ptr);
        int_ptr++; // Adding 1 to int_ptr adds 4 to the address,
    } // since an int is 4 bytes in size.
}
</code></pre>

<p>Output:</p>

<pre><code>time() - seconds since epoch: 1189311744
Current time is: 04:22:24
bytes of struct located at 0xbffff7f0
18 00 00 00 16 00 00 00 04 00 00 00 09 00 00 00
08 00 00 00 6b 00 00 00 00 00 00 00 fb 00 00 00
00 00 00 00 00 00 00 00 28 a0 04 08
int_ptr @ 0xbffff7f0 : 24
int_ptr @ 0xbffff7f4 : 22
int_ptr @ 0xbffff7f8 : 4
</code></pre>

<ol>
<li><p>i. I understand that the author has redeclared *time_ptr as a pointer to unsigned char, but how did it manage to become an array (character array, I think)? I think that this might be to do with the fact that arrays are interpreted as pointers which point to their 0th elements, but I am not sure.</p>

<p>ii. Secondly, what is the output from the dump_time_struct_bytes function (the dumped bytes)? I understand that thats the bytes from the structure, but I dont know how they are supposed to make up the 4 hours, 22 minutes and 24 seconds stored in it (if this is the case at all). Also, what does the address of *time_ptr correspond to? Is it the start of the structure? If the latter is true, do the corresponding dumped bytes in the output belong only to its first element (tm_sec) or to the whole structure ?</p></li>
<li><p>The explanation for the ""hacky pointer"" was a bit weird- why does dereferencing a converted integer pointer solely reveal the contents of the first element in the structure- tm_sec?</p></li>
</ol>

<p>Thank you in advance.</p>
"
"<p>I am developing a prototype of an algorithm that works on a set of nodes where each node maintains a connection to all other nodes and sends messages.</p>

<p>In order to send a message, the node sends it is fixed-size header first and then the data.</p>

<p>After a lot of work, I concluded that the problem is with the multi-threaded programming part of the code. Thus, I created this code as a PoC.</p>

<p>This prototype is designed to have one server with several clients of a number defined during compilation.</p>

<p>A server is in charge of listening to some clients each on a separate thread. Since this is just a prototype, we the drop the data.</p>

<p>Each client sends data into the server in two steps: Header then body using <code>send_message</code>.</p>

<p>By the way, this algorithm should produce data on a specific bandwidth benchmark from each client to the server. By default, each client sends 100Mb/s data to the server.</p>

<p>The code comprises:</p>

<h1>client.cpp:</h1>

<pre><code>#include ""network.h""

int main(int argc, char *argv[]){

    int sockfd;

    std::cout &lt;&lt; ""HEADER: "" &lt;&lt; HEADER &lt;&lt; std::endl;

    // Read the server's IP
    struct hostent *server = gethostbyname(argv[1]);

    // Read the arguments from console
    get_client_arguments (argc, argv);

    // Connect to the server
    sockfd = connect_to_server(server);

    sleep (1);

    // Start sending (Start the experiment)
    multi_unicaster (sockfd);

    close (sockfd);

    return 0;
}

/**********************************************/

void usage (char *argv){

    std::cout &lt;&lt; ""usage: "" &lt;&lt; argv &lt;&lt; "" hostname [-p port] [-t throughput]"" &lt;&lt; std::endl;
    exit(0);
}

/**********************************************/
</code></pre>

<h1>server.cpp:</h1>

<pre><code>#include ""network.h""

/**********************************************/

int main(int argc, char *argv[]){

    std::cout &lt;&lt; ""HEADER: "" &lt;&lt; HEADER &lt;&lt; std::endl;
    get_server_arguments(argc, argv);

    // Create several threads to listen for incoming connections
    // and read data from several clients simultaneously
    start_listening_threads ();

    return 0;
}

/**********************************************/

void usage (char *argv){

    std::cout &lt;&lt; ""usage: "" &lt;&lt; argv &lt;&lt; "" [-p port]"" &lt;&lt; std::endl;
    exit(0);
}

/**********************************************/
</code></pre>

<h1>message.h:</h1>

<pre><code>#ifndef __MESSAGE__
#define __MESSAGE__

#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;netdb.h&gt;
#include ""func.h""

/***************************************/

// The header structure
typedef struct {

    // Message ID
    unsigned mID;

    // IP of sender
    struct in_addr sender;

    // Message sie
    size_t datasize;

}header_type;

/***************************************/

#define HEADER sizeof(header_type)

/***************************************/

/*
 * Message Class
 */
class message
{
    private:
        // Message header
        header_type * header;

        // Message text
        byte * text;

    public:

        // Message Accessors, mutators and related functions
        byte * get_text();
        header_type * get_header();
        void set_datasize(size_t);
        size_t get_datasize();
        struct in_addr get_sender();
        void set_ID(unsigned);
        unsigned get_ID();
        void print();

        message(int,struct in_addr,size_t);
        message(header_type *, size_t);
        ~message();

        message &amp; operator = (const message&amp;);
        message(const message&amp;);
};
#endif


/***************************************/

extern std::queue &lt;message * &gt; sending_messages_queue;

/***************************************/
/*
 * Constructor used for initializing complete messages
 *
 */

message::message(int ID,struct in_addr IP,size_t d_s){

    header = (header_type *) malloc (HEADER);

    header -&gt; mID = ID;
    header -&gt; datasize = d_s;
    header -&gt; sender.s_addr = IP.s_addr;

    if (d_s &gt; 0){
        text = (byte *) malloc (d_s);
        memset (text, '.', d_s);
    }
    else text = NULL;
}

/***************************************/
/*
 * Copy constructor (Initialize)
 *
 */

message::message(const message&amp; other){

    header = (header_type *) malloc (HEADER);

    std::memcpy (header, other.header, HEADER);

    if (header -&gt; datasize &gt; 0){
        text = (byte *) malloc (header -&gt; datasize);
        std::memcpy (text, other.text, header -&gt; datasize);
    } else
        text = NULL;
}

/***************************************/
/*
 * destructor
 *
 * Message destructor
 */

message::~message() {
    if (text != NULL){
        free(text);
        text = NULL;
    }
}

/***************************************/
/*
 * Assignment operator (Update)
 *
 */

message &amp; message::operator = (const message&amp; other) {

    header = (header_type *) malloc (HEADER);

    std::memcpy (header, other.header, HEADER);

    if (header -&gt; datasize &gt;0){
        text = (byte *) malloc (header -&gt; datasize);
        std::memcpy (text, other.text, header -&gt; datasize);
    } else
        text = NULL;

    return *this;
}

/***************************************/

/*
* another constructor
*
*/

message::message(header_type *h, size_t s){

    header = (header_type *) malloc (HEADER);

    std::memcpy (header, h, HEADER);

    if (s &gt; 0){
        text = (byte *) malloc (s);
        std::memset (text, '.', s);
    } else
        text = NULL;
}

/***************************************/

/*
* get_header
*
* Header accessor
*/

header_type * message::get_header(){
    return header;
}

/***************************************/

/*
* get_text
*
* Text accessor
*/

byte * message::get_text(){
    return text;
}

/***************************************/

/*
* get_sender
*
* Sender IP accessor
*/

struct in_addr message::get_sender(){
    return header -&gt; sender;
}

/***************************************/

/*
* get_datasize
*
* datasize accessor
*/

size_t message::get_datasize(){
    return header -&gt; datasize;
}

/***************************************/

/*
* set_ID
*
* ID mutator
*/
void message::set_ID(unsigned ID) {
    header -&gt; mID = ID;
}

/***************************************/

/*
* get_ID
*
* ID Accessor
*/
unsigned message::get_ID() {
    return header -&gt; mID;
}

/***************************************/

/*
* set_datasize
*
* datasize mutator
*/
void message::set_datasize(size_t d) {
    header -&gt; datasize = d;
}

/***************************************/

/*
* print
*
*/
void message::print() {
    std::cout &lt;&lt; header -&gt; mID &lt;&lt; "","" &lt;&lt; inet_ntoa (header -&gt; sender)  &lt;&lt; "","" &lt;&lt; header -&gt; datasize;

    std::cout &lt;&lt; std::endl;
}

/***************************************/
</code></pre>

<h1>func.h:</h1>

<pre><code>// Some support functions

using namespace std;

/***********************************************************************/

#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;cstdlib&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;netdb.h&gt;
#include &lt;unistd.h&gt;
#include &lt;strings.h&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sys/time.h&gt;
#include &lt;math.h&gt;

/***********************************************************************/

typedef uint8_t byte;
const unsigned long kilo = 1024;
const unsigned long mega = 1024 * kilo;
const unsigned long giga = 1024 * mega;
const unsigned MESSAGE_SIZE = 10 * kilo;

/***********************************************************************/

int port = 4444;
int throughput = 100;
int newsockfd [CLIENTS];

/***********************************************************************/

void usage (char *argv);

/***********************************************************************/

/*
 *
 * subtract_time
 *
 * Subtracts time to handle negative values
 *
 */

struct timeval subtract_time (struct timeval * left_operand, struct timeval * right_operand){

    struct timeval res;

    if (left_operand -&gt; tv_sec &gt;= right_operand -&gt; tv_sec){
        if (left_operand -&gt; tv_usec &gt;= right_operand -&gt; tv_usec){

            res.tv_sec = left_operand -&gt; tv_sec - right_operand -&gt; tv_sec;
            res.tv_usec = left_operand -&gt; tv_usec - right_operand -&gt; tv_usec;
        }else{
            res.tv_sec = left_operand -&gt; tv_sec - right_operand -&gt; tv_sec - 1;
            res.tv_usec = 1000000 + left_operand -&gt; tv_usec - right_operand -&gt; tv_usec;
        }
    }

    return res;
}

/***********************************************************************/

void get_server_arguments (int argc, char *argv[]){

    int i = 1;
    while (i &lt; argc){

        if (strcmp (argv [i], ""-p"") ==0){

            port = atoi (argv [i + 1]);
            i+= 2;
        }
        else usage (argv [0]);
    }
}

/***********************************************************************/

void get_client_arguments (int argc, char *argv[]){

    int i = 2;

    while (i &lt; argc){

        if (strcmp (argv [i], ""-p"") ==0){

            port = atoi (argv [i + 1]);
            i+= 2;
        }

        else if (strcmp (argv [i], ""-t"") ==0){

            throughput = atoi (argv [i + 1]);
            i+= 2;
        }
        else usage (argv [0]);
    }
}

/***********************************************************************/

void print_bandwidth(unsigned long long sz){

    double size;

    if (sz &gt; giga){

        // Round result and show two decimal values
        size = round (sz / (giga /1000));
        std::cout &lt;&lt; size /1000 &lt;&lt; "" Gb/s""&lt;&lt; std::endl;
    }
    else if (sz &gt; mega){

        // Round result and show two decimal values
        size = round (sz / (mega /100));
        std::cout &lt;&lt; size /100 &lt;&lt; "" Mb/s""&lt;&lt; std::endl;
    }
    else if (sz &gt; kilo){

        // Round result and show one decimal value
        size = round (sz /( kilo /10));
        std::cout &lt;&lt; size /10 &lt;&lt; "" Kb/s""&lt;&lt; std::endl;
    }
    else{
        std::cout &lt;&lt; sz &lt;&lt; "" b/s""&lt;&lt; std::endl;
    }
}

/***********************************************************************/
</code></pre>

<h1>network.h:</h1>

<pre><code>// Network related functions

#include ""message.h""
#include &lt;netinet/tcp.h&gt;
#include &lt;arpa/inet.h&gt;

/***********************************************************************/

void read_message (int);
int accept_connection (int);
void * listening (void *);

/***********************************************************************/

unsigned burst_size;
bool NAGLE = false;
struct sockaddr_in serv_addr;
struct timeval recent_elapsed_time_val {0,0};
struct timeval start_tv;
int initial_listening_socket;
unsigned connections = 0;

/***********************************************************************/

void listen_for_connections (){

    // Server: Listens for connections from clients
    struct sockaddr_in serv_addr;

    initial_listening_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (initial_listening_socket &lt; 0)
        std::cerr &lt;&lt; ""ERROR opening socket"";
    bzero((char *) &amp;serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);
    serv_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(initial_listening_socket, (struct sockaddr *) &amp;serv_addr,sizeof(serv_addr)) &lt; 0)
        std::cerr &lt;&lt; ""ERROR on binding""&lt;&lt;std::endl;

    listen(initial_listening_socket,CLIENTS);
}

/***********************************************************************/

int accept_connection (){

    // Server: Accepts connections from client
    int newsockfd;
    socklen_t clilen;
    struct sockaddr_in cli_addr;

    clilen = sizeof(cli_addr);

    std::cout &lt;&lt; ""waiting for new connection .."" &lt;&lt; std::endl;
    newsockfd = accept(initial_listening_socket, (struct sockaddr *) &amp;cli_addr, &amp;clilen);

    std::cout &lt;&lt; ""received new connection .."" &lt;&lt; std::endl;

    connections ++;

    if (connections == CLIENTS)
        close(initial_listening_socket);

    return newsockfd;
}

/***********************************************************************/

int connect_to_server(struct hostent *server){

    // Client: Connects to server
    int sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sockfd &lt; 0)
        std::cerr &lt;&lt; ""ERROR opening socket"";

    if (server == NULL){
        std::cerr &lt;&lt; stderr &lt;&lt; ""ERROR, no such host""&lt;&lt; std::endl;
        exit(0);
    }

    int flag;
    if (NAGLE) flag = 0;
    else flag = 1;

    if (setsockopt (sockfd, IPPROTO_TCP, TCP_NODELAY, (char *) &amp;flag, sizeof(int)) ==-1){
        perror (""ERROR on setting TCP_NODELAY!"");
        std::terminate ();
    }

    bzero((char *) &amp;serv_addr, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    bcopy((char *)server-&gt;h_addr,(char *)&amp;serv_addr.sin_addr.s_addr,server-&gt;h_length);
    serv_addr.sin_port = htons(port);

    if (connect(sockfd,(struct sockaddr *)&amp;serv_addr,sizeof(serv_addr)) &lt; 0)
        std::cerr &lt;&lt;""ERROR connecting""&lt;&lt; std::endl;

    return sockfd;
}


/***********************************************************************/

void start_listening_threads (){

    // Server: Creates listening threads
    pthread_t listening_thread [CLIENTS];

    listen_for_connections ();

    for(unsigned i=0;i&lt; CLIENTS;i++){

        unsigned * arg = (unsigned *) malloc(sizeof(*arg));

        if ( arg == NULL ) {
            fprintf(stderr, ""Couldn't allocate memory for thread arg.\n"");
            exit(EXIT_FAILURE);
        }

        *arg = i;

        pthread_create(&amp;listening_thread[i], NULL,(void* (*)(void*))&amp;listening, arg);
    }

    for(unsigned i=0;i&lt; CLIENTS;i++){

        pthread_join (listening_thread[i], NULL);
    }
}

/***********************************************************************/

void * listening (void *a){

    // Server: Start listening after establishing a connection with the client
    int i = *((int *) a);

    newsockfd [i] = accept_connection ();

    while (1){

        read_message (newsockfd [i]);
    }

    return NULL;
}

/***********************************************************************/

void measure_throughput(unsigned counter){

    // Client: Tracks throughput and keeps on the wanted threshold
    struct timeval current_time;

    // Get the current time in order to track the throughput
    gettimeofday (&amp;current_time, NULL);
    struct timeval elapsed_time_val = subtract_time (&amp;current_time, &amp;start_tv);

    double elapsed = elapsed_time_val.tv_sec+ (elapsed_time_val.tv_usec/1000000.0);

    unsigned long long sent_bytes = counter * (MESSAGE_SIZE + HEADER);
    if (elapsed &gt; 0){

        // Calculate the expected time to send sent_bytes
        double theoretical_time = (sent_bytes) / ((throughput * mega) / 8.0);

        // Compare the expected time with the real elapsed time
        if (theoretical_time &gt; elapsed){
            __useconds_t additional_time = (theoretical_time - elapsed) * 1000000;
            usleep (additional_time);
        }
    }

    if (elapsed_time_val.tv_sec &gt; recent_elapsed_time_val.tv_sec){
        unsigned sending_throughput = (unsigned)((sent_bytes * 8) / (mega * elapsed * 1.0));
        std::cout &lt;&lt; ""throughput: "" &lt;&lt; sending_throughput &lt;&lt; std::endl;
        recent_elapsed_time_val = elapsed_time_val;
    }
}

/***********************************************************************/

void send_message (message * m, int sockfd){

    // Client: Send on message header then data.
    if (write (sockfd, m -&gt; get_header(), HEADER) == -1){

        perror (""Error exporting Header to socket"");
        close (sockfd);
        exit (1);
    }

    if (write (sockfd, m -&gt; get_text (), MESSAGE_SIZE) == -1){

        perror (""Error exporting Header to socket"");
        close (sockfd);
        exit (1);
    }
}

/***********************************************************************/

void read_message (int sockfd){

    // Server: Listens for one message header then text.
    int receivedPackage = 0;
    int pos = 0;
    int expected_bytes = HEADER;
    header_type header;

    while (expected_bytes &gt;0){

        if ((receivedPackage = read(sockfd, &amp;header + pos, expected_bytes)) &lt; 0){
            perror (""ERROR importing message header from socket!"");
            std::terminate();
        }
        pos += receivedPackage;
        expected_bytes -= receivedPackage;
    }

    if (header.datasize != MESSAGE_SIZE){
        message * m = new message (&amp;header, (size_t)0);
        m-&gt; print ();
    }

    pos = 0;
    receivedPackage = 0;
    expected_bytes = MESSAGE_SIZE;
    byte text [MESSAGE_SIZE];

    while (expected_bytes &gt;0){

        if ((receivedPackage = read(sockfd, text + pos, expected_bytes)) &lt; 0){
            perror (""ERROR importing message header from socket!"");
            std::terminate();
        }
        pos += receivedPackage;
        expected_bytes -= receivedPackage;
    }
}

/***********************************************************************/

void multi_unicaster (int sockfd){

    unsigned counter=0;

    gettimeofday (&amp;start_tv, NULL);

    while (1){

        counter ++;

        struct in_addr IP;

        inet_aton (""127.0.0.1"",&amp;IP);

        message * m = new message (counter, IP, MESSAGE_SIZE);

        if (m -&gt; get_datasize () != MESSAGE_SIZE)
            m-&gt; print ();

        send_message (m,sockfd);

        delete m;

        measure_throughput(counter);
    }
}

/***********************************************************************/
</code></pre>

<h1>Makefile:</h1>

<pre><code>all: server client

FLAGS=-Wall -Wextra -Werror -pedantic -pthread $(ARGS) -std=c++11 -g -rdynamic -lpthread
CXXFLAGS=$(DEF) $(FLAGS)

output/%.o: %.cpp
    g++ $(CXXFLAGS) -c -o $@ $&lt;

client: output/client.o
    g++ $(FLAGS) -o $@ $^

server: output/server.o
    g++ $(FLAGS) -o $@ $^

clean:
    rm -rf output/* *~ server client
</code></pre>

<p>When running the code on the loopback, everything goes right, however when testing it on apart servers (indeed, apart datacenters) sometimes it is working without any problem and others not.</p>

<p>If the received data is right, the received header should be right. To verify that the received data is not faulty, the <code>datasize</code> received in the header should be correct (i.e. 10 * kilo) otherwise the data is messed up.</p>

<p>This verification is provided in <code>read_message</code> function in <code>network.h</code> where I guess is the problem.</p>

<p>I provided all this code should somebody need to test it.</p>
"
"<p>I am making a synthesizer by piping data into aplay (I know it's not ideal) and the sound is lagging behind the keypresses which alter the sound. I believe this is because aplay is going at a constant 8000 Hz, but the c program is going at an unstable rate. How do I get the for loop to go at 8000 Hz in C?</p>
"
"<p>I'm using a code to save images from a camera, but I need to save the filename with the current date and time the image is taken. How can I do this? I have tried many different codes from the internet but I always get many errors and programming is not my strong side. Any advice or help will be appreciated. This is the code: <a href=""https://github.com/stereolabs/zed-save-depth/blob/master/src/main.cpp"" rel=""nofollow"">https://github.com/stereolabs/zed-save-depth/blob/master/src/main.cpp</a></p>
"
"<p>Is the following going to cause problems?</p>

<pre><code>my_func()
{
  char date_field[11];
  time_t current_time;

  time(&amp;current_time);

  sprintf(date_field, ""%0.3d%0.3d%.02d%0.2d\0"", current_time.tm_yday,
      current_time.tm_year, current_time.tm_hour, current_time.tm_min);

  ...
}
</code></pre>

<p>I realize that this <em>may</em> overrun the <code>date_field</code> buffer...  What I'm concerned about is the side effect of this occurring?  I.e.: a core dump?  How to trap/catch this kind of issue?</p>
"
"<p>Math isn't my strong skill. However, I need to simulate continuous time markov chain (CTMC) transition times for birth &amp; death process using C++.</p>

<p>I came across this <a href=""https://github.com/NathanEpstein/markov"" rel=""nofollow"">github project</a> which simulates regular CTMC, where the row sum of all lambda will be 1. But in case of birth-death process (M/M/c/K), it will be zero. So I can't exactly use it for my purpose.</p>

<p>Where can I find the algorithm to simulate M/M/c/K CTMC? I can code the algorithm if I find it. But I am unable to build out the algorithm by myself, the math goes above my head.</p>

<p>I need this simulation to send events to a M/M/c/K queue, using poisson distribution. That way I can figure out server (c) requirement under different arrival rates (lambda), while ensuring maximum server utilization.</p>
"
"<p>I have to extract DB to external DB server for licensed software.
DB has to be Postgres and I cannot change select query from application (cannot change source code).</p>

<p>Table (it has to be 1 table) holds around 6,5M rows and has unique values in main column (prefix).</p>

<p>All requests are read request, no inserts/update/delete, and there are ~200k selects/day with peaks of 15 TPS.</p>

<p>Select query is:</p>

<pre><code>SELECT prefix, changeprefix, deletelast, outgroup, tariff FROM table
WHERE '00436641997142' LIKE prefix
AND company = 0  and ((current_time between timefrom and timeto) or (timefrom is null and timeto is null)) and (strpos(""Day"", cast(to_char(now(), 'ID') as varchar)) &gt; 0  or ""Day"" is null )
ORDER BY position('%' in prefix) ASC, char_length(prefix) DESC
LIMIT 1;
</code></pre>

<p>Explain analyze shows following</p>

<pre><code>Limit  (cost=406433.75..406433.75 rows=1 width=113) (actual time=1721.360..1721.361 rows=1 loops=1)
  -&gt;  Sort  (cost=406433.75..406436.72 rows=1188 width=113) (actual time=1721.358..1721.358 rows=1 loops=1)
        Sort Key: (""position""((prefix)::text, '%'::text)), (char_length(prefix)) DESC
        Sort Method: quicksort  Memory: 25kB
        -&gt;  Seq Scan on table  (cost=0.00..406427.81 rows=1188 width=113) (actual time=1621.159..1721.345 rows=1 loops=1)
              Filter: ((company = 0) AND ('00381691997142'::text ~~ (prefix)::text) AND ((strpos((""Day"")::text, (to_char(now(), 'ID'::text))::text) &gt; 0) OR (""Day"" IS NULL)) AND (((('now'::cstring)::time with time zone &gt;= (timefrom)::time with time zone) AN (...)
              Rows Removed by Filter: 6417130
Planning time: 0.165 ms
Execution time: 1721.404 ms`
</code></pre>

<p>Slowest part of query is:</p>

<pre><code> SELECT prefix, changeprefix, deletelast, outgroup, tariff FROM table
 WHERE '00436641997142' LIKE prefix
</code></pre>

<p>which generates 1,6s (tested only this part of query)</p>

<p>Part of query tested separately:</p>

<pre><code>Seq Scan on table  (cost=0.00..181819.07 rows=32086 width=113) (actual time=1488.359..1580.607 rows=1 loops=1)
  Filter: ('004366491997142'::text ~~ (prefix)::text)
  Rows Removed by Filter: 6417130
Planning time: 0.061 ms
Execution time: 1580.637 ms
</code></pre>

<p>About data itself:
column ""prefix"" has identical first several digits (first 5) and rest are different, unique ones.</p>

<p>Postgres version is 9.5
I've changed following settings of Postgres:</p>

<pre><code>random-page-cost = 40
effective_cashe_size = 4GB
shared_buffer = 4GB
work_mem = 1GB
</code></pre>

<p>I have tried with several index types (unique, gin, gist, hash), but in all cases indexes are not used (as stated in explain above) and result speed is same.
I've also did, but no visible improvements:</p>

<pre><code>vacuum analyze verbose table
</code></pre>

<p>Please recommend settings of DB and/or index configuration in order to speed up execution time of this query.</p>

<p>Current HW is
i5, SSD, 16GB RAM on Win7, but I have option to buy stronger HW.
As I understood, for cases where read (no inserts/updates) is dominant, faster CPU cores are much more important than number of cores or disk speed > please, confirm.</p>

<p>Add-on 1:
After adding 9 indexes, index is not used also.</p>

<p>Add-on 2:
1) I found out reason for not using index: word order in query in part like is reason. if query would be:</p>

<pre><code>SELECT prefix, changeprefix, deletelast, outgroup, tariff FROM table WHERE prefix like '00436641997142%'
AND company = 0  and
((current_time between timefrom and timeto) or (timefrom is null and timeto is null)) and (strpos(""Day"", cast(to_char(now(), 'ID') as varchar)) &gt; 0  or ""Day"" is null )
 ORDER BY position('%' in prefix) ASC, char_length(prefix) DESC LIMIT 1
</code></pre>

<p>it uses index.</p>

<p>notice difference:</p>

<pre><code>... WHERE '00436641997142%' like prefix ...
</code></pre>

<p>query which uses index correctly:</p>

<pre><code>... WHERE prefix like '00436641997142%' ...
</code></pre>

<p>since I cannot change query itself, any idea how to overcome this? I can change data and Postgres settings, but not query itself.</p>

<p>2) Also, I intalled Postgres 9.6 version in order to use parallel seq.scan. In this case, parallel scan is used only if last part of query is ommited. So, query:</p>

<pre><code>SELECT prefix, changeprefix, deletelast, outgroup, tariff FROM table WHERE '00436641997142' LIKE prefix
AND company = 0  and
((current_time between timefrom and timeto) or (timefrom is null and timeto is null))
 ORDER BY position('%' in prefix) ASC, char_length(prefix) DESC LIMIT 1
</code></pre>

<p>uses parallel mode.</p>

<p>Any idea how to force original query (I cannot change query):</p>

<pre><code>SELECT prefix, changeprefix, deletelast, outgroup, tariff FROM erm_table WHERE '00436641997142' LIKE prefix
AND company = 0  and
((current_time between timefrom and timeto) or (timefrom is null and timeto is null)) and (strpos(""Day"", cast(to_char(now(), 'ID') as varchar)) &gt; 0  or ""Day"" is null )
 ORDER BY position('%' in prefix) ASC, char_length(prefix) DESC LIMIT 1
</code></pre>

<p>to use parallel seq. scan?</p>
"
"<p>I have a function like this:</p>

<pre><code>function time_elapsed_string($ptime)
{
            $date_time = strtotime(""1348-10-10 04:30:01"") + $ptime;
            $year = date(""Y"",$date_time);
            $month = date(""m"",$date_time);
            $day = date(""d"",$date_time);
            $time = date(""H:i:s"",$date_time);

    $etime = time() - $ptime + 1;

    $a = array( 31536000  =&gt;  'year',
                 2592000  =&gt;  'month',
                   86400  =&gt;  'day',
                    3600  =&gt;  'hour',
                      60  =&gt;  'minute',
                       1  =&gt;  'second'
                );

    foreach ($a as $secs =&gt; $str)
    {
        $d = $etime / $secs;
        if ($d &gt;= 1)
        {
            $r = round($d);
                                                                   // EX:
            return array('date' =&gt; $day.'-'.$month.'-'.$year,      // 2016-02-20
                         'time' =&gt; $time,                          // 03:30:04
                         'difference' =&gt; $r . ' ' . $str . ' ago'  // 2 month ago
                        );
        }
    }
}
</code></pre>

<p>And I use it like this:</p>

<pre><code>$ptime = 1470692661;
$html = '&lt;span title=""date: '.time_elapsed_string($ptime)['date'].' time: '.time_elapsed_string($ptime)['time'].'""&gt;in '.time_elapsed_string($ptime)['difference'].'&lt;span&gt;';
</code></pre>

<p>As you see, I'm using of that function's result like this:</p>

<pre><code>time_elapsed_string($ptime)['date']
ime_elapsed_string($ptime)['time']
time_elapsed_string($ptime)['difference']
</code></pre>

<p>In fact I'm calling that function every time I need one of its results. Is that right? Or should I call it once and store it into an array?</p>

<p><strong>Note:</strong> My code works as well.</p>
"
"<p>Hoping someone can help me work out what on earth is happening here.</p>

<p>I've got a script which receives a date as a parameter in this format ""2016-09-01 00:00:00"" and should create another variable containing the date for one day in the future, code is below</p>

<pre><code>    currentDate=$1
    currentDate=$(date +""%Y-%m-%d %H:%M:%S"" -d ""$currentDate"")
    nextDate=$(date +""%Y-%m-%d %H:%M:%S"" -d ""$currentDate + 1 day"")
    echo $currentDate
    echo $nextDate
</code></pre>

<p>Sometimes this works perfectly fine for example</p>

<p>2016-09-01 00:00:00 - date given as parameter</p>

<p>2016-09-02 00:00:00 - output for next day</p>

<p>But sometimes it'll only add 23 hours depending on the date provided</p>

<p>2016-02-01 00:00:00 - date given as parameter</p>

<p>2016-02-01 23:00:00 - output for next day</p>

<p>if I change the nextDay variable to add three days as below</p>

<pre><code>     nextDate=$(date +""%Y-%m-%d %H:%M:%S"" -d ""$currentDate + 3 day"")
</code></pre>

<p>it gives the output as below adding only 21 hours instead of 3 days</p>

<p>2016-02-01 00:00:00 - date given as parameter</p>

<p>2016-02-01 21:00:00 - output for next day</p>

<p>Could someone help me understand why this is happening, is it related to timezones?</p>
"
"<p>Im having a problem with glutKeyboardUpFunc. Everytime I press a key and don't release it, the callback of glutKeyboardUpFunc stills gets called, the longer I hold the key the more times the callback executes. </p>

<p>Here is a quick example I put up:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;float.h&gt;
#include &lt;time.h&gt;
#include &lt;GL/glut.h&gt;


#define DEBUG 1

/* VARI?VEIS GLOBAIS */

typedef struct {
    GLboolean doubleBuffer;
    GLint delay;
} Estado;

typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat height;
    GLfloat width;
    GLfloat y_accelaration;
} Plataforma;


//save stage coordinates
typedef struct {
    GLfloat top;
    GLfloat bottom;
    GLfloat right;
    GLfloat left;
} Screen;

Estado estado;
Screen ecra;
Plataforma plataforma;


GLfloat tab_speed = 2.0 / 20.0;
GLfloat y_accelaration = 0.001;

void Init(void) {

    struct tm *current_time;
    time_t timer = time(0);

    estado.delay = 42;
    estado.doubleBuffer = GL_TRUE;

    plataforma.height = 0.3;
    plataforma.width = 0.05;

    plataforma.y_accelaration = 0;

    plataforma.y = 0;


    // L? hora do Sistema
    current_time = localtime(&amp;timer);

    glClearColor(0.3, 0.3, 0.3, 0.0);

    glEnable(GL_POINT_SMOOTH);
    glEnable(GL_LINE_SMOOTH);
    glEnable(GL_POLYGON_SMOOTH);

}

void Reshape(int width, int height) {
    GLint size;
    GLfloat ratio = (GLfloat) width / height;
    GLfloat ratio1 = (GLfloat) height / width;

    if (width &lt; height)
        size = width;
    else
        size = height;


    glViewport(0, 0, width, height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    if (width &lt; height) {
        ecra.left = -1;
        ecra.right = 1;
        ecra.bottom = -1 * ratio1;
        ecra.top = 1 * ratio1;
        gluOrtho2D(-1, 1, -1 * ratio1, 1 * ratio1);
    } else {
        ecra.left = -1 * ratio;
        ecra.right = 1 * ratio;
        ecra.bottom = -1;
        ecra.top = 1;
        gluOrtho2D(-1 * ratio, 1 * ratio, -1, 1);
    }

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

void desenhar_plataforma(Plataforma pf) {
    glColor3f(1.0f, 0.0f, 0.0f);
    glBegin(GL_POLYGON);



    glVertex2f(pf.x - pf.width / 2, pf.y - pf.height / 2);
    glVertex2f(pf.x + pf.width / 2, pf.y - pf.height / 2);
    glVertex2f(pf.x + pf.width / 2, pf.y + pf.height / 2);
    glVertex2f(pf.x - pf.width / 2, pf.y + pf.height / 2);
    glEnd();
}


void Draw(void) {
    glClear(GL_COLOR_BUFFER_BIT);
    plataforma.x = ecra.left + 0.1;
    desenhar_plataforma(plataforma);
    glFlush();
    if (estado.doubleBuffer)
        glutSwapBuffers();
}


void Key(unsigned char key, int x, int y) {
    switch (key) {

        case 'a':
            plataforma.y += tab_speed;
            glutPostRedisplay();
            break;
        case 's':
            plataforma.y -= tab_speed;
            glutPostRedisplay();
            break;
    }
}

void KeyUp(unsigned char key, int x, int y) {

    if (DEBUG)
        printf(""Key Up %c\n"", key);
}

int main(int argc, char **argv) {
    estado.doubleBuffer = GL_TRUE;

    glutInit(&amp;argc, argv);
    glutInitWindowPosition(0, 0);
    glutInitWindowSize(800, 600);
    glutInitDisplayMode(((estado.doubleBuffer) ? GLUT_DOUBLE : GLUT_SINGLE) | GLUT_RGB);
    if (glutCreateWindow(""No Man's Pong"") == GL_FALSE)
        exit(1);

    Init();

    glutReshapeFunc(Reshape);
    glutDisplayFunc(Draw);

    // Callbacks de teclado
    glutKeyboardFunc(Key);
    glutKeyboardUpFunc(KeyUp);

    glutMainLoop();
    return 0;
}
</code></pre>

<p>Here's the ouput when pressing 'a':</p>

<pre><code>Key Up a
Key Up a
Key Up a
Key Up a
Key Up a
Key Up a
Key Up a
......
</code></pre>

<p>Needless to say im not releasing 'a'.</p>

<p>Im using linux mint 17.3 and g++, shutting off key repeat or setting glutIgnoreKeyRepeat(true), stops this issue, but also makes glutKeyboardFunc execute only once per key press, and I realy don't want that.</p>

<p>Does anyone know how to fix this, or whats causing this?</p>

<p>I also compiled the same code under windows 8.1 and the keyUp only fires when there's an actual key release.</p>
"
"<p>I have been trying to get the current date in C++ for a while now and I cannot figure out what I am doing wrong. I have looked at several sites and all of the solutions that I implement I get an error that says, ?This function or variable may be unsafe. Consider using localtime_s instead.? I tried several of the solutions found <a href=""https://stackoverflow.com/questions/997946/how-to-get-current-time-and-date-in-c"">here</a> (including the one below) but I could not get any of them to work. What am I doing wrong?</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;ctime&gt;

using namespace std;

int main()
{

    const int SALARY = 18;
    const int COMMISSION = .08;
    const int BONUS = .03;

    int monthlySales;
    int appointmentNumber;

    time_t t = time(0);   // get time now
    struct tm * now = localtime(&amp;t);

    string name;


//this is where the user adds their name and date
    cout &lt;&lt; ""Please enter the sales representative's name: "";
    cin &gt;&gt; name;
    cout &lt;&lt; ""Please enter the number of appointments: "";
    cin &gt;&gt; appointmentNumber;
    cout &lt;&lt; ""Please enter the amount of sales for the month: $"";
    cin &gt;&gt; monthlySales;

//clear screen and execute code
    system(""cls"");

    cout &lt;&lt; setfill(' ');
    cout &lt;&lt; ""Sales Representative:"" &lt;&lt; name &lt;&lt; endl;
    cout &lt;&lt; ""Pay Date:"" &lt;&lt; (now-&gt;tm_mon + 1) &lt;&lt; "" "" &lt;&lt; now-&gt;tm_mday &lt;&lt; "" "" &lt;&lt; (now-&gt;tm_year + 1900) &lt;&lt; endl;
    cout &lt;&lt; ""Work Count:"" &lt;&lt; appointmentNumber &lt;&lt; ""Sale Amount""
        &lt;&lt; monthlySales &lt;&lt; endl;

        system(""pause"");

    return 0;
}
</code></pre>
"
"<p>Ok, i'm not a coder, I need to make a little php tweak on a line of code and have spent many hours trying to figure out how to do it. There are many tutorials about time format in php but I can't find the answer to my necessity.</p>

<p>I have this line of code in an application:</p>

<pre><code>&lt;span class=""muted""&gt;Expires in &lt;?=(now() &gt; $l-&gt;list_expires) ? 'Closed' : timespan(now(),$l-&gt;list_expires)?&gt;&lt;/span&gt;
</code></pre>

<p>I discovered that 'list_expires' is a mysql column with a unix time date in the future, i.e. 1479350850.
The code calculates the time from now to the future date and outputs the result like this:
Coija.com Expires in 4 Weeks, 1 Day, 21 Hours, 30 Minutes</p>

<p>What I want is to display the result in a shorter manner, like say, 'Expires in 29 days' and if it is less that one day, 'Expires in 13 hours' or 'Expires in 10 minutes'. Another option would be '29 days left'.</p>

<p>I know the first part checks if the time expired and outputs 'closed', but right now, if it is closed the output is: 'Expired in closed'.
How can I not show 'Expired' if 'closed' must be shown?</p>

<p>Any help would be greatly appreciated.
Thank you</p>
"
"<p>I use gsoap to implement some Web-service in my C program.</p>

<p>I use gsoap like this:</p>

<pre><code>int motion_detector_check_status(const char *endpoint,
        const motion_detector_subscription_result_t *sr, int *status) {
    int rc = EXIT_SUCCESS;
    double _timeout = difftime(sr-&gt;termination_time, sr-&gt;current_time);
    char timeout[TIMEOUT_MAX_LEN];
    struct soap *soap = soap_new();
    struct _tev__PullMessages request;
    struct _tev__PullMessagesResponse response;
    char *motion_state;

    if (!soap) return EXIT_FAILURE;

    snprintf(timeout, TIMEOUT_MAX_LEN, ""PT%.0fS"", _timeout &lt; 5.0 ? _timeout : 5.0);

    request.MessageLimit = 1;
    request.Timeout = _timeout &lt; 5.0 ? (int64_t)_timeout : 5.0;
    request.__any = timeout;
    request.__size = sizeof(timeout) + 1;

    rc = soap_call___tev__PullMessages(soap, endpoint, SOAP_ACTION_PULL_MESSAGE,
            &amp;request, &amp;response);

    if (rc != SOAP_OK) {
        soap_print_fault(soap, stderr);
        goto end;
    }

    if (response.wsnt__NotificationMessage &amp;&amp;
            response.wsnt__NotificationMessage-&gt;Topic &amp;&amp;
            response.wsnt__NotificationMessage-&gt;Topic-&gt;__any) {
        if (strstr(response.wsnt__NotificationMessage-&gt;Topic-&gt;__any, MOTION_ALARM_SRC)) {
            motion_state = strstr(response.wsnt__NotificationMessage-&gt;Message.__any,
                    ""&lt;tt:SimpleItem Name=\""State\"" Value="");

            if (strcasestr(motion_state, ""true""))
                *status = 1;
            else
                *status = 0;
        }
    }

    motion_detector_check_status_free_response(&amp;response);
end:
    soap_end(soap);
    soap_destroy(soap);
    soap_free(soap);
    return rc;
}
</code></pre>

<p>Everything works well, but <code>struct _tev__PullMessagesResponse</code> has some pointers to char and other structures.</p>

<p>When I run my program in <code>valgring</code> it told me that I have memory leaks and resources referenced through pointers inside <code>response</code> aren't free after end of <code>motion_detector_check_status</code>. Of course I could write this functions by myself, but I'm wonder does gsoap provides functions to free this resources?</p>

<p>Thanks in advance, and sorry for my English.</p>
"
"<p>Let's say the user is prompted for the date - e.g. <em>Friday</em>.
How can that string be used to correctly compare with another sting?</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main(void)
{

time_t current_time;
struct tm * time_info;
char timeString[9];
time(&amp;current_time);
time_info = localtime(&amp;current_time);

strftime(timeString, sizeof(timeString), ""%A"", time_info);
printf(""%s\n"",timeString);

if (timeString == ""Friday"")
    {printf(""Weekday"");

    }
else
    {printf(""not weekday"");
    }


return 0;
}
</code></pre>

<p>The program keeps printing out <em>not weekday</em>.</p>
"
"<p>I am trying to get my tokens on a board game to fall slowly. Right now, they fall, but they fall so fast. How could I implement the timer function in my code? Right now I do a loop, that updates the y coordinate of glTranslate. But it is still too fast! the top y is the y coordinate where I press on the screen, and the bottomy is the coordinates of the lowest open spot for a token. </p>

<pre><code>col =0;

double bottomy = 0;
int row = 0;

circlex = (double)x / width ;
circley = (double)y / height ;

row = board.getRow(col) + 1;
bottomy = 500 - (25*row);

for( double topy = y ; topy &lt;= bottomy; topy += 2 ){
    glTranslatef(circlex, circley, 0.0f);
    circley += .0000000000000000001;
    display();
}

r = board.makeMove(col);
</code></pre>
"
"<p>I am running PG 9.6.1 both in production (Linux) and dev (Mac)</p>

<p>I am testing an identical query in both development and production. In development I've tested on multiple snapshots of the production db (only minutes apart).</p>

<p>For some reason, the same exact query gives substantially different query plans, the the plan resulting in production has terrible performance.</p>

<p>When I perform the following query</p>

<pre><code>SELECT DISTINCT ON (v0.""email"") v0.""id""
  ,v0.""first_seen"" ,v0.""last_seen"" ,v0.""last_heard_from"" ,v0.""last_contacted"" ,v0.""last_page_viewed"" ,v0.""sessions"" ,v0.""seen_welcome_message"" ,v0.""signed_up_at"" ,v0.""referrer"" ,v0.""unsubscribed"" ,v0.""merged"" ,v0.""marked_at"" ,v0.""first_name"" ,v0.""last_name"" ,v0.""email"" ,v0.""slug"" ,v0.""name"" ,v0.""type"" ,v0.""avatar"" ,v0.""user_id"" ,v0.""location"" ,v0.""app_id"" ,v0.""actor_id"" ,v0.""marked_by_id"" ,v0.""inserted_at"" ,v0.""updated_at""
FROM ""visitors"" AS v0
INNER JOIN ""auto_messages"" AS a1 ON (a1.""app_id"" = v0.""app_id"")
  AND (a1.""id"" = $1)
INNER JOIN LATERAL(SELECT * FROM find_matching_visitors(a1.""app_id"", a1.""formatted_default_filters"", a1.""formatted_custom_filters"")) AS f2 ON f2.""id"" = v0.""id""
WHERE (
    CASE
      WHEN a1.""window_enabled""
        THEN extract(dow FROM current_timestamp at TIME zone COALESCE((v0.""location"" - &gt;&gt; 'timezone'), 'Europe/Paris')) = ANY (a1.""window_days_of_week""::INT [])
          AND CURRENT_TIME at TIME zone COALESCE((v0.""location"" - &gt;&gt; 'timezone'), 'Europe/Paris') BETWEEN a1.""window_start""
            AND a1.""window_end""
      ELSE true
      END
    )
  AND (
    NOT EXISTS (
      SELECT *
      FROM auto_message_events
      WHERE auto_message_id = a1.""id""
        AND (
          visitor_id = v0.""id""
          OR visitor_user_id = v0.""user_id""
          OR visitor_email = v0.""email""
          )
        AND event = 'sent'
      )
    )
  AND ((v0.""type"" = 'user') OR (v0.""type"" = 'lead'))
  AND (NOT (v0.""merged""))
  AND (v0.""marked_at"" IS NULL)
  AND (NOT (v0.""email"" IS NULL) AND NOT (v0.""unsubscribed""))
  AND ((a1.""status"" = $2) AND (a1.""channel"" = $3))
GROUP BY v0.""id""
ORDER BY v0.""email""
  ,v0.""last_seen"" DESC LIMIT $4 [446, ""live"", ""email"", 500]
</code></pre>

<p>In <strong>production</strong> I get the following query plan</p>

<pre><code> Limit  (cost=1085.72..1085.73 rows=1 width=1070) (actual time=16862.966..16862.966 rows=0 loops=1)
.16862.964 rows=0 loops=1)72..1085.73 rows=1 width=1070) (actual time=16862.964.--More--
         -&gt;  Sort  (cost=1085.72..1085.73 rows=1 width=1070) (actual time=16862.963..16862.963 rows=0 loops=1)
               Sort Key: v0.email, v0.last_seen DESC
               Sort Method: quicksort  Memory: 25kB
               -&gt;  Group  (cost=1085.71..1085.71 rows=1 width=1070) (actual time=16862.946..16862.946 rows=0 loops=1)
                     Group Key: v0.id
                     -&gt;  Sort  (cost=1085.71..1085.71 rows=1 width=1070) (actual time=16862.936..16862.936 rows=0 loops=1)
                           Sort Key: v0.id
                           Sort Method: quicksort  Memory: 25kB
                           -&gt;  Nested Loop Anti Join  (cost=890.31..1085.70 rows=1 width=1070) (actual time=16862.922..16862.922 rows=0 loops=1)
                                 Join Filter: (auto_message_events.auto_message_id = a1.id)
                                 -&gt;  Nested Loop  (cost=885.54..1072.87 rows=1 width=1074) (actual time=46.013..16856.367 rows=107 loops=1)
                                       Join Filter: ((v0.id)::text = (find_matching_visitors.id)::text)
                                       Rows Removed by Join Filter: 112824
                                       -&gt;  Nested Loop  (cost=885.29..1050.12 rows=1 width=1162) (actual time=4.020..14.710 rows=949 loops=1)
                                             -&gt;  Index Scan using auto_messages_pkey on auto_messages a1  (cost=0.27..8.30 rows=1 width=122) (actual time=0.019..0.021 rows=1 loops=1)
                                                   Index Cond: (id = 435)
                                                   Filter: (((status)::text = 'live'::text) AND ((channel)::text = 'email'::text))
                                             -&gt;  Bitmap Heap Scan on visitors v0  (cost=885.02..1041.81 rows=1 width=1070) (actual time=3.995..13.180 rows=949 loops=1)
                                                   Recheck Cond: ((email IS NOT NULL) AND ((app_id)::text = (a1.app_id)::text))
                                                   Filter: ((NOT merged) AND (marked_at IS NULL) AND (NOT unsubscribed) AND (((type)::text = 'user'::text) OR ((type)::text = 'lead'::text)) AND CASE WHEN a1.window_enabled THEN ((date_part('dow'::text, timezone(COALESCE((location -&gt;&gt; 'timezone'::text), 'Europe/Paris'::text), now())) = ANY ((a1.window_days_of_week)::double precision[])) AND (timezone(COALESCE((location -&gt;&gt; 'timezone'::text), 'Europe/Paris'::text), ('now'::cstring)::time with time zone) &gt;= (a1.window_start)::time with time zone) AND (timezone(COALESCE((location -&gt;&gt; 'timezone'::text), 'Europe/Paris'::text), ('now'::cstring)::time with time zone) &lt;= (a1.window_end)::time with time zone)) ELSE true END)
                                                   Rows Removed by Filter: 56
                                                   Heap Blocks: exact=624
                                                   -&gt;  BitmapAnd  (cost=885.02..885.02 rows=39 width=0) (actual time=3.874..3.874 rows=0 loops=1)
                                                         -&gt;  Bitmap Index Scan on email_idx  (cost=0.00..284.01 rows=6344 width=0) (actual time=2.161..2.161 rows=9749 loops=1)
                                                               Index Cond: (email IS NOT NULL)
                                                         -&gt;  Bitmap Index Scan on visitors_app_id_signed_up_index  (cost=0.00..600.68 rows=6950 width=0) (actual time=1.086..1.086 rows=4502 loops=1)
                                                               Index Cond: ((app_id)::text = (a1.app_id)::text)
                                       -&gt;  Function Scan on find_matching_visitors  (cost=0.25..10.25 rows=1000 width=32) (actual time=17.681..17.706 rows=119 loops=949)
                                 -&gt;  Bitmap Heap Scan on auto_message_events  (cost=4.77..8.79 rows=1 width=74) (actual time=0.051..0.051 rows=1 loops=107)
                                       Recheck Cond: (((auto_message_id = 435) AND ((visitor_id)::text = (v0.id)::text) AND ((event)::text = 'sent'::text)) OR ((auto_message_id = 435) AND ((event)::text = 'sent'::text) AND ((visitor_user_id)::text = (v0.user_id)::text)) OR ((auto_message_id = 435) AND ((event)::text = 'sent'::text) AND ((visitor_email)::text = (v0.email)::text)))
                                       Heap Blocks: exact=107
                                       -&gt;  BitmapOr  (cost=4.77..4.77 rows=1 width=0) (actual time=0.044..0.044 rows=0 loops=107)
                                             -&gt;  Bitmap Index Scan on auto_message_events_auto_message_id_visitor_id_event_index  (cost=0.00..3.56 rows=1 width=0) (actual time=0.019..0.019 rows=1 loops=107)
                                                   Index Cond: ((auto_message_id = 435) AND ((visitor_id)::text = (v0.id)::text) AND ((event)::text = 'sent'::text))
                                             -&gt;  Bitmap Index Scan on auto_message_id_event_visitor_user_id_idx  (cost=0.00..0.59 rows=1 width=0) (actual time=0.008..0.008 rows=1 loops=107)
                                                   Index Cond: ((auto_message_id = 435) AND ((event)::text = 'sent'::text) AND ((visitor_user_id)::text = (v0.user_id)::text))
                                             -&gt;  Bitmap Index Scan on auto_message_id_event_visitor_email_idx  (cost=0.00..0.62 rows=1 width=0) (actual time=0.008..0.008 rows=1 loops=107)
                                                   Index Cond: ((auto_message_id = 435) AND ((event)::text = 'sent'::text) AND ((visitor_email)::text = (v0.email)::text))
 Planning time: 2.566 ms
 Execution time: 16863.358 ms
</code></pre>

<p>The exact same query running in <strong>development</strong> (production db snapshot)</p>

<pre><code>    Limit  (cost=417.94..417.95 rows=1 width=2096) (actual time=90.445..90.445 rows=0 loops=1)
   -&gt;  Unique  (cost=417.94..417.95 rows=1 width=2096) (actual time=90.444..90.444 rows=0 loops=1)
         -&gt;  Sort  (cost=417.94..417.95 rows=1 width=2096) (actual time=90.443..90.443 rows=0 loops=1)
               Sort Key: v0.email, v0.last_seen DESC
               Sort Method: quicksort  Memory: 25kB
               -&gt;  Group  (cost=417.92..417.93 rows=1 width=2096) (actual time=90.435..90.435 rows=0 loops=1)
                     Group Key: v0.id
                     -&gt;  Sort  (cost=417.92..417.93 rows=1 width=2096) (actual time=90.435..90.435 rows=0 loops=1)
                           Sort Key: v0.id
                            Sort Method: quicksort  Memory: 25kB
                            -&gt;  Nested Loop Anti Join  (cost=388.06..417.91 rows=1 width=2096) (actual time=90.430..90.430 rows=0 loops=1)
                                  Join Filter: (auto_message_events.auto_message_id = a1.id)
                                  -&gt;  Nested Loop  (cost=375.05..396.85 rows=1 width=2100) (actual time=87.181..87.341 rows=76 loops=1)
                                        -&gt;  Index Scan using auto_messages_pkey on auto_messages a1  (cost=0.28..8.30 rows=1 width=120) (actual time=0.015..0.017 rows=1 loops=1)
                                              Index Cond: (id = 435)
                                              Filter: (((status)::text = 'live'::text) AND ((channel)::text = 'email'::text))
                                        -&gt;  Hash Join  (cost=374.78..388.54 rows=1 width=2096) (actual time=87.163..87.292 rows=76 loops=1)
                                              Hash Cond: ((find_matching_visitors.id)::text = (v0.id)::text)
                                              -&gt;  Function Scan on find_matching_visitors  (cost=0.25..10.25 rows=1000 width=32) (actual time=79.139..79.151 rows=81 loops=1)
                                              -&gt;  Hash  (cost=374.52..374.52 rows=1 width=2096) (actual time=8.008..8.008 rows=911 loops=1)
                                                    Buckets: 1024  Batches: 1  Memory Usage: 468kB
                                                    -&gt;  Bitmap Heap Scan on visitors v0  (cost=230.95..374.52 rows=1 width=2096) (actual time=5.024..6.986 rows=911 loops=1)
                                                          Recheck Cond: (((app_id)::text = (a1.app_id)::text) AND (email IS NOT NULL))
                                                          Filter: ((NOT merged) AND (marked_at IS NULL) AND (NOT unsubscribed) AND (((type)::text = 'user'::text) OR ((type)::text = 'lead'::text)) AND CASE WHEN a1.window_enabled THEN ((date_part('dow'::text, timezone(COALESCE((location -&gt;&gt; 'timezone'::text), 'Europe/Paris'::text), now())) = ANY ((a1.window_days_of_week)::double precision[])) AND (timezone(COALESCE((location -&gt;&gt; 'timezone'::text), 'Europe/Paris'::text), ('now'::cstring)::time with time zone) &gt;= (a1.window_start)::time with time zone) AND (timezone(COALESCE((location -&gt;&gt; 'timezone'::text), 'Europe/Paris'::text), ('now'::cstring)::time with time zone) &lt;= (a1.window_end)::time with time zone)) ELSE true END)
                                                          Rows Removed by Filter: 43
                                                          Heap Blocks: exact=1094
                                                          -&gt;  BitmapAnd  (cost=230.95..230.95 rows=36 width=0) (actual time=4.804..4.804 rows=0 loops=1)
                                                                -&gt;  Bitmap Index Scan on visitors_app_id_signed_up_index  (cost=0.00..101.44 rows=2802 width=0) (actual time=1.044..1.044 rows=4670 loops=1)
                                                                      Index Cond: ((app_id)::text = (a1.app_id)::text)
                                                                -&gt;  Bitmap Index Scan on email_idx  (cost=0.00..129.26 rows=6512 width=0) (actual time=3.313..3.313 rows=20201 loops=1)
                                                                      Index Cond: (email IS NOT NULL)
                                  -&gt;  Bitmap Heap Scan on auto_message_events  (cost=13.01..17.03 rows=1 width=73) (actual time=0.039..0.039 rows=1 loops=76)
                                        Recheck Cond: (((auto_message_id = 435) AND ((visitor_id)::text = (v0.id)::text) AND ((event)::text = 'sent'::text)) OR ((auto_message_id = 435) AND ((event)::text = 'sent'::text) AND ((visitor_user_id)::text = (v0.user_id)::text)) OR ((auto_message_id = 435) AND ((event)::text = 'sent'::text) AND ((visitor_email)::text = (v0.email)::text)))
                                        Heap Blocks: exact=76
                                        -&gt;  BitmapOr  (cost=13.01..13.01 rows=1 width=0) (actual time=0.037..0.037 rows=0 loops=76)
                                              -&gt;  Bitmap Index Scan on auto_message_events_auto_message_id_visitor_id_event_index  (cost=0.00..4.43 rows=1 width=0) (actual time=0.011..0.011 rows=1 loops=76)
                                                    Index Cond: ((auto_message_id = 435) AND ((visitor_id)::text = (v0.id)::text) AND ((event)::text = 'sent'::text))
                                              -&gt;  Bitmap Index Scan on auto_message_id_event_visitor_user_id_idx  (cost=0.00..4.29 rows=1 width=0) (actual time=0.011..0.011 rows=1 loops=76)
                                                    Index Cond: ((auto_message_id = 435) AND ((event)::text = 'sent'::text) AND ((visitor_user_id)::text = (v0.user_id)::text))
                                              -&gt;  Bitmap Index Scan on auto_message_id_event_visitor_email_idx  (cost=0.00..4.29 rows=1 width=0) (actual time=0.014..0.014 rows=0 loops=76)
                                                    Index Cond: ((auto_message_id = 435) AND ((event)::text = 'sent'::text) AND ((visitor_email)::text = (v0.email)::text))
  Planning time: 2.848 ms
  Execution time: 90.722 ms
</code></pre>

<p><strong>UPDATE</strong></p>

<p>It turns out that removing the expression <code>(NOT (v0.""email"" IS NULL)</code> from the query in production, the performance corrects itself.</p>

<p>Any ideas as to why? (the field is indexed)</p>
"
"<p>I have a program that is very time critical and I want to measure the time it takes to execute the program. Here is a simple schematic of the code.</p>

<pre><code>clock1=current_time();
instruction 1;
instruction 2;
.
.
.
.
instruction n;
clock2=current_time();
total time = clock2-clock1;
</code></pre>

<p>When I am using GCC to compile the above code with -O2 or -O3 option it always moves clock2=current_time() in the middle of the instructions. Hence giving wrong results.
Is there any way to restrict gcc not to rearrange this part of the code while optimizing all other parts of the code?
Some requirements,The routine to measure time is unchangeable. I have to use the routine provided.
Thank you for your help.
Regards.</p>

<p>Update : with breakpoints</p>

<pre><code>clock1=0;clock2=0;
clock1=current_time();
breakpoint 1 : instruction 1; // clock1=&lt;value&gt; clock2=0
instruction 2;
.
.
.
.
breakpoint 2 : instruction n;// clock1=&lt;value&gt; clock2=&lt;value&gt;
clock2=current_time();
total time = clock2-clock1;
breakpoint 3:// clock1=&lt;value&gt; clock2=&lt;value&gt; total time=clock2-clock1;
</code></pre>
"
"<p>I am trying to write a program which will process a video file and will handle a timer along with it. Every video file has a <code>.txt</code> file next to it, including the time when the video was shot (like 13:43:21) in real time, I want my program to read this <code>.txt</code> file, and start a timer from that particular timestamp, and tick as it ticks in the video file.</p>

<p>So far I already can read the <code>.txt</code> file and I have the starting time stored in a <code>string</code> variable. Now, what I want to do is, to create a timer which will start off from the read string variable and tick as the video plays, so that in my program I synchronize with the time ticking in the video.</p>

<p>Edit: I am using OpenCV as library.</p>
"
"<p>I am working on a little batch program, and I am having problems with coding the time scripting, which I mean by allowing people in the program in a certain time.
The certain time is having it open at 12:00 P.M, and having it close on 11:00 P.M.
This is my script so far:</p>

<pre><code>    @echo off
    set current_time=%time:~0,5%
    rem This piece of code below is to make it start
    if %current_time% == ""12:00"" goto :START
    rem this piece of code below is to make it stop
    if %current_time% == ""23:00"" goto :STOP
    rem and if you know batch you'll get these two
    if %current_time% lss ""12:00"" if %current_time% gtr ""23:00"" goto :STOP
    if %current_time% gtr ""12:00"" if %current_time% lss ""23:00"" goto :START
    :START

    echo The program has successfully ran.
    echo Press anything to exit now.
    pause &gt;nul
    exit
    :STOP
    echo Sorry, but this program is closed. Come back at 12:00 P.M.
    pause &gt;nul
    exit
</code></pre>

<p>When I try the code, it just completely ignores the time configuration and goes straight to the start procedure. Does anybody know how to fix this?
Also, PLEASE NOTE: I am using Windows 10.</p>
"
"<p>I'm trying to work out the best schedule for a benchmark Halide code and I might be missing something because the timing results don't make much sense to me.</p>

<p>I'm using AOT compilation, and here's the algorithm part of the code:</p>

<pre><code>ImageParam input1(type_of&lt;float&gt;(), 3);
ImageParam input2(type_of&lt;float&gt;(), 3);
Func in1 = BoundaryConditions::constant_exterior(input1, 0.0f);
Func in2 = BoundaryConditions::constant_exterior(input2, 0.0f);
f1(x, y, z) = (in1(x + 1, y, z) + in1(x, y, z) + in1(x - 1, y,z));
f2(x, y, z) = (in2(x + 2, y, z) + in2(x + 1, y, z) + in2(x, y, z) +in2(x - 1, y, z) + in2(x - 2, y, z));
res(x, y, z) = f1(x, y, z) + f1(x - 1, y, z) + f2(x - 1, y, z) + f2(x, y, z);
</code></pre>

<p>For the schedule this is what I have:</p>

<pre><code>f1.store_at(res, y).compute_at(res, yi).vectorize(x, 8);
f2.store_at(res, y).compute_at(res, yi).vectorize(x, 8);
res.split(y, y, yi, 8).vectorize(x, 8).parallel(y);
res.print_loop_nest();
</code></pre>

<p>I use the current_time function to time the execution of my code. When I use the mentioned schedule for both f1 and f2 the execution time is more than when I use the schedule on only one of these Funcs. Considering the structure of the stencils I'd have thought scheduling both of them would improve performance. What am I missing here? Also when I print the loops to see the generated code:</p>

<pre><code>  for k:
    parallel j.j:
      store f1:
        store f2:
          for j.in_y in [0, 7]:
            produce f1:
              for k:
                for j:
                  for i.i:
                    vectorized i.v122 in [0, 7]:
                      f1(...) = ...
            consume f1:
              produce f2:
                for k:
                  for j:
                    for i.i:
                      vectorized i.v126 in [0, 7]:
                        f2(...) = ...
              consume f2:
                for i.i:
                  vectorized i.v133 in [0, 7]:
                    result(...) = ...
consume result:
</code></pre>

<p>Is it just the indentation or is the produce f2 nested within produce f1?
Any suggestions for a better schedule? </p>
"
"<p>How can I execute an MSSQL query from within in a Gear S3 application?  I currently have C# code running to execute the query from a desktop app which looks like this:</p>

<pre><code>string connection = ConfigurationManager.ConnectionStrings[""ABC_Data_Center.Properties.Settings.ABCDataCenterConnectionString""].ConnectionString;
try
{
    using (SqlConnection newSQLconnection = new SqlConnection(connection))
    {
        newSQLconnection.Open();
        SqlCommand command = new SqlCommand();
        command.CommandText = ""select sum(weight) as int from harvest join field on (field.field_id = harvest.field_id) join location on (field.location_id = location.location_id) where cast(timestamp as date) = cast(@current_Time as date) and (location.account_id = @account_id)"";
        command.Parameters.AddWithValue(""@account_id"", account_id);
        command.Parameters.AddWithValue(""@current_Time"", DateTime.Now);
        todaysHarvest.Text = Convert.ToInt32(command.ExecuteScalar()).ToString(""N0"");
    }
}
catch (Exception ex)
{
    MessageBox.Show(ex.Message);
}
</code></pre>

<p>Can I add this type of functionality to a smart watch application written in C using Tizen?</p>
"
"<p>What I am trying to do is to get the current system date and time and have them saved to two different variables so I can compare them later on with other dates and times. Here is the code I have so far. I issue is when I run the code I keep getting the same system time, and it is not correct, but the date is correct.</p>

<pre><code>#include &lt;time.h&gt;
#include &lt;stdio.h&gt;

int main() {

time_t raw;
time(&amp;raw);

struct tm *time_ptr;
time_ptr = localtime(&amp;raw);

char current_date[11];
char current_time [20];
strftime(current_date, sizeof(current_date), ""%m/%d/%Y"", time_ptr);
strftime(current_time, sizeof(current_time), ""%H:%I"", time_ptr);

printf(""Date Variable is: %s\n"", current_date);
printf(""Time Variable is: %s\n"", current_time);

}
</code></pre>
"
"<p>Very new to scripting.  Working my way through ""The Linux Command Line"" by Shotts.  </p>

<p>I keep running into an issue with some of the here doc delimiters being skipped.</p>

<p>I have report_uptime and report_disk_space commented out currently, but when I uncomment them some of my Here doc delimiters are being skipped. </p>

<p>Am I just missing something blaringly obvious breaking the script, or am I jacking up the here docs somehow? </p>

<pre><code>#!/bin/bash

# Program to output a system information page

##### Constants

TITLE=""System Information Report For $HOSTNAME""
CURRENT_TIME=$(date +""%x %r %Z"")
TIME_STAMP=""Generated $CURRENT_TIME, by $USER""

##### Functions

report_uptime () {
    cat &lt;&lt;- _EOF_
        &lt;H2&gt;System Uptime&lt;/H2&gt;
        &lt;PRE&gt;$(uptime)&lt;/PRE&gt;
        _EOF_
    return
}

#report_disk_space () {
#   cat &lt;&lt;- _EOF_
#       &lt;H2&gt;Disk Space Utilization&lt;/H2&gt;
#       &lt;PRE&gt;$(df -h)&lt;/PRE&gt;
#       _EOF_
#   return
#}

#report_home_space () {
#   cat &lt;&lt;- _EOF_
#       &lt;H2&gt;Home Space Utilization&lt;/H2&gt;
#       &lt;PRE&gt;$(du -sh /home/*)&lt;/PRE&gt;
#       _EOF_
#   return
#}

##### HTML code

cat &lt;&lt; _EOF_
&lt;HTML&gt;
    &lt;HEAD&gt;
        &lt;TITLE&gt;$TITLE&lt;/TITLE&gt;
    &lt;/HEAD&gt;
    &lt;BODY&gt;
        &lt;H1&gt;$TITLE&lt;/H1&gt;
        &lt;P&gt;$TIME_STAMP&lt;/P&gt;
        $(report_uptime)
        $(report_disk_space)
        $(report_home_space)
    &lt;/BODY&gt;
&lt;/HTML&gt;

_EOF_
</code></pre>
"
"<p>I'm using the Blinn-Phong algorithm to calculate the lighting in a scene, and I'm not factoring in distance yet. I've also disabled my HDR and Specular calculations until I get this first issue fixed.</p>

<p>I'm somewhere on the order of 95% sure that it's a mistake in my fragment shader, but I'm setting up a full MCVE just in case I made a mistake elsewhere.</p>

<h1>Fragment Shader:</h1>

<pre><code>R""DATA(#version 430
layout(location = 0) in vec3 vertex_color;
layout(location = 1) in vec3 vertex_normal;
layout(location = 2) in vec3 vertex_position;

layout(location = 0) out vec4 fragment_color;

uniform float ambient_factor = 0.05;
uniform float diffuse_factor = 1;
//Specular Lighting is disabled until I figure out where the mistake is.
uniform float specular_factor = 0;
uniform float specular_shininess = 15;

uniform vec4 light_position = vec4(2, 0, 2, 1);
uniform vec4 light_color = vec4(1, 1, 1, 1);

uniform float exposure = 1;

uniform vec4 eye;

void main() {
    vec3 texture_color = vertex_color;
    vec3 normalized_fragment_normal = normalize(vertex_normal);

    vec3 light_direction = normalize(light_position.xyz - vertex_position);
    vec3 eye_direction = normalize(eye.xyz - vertex_position);
    vec3 halfway_vector = normalize(light_direction + eye_direction);

    float diffuse_strength = clamp(dot(normalized_fragment_normal, light_direction), 0, 1);
    float blinn_phong_specular_strength = max(dot(normalized_fragment_normal, halfway_vector), 0);

    vec3 working_color = vec3(
        texture_color * ambient_factor +
        light_color.xyz * light_color.w * texture_color * diffuse_strength * diffuse_factor +
        light_color.xyz * light_color.w * pow(blinn_phong_specular_strength, specular_shininess) * specular_factor
    );

    //For handling HDR, but disabling for now so that the lighting differences/mistakes are more obvious.
    //const float gamma = 2.2;
    //vec3 mapped = vec3(1) - exp(-working_color * exposure);

    //mapped = pow(mapped, vec3(1 / gamma));

    //fragment_color = vec4(mapped, 1);
    fragment_color = vec4(working_color, 1);
})DATA""
</code></pre>

<p>Vertex Shader:</p>

<pre><code>R""DATA(#version 430
layout(location = 0) in vec3 position;
layout(location = 1) in vec3 color;
layout(location = 2) in vec3 normal;

layout(location = 0) out vec3 vertex_color;
layout(location = 1) out vec3 vertex_normal;
layout(location = 2) out vec3 vertex_position;

uniform mat4 projection;
uniform mat4 view;
uniform mat4 model_position;
uniform mat4 model_normal;

void main() {
    gl_Position = projection * view * model_position * vec4(position, 1);
    vertex_color = color;
    vertex_normal = (model_normal * vec4(normal, 0)).xyz;
    vertex_position = (model_position * vec4(position, 1)).xyz;
})DATA""
</code></pre>

<p>Shaders.h:</p>

<pre><code>#pragma once

#pragma warning( push )
#pragma warning( once : 4251)
#include&lt;glbinding\gl\gl.h&gt;
#include&lt;glbinding\Binding.h&gt;
#pragma warning( pop )

const char * vert_src = """"
#include ""Cube.vert.glsl""
;

const char * frag_src = """"
#include ""Cube.frag.glsl""
;

//The two Light shaders are just pass-through shaders that make the cube look pure white.
const char * light_vert_src = """"
#include ""Light.vert.glsl""
;

const char * light_frag_src = """"
#include ""Light.frag.glsl""
;

namespace shaders {
    using namespace gl;
    class failed_shader_compilation_exception : public std::runtime_error {
        std::string error_log;
    public:
        failed_shader_compilation_exception(std::string const&amp; why, std::string const&amp; err) :
            std::runtime_error(why),
            error_log(err) {}
        std::string get_log() const {
            return error_log;
        }
    };

    void handle_shader_error(GLuint shader, std::string const&amp; type, bool is_shader = true) {
        int log_length;
        if (is_shader)
            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;log_length);
        else
            glGetProgramiv(shader, GL_INFO_LOG_LENGTH, &amp;log_length);
        std::string errlog;
        errlog.resize(log_length);
        if (is_shader)
            glGetShaderInfoLog(shader, log_length, nullptr, &amp;errlog[0]);
        else
            glGetProgramInfoLog(shader, log_length, nullptr, &amp;errlog[0]);
        if (is_shader)
            glDeleteShader(shader);
        else
            glDeleteProgram(shader);
        throw failed_shader_compilation_exception(""The "" + type + "" failed to Compile"", errlog);
    }

    GLuint get_program(const char * vsrc, const char * fsrc) {
        GLuint vertex_shader = glCreateShader(GL_VERTEX_SHADER);
        int ret;

        glShaderSource(vertex_shader, 1, &amp;vsrc, nullptr);
        glCompileShader(vertex_shader);
        glGetShaderiv(vertex_shader, GL_COMPILE_STATUS, &amp;ret);
        if (!ret) {
            handle_shader_error(vertex_shader, ""Vertex Shader"");
        }

        GLuint fragment_shader = glCreateShader(GL_FRAGMENT_SHADER);

        glShaderSource(fragment_shader, 1, &amp;fsrc, nullptr);
        glCompileShader(fragment_shader);
        glGetShaderiv(fragment_shader, GL_COMPILE_STATUS, &amp;ret);
        if (!ret) {
            glDeleteShader(vertex_shader);
            handle_shader_error(fragment_shader, ""Fragment Shader"");
        }

        GLuint program = glCreateProgram();
        glAttachShader(program, vertex_shader);
        glAttachShader(program, fragment_shader);
        glLinkProgram(program);
        glDeleteShader(vertex_shader);
        glDeleteShader(fragment_shader);

        glGetProgramiv(program, GL_LINK_STATUS, &amp;ret);
        if (!ret) {
            handle_shader_error(program, ""Program"", false);
        }
        return program;
    }
}
</code></pre>

<p>Main.cpp:</p>

<pre><code>#define GLFW_INCLUDE_NONE
#include&lt;GLFW\glfw3.h&gt;

#pragma warning( push )
#pragma warning( once : 4251)
#include&lt;glbinding\gl43core\gl.h&gt;
#include&lt;glbinding\Binding.h&gt;
#pragma warning( pop )

#include&lt;iostream&gt;

#include&lt;glm/glm.hpp&gt;
#include&lt;glm/gtc/matrix_transform.hpp&gt;
#include&lt;glm/gtc/type_ptr.hpp&gt;

#include ""Shaders.h""

float vertex_data[] {
    0, 0, 0,    1, 0, 0,    0, 0, 1,
    1, 0, 0,    1, 0, 0,    0, 0, 1,
    1, 1, 0,    1, 0, 0,    0, 0, 1,
    0, 0, 0,    1, 0, 0,    0, 0, 1,
    1, 1, 0,    1, 0, 0,    0, 0, 1,
    0, 1, 0,    1, 0, 0,    0, 0, 1,

    1, 0, 0,    0, 1, 0,    1, 0, 0,
    1, 0, -1,   0, 1, 0,    1, 0, 0,
    1, 1, -1,   0, 1, 0,    1, 0, 0,
    1, 0, 0,    0, 1, 0,    1, 0, 0,
    1, 1, -1,   0, 1, 0,    1, 0, 0,
    1, 1, 0,    0, 1, 0,    1, 0, 0,

    1, 0, -1,   0, 1, 1,    0, 0, -1,
    0, 0, -1,   0, 1, 1,    0, 0, -1,
    0, 1, -1,   0, 1, 1,    0, 0, -1,
    1, 0, -1,   0, 1, 1,    0, 0, -1,
    0, 1, -1,   0, 1, 1,    0, 0, -1,
    1, 1, -1,   0, 1, 1,    0, 0, -1,

    0, 0, -1,   1, 0, 1,    -1, 0, 0,
    0, 0, 0,    1, 0, 1,    -1, 0, 0,
    0, 1, 0,    1, 0, 1,    -1, 0, 0,
    0, 0, -1,   1, 0, 1,    -1, 0, 0,
    0, 1, 0,    1, 0, 1,    -1, 0, 0,
    0, 1, -1,   1, 0, 1,    -1, 0, 0,

    0, 1, 0,    0, 0, 1,    0, 1, 0,
    1, 1, 0,    0, 0, 1,    0, 1, 0,
    1, 1, -1,   0, 0, 1,    0, 1, 0,
    0, 1, 0,    0, 0, 1,    0, 1, 0,
    1, 1, -1,   0, 0, 1,    0, 1, 0,
    0, 1, -1,   0, 0, 1,    0, 1, 0,

    0, 0, 0,    1, 1, 0,    0, -1, 0,
    0, 0, -1,   1, 1, 0,    0, -1, 0,
    1, 0, -1,   1, 1, 0,    0, -1, 0,
    0, 0, 0,    1, 1, 0,    0, -1, 0,
    1, 0, -1,   1, 1, 0,    0, -1, 0,
    1, 0, 0,    1, 1, 0,    0, -1, 0,
};

float light_cube_data[]{
    0, 0, 0,    1, 0, 0,    1, 1, 0,
    0, 0, 0,    1, 1, 0,    0, 1, 0,

    1, 0, 0,    1, 0, -1,   1, 1, -1,
    1, 0, 0,    1, 1, -1,   1, 1, 0,

    1, 0, -1,   0, 0, -1,   0, 1, -1,
    1, 0, -1,   0, 1, -1,   1, 1, -1,

    0, 0, -1,   0, 0, 0,    0, 1, 0,
    0, 0, -1,   0, 1, 0,    0, 1, -1,

    0, 1, 0,    1, 1, 0,    1, 1, -1,
    0, 1, 0,    1, 1, -1,   0, 1, -1,

    0, 0, 0,    0, 0, -1,   1, 0, -1,
    0, 0, 0,    1, 0, -1,   1, 0, 0,
};

int main() {
    glfwInit();
    GLFWwindow * window = glfwCreateWindow(300, 300, ""bluh"", nullptr, nullptr);
    glfwMakeContextCurrent(window);
    glbinding::Binding::initialize();
    using namespace gl43core;
    GLuint program = 0, light_program = 0;
    try {
        program = shaders::get_program(vert_src, frag_src);
        light_program = shaders::get_program(light_vert_src, light_frag_src);
    }
    catch (shaders::failed_shader_compilation_exception const&amp; e) {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        std::cerr &lt;&lt; e.get_log() &lt;&lt; std::endl;
        system(""pause"");
        return 1;
    }
    glUseProgram(program);
    GLuint vao, vbo;
    GLuint light_vao, light_vbo;

    glGenVertexArrays(1, &amp;vao);
    glBindVertexArray(vao);
    glGenBuffers(1, &amp;vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertex_data), vertex_data, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glEnableVertexAttribArray(1);
    glEnableVertexAttribArray(2);
    glVertexAttribPointer(0, 3, GL_FLOAT, false, 9 * sizeof(GLfloat), (void*)0);
    glVertexAttribPointer(1, 3, GL_FLOAT, false, 9 * sizeof(GLfloat), (void*)(3 * sizeof(GLfloat)));
    glVertexAttribPointer(2, 3, GL_FLOAT, false, 9 * sizeof(GLfloat), (void*)(3 * sizeof(GLfloat)));

    glGenVertexArrays(1, &amp;light_vao);
    glBindVertexArray(light_vao);
    glGenBuffers(1, &amp;light_vbo);
    glBindBuffer(GL_ARRAY_BUFFER, light_vbo);
    glBufferData(GL_ARRAY_BUFFER, sizeof(light_cube_data), light_cube_data, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, false, 3 * sizeof(GLfloat), (void*)0);

    glEnable(GL_DEPTH_TEST);
    glEnable(GL_CULL_FACE);

    glm::mat4 view = glm::lookAt(glm::vec3(2, 3, 3), glm::vec3(0, 0, 0), glm::vec3(0, 1, 0));
    struct manip_data {
        glm::quat view_quat;
        glm::vec3 view_position;
        glm::vec4 light_position{ 3, 0, 3, 1 };
        glm::vec4 light_color{ 1, 1, 1, 1 };
        double prior_time;
        double current_time;
    };

    manip_data data;
    data.view_quat = glm::quat(view);
    data.view_position = glm::vec3(glm::inverse(view)[3]);
    data.prior_time = data.current_time = glfwGetTime();

    glfwSetWindowUserPointer(window, &amp;data);
    glfwSetKeyCallback(window, [](GLFWwindow * window, int key, int code, int action, int modifier) {
        manip_data &amp; data = *(reinterpret_cast&lt;manip_data *&gt;(glfwGetWindowUserPointer(window)));
        data.current_time = glfwGetTime();
        double dt = data.current_time - data.prior_time;
        if (action == GLFW_PRESS || action == GLFW_REPEAT) {
            switch (key) {
            case GLFW_KEY_W: data.view_position += glm::inverse(data.view_quat) * glm::vec3(0, 0, -1) * float(dt) * 50.f; break;
            case GLFW_KEY_S: data.view_position += glm::inverse(data.view_quat) * glm::vec3(0, 0, 1) * float(dt) * 50.f; break;
            case GLFW_KEY_A: data.view_position += glm::inverse(data.view_quat) * glm::vec3(-1, 0, 0) * float(dt) * 50.f; break;
            case GLFW_KEY_D: data.view_position += glm::inverse(data.view_quat) * glm::vec3(1, 0, 0) * float(dt) * 50.f; break;
            case GLFW_KEY_LEFT_SHIFT: data.view_position += glm::inverse(data.view_quat) * glm::vec3(0, 1, 0) * float(dt) * 50.f; break;
            case GLFW_KEY_LEFT_CONTROL: data.view_position += glm::inverse(data.view_quat) * glm::vec3(0, -1, 0) * float(dt) * 50.f; break;

            case GLFW_KEY_KP_8: data.view_quat = glm::angleAxis(-float(dt) * 50, glm::vec3(1, 0, 0)) * data.view_quat; break;
            case GLFW_KEY_KP_2: data.view_quat = glm::angleAxis(float(dt) * 50, glm::vec3(1, 0, 0)) * data.view_quat; break;
            case GLFW_KEY_KP_4: data.view_quat = glm::angleAxis(-float(dt) * 50, glm::vec3(0, 1, 0)) * data.view_quat; break;
            case GLFW_KEY_KP_6: data.view_quat = glm::angleAxis(float(dt) * 50, glm::vec3(0, 1, 0)) * data.view_quat; break;
            case GLFW_KEY_KP_9: data.view_quat = glm::angleAxis(-float(dt) * 50, glm::vec3(0, 0, -1)) * data.view_quat; break;
            case GLFW_KEY_KP_7: data.view_quat = glm::angleAxis(float(dt) * 50, glm::vec3(0, 0, -1)) * data.view_quat; break;
            }
        }
        data.prior_time = data.current_time;
    });

    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
        data.prior_time = glfwGetTime();
        int width, height;
        glfwGetFramebufferSize(window, &amp;width, &amp;height);
        glViewport(0, 0, width, height);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glm::mat4 projection = glm::perspective(glm::radians(60.f), float(width) / height, 0.1f, 100.f);
        glm::mat4 model;
        glm::mat4 normal_model;

        view = glm::translate(glm::mat4_cast(data.view_quat), -data.view_position);
        glm::vec4 eye = glm::inverse(view)[3];
        glm::vec4 light_position{ 1.25, 0.5, 1.25, 1 };

        glUseProgram(program);
        glBindVertexArray(vao);
        glUniformMatrix4fv(glGetUniformLocation(program, ""projection""), 1, false, glm::value_ptr(projection));
        glUniformMatrix4fv(glGetUniformLocation(program, ""view""), 1, false, glm::value_ptr(view));
        glUniformMatrix4fv(glGetUniformLocation(program, ""model_position""), 1, false, glm::value_ptr(model));
        glUniformMatrix4fv(glGetUniformLocation(program, ""model_normal""), 1, false, glm::value_ptr(normal_model));
        glUniform4fv(glGetUniformLocation(program, ""eye""), 1, glm::value_ptr(eye));
        glUniform4fv(glGetUniformLocation(program, ""light_position""), 1, glm::value_ptr(light_position));

        glDrawArrays(GL_TRIANGLES, 0, sizeof(vertex_data) / sizeof(GLfloat) / 9);

        model = glm::translate(model, glm::vec3(light_position));
        model = glm::scale(model, glm::vec3(0.25, 0.25, 0.25));

        glUseProgram(light_program);
        glBindVertexArray(light_vao);

        glUniformMatrix4fv(glGetUniformLocation(light_program, ""projection""), 1, false, glm::value_ptr(projection));
        glUniformMatrix4fv(glGetUniformLocation(light_program, ""view""), 1, false, glm::value_ptr(view));
        glUniformMatrix4fv(glGetUniformLocation(light_program, ""model_position""), 1, false, glm::value_ptr(model));

        glDrawArrays(GL_TRIANGLES, 0, sizeof(light_cube_data) / sizeof(GLfloat) / 3);

        glfwSwapBuffers(window);
    }

    return 0;
}
</code></pre>

<p>This is a picture of the default rendering position, with some annotations I added to identify how I know the lighting is wrong.</p>

<p><a href=""https://i.stack.imgur.com/F4ohL.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/F4ohL.png"" alt=""Picture of Incorrect Lighting""></a></p>

<p>I'm using GLFW and glbinding for my OpenGL API access, but GLEW has virtually identical code if you use it instead of glbinding. I'm also using GLM for math functions.</p>
"
"<p>If an example , I set a value of :</p>

<pre><code>a = 50
</code></pre>

<p>How do I do a decrement whereby a always decreases by 2 ? An example :</p>

<pre><code>48
46
44
42
40
</code></pre>

<p>Whereby the return results , I can use as a variable. Example in the case below , this method is to get temperature at random. But I would like it to decrease so that I can call this get temperature method even below for it to loop.</p>

<pre><code>/* Retrieves current temperature. */
static int32_t get_temperature_sample(void)
{
    /* For the sake of example, random data is used */
    return rand() % 10 + 25;
}

/* Periodically called by Kaa SDK. */
static void example_callback(void *context)
{
    time_t current_time = time(NULL);

    /* Respect sample period */
    if (difftime(current_time, last_sample_time) &gt;= sample_period) {
        int32_t temperature = get_temperature_sample();

        printf(""Sampled temperature: %i\n"", temperature);
        last_sample_time = current_time;

        kaa_user_log_record_t *log_record = kaa_logging_data_collection_create();
        log_record-&gt;temperature = temperature;

        kaa_logging_add_record(kaa_client_get_context(context)-&gt;log_collector, log_record, NULL);
    }
}
</code></pre>

<p>Like if the above codes , if I were to say that for my temperature. I wouldnt want it to be random as you can see it uses random. I want to set a value for my temperature and decrease like a constant until it reaches 0 in my print function shown below.</p>

<pre><code>printf(""Sampled temperature: %i\n"", temperature);
        last_sample_time = current_time;
</code></pre>
"
"<p>First thing to say, i'm an absolute noob in programming so it might be a very simple thing and i'm not getting it.  </p>

<p>I want to know how much time has passed since the beginning of the day and to do that i used the <code>time()</code> function.  </p>

<p>I then want to print it and here is my problem: with the first printf the variable <code>seconds</code> is printed correctly but in the second <code>printf</code> (where I print <code>mills</code> and <code>seconds</code>) it gives me a wrong output.</p>

<p>The code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

int main(void) {
  long long int mills, seconds;

  mills = time(NULL);
  printf(""Mills: %i\n"", mills );

  seconds = mills / 1000;

  //here the variable is printed correctly
  printf(""Seconds: %i\n"", seconds );

  //here mills gets printed correctly but seconds gets printed as 0
  printf(""Milliseconds since midnight: %i\nSeconds since midnight: %i\n"", mills, seconds);

  return 0;

}
</code></pre>

<p>The output:</p>

<pre><code>Mills: 1486143107
Seconds: 1486143
Milliseconds since midnight: 1486143107
Seconds since midnight: 0
</code></pre>

<p>Why is the variable printed correctly the first time but not the second time? Shouldn't it be always the same?</p>
"
"<p>I wrote some code below, at the moment I'm testing so there's no database queries in the code.</p>

<p>The code below where it says <code>if(filesize($filename) != 0)</code> always goes to <code>else</code> even though the file is not 0 bytes and has 16 bytes of data in there. I am getting nowhere, it just always seems to think file is 0 bytes.</p>

<p>I think it's easier to show my code (could be other errors in there but I'm checking each error as I go along, dealing with them one by one). I get no PHP errors or anything.</p>

<pre><code>$filename = 'memberlist.txt';
$file_directory = dirname($filename);
$fopen = fopen($filename, 'w+');

// check is file exists and is writable
if(file_exists($filename) &amp;&amp; is_writable($file_directory)){

    // clear statcache else filesize could be incorrect
    clearstatcache();

    // for testing, shows 0 bytes even though file is 16 bytes
    // file has inside without quotes:   '1487071595 ; 582'
    echo ""The file size is actually "".filesize($filename)."" bytes.\n"";

    // check if file contains any data, also tried !==
    // always goes to else even though not 0 bytes in size
    if(filesize($filename) != 0){

        // read file into an array
        $fread = file($filename);

        // get current time
        $current_time = time();

        foreach($fread as $read){
            $var   = explode(';', $read);
            $oldtime  = $var[0];
            $member_count = $var[1];
        }
            if($current_time - $oldtime &gt;= 86400){
                // 24 hours or more so we query db and write new member count to file
                echo 'more than 24 hours has passed'; // for testing

            } else {
                // less than 24 hours so don't query db just read member count from file
                echo 'less than 24 hours has passed'; // for testing
            }
    } else { // WE ALWAYS END UP HERE
        // else file is empty so we add data
        $current_time = time().' ; ';
        $member_count = 582; // this value will come from a database
        fwrite($fopen, $current_time.$member_count);
        fclose($fopen);
        //echo ""The file is empty so write new data to file. File size is actually "".filesize($filename)."" bytes.\n"";
    }

} else {
    // file either does not exist or cant be written to
    echo 'file does not exist or is not writeable'; // for testing
}
</code></pre>

<p>Basically the code will be on a memberlist page which currently retrieves all members and counts how many members are registered. The point in the script is if the time is less than 24 hours we read the member_count from file else if 24 hours or more has elapsed then we query database, get the member count and write new figure to file, it's to reduce queries on the memberlist page.</p>

<p><strong>Update 1:</strong></p>

<p>This code:</p>

<p><code>echo ""The file size is actually "".filesize($filename)."" bytes.\n"";</code></p>

<p>always outputs the below even though it's not 0 bytes.</p>

<blockquote>
  <p>The file size is actually 0 bytes.</p>
</blockquote>

<p>also tried</p>

<p><code>var_dump (filesize($filename));</code></p>

<p>Outputs:</p>

<blockquote>
  <p>int(0)</p>
</blockquote>
"
"<p>I am trying to get the total time a particular thread spent so far programatically.</p>

<p><code>getrusage</code> returns a thread's CPU time but I want the <em>total</em> time i.e. including the time spent by the thread being blocked for whatever reason.</p>

<p>Please note that I will be making use of this functionality by instrumenting a given program using a profiler that I wrote.</p>

<p>A program may have many threads (I am focusing on profiling servers so there can be many). At any given time I would want to know how much time a particular thread spent (so far). So its not convenient to start a timer for every thread as they are spawned. So I would want something of usage similar to <code>getrusage</code> e.g. it returns the total time of the current thread or maybe I can pass to it a thread id. So manual mechanisms like taking a timestamp when the thread was spawned and one later then taking their difference won't be  very helpful for me.</p>

<p>Can anyone suggest how to do this?</p>

<p>Thanks!</p>
"
"<p>I want to be able to put into a string the local time and date with millisecond resolution like so:</p>

<p>YYYY-MM-DD hh:mm:ss.sss</p>

<p>Seems like a simple thing to do, but I haven't found a simple answer for how to do this.  I am writing in C++ and do have access to 11 compiler but am fine using a C solution if it's cleaner.  I found a post here with a solution <a href=""https://stackoverflow.com/questions/39230127/get-both-date-and-time-in-milliseconds"">Get both date and time in milliseconds</a> but surely it can't be that difficult given use of standard libraries.  I'm probably going to move forward with that type of solution but was hoping to add to the knowledge base by asking the question here on SO.</p>

<p>I know this will work but again, seems unnecessarily difficult:</p>

<pre><code>#include &lt;sys/time.h&gt;
#include &lt;stdio.h&gt;

int main(void)
{
    string sTimestamp;
    char acTimestamp[256];

    struct timeval tv;
    struct tm *tm;

    gettimeofday(&amp;tv, NULL);

    tm = localtime(&amp;tv.tv_sec);

    sprintf(acTimestamp, ""%04d-%02d-%02d %02d:%02d:%02d.%03d\n"",
            tm-&gt;tm_year + 1900,
            tm-&gt;tm_mon + 1,
            tm-&gt;tm_mday,
            tm-&gt;tm_hour,
            tm-&gt;tm_min,
            tm-&gt;tm_sec,
            (int) (tv.tv_usec / 1000)
        );

    sTimestamp = acTimestamp;

    cout &lt;&lt; sTimestamp &lt;&lt; endl;

    return 0;
}
</code></pre>

<p>Tried looking at put_time for C++ and strftime for the old C way.  Both only allow me to get to second resolution best I can tell.  You can see the two approaches I've gotten so far below.  I would like to put it into a string</p>

<pre><code>auto t = std::time(nullptr);
auto tm = *std::localtime(&amp;t);
std::cout &lt;&lt; std::put_time(&amp;tm, ""%Y-%m-%d %H:%M:%S"") &lt;&lt; std::endl;

time_t rawtime;
struct tm * timeinfo;
char buffer[80];

time (&amp;rawtime);
timeinfo = localtime(&amp;rawtime);

strftime(buffer,sizeof(buffer),""%Y-%m-%d %I:%M:%S"",timeinfo);
std::string str(buffer);

std::cout &lt;&lt; str;
</code></pre>

<p>Only thing I can figure out is to use gettimeofday and get rid of all the data except the last second and append it to the timestamp, still wish there was a cleaner approach.</p>

<p>Anyone find a solution that works better?</p>
"
"<p>There is a timer which invokes a function every 24 hours. This function reads a file to get the number of days remaining, decrements it by 1 and writes back the new remaining days to the same file.</p>

<p>Problem: If the system reboots, the timer (which is waiting to be triggered at the 24 hour mark) may not be invoked and the writing to file will not happen. For instance, if the reboot happens every day before the 24 hour period, the remaining days will never be decremented.</p>

<p>I am using C++ program on a Linux system.</p>

<p>What is the logic required to handle this problem.</p>
"
"<p>For example, I have such function which performs some useful work (for event-driven simulation):</p>

<pre><code>int function()
{
    do_useful_work();
    return 0;
}
</code></pre>

<p>If I need do measurements of performance of this <code>useful_work</code> I should do:</p>

<pre><code>int function()
{
    count_time(time_before);
    count_X_metrics(X_before);

    do_useful_work();

    count_time(time_after);
    count_X_metrics(X_after);

    return 0;
}
</code></pre>

<p>This approach makes code more clumsy. Is there a way, patters to do these countings  outside of <code>int function()</code> to make code clearer?</p>
"
"<p>I am creating a code for a wheel speed sensor as part of a bigger group project.  The code will measure and display ground speed and distance travelled for an autonomous land yacht using a Hall effect sensor and a magnet attached to the wheel.  I have written the code and on its own it works perfectly fine.  However when I try to add it to the full project code it does not seem to work at all.  The only difference is that inside <code>void loop()</code> there is a bunch of other things happening.  I have checked and double checked all the pins and all of the code and I simply can not work it out.  it will work sometimes for one spin of the wheel then it seems to sort of exit a loop somehow as the speed then always reads <code>0m/s</code> once the wheel has stopped and started again,</p>

<p>Here is the code on its own:</p>

<pre><code>int sensorPin1 = 2; // hall effect
float revs;
float rpm;
volatile byte rpmcount;

long fin_time;
long current_time;
long stop_time;
float distance;
const float circumference = 0.31416;
float groundspeed;
const float Pi = 3.14159;

#include &lt;LiquidCrystal.h&gt;
LiquidCrystal lcd(12, 11, 5, 4, 3, 13);


void setup()
{
  Serial.begin(9600);
  pinMode(sensorPin1, INPUT);
  attachInterrupt(0, RPM, RISING);
}

void RPM()
{
  rpmcount++;
  revs++;
}

void loop()
{
  lcd.clear();
  lcd.begin(16,2);
  lcd.setCursor(0,0);
  lcd.print(""GS="");
  lcd.setCursor(3,0);
  lcd.print(groundspeed,1);
  lcd.print(""m/s"");
  lcd.setCursor(10,0);
  lcd.print(""D="");
  lcd.print(distance,0);
  lcd.print(""m"");

  if(rpmcount == 1)
  {
    current_time = time - fin_time;
    rpm = ((60000)/current_time);
    groundspeed = ((rpm * circumference) / 60);
    distance = revs*circumference;
    rpmcount = 0;
    fin_time = millis();
  }

  stop_time = millis() - fin_time;
  if(stop_time &gt;= 2000)
  {
    rpm = 0;
    groundspeed = 0;
    delay(20);
  }
}
</code></pre>

<p>the code within the main project takes up the exact same structure, the only difference is that <code>void setup()</code> and <code>void loop()</code> have a bunch of other things in side them for all of the other sensors on the vessel.  I have checked the code over and the main arithmetic inside my code is not contained within any other <code>if</code> loops or anything other than <code>if (rpmcount == 1)</code>.</p>

<p>Does anybody have an ideas?</p>

<p>I could upload the full project code but it is hundreds of lines and this question is long enough already.</p>
"
"<p>My script is capturing time from docker container and next step i want to convert it to some format so i can substitute docker time with current system time and get the difference.</p>

<p>So for now i want at least to convert it so my script will understand that i'm working with the time.</p>

<pre><code>#!/bin/bash

name=$1
matching=$(docker ps -a --filter=""name=$name"" -q | xargs)
current_time=$(date -u +""%Y-%m-%dT%T"")
echo Current time: ${current_time}

for i in $matching
do
    time=sudo docker inspect $i | grep -w ""StartedAt"" | awk '{gsub(/""/, """", $2); print $2 }' | head -n 1 | cut -c -19
    echo ${time}
    echo $(date -d +""%Y-%m-%dT%H:%M:%S"" --date=""$time"")
done
</code></pre>

<p>The output i'm getting is</p>

<pre><code>Thu Apr 20 00:00:00 PDT 2017
2017-04-19T00:57:15
</code></pre>

<p>But i expect to get:</p>

<pre><code>Wed Apr 19 00:57:15 PDT 2017
2017-04-19T00:57:15
</code></pre>
"
"<p>The problem is described in the title. </p>

<p>I have two functions. In the first I get file name (variable <code>text</code>), but the function does not return expected value. After returning the value <code>text</code>, it becomes an abrakadabra. But in the second function variable <code>text</code> is returned correctly. Any help would be greatly appreciated.</p>

<pre><code>char* GetCurrentClipboardData(...)
{
    char* text;
    wchar_t file[MAX_PATH];

    if( OpenClipboard(NULL) )
    {
        HGLOBAL hFile = (HGLOBAL)GetClipboardData(CF_HDROP);
        if (hFile)
        {
            HDROP hDrop = (HDROP)GlobalLock(hFile);
            DragQueryFile(hDrop, 0, file, MAX_PATH);
            _bstr_t b(file);
            text = b;
            if (text != Text)
            {
                SaveDataToFile (file_path, current_time, text);
                char* copy = ReadFile(shadowcopy_path);
                if (copy == ""1"")
                    MakeFileShadowCopy(file, shadowcopies);
            }
            GlobalUnlock(hFile);
        }

        HBITMAP hBitmap = (HBITMAP)GetClipboardData(CF_BITMAP);
        if (hBitmap)
        {
            text = ""???????????"";
            if (text != Text)
            {
                SaveDataToFile (image_path, current_time, text);
                char* copy = ReadFile(shadowcopy_path);
                if (copy == ""1"")
                    MakeImageShadowCopy(hBitmap, shadowcopies, current_date, current_time);
            }
            GlobalUnlock(hBitmap);
        }
        CloseClipboard();
    }
    return text;
}
</code></pre>
"
"<p>How can I record the timestamp in accordance to the user's timezone settings?</p>

<p>For example:</p>

<ol>
<li>The user has the timezone setting as $my_tz = ""UP3"";</li>
<li>The user sets the deadline of an item as $time_to_set = ""2017-05-31 03:15 PM"";</li>
<li>I need the users for example with different timezone settings to convert the time properly in accordance to their timezone (e.g. USER 1: UP3, USER 2: UP8). They need to see the time properly. I tried to set but the offset seems to have +1 hour difference and it is not accurate.</li>
<li>I would need time set to the timezone (UP3) to be converted to the (UTC) base without going off by +1 hour.</li>
</ol>

<p>Thank you so much!</p>

<p>Here is my code you can test to see what I mean.</p>

<pre><code>    $my_tz = ""UP3"";
    $utc_time = local_to_gmt(time());
    $current_time = gmt_to_local($utc_time, $my_tz, FALSE);

    echo ""Current Time: "".unix_to_human($current_time).""&lt;/br&gt;"";
    echo $current_time;
    echo ""&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;&lt;/br&gt;"";

    $time_to_set = ""2017-05-31 03:15 PM"";
    $time_set_unix = human_to_unix($time_to_set);
    $time_to_normal = local_to_gmt($time_set_unix, ""UP8"", FALSE);

    echo $time_to_set.""&lt;/br&gt;"";
    echo $time_set_unix.""&lt;/br&gt;"";
    echo $time_to_normal.""&lt;/br&gt;"";
    echo unix_to_human($time_to_normal).""&lt;/br&gt;"";
</code></pre>
"
"<p>I'm currently writing code for a simulator to sync with ROS time. Essentially, the problem becomes ""write a get_time and sleep that scales according to ROS time""? Doing this will allow no change to the codebase and just require linking to the custom get_time and sleep. get_time seems to work perfectly; however, I've been having trouble getting the sleep to run accurately.</p>

<p>My current design is like this (code attached at the bottom):</p>

<ol>
<li>Thread calls sleep</li>
<li>Sleep will add the time when to unlock this thread (current_time + sleep_time) into a priority queue, and then wait on a condition variable.</li>
<li>A separate thread (let's call it watcher) will constantly loop and check for the top of the queue; if the top of the prio queue > current time, then it will notify_all on the condition variable and then pop the prio queue</li>
</ol>

<p>However, it seems like the watcher thread is not accurate enough (I see discrepancies of 0~50ms), meaning the sleep calls make the threads sleep too long sometimes. I also visibly notice lag/jagged behavior in the simulator compared to if I were to replace the sleep with a usleep(1000*ms).</p>

<p>Unfortunately, I'm not too experienced at these types of designs, and I feel like there are lots of ways to optimize/rewrite this to make it run more accurately.
So my question is, are condition variables the right way? Am I even using them correctly? Here are some things I tried:</p>

<ul>
<li>reduce the number of unnecessary notify_all calls by having an array of condition variables and assigning them based on time like this: (ms/100)%256. The idea being that close together times will share the same cv because they are likely to actually wake up from the notify_all. This made the performance worse</li>
<li>keep the threads and prio_queue pushing etc. but instead use usleep. I found out that the usleep will make it work so much better, which probably means the mutex, locking, and pushing/popping operations do not contribute to a noticeable amount of lag, meaning it must be in the condition variable part</li>
</ul>

<hr>

<p>Code:
Watcher (this is run on startup)</p>

<pre><code>void watcher()
{
  while (true)
  {
    usleep(1);
    {
      std::lock_guard&lt;std::mutex&gt; lk(m_queue);
      if (prio_queue.empty())
        continue;
      if (get_time_in_ms() &gt;= prio_queue.top())
      {
        cv.notify_all();
        prio_queue.pop();
      }
    }
  }
}
</code></pre>

<p>Sleep</p>

<pre><code>void sleep(int ms)
{
  int wakeup = get_time_in_ms() + ms;
  {
    std::lock_guard&lt;std::mutex&gt; lk(m_queue);
    prio_queue.push(wakeup);
  }
  std::unique_lock&lt;std::mutex&gt; lk(m_time);
  cv.wait(lk, [wakeup] {return get_time_in_ms() &gt;= wakeup;});
  lk.unlock();
}
</code></pre>

<p>Any help would be appreciated. Thanks so much!</p>
"
"<p>I want to create a class similar to this:</p>

<pre><code>class MyTime {
public:
    int seconds;
    int useconds;

    /*** functions ***/
}
</code></pre>

<p>but which has the following behavior:</p>

<pre><code>MyTime now;
double current_time = now; // returns double representing seconds
</code></pre>

<p>Is there a way to do this without have to define an <code>asDoubleSeconds()</code> function? Can I change the behavior by overloading the assignment operator somehow?</p>

<p>If not, is there a way to do something like this:</p>

<pre><code>double current_time = double(now);
</code></pre>
"
"<p>I need to get access to the <strong>current status</strong> of traffic lights in <strong>Webots</strong>. </p>

<p>Checking the ""generic_traffic_light.c"" controller for a Generic traffic light, we have:</p>

<pre><code>WbDeviceTag red_light;
red_light = wb_robot_get_device(""ref light"");
...
wb_led_set(red_light, 1);
</code></pre>

<p>Assuming I use several generic traffic lights, is it possible to have access to each traffic light status?</p>

<p>I can get the nodes of my generic traffic lights by:</p>

<pre><code>Node *traffic_node = supervisor-&gt;getFromDef(""traffic_light_1"");
</code></pre>

<p>but <code>Node</code> doesn't have any <code>Device</code> method or any <code>LED</code>-related <code>Field</code>.</p>

<p>Thanks a lot for your help</p>
"
"<p>Trying to learn fmbt ,in the <a href=""https://github.com/01org/fMBT/tree/master/examples/c%2B%2B-unittest"" rel=""nofollow noreferrer"">c++ test</a> it is  using a shared library, the source file of the shared library is preprocessed from another file as in the following make output shows:</p>

<pre><code>g++ -O0 -g -Wall -pedantic -I../../src -I/usr/include/fmbt -fPIC   -c -o mycounter.o mycounter.cc

fmbt-aalc -o mycountertest.cc mycountertest.cc.aal

g++ -O0 -g -Wall -pedantic -I../../src -I/usr/include/fmbt -fPIC   -c -o mycountertest.o mycountertest.cc

g++ -shared -o mycountertest.so mycounter.o mycountertest.o
</code></pre>

<p>When I am trying to debug the shared the library, it always go to the <code>mycountertest.cc.aal</code> file:</p>

<pre><code>ubuntu@i-hics5mzq:~/fMBT/examples/c++-unittest$ gdb  fmbt
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type ""show copying""
and ""show warranty"" for details.
This GDB was configured as ""x86_64-linux-gnu"".
Type ""show configuration"" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.

Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type ""help"".
Type ""apropos word"" to search for commands related to ""word""...
Reading symbols from fmbt...done.
(gdb) break awrapper.cc:149
Breakpoint 1 at 0x585e06: file awrapper.cc, line 149.
(gdb) run test.conf
Starting program: /usr/local/bin/fmbt test.conf
[Thread debugging using libthread_db enabled]
Using host libthread_db library ""/lib/x86_64-linux-gnu/libthread_db.so.1"".
&lt;fmbt_log&gt;
&lt;version&gt;
    0.38-1

&lt;/version&gt;
&lt;conf_load&gt;
    &lt;conf_file name=""test.conf""/&gt;
    &lt;end_time time=""1501727367.947618""/&gt;
&lt;/conf_load&gt;
&lt;conf_execute&gt;
    &lt;action_name name=""iCreate""/&gt;
    &lt;action_name name=""iDestroy""/&gt;
    &lt;action_name name=""iIncrement""/&gt;
    &lt;action_name name=""iReset""/&gt;
    &lt;action_name name=""iCount""/&gt;
    &lt;test_engine&gt;
        &lt;tags enabled=""""/&gt;
        &lt;status steps=""0"" coverage=""0.000000"" scov=""0.000000e+00""/&gt;
        &lt;current_time time=""1501727366.958535""/&gt;
        &lt;suggested_action type=""input"" name=""iCreate"" time=""1501727366.958600""/&gt;


Breakpoint 1, Awrapper::execute (this=0x93b6d0, action=std::vector of length 1, capacity 1 = {...}) at awrapper.cc:149
149       int tmp=ada-&gt;adapter_execute(1,"""");
(gdb) s
_gen_mycountertest::adapter_execute (this=0x94ce50, action=1, param=0x65f8b0 """") at mycountertest.cc.aal:27
27              adapter() {
</code></pre>

<p>why gdb is not using the generated <code>mycountertest.cc</code> file.</p>

<p>here is the <code>mycountertest.cc</code> content, does the special class name has something to do with it ? : </p>

<pre><code>#line 3 ""mycountertest.cc.aal""

        #include ""mycounter.h""
    #include ""aal.hh""

class _gen_mycountertest:public aal {
private:

#line 6 ""mycountertest.cc.aal""
//variables

        MyCounter* mycounter;
        int value;


//action1: ""iCreate""

#line 17 ""mycountertest.cc.aal""
bool action1_guard(const std::string&amp; name) {
{
 return mycounter == NULL;
}
return true;//default
}
</code></pre>
"
"<p>I am currently working with FFmpeg in a video streaming solution over RTP. What bugs me is how to stream at a correct framerate. Currently I am using a sleep in the main streaming loop: </p>

<pre><code>while (av_read_frame (input_format_ctx, &amp;packet) &gt;= 0) { // Read a video packet as long as EOF is not reached or an error occurr
        if(packet.stream_index == 0) {
            if (av_interleaved_write_frame(output_format_ctx, &amp;packet) &lt; 0) { // Write the packet to the output stream
                av_packet_unref(&amp;packet); // Wipe the packet
                av_free_packet(&amp;packet); // Release the packet and finishes if a problem occured
                break;
            }
            av_packet_unref(&amp;packet); // Wipe the packet
            av_free_packet(&amp;packet); // Release the packet
        }

        current_time = getSystemTime(); // Get system time
        adaptativeSleep ((last_time + 1/(output_framerate)) - current_time); // Sleep according to framerate
        last_time = getSystemTime(); // Get finish
    }
</code></pre>

<p>Is there a correct way of letting FFmpeg handle the framerate?</p>

<p>Thanks in advance</p>

<p>P.S.: I only remux the stream, as a result FFmpeg runs through the file in a few seconds witought my ""sleep"".</p>
"
"<p>I need to run a curl request to locahost at least once in every 30 mins. So the command will be <code>curl http://localhost:8080</code>. </p>

<p>The catch here is, I want to select a time randomly between 5min - 30 min and then execute the curl command. The pseudo-code might look like this</p>

<pre><code>while(true)
n = random number between 5-30
run curl http://localhost:8080 after 'n' minutes
</code></pre>

<p>A detailed answer would be nice since I don't have much knowledge about linux.</p>
"
"<p>I followed this tutorial for installing a Kaa application into an ESP8266, and it worked after a few modifications: <a href=""https://kaaproject.github.io/kaa/docs/v0.10.0/Programming-guide/Using-Kaa-endpoint-SDKs/C/SDK-ESP8266/"" rel=""nofollow noreferrer"">https://kaaproject.github.io/kaa/docs/v0.10.0/Programming-guide/Using-Kaa-endpoint-SDKs/C/SDK-ESP8266/</a></p>

<p>One of the modifications I had to make was to move a line of code in eagle.app.v6.ld because of byte overflow (arrow points to change I made):</p>

<pre><code>...

.irom0.text : ALIGN(4)
{
_irom0_text_start = ABSOLUTE(.);
*(.literal.* .text.*) --&gt; moved from "".text : ALIGN(4){...}""

...

}

...
</code></pre>

<p>After I did this I still had some byte overflow, so I modified the original cmake command from the documentation to disable cmake extensions that were taking up space:</p>

<pre><code>cmake \
-DCMAKE_TOOLCHAIN_FILE=../kaa/toolchains/esp8266.cmake \
-DKAA_PLATFORM=esp8266 \
-DCMAKE_BUILD_TYPE=MinSizeRel \
-DWITH_EXTENSION_CONFIGURATION=OFF \
-DWITH_EXTENSION_EVENT=OFF \
-DWITH_EXTENSION_LOGGING=OFF \
-DWITH_EXTENSION_NOTIFICATION=OFF \
-DWITH_EXTENSION_USER=OFF \
-DWITH_ENCRYPTION=OFF \
-DKAA_MAX_LOG_LEVEL=3 ..
</code></pre>

<p>Finally, when I ran the make command. it worked. I then created and flashed the binaries into my ESP. Then I reset my ESP with GPIO0 high (so it can boot from flash) and the ESP sent ""Hello, Kaa!"" into the serial port I was connected to.</p>

<p>Now, however. I am trying to make it so that my ESP8266 connects to my Kaa server and generates an Endpoint Profile, so I need the code to create a transport channel to communicate to both the Bootstrap server and Operations server. </p>

<p>To do this, I tried using the code from Your First Kaa Application that generates fake temp readings and receives the configuration schema and pushes data to my Cassandra server via log appender:
<a href=""https://kaaproject.github.io/kaa/docs/v0.10.0/Programming-guide/Your-first-Kaa-application/"" rel=""nofollow noreferrer"">https://kaaproject.github.io/kaa/docs/v0.10.0/Programming-guide/Your-first-Kaa-application/</a></p>

<p>So in my attempt to do this, I left my directory the same:</p>

<pre><code>CMakeLists.txt
driver/
    uart.h
    uart.c
ld/
    eagle.app.v6.ld
    eagle.rom.addr.v6.ld
kaa/
    &lt;put Kaa SDK here&gt; --&gt; replaced with new SDK with log and configuration schema
user/
    user_main.c
src/
    kaa_demo.c --&gt; replaced with new code from ""Your First Kaa Application""
</code></pre>

<p>I then replaced this code into my kaa_demo.c file:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;time.h&gt;
#include &lt;kaa/kaa.h&gt;
#include &lt;kaa/platform/kaa_client.h&gt;
#include &lt;kaa/kaa_error.h&gt;
#include &lt;extensions/configuration/kaa_configuration_manager.h&gt;
#include &lt;extensions/logging/kaa_logging.h&gt;
#include &lt;kaa/gen/kaa_logging_gen.h&gt;
#include &lt;kaa/platform/kaa_client.h&gt;
#include &lt;kaa/utilities/kaa_log.h&gt;
#include &lt;kaa/platform-impl/common/ext_log_upload_strategies.h&gt;

static int32_t sample_period;
static time_t  last_sample_time;
extern kaa_error_t ext_unlimited_log_storage_create(void **log_storage_context_p, kaa_logger_t *logger);
/* Retrieves current temperature. */
static int32_t get_temperature_sample(void)
{
    /* For the sake of example, random data is used */
    return rand() % 10 + 25;
}
/* Periodically called by Kaa SDK. */
static void example_callback(void *context)
{
    time_t current_time = time(NULL);
    /* Respect sample period */
    if (difftime(current_time, last_sample_time) &gt;= sample_period) {
        int32_t temperature = get_temperature_sample();
        printf(""Sampled temperature: %i\n"", temperature);
        last_sample_time = current_time;
        kaa_user_log_record_t *log_record = kaa_logging_data_collection_create();
        log_record-&gt;temperature = temperature;
        kaa_logging_add_record(kaa_client_get_context(context)-&gt;log_collector, log_record, NULL);
    }
}
/* Receives new configuration data. */
static kaa_error_t on_configuration_updated(void *context, const kaa_root_configuration_t *conf)
{
    (void) context;
    printf(""Received configuration data. New sample period: %i seconds\n"", conf-&gt;sample_period);
    sample_period = conf-&gt;sample_period;
    return KAA_ERR_NONE;
}
int main(void)
{
    /* Init random generator used to generate temperature */
    srand(time(NULL));
    /* Prepare Kaa client. */
    kaa_client_t *kaa_client = NULL;
    kaa_error_t error = kaa_client_create(&amp;kaa_client, NULL);
    if (error) {
        return EXIT_FAILURE;
    }
    /* Configure notification manager. */
    kaa_configuration_root_receiver_t receiver = {
        .context = NULL,
        .on_configuration_updated = on_configuration_updated
    };
    error = kaa_configuration_manager_set_root_receiver(
        kaa_client_get_context(kaa_client)-&gt;configuration_manager,
        &amp;receiver);
    if (error) {
        return EXIT_FAILURE;
    }
    /* Obtain default configuration shipped within SDK. */
    const kaa_root_configuration_t *dflt = kaa_configuration_manager_get_configuration(
        kaa_client_get_context(kaa_client)-&gt;configuration_manager);
    printf(""Default sample period: %i seconds\n"", dflt-&gt;sample_period);
    sample_period = dflt-&gt;sample_period;

    /* Configure data collection. */
    void *log_storage_context         = NULL;
    void *log_upload_strategy_context = NULL;
    /* The internal memory log storage distributed with Kaa SDK. */
    error = ext_unlimited_log_storage_create(&amp;log_storage_context,
        kaa_client_get_context(kaa_client)-&gt;logger);
    if (error) {
        return EXIT_FAILURE;
    }
    /* Create a strategy based on timeout. */
    error = ext_log_upload_strategy_create(
        kaa_client_get_context(kaa_client), &amp;log_upload_strategy_context,
        KAA_LOG_UPLOAD_BY_TIMEOUT_STRATEGY);
    if (error) {
        return EXIT_FAILURE;
    }
    /* Strategy will upload logs every 5 seconds. */
    error = ext_log_upload_strategy_set_upload_timeout(log_upload_strategy_context, 5);
    if (error) {
        return EXIT_FAILURE;
    }
    /* Specify log bucket size constraints. */
    kaa_log_bucket_constraints_t bucket_sizes = {
         .max_bucket_size       = 32,   /* Bucket size in bytes. */
         .max_bucket_log_count  = 2,    /* Maximum log count in one bucket. */
    };
    /* Initialize the log storage and strategy (by default, they are not set). */
    error = kaa_logging_init(kaa_client_get_context(kaa_client)-&gt;log_collector,
        log_storage_context, log_upload_strategy_context, &amp;bucket_sizes);
    if (error) {
        return EXIT_FAILURE;
    }

    /* Start Kaa SDK's main loop. example_callback is called once per second. */
    error = kaa_client_start(kaa_client, example_callback, kaa_client, 1);
    /* Should get here only after Kaa stops. */
    kaa_client_destroy(kaa_client);

    if (error) {
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}
</code></pre>

<p>I left the CMakeLists.txt file the same:</p>

<pre><code>cmake_minimum_required(VERSION 3.0.2)

project(kaa_demo C)

# Add Kaa SDK directory
add_subdirectory(kaa)

# Add source files
add_library(kaa_demo_s STATIC user/user_main.c driver/uart.c src/kaa_demo.c)

set(CMAKE_C_FLAGS ""${CMAKE_C_FLAGS} -std=c99"")

if(NOT DEFINED ESP_RTOS_SDK)
    set(ESP_RTOS_SDK /opt/Espressif/esp-rtos-sdk)
endif()

# specify include directories
target_include_directories(kaa_demo_s PUBLIC driver)
target_include_directories(kaa_demo_s PUBLIC .)
target_include_directories(kaa_demo_s PUBLIC
                           ${ESP_RTOS_SDK}/extra_include
                           ${ESP_RTOS_SDK}/include
                           ${ESP_RTOS_SDK}/include/lwip
                           ${ESP_RTOS_SDK}/include/lwip/ipv4
                           ${ESP_RTOS_SDK}/include/lwip/ipv6
                           ${ESP_RTOS_SDK}/include/espressif/
                           )

exec_program(xtensa-lx106-elf-gcc .
            ARGS -print-libgcc-file-name
            OUTPUT_VARIABLE ESP8266_LIBGCC
            )

link_directories(${CMAKE_CURRENT_SOURCE_DIR}/ld)

target_link_libraries(kaa_demo_s PUBLIC
                      kaac
                      ${ESP_RTOS_SDK}/lib/libfreertos.a
                      ${ESP_RTOS_SDK}/lib/libhal.a
                      ${ESP_RTOS_SDK}/lib/libpp.a
                      ${ESP_RTOS_SDK}/lib/libphy.a
                      ${ESP_RTOS_SDK}/lib/libnet80211.a
                      ${ESP_RTOS_SDK}/lib/libwpa.a
                      ${ESP_RTOS_SDK}/lib/liblwip.a
                      ${ESP_RTOS_SDK}/lib/libmain.a
                      ${ESP_RTOS_SDK}/lib/libssl.a
                      ${ESP_RTOS_SDK}/lib/libhal.a
                      ${ESP8266_LIBGCC}
                      -Teagle.app.v6.ld
                      )

file(WRITE ${CMAKE_BINARY_DIR}/blank.c """")
add_executable(kaa_demo ${CMAKE_BINARY_DIR}/blank.c)

target_link_libraries(kaa_demo kaa_demo_s)
</code></pre>

<p>I left the user_main.c file the same:</p>

<pre><code>#include &lt;freertos/FreeRTOS.h&gt;
#include &lt;freertos/task.h&gt;

#include ""uart.h""

extern int main(void);

static void main_task(void *pvParameters)
{
    (void)pvParameters;
    main();
    for (;;);
}

void user_init(void)
{
    uart_init_new();
    UART_SetBaudrate(UART0, 115200);
    UART_SetPrintPort(UART0);

    portBASE_TYPE error = xTaskCreate(main_task, ""main_task"", 512, NULL, 2, NULL );
    if (error &lt; 0) {
        printf(""Error creating main_task! Error code: %ld\r\n"", error);
    }
}
</code></pre>

<p>I left eagle.app.v6.ld (except for the modification described in the beginning) and eagle.rom.addr.ld, uart.h, and uart.c the same (obtained from github)</p>

<p>So when I change to the build directory and run this cmake command:</p>

<pre><code>cmake \
-DCMAKE_TOOLCHAIN_FILE=../kaa/toolchains/esp8266.cmake \
-DKAA_PLATFORM=esp8266 \
-DCMAKE_BUILD_TYPE=MinSizeRel \
-DWITH_EXTENSION_CONFIGURATION=OFF \
-DWITH_EXTENSION_EVENT=OFF \
-DWITH_EXTENSION_LOGGING=OFF \
-DWITH_EXTENSION_NOTIFICATION=OFF \
-DWITH_EXTENSION_USER=OFF \
-DWITH_ENCRYPTION=OFF \
-DKAA_MAX_LOG_LEVEL=3 ..
</code></pre>

<p>I get this: (esp8266 is my username, kaa-app is the main directory that contains: CMakeLists.txt, build, drivers, etc.)</p>

<pre><code>-- Default SDK location will be used: /opt/Espressif/esp-rtos-sdk
-- Toolchain path: /opt/Espressif/crosstool-NG/builds/xtensa-lx106-elf
-- ESP8266 SDK path: /opt/Espressif/esp-rtos-sdk
==================================
BUILD_TYPE = MinSizeRel
KAA_PLATFORM = esp8266
KAA_MAX_LOG_LEVEL = 3
==================================
BOOTSTRAP ENABLED
PROFILE ENABLED
KAA WILL BE INSTALLED TO /usr/local
-- Could NOT find Doxygen (missing: DOXYGEN_EXECUTABLE)
-- Configuring done
-- Generating done
-- Build files have been written to: /home/esp8266/Documents/kaa-app/build
</code></pre>

<p>So then I run make, and I get this error:</p>

<pre><code>libkaa_demo_s.a(kaa_demo2.c.obj):(.text.example_callback+0x8): undefined reference to `time'
libkaa_demo_s.a(kaa_demo2.c.obj):(.text.example_callback+0xc): undefined reference to `difftime'
libkaa_demo_s.a(kaa_demo2.c.obj):(.text.example_callback+0x20): undefined reference to `kaa_logging_add_record'
libkaa_demo_s.a(kaa_demo2.c.obj): In function `example_callback':
kaa_demo2.c:(.text.example_callback+0x35): undefined reference to `time'
kaa_demo2.c:(.text.example_callback+0x42): undefined reference to `difftime'
kaa_demo2.c:(.text.example_callback+0x9e): undefined reference to `kaa_logging_add_record'
libkaa_demo_s.a(kaa_demo2.c.obj):(.text.startup.main+0x10): undefined reference to `srand'
libkaa_demo_s.a(kaa_demo2.c.obj):(.text.startup.main+0x14): undefined reference to `kaa_configuration_manager_set_root_receiver'
libkaa_demo_s.a(kaa_demo2.c.obj):(.text.startup.main+0x18): undefined reference to `kaa_configuration_manager_get_configuration'
libkaa_demo_s.a(kaa_demo2.c.obj):(.text.startup.main+0x1c): undefined reference to `ext_unlimited_log_storage_create'
libkaa_demo_s.a(kaa_demo2.c.obj):(.text.startup.main+0x20): undefined reference to `ext_log_upload_strategy_create'
libkaa_demo_s.a(kaa_demo2.c.obj):(.text.startup.main+0x24): undefined reference to `ext_log_upload_strategy_set_upload_timeout'
libkaa_demo_s.a(kaa_demo2.c.obj):(.text.startup.main+0x28): undefined reference to `kaa_logging_init'
libkaa_demo_s.a(kaa_demo2.c.obj):(.text.startup.main+0x3a): undefined reference to `time'
libkaa_demo_s.a(kaa_demo2.c.obj):(.text.startup.main+0x40): undefined reference to `srand'
libkaa_demo_s.a(kaa_demo2.c.obj): In function `main':
kaa_demo2.c:(.text.startup.main+0x69): undefined reference to `kaa_configuration_manager_set_root_receiver'
kaa_demo2.c:(.text.startup.main+0x7b): undefined reference to `kaa_configuration_manager_get_configuration'
kaa_demo2.c:(.text.startup.main+0xa5): undefined reference to `ext_unlimited_log_storage_create'
kaa_demo2.c:(.text.startup.main+0xb8): undefined reference to `ext_log_upload_strategy_create'
kaa_demo2.c:(.text.startup.main+0xc5): undefined reference to `ext_log_upload_strategy_set_upload_timeout'
kaa_demo2.c:(.text.startup.main+0xe6): undefined reference to `kaa_logging_init'
collect2: error: ld returned 1 exit status
CMakeFiles/kaa_demo.dir/build.make:120: recipe for target 'kaa_demo' failed
make[2]: *** [kaa_demo] Error 1
CMakeFiles/Makefile2:107: recipe for target 'CMakeFiles/kaa_demo.dir/all' failed
make[1]: *** [CMakeFiles/kaa_demo.dir/all] Error 2
Makefile:127: recipe for target 'all' failed
make: *** [all] Error 2
</code></pre>

<p>So it seems that when it tries linking the files it cannot find the new headers I included:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;time.h&gt;
#include &lt;kaa/kaa.h&gt;
#include &lt;kaa/platform/kaa_client.h&gt;
#include &lt;kaa/kaa_error.h&gt;
#include &lt;extensions/configuration/kaa_configuration_manager.h&gt;
#include &lt;extensions/logging/kaa_logging.h&gt;
#include &lt;kaa/gen/kaa_logging_gen.h&gt;
#include &lt;kaa/platform/kaa_client.h&gt;
#include &lt;kaa/utilities/kaa_log.h&gt;
#include &lt;kaa/platform-impl/common/ext_log_upload_strategies.h&gt;
</code></pre>

<p>However, the target directory that is included in CMakeLists.txt contains the header files that I need (for the C headers):</p>

<pre><code>${ESP_RTOS_SDK}/extra_include
</code></pre>

<p>So I really do not know what I need to add or modify, I am completely stuck. Any help would be much appreciated! Thanks!</p>
"
"<p>The title line of this post is really only one half (the simpler half) of my question. So, I'll step back a moment to talk about what I'm trying to do.</p>

<p>It's pretty easy to measure elapsed time with <code>std::chrono</code>. However, I haven't seen any ""Timer"" implementations thus far that would do the equivalent of laps on a stopwatch. That is to say, you call <code>Timer.start()</code> when you want to start tracking intervals, and call <code>Timer.tick()</code> every time you want to record an interval. Then, after the fast stuff is over, you could look back on the list of time intervals recorded; maybe account for averages and 1% highs or something.</p>

<p>Also, because I use it a lot, I'd want to arbitrarily ask the timer how many microseconds have elapsed since midnight.</p>

<p>The first task for a constructor for this imaginary class would be to set midnight internally. Initially, I was doing this via the technique from <a href=""https://stackoverflow.com/a/11123391/1464937"">this</a> wonderful answer. As I went to implement my notion of a <code>Timer</code> class, though, I realized I wanted to use either <code>high_resolution_clock</code> or <code>steady_clock</code> (even though <code>system_clock</code> uses nanosecond intervals on my platform). The issue then arises: how to set a <code>chrono::steady_clock::time_point</code> to midnight?</p>

<p>Only <code>system_clock</code> has <code>to_time_t</code> and <code>from_time_t</code>, and in so far as I can tell, that's the only way to express ""today at midnight"" in a way that <code>chrono</code> understands. And for all my reading last night, I couldn't find a way to cast a <code>system_clock::time_point</code> to a <code>steady_clock::time_point</code>. My nearest attempt was:</p>

<pre><code>typedef std::conditional&lt;std::chrono::high_resolution_clock::is_steady,
                         std::chrono::high_resolution_clock,
                         std::chrono::steady_clock&gt;::type TimerClock;

TimerClock::time_point midnight;

chrono::system_clock::time_point current_time = chrono::system_clock::now();

time_t raw_time = chrono::system_clock::to_time_t(current_time);

tm *tm_midnight = localtime(&amp;raw_time);
tm_midnight-&gt;tm_hour = 0;
tm_midnight-&gt;tm_min  = 0;
tm_midnight-&gt;tm_sec  = 0;

midnight = chrono::system_clock::from_time_t(mktime(tm_midnight));
</code></pre>

<p>But obviously that won't fly. And in so far as I can tell, <code>chrono::time_point_cast</code> is designed to give you access to different resolutions from the same clock type.</p>

<p>This leaves me with two routes/questions:</p>

<ul>
<li>Can I directly set the value of a <code>time_point</code> from <code>high_precision_clock</code> or <code>steady_clock</code> to be ""today at midnight""</li>
<li>Can I convert a <code>system_clock::time_point</code> to be used with a different <code>chrono</code> clock?</li>
</ul>

<p>And, of course, I'd be happy to be pointed to a better method of dealing with this all together, if it still lines up with my overall goals above.</p>

<p>Thanks in advance. =)</p>
"
"<p>I am working on a project which receives requests through an API and adds them to a FIFO. I want to be able to log the number of requests received (added on the queue) and the number of requests processed (removed from the queue). At the moment I am trying to the request received a second average. </p>

<p>I am doing this by having an array of longs containing 60 elements, each element will store the number of requests received in that second. </p>

<p>I am doing this using the following:</p>

<pre><code>if (fifo-&gt;enqueue(crashInfo))
    {
        this-&gt;requestProcessMutex.lock();
        this-&gt;currentRequestsASecond++; //Used to get the total requests a second
        this-&gt;requestProcessMutex.unlock();
        cout &lt;&lt; ""Current Requests Incremented to "" &lt;&lt; this-&gt;currentRequestsASecond &lt;&lt; endl;
        return true;
    }
    else
    {
        return false;
    }
</code></pre>

<p>From the above code the cout is showing that the counter is being incremented and then reset to 0 as expected each second. </p>

<p>To add the requests a second to the array I do the following, I also log out every 10 seconds what the current average is. </p>

<pre><code>void FIFOManager::processRequestsSecondArray()
{
    int counter = 0;
    time_t lastLoggedTime = std::time(NULL);
    while (this-&gt;bitsLibrary-&gt;getApplicationStatus() != StatusManager::ApplicationStatus::Stopping)
    {

        this-&gt;requestProcessMutex.lock();
        time_t current_time = std::time(NULL);
        long timeDiff = current_time - lastLoggedTime;
        if (timeDiff &gt;= 10) //Only log every 10 seconds
        {
            stringstream logstream;
            logstream &lt;&lt; this-&gt;getAverageRequestProcessTime(AverageRetrievalType::RequestsASec) &lt;&lt; "" requests received a second"";
            this-&gt;bitsLibrary-&gt;writeToLog(logstream.str(), ""FIFOManager"", ""processRequestsSecondArray"");
            lastLoggedTime = std::time(NULL);
        }
        requestsASecondForAMinute[counter] = this-&gt;currentRequestsASecond;

        cout &lt;&lt; ""ADDING REQUEST COUNTER VALUE "" &lt;&lt; this-&gt;currentRequestsASecond &lt;&lt; "" AT "" &lt;&lt; counter &lt;&lt; endl;
        if (counter &lt; 59)
        {
            counter++;
        }
        else
        {
            counter = 0; //Only storing a minutes worth (60 secondS) so reset and start to overwrite
        }
        this-&gt;requestProcessMutex.unlock();
        this_thread::sleep_for(chrono::seconds(1));
        this-&gt;requestProcessMutex.lock();
        this-&gt;currentRequestsASecond = 0;
        this-&gt;requestProcessMutex.unlock();
    }
}
</code></pre>

<p>The <code>processRequestsSecondArray</code> is in array which sleeps for 1 second, at each second should store the value of <code>currentRequestsASecond</code> into the array at the current second element, each minute it wraps and overwrites through the array. </p>

<p>The output of <code>ADDING REQUEST COUNTER VALUE</code> is always stating that it is adding <code>0</code> but <code>currentRequestsASecond</code> doesn't get reset to 0 until after the sleep has occurred so what am I doing wrong?</p>
"
"<p>What would be the best way to add a chronometer because this type of chronometer that I invented makes my game snake advance in 1 second and its really slow</p>

<pre><code>void timer()
{
    int g = 1;
    int h = 0;
    while (g != 0)
    {

    Sleep(1000);
    h = h + 1;
    gotoxy(50, 1); printf(""Tiempo: %d"",h);
    }

}
</code></pre>
"
"<p>I did encryption on my android phone, the encryption was successful (confirmed from logcat).
now the system reboots normally, once it completes boot up, system asked me for disk password to decrypt the userdata.</p>

<p>I entered the disc password and system reboots :O , asking me disk password again. The ideal condition should be device loads the decrypted userdata.</p>

<p>On Checking the last_kmsg logs, it shows kernel panic.  How do I analyse the kernel logs?</p>

<p>below are the kernel panic situation logs,</p>

<pre><code>    [   65.969569] WARNING: at kernel/arch/arm/mach-msm/msm-pm.c:837 msm_pm_wait_cpu_shutdown+0xb0/0xd0()

[   65.981686] ---[ end trace 39b994bb8aed4d13 ]---
[   66.303908] init: untracked pid 962 exited
[   66.402400] check_dsi_ctrl_status: rohi:  check_dsi_ctrl_status  IN
[   66.407913] Unable to handle kernel NULL pointer dereference at virtual address 000000d4
[   66.418851] pgd = c0004000
[   66.421101] [000000d4] *pgd=00000000
[   66.425927] Internal error: Oops: 17 [#1] PREEMPT SMP ARM
[   66.430445] Modules linked in:
[   66.433416] CPU: 0    Tainted: G        W     (3.4.0-gc5da25d-00089-g25d4b28-dirty #2)
[   66.441406] PC is at check_dsi_ctrl_status+0x54/0x1bc
[   66.446349] LR is at check_dsi_ctrl_status+0x14/0x1bc

[   66.451383] pc : [&lt;c03fc68c&gt;]    lr : [&lt;c03fc64c&gt;]    psr: a0000013

[   66.451387] sp : f606ff48  ip : f606fe16  fp : f5422d90

[   66.462914] r10: 00000000  r9 : c03fc638  r8 : f6288010

[   66.468050] r7 : f6289000  r6 : 00000000  r5 : f6288028  r4 : f5422d8c

[   66.474631] r3 : f5b6b2d0  r2 : c03de2a8  r1 : c0c9f75d  r0 : 0000004c

[   66.481072] Flags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment kernel

[   66.488438] Control: 10c5787d  Table: 34c5c06a  DAC: 00000015

[   66.494091]

[   66.494093] PC: 0xc03fc60c:

[   66.498416] c60c  e59f1014 01a02003 e5963004 eb156f8b e1a00004 e8bd807c c0c9f63f c0a3ba78

[   66.506499] c62c  c0cdf6f9 c0cc6736 c0c9f660 e92d41f3 e1a04000 e59f1184 e59f0184 eb156f7f

[   66.514658] c64c  e354000c 059f017c 0a00001e e5943044 e5932118 e592506c e3550000 059f0168

[   66.522819] c66c  0a000018 e5152008 e2458018 e3520000 059f0158 0a000013 e5937288 e5976048

[   66.530979] c68c  e59600d4 e3500000 0a000000 eb15aa29 e2877020 e1a00007 eb15aa26 e5943044

[   66.539139] c6ac  e5d3139c e3510000 0a000009 e1a00007 eb15a947 e59600d4 e3500000 0a000000

[   66.547298] c6cc  eb15a943 e59f0108 e59f10f0 eb156f5b ea000039 e5963124 e3530000 0a000001

[   66.555457] c6ec  e1a00006 e12fff33 e59f00e8 e1d032ba e3130004 0a000003 e2800018 e59f10d8

[   66.563619]

[   66.563622] LR: 0xc03fc5cc:

[   66.567871] c5cc  e3a04000 ea000011 e5d45000 e3a02000 e3550000 03a05007 13a05008 e1a01005

[   66.576031] c5ec  ebfff2f6 e2504000 0afffff4 e59f302c e3550008 e58d4000 e59f2024 e59f0024

[   66.584190] c60c  e59f1014 01a02003 e5963004 eb156f8b e1a00004 e8bd807c c0c9f63f c0a3ba78

[   66.592350] c62c  c0cdf6f9 c0cc6736 c0c9f660 e92d41f3 e1a04000 e59f1184 e59f0184 eb156f7f

[   66.600509] c64c  e354000c 059f017c 0a00001e e5943044 e5932118 e592506c e3550000 059f0168

[   66.608670] c66c  0a000018 e5152008 e2458018 e3520000 059f0158 0a000013 e5937288 e5976048

[   66.616829] c68c  e59600d4 e3500000 0a000000 eb15aa29 e2877020 e1a00007 eb15aa26 e5943044

[   66.624989] c6ac  e5d3139c e3510000 0a000009 e1a00007 eb15a947 e59600d4 e3500000 0a000000

[   66.633151]

[   66.633153] SP: 0xf606fec8:

[   66.637402] fec8  205b0000 36362020 3230342e 5d303034 00000020 c03fc68c a0000013 ffffffff

[   66.645562] fee8  f606ff34 f6288010 c03fc638 00000000 f5422d90 c0968fd8 0000004c c0c9f75d

[   66.653725] ff08  c03de2a8 f5b6b2d0 f5422d8c f6288028 00000000 f6289000 f6288010 c03fc638

[   66.661881] ff28  00000000 f5422d90 f606fe16 f606ff48 c03fc64c c03fc68c a0000013 ffffffff

[   66.670041] ff48  f5422d8c f5422d8c f6021fc0 f5422d8c ce45c900 ce462c00 ce45ca18 c01af4a8

[   66.678202] ff68  f6021fc0 00000001 00000000 f6021fc0 ce45ca18 f606e000 c16c5319 ce45c900

[   66.686361] ff88  ce45ca18 f6021fd0 00000009 c01af858 00000000 f6059edc f6021fc0 c01af6d4

[   66.694520] ffa8  00000013 00000000 00000000 00000000 00000000 c01b3f34 f6059edc 00000000

[   66.702683]

[   66.702685] IP: 0xf606fd96:

[   66.706936] fd94  00000017 00000000 c0109c60 00000000 0000000b 000000d4 00000017 00000000

[   66.715093] fdb4  f606ff00 00000017 c0957bf4 f6050f00 c096a9bc 00ac005a f61fd800 f606fdf8

[   66.723253] fdd4  00000000 00000000 c5b41000 0001116b 0000000c f606fe3c c06da00c 00000000

[   66.731412] fdf4  00000080 001d00f3 00ec0097 00b30073 00a6005c 00a900c9 00d10093 006500d8

[   66.739573] fe14  00ad009f 00000046 f61fd800 f61fd800 0001116b 00000046 c03fc68c f606ff00

[   66.747731] fe34  00000017 000000d4 c102bd98 00000007 c102bd28 f5422d90 c01003b4 00016d23

[   66.755892] fe54  00000000 c1055500 00000001 00000001 f606e000 f606fe7c c096ac54 60000093

[   66.764051] fe74  00016d23 c1055488 c0968cc8 c1055488 c0197f44 ffffffff 00000001 0000000f

[   66.772211] fe94  0000004c 00000003 c178528f 00000009 c1055488 60000013 c0198458 00000000

[   66.780371]

[   66.780373] FP: 0xf5422d10:

[   66.784626] 2d10  f5422d10 f5422d10 c047bb08 c047bb50 00000000 00000000 00000000 00000000

[   66.792784] 2d30  00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000

[   66.800943] 2d50  f5422d50 f5422d50 f5b6d000 f5435400 00000000 00000000 00000000 00000000

[   66.809103] 2d70  00000000 00000000 00000000 00000000 c03fc7f4 c4c37a58 00000000 00000000

[   66.817263] 2d90  f5422d90 f5422d90 c03fc638 00000000 00200200 ffffa4be c17a5880 c01b00a4

[   66.825425] 2db0  f5422d8c ffffffff ffffffff 00000000 00000000 00000000 00000000 00000000

[   66.833583] 2dd0  f5b6b2d0 00001388 00000000 00000000 00000000 00000000 00000000 00000000

[   66.841742] 2df0  00000000 00000000 00000000 00000000 f5401380 c4c4a504 f6121f40 f6121f58

[   66.849903]

[   66.849905] R1: 0xc0c9f6dd:

[   66.854156] f6dc  725f6266 73696765 5f726574 65696c63 6620746e 656c6961 72202c64 72757465

[   66.862316] f6fc  2064656e 68746977 3d637220 000a6425 253e363c 44203a73 73204953 75746174

[   66.870477] f71c  68632073 206b6365 65746e69 6c617672 0a64253a 3a732500 49534420 72746320

[   66.878633] f73c  7473206c 73757461 726f7720 7571206b 20657565 74696e69 696c6169 0a64657a

[   66.886794] f75c  3e333c00 203a7325 69686f72 6320203a 6b636568 6973645f 7274635f 74735f6c

[   66.894955] f77c  73757461 4e492020 3e333c00 723a7325 3a69686f 49534420 61747320 20737574

[   66.903116] f79c  61746164 746f6e20 61766120 62616c69 000a656c 253e333c 72203a73 3a69686f

[   66.911276] f7bc  6e615020 64206c65 20617461 20746f6e 69617661 6c62616c 3c000a65 73253e33

[   66.919430] f7dc  6f72203a 3a206968 49534420 72746320 726f206c 61747320 5f737574 63656863

[   66.927596]

[   66.927598] R2: 0xc03de228:

[   66.931847] e228  ebf6d211 eaffffff e1a00000 eaffffff e1a00000 e3500000 e5876110 0a000001

[   66.940005] e248  f57ff04f f57ff06f e5944260 e3a00002 e2841004 ebf6d204 eaffffff e1a00000

[   66.948163] e268  eaffffff e1a00000 e3500000 e5845004 0a000001 f57ff04f f57ff06f f57ff04f

[   66.956328] e288  e8bd80f8 c0c955ca c0a38788 c16cffe8 c0c966f1 00200002 02200202 c17fb6f8

[   66.964484] e2a8  e92d4070 e2504000 1a000004 e59f011c e1a05004 e59f1118 eb15e861 ea000041

[   66.972645] e2c8  e59f0110 e300311a e19030b3 e3130004 0a000003 e2800f42 e59f10fc e59f20f0

[   66.980804] e2e8  ebff265b e2845d11 e1a00004 e3a01001 e2855004 eb001403 e1a00005 eb162a93

[   66.988965] e308  e3a03000 e1a06000 e3a01002 e1a00004 e5843418 ebfffaca e1a00005 e1a01006

[   66.997126]

[   66.997128] R3: 0xf5b6b250:

[   67.001378] b250  f5419bc0 00000000 00000000 00000000 00000000 00000000 00000000 00000000

[   67.009539] b270  00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000

[   67.017698] b290  00000000 00000000 00000000 00000000 c165b998 00000000 f5434200 00000001

[   67.025855] b2b0  c7000000 00000000 c165b9fc 00000000 00000000 f5b6b2d0 00000000 00000000

[   67.034015] b2d0  11161126 00000000 00000000 00000002 00080000 f6288028 00000000 00000000

[   67.042177] b2f0  00000000 00000000 f5b6b000 000007d0 ce480c05 f5b6b304 f5b6b304 c03f88b8

[   67.050336] b310  f602e1cc f602e1cc ffffa536 f602e000 c01b00a4 f5b6b300 ffffffff ffffffff

[   67.058498] b330  00000000 00000000 00000000 00000000 00000000 00000001 0000000d 00000000

[   67.066658]

[   67.066660] R4: 0xf5422d0c:

[   67.070982] 2d0c  ffffffff f5422d10 f5422d10 c047bb08 c047bb50 00000000 00000000 00000000

[   67.079071] 2d2c  00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000

[   67.087231] 2d4c  00000000 f5422d50 f5422d50 f5b6d000 f5435400 00000000 00000000 00000000

[   67.095387] 2d6c  00000000 00000000 00000000 00000000 00000000 c03fc7f4 c4c37a58 00000000

[   67.103546] 2d8c  00000000 f5422d90 f5422d90 c03fc638 00000000 00200200 ffffa4be c17a5880

[   67.111706] 2dac  c01b00a4 f5422d8c ffffffff ffffffff 00000000 00000000 00000000 00000000

[   67.119867] 2dcc  00000000 f5b6b2d0 00001388 00000000 00000000 00000000 00000000 00000000

[   67.128028] 2dec  00000000 00000000 00000000 00000000 00000000 f5401380 c4c4a504 f6121f40

[   67.136188]

[   67.136190] R5: 0xf6287fa8:

[   67.140514] 7fa8  aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa

[   67.148599] 7fc8  aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa

[   67.156759] 7fe8  aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa f6386e00 f612a3a8

[   67.164922] 8008  c0481904 00000000 00000000 c03e1248 c03e11a0 00000000 c03de2a8 c03df418

[   67.173080] 8028  00000438 00000780 00000000 00000000 00000018 00000008 00000000 00000000

[   67.181237] 8048  000000ff 000000ff 00000000 00000000 33c11dc0 00000000 00000000 00000000

[   67.189400] 8068  00000000 00000000 00000000 00000002 00000001 00000014 00000000 00000000

[   67.197559] 8088  00000000 00000000 00000000 00000000 00000004 00000000 00000000 00000000

[   67.205720]

[   67.205723] R7: 0xf6288f80:

[   67.209971] 8f80  aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa

[   67.218131] 8fa0  aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa

[   67.226292] 8fc0  aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa

[   67.234449] 8fe0  aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa

[   67.242612] 9000  08e57817 0000000f f5419c00 00000000 00000001 00000001 f5419d40 f5b4bc10

[   67.250770] 9020  00000001 0f9a0f9a dead4ead ffffffff ffffffff f6289034 f6289034 00000000

[   67.258932] 9040  00000000 f6289020 00000000 00000000 00000000 00000000 f6289058 f6289058

[   67.267091] 9060  f6289060 f6289060 f6289068 f6289068 00000000 00000000 00a00000 00870000

[   67.275250]

[   67.275252] R8: 0xf6287f90:

[   67.279504] 7f90  aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa

[   67.287663] 7fb0  aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa

[   67.295823] 7fd0  aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa

[   67.303982] 7ff0  aaaaaaaa aaaaaaaa aaaaaaaa aaaaaaaa f6386e00 f612a3a8 c0481904 00000000

[   67.312141] 8010  00000000 c03e1248 c03e11a0 00000000 c03de2a8 c03df418 00000438 00000780

[   67.320303] 8030  00000000 00000000 00000018 00000008 00000000 00000000 000000ff 000000ff

[   67.328461] 8050  00000000 00000000 33c11dc0 00000000 00000000 00000000 00000000 00000000

[   67.336621] 8070  00000000 00000002 00000001 00000014 00000000 00000000 00000000 00000000

[   67.344782]

[   67.344784] R9: 0xc03fc5b8:

[   67.349033] c5b8  eb156fa3 ea000016 eb020a43 e2506000 1a000001 e3a04000 ea000011 e5d45000

[   67.357195] c5d8  e3a02000 e3550000 03a05007 13a05008 e1a01005 ebfff2f6 e2504000 0afffff4

[   67.365356] c5f8  e59f302c e3550008 e58d4000 e59f2024 e59f0024 e59f1014 01a02003 e5963004

[   67.373514] c618  eb156f8b e1a00004 e8bd807c c0c9f63f c0a3ba78 c0cdf6f9 c0cc6736 c0c9f660

[   67.381674] c638  e92d41f3 e1a04000 e59f1184 e59f0184 eb156f7f e354000c 059f017c 0a00001e

[   67.389834] c658  e5943044 e5932118 e592506c e3550000 059f0168 0a000018 e5152008 e2458018

[   67.397992] c678  e3520000 059f0158 0a000013 e5937288 e5976048 e59600d4 e3500000 0a000000

[   67.406152] c698  eb15aa29 e2877020 e1a00007 eb15aa26 e5943044 e5d3139c e3510000 0a000009

[   67.414314] Process kworker/0:0 (pid: 4, stack limit = 0xf606e2f0)

[   67.420549] Stack: (0xf606ff48 to 0xf6070000)

[   67.424820] ff40:                   f5422d8c f5422d8c f6021fc0 f5422d8c ce45c900 ce462c00

[   67.433051] ff60: ce45ca18 c01af4a8 f6021fc0 00000001 00000000 f6021fc0 ce45ca18 f606e000

[   67.441141] ff80: c16c5319 ce45c900 ce45ca18 f6021fd0 00000009 c01af858 00000000 f6059edc

[   67.449373] ffa0: f6021fc0 c01af6d4 00000013 00000000 00000000 00000000 00000000 c01b3f34

[   67.457532] ffc0: f6059edc 00000000 f6021fc0 00000000 00000000 dead4ead ffffffff ffffffff

[   67.465691] ffe0: f606ffe0 f606ffe0 f6059edc c01b3eb4 c0106c24 c0106c24 00000000 00000000

[   67.473824] [&lt;c03fc68c&gt;] (check_dsi_ctrl_status+0x54/0x1bc) from [&lt;c01af4a8&gt;] (process_one_work+0x200/0x400)

[   67.483787] [&lt;c01af4a8&gt;] (process_one_work+0x200/0x400) from [&lt;c01af858&gt;] (worker_thread+0x184/0x2a4)

[   67.492922] [&lt;c01af858&gt;] (worker_thread+0x184/0x2a4) from [&lt;c01b3f34&gt;] (kthread+0x80/0x90)

[   67.501215] [&lt;c01b3f34&gt;] (kthread+0x80/0x90) from [&lt;c0106c24&gt;] (kernel_thread_exit+0x0/0x8)

[   67.509510] Code: 059f0158 0a000013 e5937288 e5976048 (e59600d4)

[   67.517435] ---[ end trace 39b994bb8aed4d14 ]---

[   67.521491] Kernel panic - not syncing: Fatal exception

[   67.526423] CPU3: stopping

[   67.529207] [&lt;c010c114&gt;] (unwind_backtrace+0x0/0x11c) from [&lt;c010af90&gt;] (handle_IPI+0x118/0x200)

[   67.538135] [&lt;c010af90&gt;] (handle_IPI+0x118/0x200) from [&lt;c0100578&gt;] (gic_handle_irq+0x100/0x10c)

[   67.546916] [&lt;c0100578&gt;] (gic_handle_irq+0x100/0x10c) from [&lt;c0969040&gt;] (__irq_svc+0x40/0x70)

[   67.555190] Exception stack(0xf4c8dd90 to 0xf4c8ddd8)

[   67.560425] dd80:                                     e4ceeda0 00000000 05480548 00000001

[   67.568587] dda0: cdf0e0a8 00000000 e4ceeda0 00000000 ffffffff 0000000c 00000000 00000000

[   67.576544] ddc0: f4c8c000 f4c8ddd8 c0968cf0 c0968cf4 60000013 ffffffff

[   67.583365] [&lt;c0969040&gt;] (__irq_svc+0x40/0x70) from [&lt;c0968cf4&gt;] (_raw_spin_unlock_irq+0xc/0x34)

[   67.592145] [&lt;c0968cf4&gt;] (_raw_spin_unlock_irq+0xc/0x34) from [&lt;c0220e28&gt;] (delete_from_page_cache+0x40/0x5c)

[   67.602032] [&lt;c0220e28&gt;] (delete_from_page_cache+0x40/0x5c) from [&lt;c022befc&gt;] (truncate_inode_page+0xa4/0xb4)

[   67.611933] [&lt;c022befc&gt;] (truncate_inode_page+0xa4/0xb4) from [&lt;c0234110&gt;] (shmem_truncate_range+0x130/0x3cc)

[   67.621615] [&lt;c0234110&gt;] (shmem_truncate_range+0x130/0x3cc) from [&lt;c023458c&gt;] (shmem_evict_inode+0x98/0x13c)

[   67.631628] [&lt;c023458c&gt;] (shmem_evict_inode+0x98/0x13c) from [&lt;c0270d58&gt;] (evict+0x8c/0x150)

[   67.640047] [&lt;c0270d58&gt;] (evict+0x8c/0x150) from [&lt;c026e46c&gt;] (shrink_dcache_for_umount_subtree+0x108/0x13c)
[   67.649862] [&lt;c026e46c&gt;] (shrink_dcache_for_umount_subtree+0x108/0x13c) from [&lt;c026e7fc&gt;] (shrink_dcache_for_umount+0x3c/0x4c)
[   67.661234] [&lt;c026e7fc&gt;] (shrink_dcache_for_umount+0x3c/0x4c) from [&lt;c025cff0&gt;] (generic_shutdown_super+0x1c/0xbc)
[   67.671554] [&lt;c025cff0&gt;] (generic_shutdown_super+0x1c/0xbc) from [&lt;c025d100&gt;] (kill_anon_super+0xc/0x18)
[   67.681008] [&lt;c025d100&gt;] (kill_anon_super+0xc/0x18) from [&lt;c025d228&gt;] (deactivate_locked_super+0x3c/0x68)
[   67.690562] [&lt;c025d228&gt;] (deactivate_locked_super+0x3c/0x68) from [&lt;c0275424&gt;] (sys_umount+0x318/0x330)
[   67.699750] [&lt;c0275424&gt;] (sys_umount+0x318/0x330) from [&lt;c0106120&gt;] (ret_fast_syscall+0x0/0x30)
[   69.718711] wcnss crash shutdown 0
[   69.721174] Rebooting in 5 seconds..
[   74.726167] Going down for restart now
[   74.729760] Calling SCM to disable SPMI PMIC arbiter


7 Corrected bytes, 0 unrecoverable blocks
</code></pre>
"
"<p>I'm trying to find the <strong>fastest</strong> way of moving <strong>large</strong> data from kernel to user space.
Right now I'm trying out GKH's debugfs, but I'm struggling to get the blob wrapper working.</p>

<p>This is what I got so far:</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/moduleparam.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/debugfs.h&gt;

MODULE_AUTHOR(""CREED0R"");
MODULE_LICENSE(""GPL"");


struct dentry *dfs;
struct debugfs_blob_wrapper *myblob;

int my_init(void)
{
    int stats[10];
    int i;

    for (i = 0; i &lt; 10; i++)
        stats[i] = i;

    myblob-&gt;data = (void *) stats;
    myblob-&gt;size = (unsigned long) 10;

    dfs = debugfs_create_blob(""test"", 0644, NULL, myblob);

    if (dfs == NULL) {
        printk(""Could not create debugfs blob\n"");
        return 1;
    }

    printk(""DebugFS file created\n"");

    return 0;
}


void my_exit(void)
{
    printk(""DebugFS file deleted\n\n"");
    debugfs_remove(dfs);
}


module_init(my_init);
module_exit(my_exit);
</code></pre>

<p>It builds, but if I run insmod my qemu instance dies horribly.</p>

<p>Not sure why that is. What am I missing?</p>
"
"<p>So I'm trying to write a kernel module that uses the linux/timer.h file. I got it to work inside just the module, and now I am trying to get it to work from a user program.</p>

<p>Here is my kernel module:</p>

<pre><code>//Necessary Includes For Device Drivers.
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;asm/uaccess.h&gt;
#include &lt;linux/timer.h&gt;
#include &lt;linux/ioctl.h&gt;

#define DEVICE_NAME ""mytimer""
#define DEVICE_FILE_NAME ""mytimer""
#define MAJOR_NUM 61
#define MINOR_NUM 0

MODULE_LICENSE(""Dual BSD/GPL"");

static struct timer_list my_timer;

struct file_operations FileOps =
{
    //No File Operations for this timer.
};

//Function to perform when timer expires.
void TimerExpire(int data)
{
    printk(""Timer Data: %d\n"", data);
}

//Function to set up timers.
void TimerSetup(void)
{
    setup_timer(&amp;my_timer, TimerExpire, 5678);
    mod_timer(&amp;my_timer, jiffies + msecs_to_jiffies(5000));
}

//Module Init and Exit Functions.
int init_module(void)
{
    int initResult = register_chrdev(MAJOR_NUM, ""mytimer"", &amp;FileOps);

    if (initResult &lt; 0)
    {
        printk(""Cannot obtain major number %d\n"", MAJOR_NUM);

        return initResult;
    }

printk(""Loading MyTimer Kernel Module...\n"");


return 0;
}
void cleanup_module(void)
{
    unregister_chrdev(MAJOR_NUM, ""mytimer"");
    printk(""Unloading MyTimer Kernel Module...\n"");
}
</code></pre>

<p>More specifically, I want my user program to call the TimerSetup() function. I know that I'll need to use ioctl() but I'm not sure how to specify in my MODULE FILE that TimerSetup() should be callable via ioctl().</p>

<p>Also, my second question: I was able to insmod my module and also mknod into /dev/mytimer with the correct major number. But when I tried to open() it so that I can get the file descriptor from it, it kept returning -1, which I'm assuming is wrong. I made sure the permissions were fine (in fact, I made it 777 just to be sure)... It still doesn't work... Is there something I'm missing?</p>

<p>Here is the user program just in case:</p>

<pre><code>#include &lt;stdio.h&gt;

int main(int argc, char* argv[])
{
    int fd = open(""/dev/mytimer"", ""r"");
    printf(""fd: %d\n"", fd);

    return 0;
}
</code></pre>
"
"<p>I made a google search about ""anonymous inode"" and it seems it's related to epoll ... but what actually is it?</p>
"
"<p>I wrote a small device driver for a ""coin"" device. I create an entry in /drivers/char/Kconfig
and corresponding Makefile, then selected built-in option in menuconfig. The kernel compiled fine (built-in.o file was created). But I still can't access the device (/dev/coin was not created) and there was no entry under /proc/devices.
Please help!!</p>

<p>I am cross-compiling for powerpc</p>

<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/random.h&gt;
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/init.h&gt;

#define DEVNAME ""coin""
#define LEN  20
enum values {HEAD, TAIL};

struct dentry *dir, *file;
int file_value;
int stats[2] = {0, 0};
char *msg[2] = {""head\n"", ""tail\n""};

static int major;
static struct class *class_coin;
static struct device *dev_coin;

static ssize_t r_coin(struct file *f, char __user *b,
                      size_t cnt, loff_t *lf)
{
        char *ret;
        u32 value = random32() % 2;
        ret = msg[value];
        stats[value]++;
        return simple_read_from_buffer(b, cnt,
                                       lf, ret,
                                       strlen(ret));
}

static struct file_operations fops = { .read = r_coin };

#ifdef CONFIG_COIN_STAT
static ssize_t r_stat(struct file *f, char __user *b,
                         size_t cnt, loff_t *lf)
{
        char buf[LEN];
        snprintf(buf, LEN, ""head=%d tail=%d\n"",
                 stats[HEAD], stats[TAIL]);
        return simple_read_from_buffer(b, cnt,
                                       lf, buf,
                                       strlen(buf));
}

static struct file_operations fstat = { .read = r_stat };
#endif

static int __init coin_init(void)
{
        void *ptr_err;
        major = register_chrdev(0, DEVNAME, &amp;fops);
        if (major &lt; 0)
                return major;

        class_coin = class_create(THIS_MODULE,
                                  DEVNAME);
        if (IS_ERR(class_coin)) {
                ptr_err = class_coin;
                goto err_class;
        }

        dev_coin = device_create(class_coin, NULL,
                                 MKDEV(major, 0),
                                 NULL, DEVNAME);
        if (IS_ERR(dev_coin))
                goto err_dev;

#ifdef CONFIG_COIN_STAT
        dir = debugfs_create_dir(""coin"", NULL);
        file = debugfs_create_file(""stats"", 0644,
                                   dir, &amp;file_value,
                                   &amp;fstat);
#endif

        return 0;
err_dev:
        ptr_err = class_coin;
        class_destroy(class_coin);
err_class:
        unregister_chrdev(major, DEVNAME);
        return PTR_ERR(ptr_err);
}

static void __exit coin_exit(void)
{
    #ifdef CONFIG_COIN_STAT
    debugfs_remove(file);
    debugfs_remove(dir);
    #endif

    device_destroy(class_coin, MKDEV(major, 0));
    class_destroy(class_coin);
    return unregister_chrdev(major, DEVNAME);
}

module_init(coin_init);
module_exit(coin_exit);
</code></pre>
"
"<p>I have a driver that is integrated with kernel and is creating a debug folder and couple of files. I have a test framework for the same driver, which is built as a module and when the test framework's .<code>ko</code> is insmoded, I would like it to create couple of more files under the same <code>debugfs</code> folder. Now the question is, I see only <code>debugfs_create_dir()</code> API and not an API to open an existing <code>debugfs</code><br>
( I need to open it to get the dentry handle which will be used in creating the new files in that directory).</p>
"
"<p>I try to implement a write function to a debugfs file. I hope I can use  <code>echo ""hello"" &gt; /sys/kernel/debugfs/mydir/myfile</code> to write a string to the file. And use <code>echo ""world"" &gt;&gt; /sys/kernel/debugfs/mydir/myfile</code> to append <code>world</code> after <code>hello</code>. I found two problem in my implementation. One is the <code>echo</code> command would stuck if the length of input string is over the buffer size. The other is the <code>echo ""world"" &gt;&gt; /sys/kernel/debugfs/mydir/myfile</code> never append the string. Instead, it new a string. Below is my implementation.</p>

<pre><code>#include &lt;linux/module.h&gt;       /* Needed by all modules */
#include &lt;linux/kernel.h&gt;       /* Needed for KERN_INFO */
#include &lt;linux/init.h&gt;         /* Needed for the macros */
#include &lt;linux/miscdevice.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/sched.h&gt;
MODULE_LICENSE(""GPL"");

#define BUF_SIZE 10

static char foo_buf[BUF_SIZE];
static struct dentry *debug_dir;
static struct dentry *debug_foo;

static ssize_t foo_read(struct file *file, char __user *buf, size_t count,
            loff_t *f_pos)
{
    return simple_read_from_buffer(buf, count, f_pos, foo_buf, sizeof(foo_buf));
}

static ssize_t foo_write(struct file *file, const char __user *buf, size_t count,
                    loff_t *f_pos)
{
    size_t ret;

    if (*f_pos &gt; BUF_SIZE)
            return -EINVAL;
    ret = simple_write_to_buffer(foo_buf, sizeof(foo_buf), f_pos, buf, count);
    if (ret &lt; 0)
            return ret;
    foo_buf[ret] = '\0';

    return ret;
}

static const struct file_operations foo_fops = {
    .owner = THIS_MODULE,
    .read = foo_read,
    .write = foo_write,
};

static int __init debugfs_start(void)
{

    pr_err(""init debugfs"");

    debug_dir = debugfs_create_dir(""mydir"", NULL);
    if (debug_dir == NULL) {
            pr_err(""debugfs create my dir failed"");
            return -ENOMEM;
    }

    debug_foo = debugfs_create_file(""foo"", 0744, debug_dir,
                                       NULL, &amp;foo_fops);
    if (!debug_foo) {
            debugfs_remove(debug_dir);
            return -ENOMEM;
    }
    return 0;
}

static void __exit debugfs_end(void)
{
    pr_err(""exit debugfs"");
    debugfs_remove_recursive(debug_dir);
}

module_init(debugfs_start);
module_exit(debugfs_end);
</code></pre>
"
"<p>as I know, to inform the user space from kernel space, one way is to using poll. That means kernel driver should provide poll method first.
Below code is found from internet, and it really works!</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/string.h&gt;
#include &lt;linux/vmalloc.h&gt;
#include &lt;asm/uaccess.h&gt;

MODULE_LICENSE(""GPL"");
MODULE_DESCRIPTION(""Fortune Cookie Kernel Module"");
MODULE_AUTHOR(""M. Tim Jones"");

#define MAX_COOKIE_LENGTH       PAGE_SIZE

static struct proc_dir_entry *proc_entry;
static char *cookie_buf;  // Space for fortune strings
static int write_index;   // Index to write next fortune
static int read_index;    // Index to read next fortune

ssize_t fortune_write( struct file *filp, const char __user *buff,
                        unsigned long len, void *data )
// Refer to: ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
{
  int space_available = (MAX_COOKIE_LENGTH-write_index);

  if (len &gt; space_available) {
    printk(KERN_INFO ""fortune: cookie buffer is full!\n"");
    return -ENOSPC;
  }

  if (copy_from_user( &amp;cookie_buf[write_index], buff, len )) {
    return -EFAULT;
  }

  write_index += len;
  cookie_buf[write_index-1] = 0;

  return len;
}

ssize_t fortune_read(struct file *file, char *buf, size_t count, loff_t *f_pos){
// Refer to: ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    int len;

    //there's no fortune or a fortune has already been read
    //the *f_pos &gt; 0 hack is needed because `cat /proc/fortune` would otherwise
    //display every thing in the cookie_buf
    if(write_index == 0 || *f_pos &gt; 0){
        return 0;
    }

    // cicle through fortunes
    if(read_index &gt;= write_index){
        read_index = 0;
    }

    len = sprintf(buf, ""%s\n"", &amp;cookie_buf[read_index]);

    read_index += len;
    *f_pos += len;

    return len;
}

static const struct file_operations proc_test_fops = {
   .owner        = THIS_MODULE,
//    .open        = led_proc_open,
   .read        = fortune_read,
//    .llseek        = seq_lseek,
//    .release    = single_release,
   .write        = fortune_write,
//    unsigned int (*poll) (struct file *, struct poll_table_struct *);
//    int (*fasync) (int, struct file *, int);
};

int __init init_fortune_module( void )
{
    int ret = 0;
    cookie_buf = (char *)vmalloc( MAX_COOKIE_LENGTH );
    if (!cookie_buf) {
        ret = -ENOMEM;
    } else {
        memset( cookie_buf, 0, MAX_COOKIE_LENGTH );
//        proc_entry = create_proc_entry( ""fortune"", 0644, NULL );
        proc_entry = proc_create( ""fortune"", 0644, NULL, &amp;proc_test_fops );

        if (proc_entry == NULL) {
            ret = -ENOMEM;
            vfree(cookie_buf);
            printk(KERN_INFO ""fortune: Couldn't create proc entry\n"");
        } else {
            write_index = 0;
            read_index = 0;
            printk(KERN_INFO ""fortune: Module loaded.\n"");
        }
    }

    return ret;
}

void __exit exit_fortune_module( void )
{
//    remove_proc_entry(""fortune"", &amp;proc_entry);
    proc_remove(proc_entry);
    vfree(cookie_buf);
    printk(KERN_INFO ""fortune: Module unloaded.\n"");
}

module_init( init_fortune_module );
module_exit( exit_fortune_module );
</code></pre>

<p>I can do like this to make it work:</p>

<pre><code>echo ""hello"" &gt; /proc/fortune
</code></pre>

<p>And then </p>

<pre><code>cat /proc/fortune
</code></pre>

<p>to see the result.</p>

<p>But how to add poll method to it? I tried some times, but still failed.
Could anyone help? Thanks!</p>
"
"<p>debugfs api such as <a href=""http://www.fsl.cs.sunysb.edu/kernel-api/re465.html"" rel=""nofollow"">debugfs_create_dir</a> said</p>

<blockquote>
  <p>If debugfs is not enabled in the kernel, the value -ENODEV will be returned. It is not wise to check for this value, but rather, check for NULL or !NULL instead as to eliminate the need for #ifdef in the calling code.</p>
</blockquote>

<p>But why is it not wise? Could you give me any examples about <code>eliminate the need for #ifdef in the calling code</code>?</p>
"
"<p>I am creating a simple <code>debugfs</code> file inside <code>/sys/kernel/debug/test/testFile</code> using the following code:</p>

<pre><code>pDebugfs = debugfs_create_dir(name, NULL);

if (!pDebugfs)
            goto fail;

if (!debugfs_create_file(""testFile"", MODE_T, pDebugfs,
        NULL,  &amp;debugfs_fops)) {
    goto fail;
}
</code></pre>

<p>And now when I write to this file, <code>open</code> method will be called which has the definition:</p>

<pre><code>static ssize_t debugfs_open(struct inode *inode, struct file *filp)
</code></pre>

<p>Now the <code>pDebugfs</code> which is of type <code>dentry</code> has a pointer to an <code>inode</code> called <code>d_inode</code> as defined <a href=""http://lxr.free-electrons.com/source/include/linux/dcache.h#L108"" rel=""nofollow"">here</a>.</p>

<p>My question is what is the relationship between this <code>inode</code> pointer and the one called in <code>open</code>? Are they related? If yes, how? I tried to print the <code>i_flags</code> value in both the <code>i_node</code> definitions but they don't match, I assign <code>i_flags</code> in <code>init</code> and just check its value in <code>open</code> but they don't match.</p>
"
"<p>I've managed to successfully create a <code>dentry</code> in the matching path, but now how do I actually write there?</p>

<pre><code>struct dentry* log_dir = debugfs_create_dir (""my_module"", NULL);
struct dentry* log_file = debugfs_create_dir (""log"", 0777, log_dir, NULL, NULL);
</code></pre>
"
"<p>I am trying to create a debugfs file using the debugfs_create_file(...). I have written a sample code for this.</p>

<pre><code>static int __init mmapexample_module_init(void)
 {
         file1 = debugfs_create_file(""mmap_example"", 0644, NULL, NULL, &amp;my_fops)\
 ;
         printk(KERN_ALERT ""Hello, World\n"");
         if(file1==NULL)
           {
             printk(KERN_ALERT ""Error occured\n"");
           }
         if(file1==-ENODEV)
           {
             printk(KERN_ALERT ""ENODEV occured\n"");
           }
         return 0;
 }
</code></pre>

<p>When i ran insmod i could get the Hello, World message but no the error message. So i think the debugfs_create_file worked fine. However i couldn't find any file in /sys/kernel/debug. The folder is there but it is empty. Can anyone help me with this? Thank you...</p>

<p>Thanks,
Bala</p>
"
"<p>What flags do I use for debugfs_create_file_N(...)?  All the resources I can find basically say 'set them as appropriate'.</p>

<p>I've tried 777, MAY_WRITE|MAY_READ, and FMODE_WRITE|FMODE_READ; but so far cat'ing the file only gives me a '0'.</p>
"
"<p>I am looking for copying PID value from User space to Kernel space, here is my code snaps.</p>

<p>Kernel Module:</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;asm/siginfo.h&gt;
#include &lt;linux/rcupdate.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/signal.h&gt;
MODULE_LICENSE (""GPL"");

struct siginfo sinfo;
pid_t pid;
struct task_struct *task;
int init_module () {
memset(&amp;sinfo, 0, sizeof(struct siginfo));
sinfo.si_signo = SIGIO;
sinfo.si_code = SI_USER;
pid = 5218; // Everytime a new PID
//task = find_task_by_vpid(pid); // I am also working on new and old version of UBUNTU so thats why this is here
task = pid_task(find_vpid(pid), PIDTYPE_PID);
printk(""%d .\n"", task);
if(task == NULL) {
printk(""Cannot find PID from user program\r\n"");
return 0;
}
send_sig_info(SIGIO, &amp;sinfo, task);
return 0;
}
void cleanup_module () {
printk(KERN_ALERT""\nGoodBye World\n\n"");
}
</code></pre>

<p>Userspace Code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;string.h&gt;
void signal_handler (int signum){
if (signum == SIGIO) printf (""SIGIO\r\n""); return;
}
int main () {
int i=1 ;
signal(SIGIO, signal_handler);
printf(""My PID is %d.\n"",getpid());
while (i);
return 0;
}
</code></pre>

<p>Now, here I am always running user space program to get PID and then I always have to edit the pid variable in Kernel module.</p>

<p>I found one way to access information from user space into Kernel space and vice-versa (i.e., using <code>copy_from/to_user()</code> )</p>

<p>But I am unable to understand either of them for getting a PID from user space, I have to make file in <code>/dev</code> directory and should apply all the required functions for just getting PID?</p>

<p>Is there any other way? if not, then can anyone please help me to do this? I am new in c programming and playing with kernel module directly so its hard for me.</p>
"
"<p>With proc we can easily use read &amp; write system call as shown in this example.
<a href=""https://stackoverflow.com/questions/9863005/write-on-proc-entry-through-user-space"">write on /proc entry through user space</a>  </p>

<p>But i am working on passing information from driver to user-space using debugfs.
I am able to find these two example code. Here application is able to read and write to debugfs file using mmap() system call.</p>

<ul>
<li><a href=""http://people.ee.ethz.ch/~arkeller/linux/code/mmap_simple_kernel.c"" rel=""nofollow noreferrer"">http://people.ee.ethz.ch/~arkeller/linux/code/mmap_simple_kernel.c</a></li>
<li><a href=""http://people.ee.ethz.ch/~arkeller/linux/code/mmap_user.c"" rel=""nofollow noreferrer"">http://people.ee.ethz.ch/~arkeller/linux/code/mmap_user.c</a></li>
</ul>

<p>But suppose in my case requirement for communicating using Debugfs file with device driver:</p>

<pre><code>user-space application    &lt;-------&gt; debugfs file &lt;-------&gt; Device driver
</code></pre>

<ol>
<li><p>So can i use same code mmap_simple_kernel.c inside my --->> device driver code  --->> and transfer data to debugfs directly from driver ? But in this case there will be two file_operations structures inside my driver will it cause some problem ? Is it right approach ?</p></li>
<li><p>Or just like application is following process in -- mmap_user.c  --- same process -- i follow in my device driver program. And keep mmap_simple_kernel.c  as seprate module for debugfs entry ?</p></li>
</ol>
"
"<p>I need to write an SPI Linux character device driver for omap4 from scratch.
I know some basics of writing device drivers. But, I don't know how to start writing platform specific device driver from scratch.</p>

<p>I've written some basic char drivers, and I thought writing SPI device driver would be similar to it. Char drivers have a structure <code>file_operations</code> which contains the functions implemented in the driver.</p>

<pre><code>struct file_operations Fops = {
    .read = device_read,
    .write = device_write,
    .ioctl = device_ioctl,
    .open = device_open,
    .release = device_release,  /* a.k.a. close */
};
</code></pre>

<p>Now, I am going through <a href=""http://lxr.free-electrons.com/source/drivers/spi/spi-omap2-mcspi.c"" rel=""noreferrer"">spi-omap2-mcspi.c</a> code as a reference to get an idea to start developing SPI driver from scratch.</p>

<p>But, I don't see functions such as open, read, write etc.
Don't know from where the program starts.</p>
"
"<p>Hello all I'm new to Linux and wondering how to use a Linux sequence file in a module to traverse kernel objects.</p>

<p>What I know is I can use the command:</p>

<pre><code> cat /proc/kallsyms
</code></pre>

<p>to view the available symbols and from what I've read on google, the symbols in the list that have a 'D' or 'd' are pointers to data structures.</p>

<p>Though I know the basics of how to create a module, the examples on the internet on how to use seq operations are not uniform and I'm getting a little confused. </p>

<p>If someone knows of any good doco that will help me understand how to create a seq file to traverse kernel objects and could post a link (or a quick example), I would be greatly appreciative.</p>
"
"<p>I have a kernel module that creates several DebugFS entries, each 4 to 8 bytes. I would like to use one (or more) of these entries to initiate action within the kernel module--in other words, I want to use an entry for configuration purposes.<br /><br />
Is there a common idiom to detect the user write to the DebugFS entry without polling (some kind of user-space to kernel space signal) within my kernel module, or is sleep/poll the best (only?) option.</p>
"
"<p>I have created a file using <code>debugfs</code> API inside <code>/sys/kernel/debug/test/testFile</code>. I have created the file with mode set to <code>444</code>, so it is now read only.</p>

<p>Now I have essentially followed this <a href=""http://blog.techveda.org/debugfs/"" rel=""nofollow"">tutorial</a> in creating this <code>debugfs</code> file. And for this file both <code>read</code> and <code>write</code> are define. Moreover, concretely, I create file using this:</p>

<p><code>debugfs_create_file(""testFile"", 444, pDebugfs,
        NULL,  &amp;debugfs_fops)</code></p>

<p>File is successfully created and I can easily read from it by <code>cat ...</code> but why I can write to it too even though I can explicitly created as <code>read only</code>. I am logged in as root. Why is that? Should not it not allow me to write to it?</p>

<p>Finally, <code>ls -l</code> results:</p>

<p><code>-r--r--r-- 1 root root 0 ???   28 15:27 /sys/kernel/debug/test/testFile</code></p>

<p>Now, you may argue that since I am <em>root</em>, I can write to any file. Well, then if you search <code>let's access blob file</code> on the page, the OP cannot write to blob file, even though as root, because it is read only. Why is that? </p>
"
"<p>In my application there is a thread which takes care of RESET button that when and for how much time it was pressed; on the basis of that we take the action.
Problem is to minimize CPU usage:</p>

<p>1.<code>popen</code> usage <code>fp=popen(RESET_GPIO_VALUE,""r"");</code> with this application have <code>75% CPU consumption</code>.</p>

<ol start=""2"">
<li><p><code>fopen</code> usage <code>fp=fopen(RESET_GPIO_VALUE,""r"");</code> with this application have <code>87% CPU consumption</code>.</p></li>
<li><p><code>open</code> usage <code>fd = open(RESET_GPIO_VALUE,O_RDONLY);</code> with this application have <code>95% CPU consumption</code>.</p></li>
</ol>

<p>Is there any method to access the GPIO with around <code>10-15% of CPU consumption</code>.</p>

<p>Here currently in my logic I continuously check the RESET GPIO by checking its value via above define methods. As button pressed timer started and released stop the timer and calculate the difference of time. This whole action running in infinite loop.</p>
"
"<p>I have shared memory segment created in kernel using mmap. I need to access this mapped memory from both kernel and user space. What mechanism should I use to protect the memory from concurrent access ?
I want to have something like:</p>

<p>Kernel module:</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/debugfs.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/mm.h&gt;

#ifndef VM_RESERVED
# define  VM_RESERVED   (VM_DONTEXPAND | VM_DONTDUMP)
#endif

struct dentry  *file;

struct mmap_info
{
    char *data;
    int reference;
};

void mmap_open(struct vm_area_struct *vma)
{
    struct mmap_info *info = (struct mmap_info *)vma-&gt;vm_private_data;
    info-&gt;reference++;
}

void mmap_close(struct vm_area_struct *vma)
{
    struct mmap_info *info = (struct mmap_info *)vma-&gt;vm_private_data;
    info-&gt;reference--;
}

static int mmap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
{
    struct page *page;
    struct mmap_info *info;

    info = (struct mmap_info *)vma-&gt;vm_private_data;
    if (!info-&gt;data)
    {
        printk(""No data\n"");
        return 0;
    }
    page = virt_to_page(info-&gt;data);
    get_page(page);
    vmf-&gt;page = page;
    return 0;
}

struct vm_operations_struct mmap_vm_ops =
{
    .open =     mmap_open,
    .close =    mmap_close,
    .fault =    mmap_fault,
};

int op_mmap(struct file *filp, struct vm_area_struct *vma)
{
    vma-&gt;vm_ops = &amp;mmap_vm_ops;
    vma-&gt;vm_flags |= VM_RESERVED;
    vma-&gt;vm_private_data = filp-&gt;private_data;
    mmap_open(vma);
    return 0;
}

int mmapfop_close(struct inode *inode, struct file *filp)
{
    struct mmap_info *info = filp-&gt;private_data;
    free_page((unsigned long)info-&gt;data);
    kfree(info);
    filp-&gt;private_data = NULL;
    return 0;
}

int mmapfop_open(struct inode *inode, struct file *filp)
{
    struct mmap_info *info = kmalloc(sizeof(struct mmap_info), GFP_KERNEL);
    info-&gt;data = (char *)get_zeroed_page(GFP_KERNEL);
    memcpy(info-&gt;data, ""hello from kernel this is file: "", 32);
    memcpy(info-&gt;data + 32, filp-&gt;f_dentry-&gt;d_name.name, strlen(filp-&gt;f_dentry-&gt;d_name.name));
    /* assign this info struct to the file */
    filp-&gt;private_data = info;
    return 0;
}

static const struct file_operations mmap_fops = {
    .open = mmapfop_open,
    .release = mmapfop_close,
    .mmap = op_mmap,
};

 static int __init mmapexample_module_init(void)
{
    file = debugfs_create_file(""mmap_example"", 0644, NULL, NULL, &amp;mmap_fops);
    return 0;
}

static void __exit mmapexample_module_exit(void)
{
    debugfs_remove(file);
}

module_init(mmapexample_module_init);
module_exit(mmapexample_module_exit);
MODULE_LICENSE(""GPL"");
</code></pre>

<p>User space:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/mman.h&gt;

#define PAGE_SIZE     4096

int main ( int argc, char **argv )
{
    int configfd;
    char * address = NULL;

    configfd = open(""/sys/kernel/debug/mmap_example"", O_RDWR);
    if(configfd &lt; 0)
    {
        perror(""Open call failed"");
        return -1;
    }

    address = mmap(NULL, PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, configfd, 0);
    if (address == MAP_FAILED)
    {
        perror(""mmap operation failed"");
        return -1;
    }
    printf(""Initial message: %s\n"", address);
    memcpy(address + 11 , ""*user*"", 6);
    printf(""Changed message: %s\n"", address);
    close(configfd);
    return 0;
}
</code></pre>

<p>but with locks.</p>
"
"<p>I am trying to implement a SPI driver for custom hardware. I have started with a copy of the spidev driver, which has support for almost everything I need.</p>

<p>We're using a protocol that has three parts: a command bit (read / write) an address, and an arbitrary amount of data.</p>

<p>I had assumed that simply adding lseek capabilities would be the best way to do this. ""Seek"" to the desired address, then read or write any number of bytes. I created a custom .llseek in the new driver's file_operations, but I have never seen that function even be called. I have tried using fseek(), lseek(), and pread() and none of those functions seem to call the new my_lseek() function. Every call reports ""errno 29 ESPIPE Illegal Seek""</p>

<p>The device is defined in the board.c file:</p>

<pre><code>static struct spi_board_info my_spi_board_info[] __initdata = {
[0] = {
    .modalias      = ""myspi"",
    .bus_num        = 1,
    .chip_select    = 0,
    .max_speed_hz   = 3000000,
    .mode           = SPI_MODE_0,
    .controller_data = &amp;spidev_mcspi_config,
}, ...
</code></pre>

<p>I suspect there might be something with the way that the dev files get created, mainly because the example that I found references filp->f_pos</p>

<pre><code>static int myspi_llseek(struct file *filp, loff_t off, int whence)
{
    ...
    newpos = filp-&gt;f_pos + off;
    ...
}
</code></pre>

<p>So my questions are: Is there a way to have this driver (lightly modified spidev)  support the ""seek"" call? At what point does this get defined to return errno 29? Will I have to start from a new driver and not be able to rely on the spi_board_info() and spi_register_board_info() setup?</p>

<p>Only one driver in the /drivers/spi directory (spi-dw) references lseek, and they use the default_llseek implementation. There are a couple of ""hacks"" that we've come up with to get everything up and running, but I tend to be a person who wants to learn to get it done the right way.</p>

<p>Any suggestions are greatly appreciated!  (PS, the kernel version is 3.4.48 for an OMAP Android system)</p>
"
"<p>I am trying to map reserved memory (30M with offset of 2G) at boot time (boot kernel parameters mem=2G memmap=30M$2G) to user space using the remap_pfn_range, bellow is my driver code:</p>

<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;asm/uaccess.h&gt;
// #include &lt;asm/error.h&gt;

#define MAP_MAJOR 150

#define RAW_DATA_SIZE 0x1E00000 // 30 Mo
#define RAW_DATA_OFFSET 0x80000000 //2G

int results;
static void *rawdataStart = NULL;

static int map_mmap(struct file *filp, struct vm_area_struct *vma);

struct file_operations map_fops = {
        .open = nonseekable_open,
        .mmap = map_mmap
};

static int map_mmap(struct file *filp, struct vm_area_struct *vma) {
    if (rawdataStart == NULL) {
        printk(KERN_ERR ""Memory not mapped!\n"");
        return -EAGAIN;
    }
    if ((vma-&gt;vm_end - vma-&gt;vm_start) != RAW_DATA_SIZE) {
        printk(KERN_ERR ""Error: sizes don't match (buffer size = %d, requested size = %lu)\n"", RAW_DATA_SIZE, vma-&gt;vm_end - vma-&gt;vm_start);
        return -EAGAIN;
    }
    results = remap_pfn_range(vma, vma-&gt;vm_start, RAW_DATA_OFFSET &gt;&gt; PAGE_SHIFT, RAW_DATA_SIZE, PAGE_SHARED);
    if (results != 0) {
        printk(KERN_ERR ""Error in calling remap_pfn_range: returned %d\n"", results);
        return -EAGAIN;
    }

    return 0;
}

static int __init map_init(void)
{

    printk(""init map module\n"");

    if (register_chrdev(MAP_MAJOR,""mapReserved"", &amp;map_fops) &lt;0 )
    {
        printk(""unable to get major for map module\n"");
        return -EBUSY;
    }


    rawdataStart = ioremap(RAW_DATA_OFFSET, RAW_DATA_SIZE);
    if (rawdataStart == NULL) {
        printk(KERN_ERR ""Unable to remap memory\n"");
        return 1;
    }
    printk(KERN_INFO ""ioremap returned %p\n"", rawdataStart);

    return 0;
}

void __exit map_cleanup(void)
{
    printk(""exit map module\n"");
    unregister_chrdev(MAP_MAJOR,""mapReserved"");
    if (rawdataStart != NULL) {
        printk(KERN_INFO ""Unmapping memory at %p\n"", rawdataStart);
        iounmap(rawdataStart);
    } else {
        printk(KERN_WARNING ""No memory to unmap!\n"");
    }

    return;
}

MODULE_LICENSE(""GPL"");

module_init( map_init);
module_exit( map_cleanup);
</code></pre>

<p>and my user space app is below </p>

<pre><code>#include &lt;sys/mman.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;

#define RAW_DATA_SIZE 0x1E00000


int main(void)
{
  void * data;
  int fd = open(""/dev/mapReserved"", O_RDWR);
  if (fd == -1) {
         perror(""open error...\n"");
         return -1;
  }
  data = mmap(NULL, RAW_DATA_SIZE, PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, fd, 4096);
  close(fd);
  return 0;
}
</code></pre>

<p>when i insert the module it's return </p>

<pre><code>[  873.621763] init map module
[  873.623175] ioremap returned fb580000
</code></pre>

<p>but when i am executing the user space app it's return error</p>

<pre><code>open error...
</code></pre>
"
"<p>For some reason my <code>mmap</code> failed with an <code>Invalid argument</code> message even though my offset is page aligned. Page size is 4096 bytes. Also <code>CONFIG_STRICT_DEVMEM</code> is disabled, i.e. I can access memory above 1MB.</p>

<p>Here is my code:</p>

<pre><code>void *mmap64;
off_t offset = 0x000000d9fcc000;
int memFd = open(""/dev/mem"", O_RDWR);
if (-1 == memFd)
  perror(""Error "");

mmap64 = mmap(0, getpagesize(), PROT_WRITE | PROT_READ, MAP_SHARED, memFd, offset);
if (MAP_FAILED == mmap64) {
  perror(""Error "");
  return -1;
}
</code></pre>

<p>Can someone explain why this is happening?</p>

<p><strong>EDIT</strong></p>

<p>Here is the <code>strace</code> of my code</p>

<pre><code>execve(""./to_phys_test"", [""./to_phys_test"", ""-r""], [/* 18 vars */]) = 0
brk(0)                                  = 0x2012000
access(""/etc/ld.so.nohwcap"", F_OK)      = -1 ENOENT (No such file or directory)
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe240a2c000
access(""/etc/ld.so.preload"", R_OK)      = -1 ENOENT (No such file or directory)
open(""/etc/ld.so.cache"", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=162063, ...}) = 0
mmap(NULL, 162063, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fe240a04000
close(3)                                = 0
access(""/etc/ld.so.nohwcap"", F_OK)      = -1 ENOENT (No such file or directory)
open(""/lib/x86_64-linux-gnu/libc.so.6"", O_RDONLY|O_CLOEXEC) = 3
read(3, ""\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P \2\0\0\0\0\0""..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=1840928, ...}) = 0
mmap(NULL, 3949248, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fe240447000
mprotect(0x7fe240601000, 2097152, PROT_NONE) = 0
mmap(0x7fe240801000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1ba000) = 0x7fe240801000
mmap(0x7fe240807000, 17088, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fe240807000
close(3)                                = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe240a03000
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe240a01000
arch_prctl(ARCH_SET_FS, 0x7fe240a01740) = 0
mprotect(0x7fe240801000, 16384, PROT_READ) = 0
mprotect(0x601000, 4096, PROT_READ)     = 0
mprotect(0x7fe240a2e000, 4096, PROT_READ) = 0
munmap(0x7fe240a04000, 162063)          = 0
open(""/dev/mem"", O_RDWR)                = 3
open(""/dev/my_kmodule"", O_RDWR)    = 4
ioctl(4, 0x40086e00, 0x7ffc72b334b0)    = 0
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe240a2b000
write(1, ""sa.size = 44\n"", 13)          = 13
write(1, ""sa.addr_uint64_t = d9047000\n"", 28) = 28
write(1, ""sa.addr_void_ptr = 0xd9047000\n"", 30) = 30
write(1, ""PAGE_SIZE = 4096\n"", 17)      = 17
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, 3, 0xd9047000) = -1 EINVAL (Invalid argument)
dup(2)                                  = 5
fcntl(5, F_GETFL)                       = 0x8002 (flags O_RDWR|O_LARGEFILE)
brk(0)                                  = 0x2012000
brk(0x2033000)                          = 0x2033000
fstat(5, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0
mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fe240a2a000
lseek(5, 0, SEEK_CUR)                   = -1 ESPIPE (Illegal seek)
write(5, ""Error : Invalid argument\n"", 25) = 25
close(5)                                = 0
munmap(0x7fe240a2a000, 4096)            = 0
exit_group(-1)                          = ?
+++ exited with 255 +++
</code></pre>
"
"<p>I am struggling to find out, what steps are necessary to access a gpio-pin from a linux kernel module.
Maybe someone can explain it to me by a simple example. I like to use pin 4(input) and 33(output). My steps so far:</p>

<p>1.) Device Tree(dts): I leave the dts file untouched - Do I need to setup the pin 4 and 33 via pin control?</p>

<p>2.) kernel module: some pseudo code</p>

<pre><code>gpio_is_valid(4)
gpio_request_one(4, GPIOF_DIR_IN | GPIOF_EXPORT_DIR_FIXED , ""myPin4"")
gpio_export(4, false)
gpio_get_value(4)

gpio_is_valid(33)
gpio_request_one(33, GPIOF_DIR_OUT | GPIOF_INIT_LOW | GPIOF_OPEN_SOURCE | GPIOF_EXPORT_DIR_FIXED , ""myPin33"")
gpio_export(33, false)
gpio_set_value(33, 1)
</code></pre>

<p>How to do it in a proper way?</p>
"
"<p>I am new to linux kernel. And recently, i've went through the sendfile syscall in kernel 2.6.33. The following is the sequence of my journey:</p>

<pre><code>   do_sendfile()
=&gt; do_splice_direct()
=&gt; splice_direct_to_actor()
=&gt; do_splice_to()
=&gt; do_splice_from()
=&gt; splice_read,splice_write
</code></pre>

<p>Throughout this sequence, I didn't find the place where splice use the DMA copy. So where is the DMA copying taking place?</p>
"
"<p>Have a homework assignment in which I'm supposed to create a vector of pointers to objects</p>

<p>Later on down the load, I'll be using inheritance/polymorphism to extend the class to include fees for two-day delivery, next day air, etc. However, that is not my concern right now. The final goal of the current program is to just print out every object's content in the vector (name &amp; address) and find it's shipping cost (weight*cost).</p>

<p>My Trouble is not with the logic, I'm just confused on few points related to objects/pointers/vectors in general. But first my code. I basically cut out everything that does not mater right now, int  main, will have user input, but right now I hard-coded two examples.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
using namespace std;

class Package {
public:
    Package(); //default constructor
    Package(string d_name, string d_add, string d_zip, string d_city, string d_state, double c, double w);
    double calculateCost(double, double);
    ~Package();

private:
    string dest_name;
    string dest_address;
    string dest_zip;
    string dest_city;
    string dest_state;
    double weight;
    double cost;

};

Package::Package()
{
    cout&lt;&lt;""Constucting Package Object with default values: ""&lt;&lt;endl;
    string dest_name="""";
    string dest_address="""";
    string dest_zip="""";
    string dest_city="""";
    string dest_state="""";
    double weight=0;
    double cost=0;
}
Package::Package(string d_name, string d_add, string d_zip, string d_city, string d_state, string r_name, string r_add, string r_zip, string r_city, string r_state, double w, double c){

    cout&lt;&lt;""Constucting Package Object with user defined values: ""&lt;&lt;endl;
    string dest_name=d_name;
    string dest_address=d_add;
    string dest_zip=d_zip;
    string dest_city=d_city;
    string dest_state=d_state;
    double weight=w;
    double cost=c;
}
Package::~Package()
{
    cout&lt;&lt;""Deconstructing Package Object!""&lt;&lt;endl;
    delete Package;
}
double Package::calculateCost(double x, double y){
    return x+y;
}
int main(){
    double cost=0;
    vector&lt;Package*&gt; shipment;
    cout&lt;&lt;""Enter Shipping Cost: ""&lt;&lt;endl;
    cin&gt;&gt;cost;
    shipment.push_back(new Package(""tom r"",""123 thunder road"", ""90210"", ""Red Bank"", ""NJ"", cost, 10.5));
    shipment.push_back(new Package (""Harry Potter"",""10 Madison Avenue"", ""55555"", ""New York"", ""NY"", cost, 32.3));
    return 0;

}
</code></pre>

<p>So my questions are: </p>

<ol>
<li>I'm told I have to use a vector
of Object Pointers, not Objects.
Why? My assignment calls for it
specifically, but I'm also told it
won't work otherwise.</li>
<li>Where should I be creating this
vector?
    Should it be part of my Package
    Class? How do I go about adding
    objects into it then?</li>
<li><p>Do I need a copy constructor? Why?</p></li>
<li><p>What's the proper way to deconstruct
my vector of object pointers?</p></li>
</ol>

<p>Any help would be appreciated. I've searched for a lot of related articles on here and I realize that my program will have memory leaks. Using one of the specialized ptrs from boost:: will not be available for me to use. Right now, I'm more concerned with getting the foundation of my program built. That way I can actually get down to the functionality I need to create.</p>

<p>Thanks. </p>
"
"<p>I'm trying to read up on constraint satisfaction problems and trying to code them to solve a few sample problems. I came across <a href=""http://rosettacode.org/wiki/Zebra_puzzle#C.2B.2B"" rel=""nofollow"">http://rosettacode.org/wiki/Zebra_puzzle#C.2B.2B</a> to solve the classic <a href=""https://en.wikipedia.org/wiki/Zebra_Puzzle"" rel=""nofollow"">zebra puzzle.</a> In the C code given in rosetta code website, There was this following function. I have given only a few lines from it. I didn't know what the purpose of the two <code>if</code> statements is and how they worked.
Can someone explain it? </p>

<pre><code>int checkHouses(int ha[5][5])
{
...
    int c_add = 0, c_or = 0;
    int m_add = 0, m_or = 0;
    int d_add = 0, d_or = 0;
    int a_add = 0, a_or = 0;
    int s_add = 0, s_or = 0;

    for (int i = 0; i &lt; 5; i++) {
        // Uniqueness tests.
        if (ha[i][C] &gt;= 0) {
            c_add += (1 &lt;&lt; ha[i][C]);
            c_or |= (1 &lt;&lt; ha[i][C]);
        }
        if (ha[i][M] &gt;= 0) {
            m_add += (1 &lt;&lt; ha[i][M]);
            m_or |= (1 &lt;&lt; ha[i][M]);
        }
        if (ha[i][D] &gt;= 0) {
            d_add += (1 &lt;&lt; ha[i][D]);
            d_or |= (1 &lt;&lt; ha[i][D]);
        }
        if (ha[i][A] &gt;= 0) {
            a_add += (1 &lt;&lt; ha[i][A]);
            a_or |= (1 &lt;&lt; ha[i][A]);
        }
        if (ha[i][S] &gt;= 0) {
            s_add += (1 &lt;&lt; ha[i][S]);
            s_or |= (1 &lt;&lt; ha[i][S]);
        }
    }

    if ((c_add != c_or) || (m_add != m_or) || (d_add != d_or)
        || (a_add != a_or) || (s_add != s_or)) {
        return Invalid;
    }

    if ((c_add != 0b11111) || (m_add != 0b11111) || (d_add != 0b11111)
        || (a_add != 0b11111) || (s_add != 0b11111)) {

        return Underfull;
}
</code></pre>
"
"<p>I am writing a C program to understand strings and pointers. Everything works except the sizeof operation for a char* [] and char**[].</p>

<p>Here is my code:</p>

<pre><code>int main(){
  puts("""");
  char src[]= ""rabbit"";
  char* src2[] = {""rabbit"",""dog"",""monkey""};
  char* src3[] = {""fish"",""horse"",""dolphin""};
  char** src4[] = {src2,src3};
  int i,j;

  printf(""Size of the char array only is %d\n"",sizeof(src));
  printf(""Size of the array of string pointers only is %d\n"", sizeof(&amp;src2));
  printf(""Size of the array of pointers to string pointers only %d\n\n"", sizeof(src4));

   puts(""Single char array is:"");
   for(i = 0; i&lt;sizeof(src)-1; i++){
     printf(""%c,"",src[i]);
   }

  puts (""\n"");

  puts(""Array of strings:"");
  puts(src2[0]);
  puts(src2[1]);
  puts(src2[2]);
  puts("""");

  puts(""Printing the char** [] contents "");

  for(i=0; i&lt;2; i++){
    for(j=0; j &lt; 3;j++){
      puts(src4[i][j]);
     }
  }

  puts("""");

  return 0;

}
</code></pre>

<p>So how do get the number of elements in char* [] and char** [] ?
Also on another note if I for example declare char*[] src2 = {""rabbit"",""dog"",""monkey""}; as only char*[] m_src. Then do I have to malloc space for each element I add into this array ? for example</p>

<p>If I had instead done</p>

<pre><code>    // Code segment changed for char*[]
    char* m_src[];
    // could I do this
    m_src = malloc(3 * sizeof(char*));
    m_src[0] = ""rabbit"";
    m_src[1] = ""dog"";
    m_src[2] = ""monkey"";

    /* Even more is there a way to dynamically add elements to the
    array like mallocing space for a single element at a time and tacking it onto the
    array char* m_src? */
</code></pre>
"
"<p>How does the process of creating a file in ext2 file system look like?</p>

<p>I am trying to make a simple syscall which takes a path and creates given file - like touch.</p>

<p>For example, the code:</p>

<pre><code>int main(void)
{
    syscall(MY_SYSCALL_NUMBER, ""/tmp/file"");
}
</code></pre>

<p>Should create a file called ""file"" in /tmp.</p>

<p>Now how should the syscall itself work?</p>

<p>My work so far (I ommited error checking for readibility here):</p>

<pre><code>asmlinkage long sys_ccp(const char __user *arg)
{
     struct path path;
     struct inode *new_inode;
     struct qstring qname;

     //ommited copy from user for simplicity
     qname.name = arg;
     qname.len = length(arg);

     kern_path(src, LOOKUP_FOLLOW, &amp;path);
     new_inode = ext2_new_inode(path.dentry-&gt;d_parent-&gt;d_inode, S_IFREG, &amp;qname);
}
</code></pre>

<p>This seems to work (I can see in logs that an inode is allocated), however, when I call <code>ls</code> on the directory I can't see the file there.</p>

<p>My idea was to add the new inode to <code>struct dentry</code> of directory, so I added this code:</p>

<pre><code>struct dentry *new_dentry;

new_dentry = d_alloc(path.dentry-&gt;d_parent, &amp;qname);
d_instantiate(new_dentry, new_inode);
</code></pre>

<p>However, this still doesn't seem to work (I can't see the file using <code>ls</code>).</p>

<p>How to implement this syscall correctly, what am I missing?</p>

<p>EDIT:
Regarding R.. answer - purpuse of this syscall is to play around with ext2 and learn about its design, so we can assumie that path is always valid, the filesystem is indeed ext2 and so on.</p>
"
"<p>I have a inheritance that the destructor of base class applies <a href=""http://en.wikipedia.org/wiki/Template_method_pattern"" rel=""nofollow"">Template Method Pattern</a>. The destructor has to do some works before calling the virtual clean function, and do some another works after calling.</p>

<p>We know that <a href=""http://www.artima.com/cppsource/nevercall.html"" rel=""nofollow"">Never Call Virtual Functions during Construction or Destruction</a>. So the following code definitely is not available.</p>

<pre><code>class base
{
public:
    virtual ~base()
    {
        // ... do something before do_clear()
        do_clear();
        // ... do something after do_clear()
    }

private:
    virtual void do_clear() = 0;
};

class d1
    : public base
{
public:
    d1() : m_x(new int) {}
    ~d1() {}

private:
    virtual void do_clear()
    {
        delete m_x;
    }
    int *m_x;
};
</code></pre>

<p>But if I moved the destruction of process to the destructor of derived class, for example:</p>

<pre><code>class base
{
public:
    virtual ~base()
    {
    }

protected:
    void clear()
    {
        // ... do something before do_clear()
        do_clear();
        // ... do something after do_clear()
    }

private:
    virtual void do_clear() = 0;
};

class d1
    : public base
{
public:
    d1() : m_x(new int) {}
    ~d1()
    {
        clear();
    }

private:
    virtual void do_clear()
    {
        delete m_x;
    }
    int *m_x;
};
</code></pre>

<p>If the client write that:</p>

<pre><code>base *x = new d1;
delete x;
</code></pre>

<p>It will call <code>~d1()</code>, then call <code>base::clear()</code>, eventually call the virtual function <code>d1::do_clear()</code> properly.</p>

<p>The <code>base::clear()</code> can been moved to public, and the client can make things safely by calling <code>base::clear()</code> before destruction. A precondition is the client must know and not forget to call, I think it isn't convenient and breaks encapsulation.</p>

<p>My question is:</p>

<ol>
<li>Is the design dangerous/risk?</li>
<li>Is existing other better design for this?</li>
</ol>
"
"<p>In Linux v0.11 <code>task_struct</code> had an <code>executable</code> member of type <code>m_inode *</code>. I am looking for something similar.</p>

<p>Does the exec/execve system call store this information anywhere or is it lost upon loading into memory?</p>
"
"<p>I'm working on a virtual file system which isn't disk based, kind of like /proc. Now I want to create a symlink within it to a target on a ext3 file system. I haven't found any standard documentation on ways to achieve this. What I've guessed so far is that I have to write a function to put in for <code>symlink</code> in <code>struct inode_operations</code>. But frankly I'm at a loss even with the function parameters. </p>

<p>If it matters, I started off with this tutorial on LWN: <a href=""http://lwn.net/Articles/13325/"" rel=""nofollow noreferrer"">http://lwn.net/Articles/13325/</a> </p>

<p>EDIT: I'm working with libfs, not FUSE at the moment</p>
"
"<p>I've run into the need to be able refer to a directory by path given its file descriptor in Linux. The path doesn't have to be canonical, it just has to be functional so that I can pass it to other functions. So, taking the same parameters as passed to a function like <code>fstatat()</code>, I need to be able to call a function like <code>getxattr()</code> which doesn't have a <code>f-XYZ-at()</code> variant.</p>

<p>So far I've come up with these solutions; though none are particularly elegant.</p>

<p>The simplest solution is to avoid the problem by calling <code>openat()</code> and then using a function like <code>fgetxattr()</code>. This works, but not in every situation. So another method is needed to fill the gaps.</p>

<p>The next solution involves looking up the information in proc: </p>

<pre><code>if (!access(""/proc/self/fd"",X_OK)) {
    sprintf(path,""/proc/self/fd/%i/"",fd);
}
</code></pre>

<p>This, of course, totally breaks on systems without proc, including some chroot environments.</p>

<p>The last option, a more portable but potentially-race-condition-prone solution, looks like this:</p>

<pre><code>DIR* save = opendir(""."");
fchdir(fd);
getcwd(path,PATH_MAX);
fchdir(dirfd(save));
closedir(save);
</code></pre>

<p>The obvious problem here is that in a multithreaded app, changing the working directory around could have side effects.</p>

<p>However, the fact that it works is compelling: if I can get the path of a directory by calling <code>fchdir()</code> followed by <code>getcwd()</code>, why shouldn't I be able to just get the information directly: <code>fgetcwd()</code> or something. Clearly the kernel is tracking the necessary information.</p>

<p>So how do I get to it?</p>

<hr>

<h2>Answer</h2>

<p>The way Linux implements <code>getcwd</code> in the kernel is this: it starts at the directory entry in question and prepends the name of the parent of that directory to the path string, and repeats that process until it reaches the root. This same mechanism can be theoretically implemented in user-space.</p>

<p>Thanks to <strong>Jonathan Leffler</strong> for pointing this algorithm out. Here is a link to the kernel implementation of this function: <a href=""https://github.com/torvalds/linux/blob/v3.4/fs/dcache.c#L2577"" rel=""nofollow noreferrer"">https://github.com/torvalds/linux/blob/v3.4/fs/dcache.c#L2577</a></p>
"
"<p>I want to add a new system call to the Linux kernel that will show information about all pipes that are created in the system.</p>

<p><strong>How can I get the inode (or any other related structure that will allow me to access the pipe_inode_info) of every pipe in the pipefs?</strong></p>

<p>I have been looking at <a href=""http://lxr.linux.no/linux+v2.6.38/include/linux/mount.h#L55"" rel=""nofollow"">struct vfsmount</a>, <a href=""http://lxr.linux.no/linux+v2.6.38/include/linux/dcache.h#L116"" rel=""nofollow"">struct dentry</a> and <a href=""http://lxr.linux.no/linux+v2.6.38/include/linux/fs.h#L1359"" rel=""nofollow"">struct super_block</a>, but I have not found the proper way. <strong>Is there any way I could get the file structure of every file in the pipefs?</strong></p>
"
"<p>I'm studying Chapter 3.5 of <a href=""http://www.makelinux.net/ldd3/chp-3-sect-5"">Linux Device Drivers, 3rd edition</a>. This section introduces a method to retrieve a custom structure we defined ourselves from <code>struct inode *inode</code> in the open function:</p>

<pre><code>int scull_open(struct inode *inode, struct file *filp)
{
    struct scull_dev *dev;

    dev = container_of(inode-&gt;i_cdev, struct scull_dev, cdev);
    filp-&gt;private_data = dev; /* for other methods */

    }
    return 0;
}
</code></pre>

<p>From my understanding, while the device is opened, the <code>struct inode *inode</code> representing the device is passed to <code>scull_open</code>. Then, the custom structure <code>dev</code> is extracted and passed to <code>filp-&gt;private_data</code> so that other methods such as <code>scull_read</code> can use it:</p>

<pre><code>ssize_t scull_read(struct file *filp, char _ _user *buf, size_t count,
                loff_t *f_pos)
{
    struct scull_dev *dev = filp-&gt;private_data;
    /* other codes that uses *dev   */
}
</code></pre>

<p>This seems fine to me until I realized that we already had a <code>struct scull_dev *dev</code> during initialization in <code>scull_setup_cdev</code> <a href=""http://www.makelinux.net/ldd3/chp-3-sect-4"">here</a>.</p>

<p>I'm rather confused since I thought we can make <code>struct scull_dev *dev</code> a global variable, then <code>scull_read</code> and other methods will eventually have access to it without going through all the passing using <code>inode</code> and <code>file</code>. </p>

<p>My question is, why don't we just make it a global variable?</p>

<p>Can anyone provide some practical examples of using this method to pass data ?</p>
"
"<p>I'm having some problems with this system call and probably with kmalloc.</p>

<p>Well , basically I'm building a system call , and this system call and the kernel are compiled without a problem.
But when I call my system call , the shell shows a lot of message and then the computer crash.</p>

<p>I think the problem is with the <strong>kmalloc</strong> , because when I remove the <strong>kmalloc</strong> and other code that envolves the <strong>kmalloc</strong> the system call works perfectly.</p>

<p><strong>For example: bloqueados = kmalloc(sizeof(struct bloqueio),GFP_ATOMIC);</strong></p>

<p>Just to add :
Maybe it's ocurring a deadlock , but I don't know accuratelly.</p>

<p>Thank you.</p>

<p>This is the code :</p>

<pre><code>#include &lt;linux/linkage.h&gt;
#include &lt;linux/io_block_unblock.h&gt;
//#include &lt;linux/printk.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/unistd.h&gt;
#include &lt;linux/stddef.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/gfp.h&gt;
#include &lt;linux/unistd.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/mount.h&gt;
#include &lt;linux/genhd.h&gt;
#include &lt;linux/device.h&gt;

struct bloqueio *bloqueados;
EXPORT_SYMBOLL(bloqueados);
asmlinkage long sys_io_block(const char __user *particao, const char __user *arquivo){
    int id_inode;
    struct file *arq;
    char *part;
    struct bloqueio *tmp;
    arq  = filp_open(arquivo,O_CREAT, S_IRWXU);
    printk(KERN_EMERG ""\nstruct file criado para o arquivo %s"",arquivo);
    id_inode = arq-&gt;f_path.dentry-&gt;d_inode-&gt;i_ino;
    printk(KERN_EMERG ""\nO inode do arquivo %s e  %d"",arquivo, id_inode);
    //part = arq-&gt;f_path.mnt-&gt;mnt_sb-&gt;s_bdev-&gt;bd_part-&gt;__dev.init_name;
    //printk(KERN_EMERG ""\nA particao a qual o arquivo se encontra e %s"",part);
    if(bloqueados == NULL){
            bloqueados = kmalloc(sizeof(struct bloqueio),GFP_ATOMIC);//&lt;--------------
            if(!bloqueados){
                    printk(KERN_EMERG ""\n Erro ao alocar memoria"");
                    return 0;
            }
            bloqueados-&gt;inode = id_inode;
            bloqueados-&gt;tipo = 0;
            bloqueados-&gt;prox = NULL;
    }
    else
    {
            tmp = kmalloc(sizeof(struct bloqueio), GFP_ATOMIC);//&lt;--------------------
            if(!bloqueados){
                    printk(KERN_EMERG ""\n Erro ao alocar memoria"");
                    return 0;
            }
            tmp-&gt;inode = id_inode;
            tmp-&gt;tipo = 0;
            tmp-&gt;prox = bloqueados-&gt;prox;
            bloqueados-&gt;prox = tmp;
    }
    return 1;
</code></pre>

<p>}</p>

<p><strong>Just to add , this is the struct bloqueio.</strong></p>

<pre><code>extern int contem(const char *arquivo);

struct bloqueio{
   int inode;
   int tipo;   // 0 -&gt; arquivo   1 -&gt; parti??o
   struct bloqueio *prox;
};

 extern struct bloqueio *bloqueados;
</code></pre>
"
"<p>I am writing a stackable file system which would rename unlinked files to a particular folder say abc by default. So as any file /xyz is unlinked its renamed to /abc/xyz. I want to do this by overriding the unlink function of stackable file system. I am using wrapfs so I am modifying wrapfs_unlink for this. I have dentry of the unlinked file also I have inode of parent directory , now I need to have inode of /abc and dentry of /abc/xyz to call vfs_rename instead of vfs_unlink. I could find the dentry and vfsmount for the / so I have a dentry for / but I don't know how to get the dentry/inode of /abc I know I can get inode from dentry but I cannot get dentry also. I tried using lookup_one_len /abc is created but still it returns a negative inode , also I tried to use vfs_path_lookup to find the directory /abc it also returns an error. Am I using wrong functions? Or these methods see cache only not the actual directory structure ? Please help.</p>
"
"<p>Take a look at the <code>struct file</code> definition <a href=""http://lxr.linux.no/#linux+v2.6.18/include/linux/fs.h#L671"" rel=""nofollow"">from this code</a> of Linux kernel version 2.6.18.  </p>

<p>I'm trying to compare two <code>struct file</code> variables in my code and determine if they're referring to the same file.  Is there any unique identifier in that structure that would help me make this comparison?  Or are there any helper functions available?</p>
"
"<p>I just implemented a simple driver(<a href=""http://code.google.com/p/ldd3/source/browse/trunk/scull/main.c?r=2#292"" rel=""nofollow"">scull device</a>) following Linux Device Driver</p>

<p>In the read function, I want to get the name of the file system. So I made some changes.</p>

<pre><code>ssize_t scull_read(struct file *filp, char __user *buf, size_t count,
            loff_t *f_pos)
{
    struct scull_dev *dev = filp-&gt;private_data;
    struct scull_qset *dptr;        /* the first listitem */
    int quantum = dev-&gt;quantum, qset = dev-&gt;qset;
    int itemsize = quantum * qset; /* how many bytes in the listitem */
    int item, s_pos, q_pos, rest;
    ssize_t retval = 0;

//start of change

    struct super_block *sp;
    const char *name;

    /** Get the super_block via struct inode, it works **/
    sp = flip-&gt;f_path.dentry-&gt;d_inode-&gt;i_sb;
    name = sp-&gt;s_type-&gt;name;

    /** Get the super_block via struct vfsmount, not works **/
    sp = flip-&gt;f_path.mnt-&gt;mnt_sb;

//end of change

    if (down_interruptible(&amp;dev-&gt;sem))
            return -ERESTARTSYS;
    if (*f_pos &gt;= dev-&gt;size)
            goto out;
    if (*f_pos + count &gt; dev-&gt;size)
            count = dev-&gt;size - *f_pos;
    ....
</code></pre>

<p>To get the super_block via inode, everything works well.</p>

<p>But while I am trying to get the super_block via vfsmount structure, I get error in compiling</p>

<pre><code> error: dereferencing pointer to incomplete type
</code></pre>

<p>It seems like that the super_block in vfsmount structure is not initialized.</p>

<p>To me, we should get the same super_block whatever the method we choose. But it's strange that the second method doesn't work.</p>

<p>Please correct if I wrongly understand.</p>

<p><strong>EDIT</strong></p>

<p>The following are the content of header file</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/moduleparam.h&gt;
#include &lt;linux/types.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/semaphore.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;asm/uaccess.h&gt;
#include ""scull.h""
</code></pre>
"
"<p>I am following the <strong>open()</strong> system call to find out when the <strong>struct file_operations</strong> and <strong>struct file</strong> get connected during a creation of file.</p>

<p>The main path is as follows:</p>

<pre><code>sys_open -&gt; do_sys_open -&gt; do_filp_open -&gt; nameidata_to_filp -&gt; __dentry_open
</code></pre>

<p>In __dentry_open</p>

<pre><code> static struct file *__dentry_open(struct dentry *dentry, struct vfsmount *mnt,
                                     int flags, struct file *f,
                                     int (*open)(struct inode *, struct file *),
                                     const struct cred *cred)
{
    struct inode *inode;
    int error;

    f-&gt;f_flags = flags;
    f-&gt;f_mode = ((flags+1) &amp; O_ACCMODE) | FMODE_LSEEK |
                            FMODE_PREAD | FMODE_PWRITE;
    inode = dentry-&gt;d_inode;
    if (f-&gt;f_mode &amp; FMODE_WRITE) {
            error = __get_file_write_access(inode, mnt);
            if (error)
                    goto cleanup_file;
            if (!special_file(inode-&gt;i_mode))
                    file_take_write(f);
    }

    f-&gt;f_mapping = inode-&gt;i_mapping;
    f-&gt;f_path.dentry = dentry;
    f-&gt;f_path.mnt = mnt;
    f-&gt;f_pos = 0;
    f-&gt;f_op = fops_get(inode-&gt;i_fop);//I think it is here that they get connected
    file_move(f, &amp;inode-&gt;i_sb-&gt;s_files);

    error = security_dentry_open(f);

    ...
</code></pre>

<p>But when and in which function that the i_fop in inode gets initialized?</p>
"
"<p>I am trying to find what member(s) of the <code>struct fdtable</code> or <code>struct file</code> will let me determine whether or not an open file is a socket or a pipe.</p>

<p>the only path I can seem to find is:</p>

<pre><code>struct file f ....;
f.path-&gt;mnt-&gt;mnt_devname
</code></pre>

<p>This returns the device name at the mountpoint, all sockets/pipes apparently belong to sockfs or pipefs respectively. </p>

<p>Is there a faster way to check to see if an open file is a socket or pipe using a different member of the struct file or fdtable?</p>

<p>Note: I am using the kernel definitions from 2.6.24</p>
"
"<p>I am developing a kernel module that uses unlocked_ioctl. I tested it with kernel version 2.6.24-23-generic and it works perfectly. Now I tried it with kernel version 3.3.1-1-ARCH and something weird happens: the ioctl function is not executed when the request value (cmd) is 2. It returns 0, but  the function is not executed. In order to check that it is not executed I did the following:</p>

<pre><code>static long midriver_ioctl(struct file *file,
    unsigned int cmd, unsigned long arg) {

printk(""Called with cmd = %d\n"", cmd);
</code></pre>

<p>I wrote a test program that calls ioctl for this device from 0 to 4096, and I can see in dmesg the message ""Called with cmd = n"" for all those values, except of ""2"", the only one that is not shown. </p>

<p>Any clues about what I am doing wrong?</p>

<p>Thank you in advance,</p>
"
"<p>In a userspace program in Linux, I get a piece of memory via allocation from the heap, then the pointer is distributed to a lot of other components running in other threads to use. I would like to get notified when the said piece of memory is modified. I can of course develop a custom userspace solution for other components to use when they try to modify the memory. The problem in my case is that these are legacy components and they can write to memory in many occasions. So I'm wondering whether there is a similar API like inotify (get notified when file is changed) or other approaches in order to get notified when a piece of memory is changed.</p>

<p>I considered using mmap and inotify, which obviously won't work if the changes are not flushed. Any suggestions are appreciated :-)</p>
"
"<p>I've got some linux drivers I'm trying to port from linux 2.4 to 3.0. During this lengthy span of time, the argument list of ioctl (unlocked_ioctl now) changed a bit:</p>

<pre><code>-static int can_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+static long can_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
</code></pre>

<p>The code was using the inode to get the minor version and was passing it to some other commands. Now that inode isn't a ""free-be"" given in the ioctl parameter list, how can I get it? </p>

<p>Is it possible to derive from the file pointer? or should I ""save"" a global pointer to it when it shows up in the _open() method? I'd rather avoid that if there's a better way.</p>
"
"<p><strong>EDIT:</strong> I don't have a good answer yet as to why I'm getting a failure here... So let me rephrase this a little. Do I even need the verify_area() check? What is the point of that? I have tested out the fact that my structure gets passed successfully to this ioctl, I'm thinking of just removing the failing check, but I'm not 100% what it's in there to do. Thoughts?
<strong>END EDIT</strong></p>

<p>I'm working to update some older linux kernel drivers and while testing one out I'm getting a failure which seems odd to me. Here we go:</p>

<p>I have a simple ioctl call in user space:</p>

<pre><code>Config_par_t    cfg;
int ret;
cfg.target = CONF_TIMING;
cfg.val1   = nBaud;
ret = ioctl(fd, CAN_CONFIG, &amp;cfg);
</code></pre>

<p>The Config_par_t is defined in can4linux.h file (this is the CAN driver that comes with uCLinux):</p>

<pre><code>typedef struct Command_par {
  int cmd;          /**&lt; special driver command */
  int target;           /**&lt; special configuration target */
  unsigned long val1;       /**&lt; 1. parameter for the target */
  unsigned long val2;       /**&lt; 2. parameter for the target */
  int error;            /**&lt; return value */
  unsigned long retval; /**&lt; return value */
} Command_par_t ;
</code></pre>

<p>In the kernel side of things, the ioctl function calls verify_area, which is the failing procedure:</p>

<pre><code>long can_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
    void *argp;
    long retval = -EIO;
    Message_par_t Message;
    Command_par_t Command;
    struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
    argp = &amp;Message;

    Can_errno = 0;

    switch(cmd) {
      case CONFIG:
        if( verify_area(VERIFY_READ, (void *) arg, sizeof(Command_par_t))) {
          return(retval);
        }
</code></pre>

<p>Now I know that verify_area() isn't used anymore so I updated it in a header file with this macro to access_ok:</p>

<pre><code>#if LINUX_VERSION_CODE &gt; KERNEL_VERSION(2, 6, 0)
#define verify_area(type, addr, size) access_ok(type, addr, size)
#endif
</code></pre>

<p>I'm on a x86 platform so I'm pretty sure the actual access_ok() macro being called is the one in /usr/src/linux/arch/x86/include/asm/uaccess.h as defined here:</p>

<pre><code>#define access_ok(type, addr, size) (likely(__range_not_ok(addr, size) == 0))

#define __range_not_ok(addr, size)                  \
({                                  \
    unsigned long flag, roksum;                 \
    __chk_user_ptr(addr);                       \
    asm(""add %3,%1 ; sbb %0,%0 ; cmp %1,%4 ; sbb $0,%0""     \
      : ""=&amp;r"" (flag), ""=r"" (roksum)             \
      : ""1"" (addr), ""g"" ((long)(size)),             \
        ""rm"" (current_thread_info()-&gt;addr_limit.seg));      \
   flag;                                \
})
</code></pre>

<p>I guess to me this looks like it should be working. Any ideas why I'm getting a 1 return from this verify_area if check? Or any ideas on how I can go about narrowing down the problem?</p>

<pre><code>if( verify_area(VERIFY_READ, (void *) arg, sizeof(Command_par_t))) {
</code></pre>
"
"<p>I am implementing my own system call in linux. It is calling the rename system call inside it. It uses a user argument (below is the code) to pass the code to the rename.</p>

<p>Here is the basic code:</p>

<pre><code>int sys_mycall(const char __user * inputFile)   {

//
// Code to generate my the ""fileName""
//
//

old_fs = get_fs();
set_fs(KERNEL_DS);

    ans =  sys_renameat(AT_FDCWD, fileName, AT_FDCWD, inputFile);

set_fs(old_fs);

    return ans;

}
</code></pre>

<p>I have two doubts here.</p>

<ol>
<li>I am using the <code>old_fs = get_fs();</code>,<code>set_fs(KERNEL_DS);</code> and <code>set_fs(old_fs);</code> to hack around the actual call to <code>sys_rename</code> because there was an error. I got the answer from this question: <a href=""https://stackoverflow.com/questions/7629141/allocate-user-space-memory-from-kernel"">allocate user-space memory from kernel</a> ... Is this a right work around?</li>
<li>How to call otherwise a system call from a system call</li>
</ol>

<p><strong>EDIT:</strong></p>

<pre><code>int sys_myfunc(const char __user * inputFileUser)   {


    char inputFile[255];
    int l = 0;
    while(inputFileUser[l] != '\0') l++;

    if(l==0)
        return -10;

    if(copy_from_user(inputFile,inputFileUser,l+1)&lt; 0 ) return -20;
//
//GENERATE fileName here
//
//

    char fileName[255];
    return  sys_renameat(AT_FDCWD, inputFile, AT_FDCWD, fileName);

}
</code></pre>

<p>The following still returns -1. Why? I copied the data to kernel space.</p>
"
"<p>How can I erase a file's contents completely to 0s or 1s in the linux kernel 3.5 given its file name (path to it) as the only input parameter?</p>

<p>I studied the structure of the unlink system call and it after a lot of checking calls <code>int vfs_unlink(struct inode *dir, struct dentry *dentry)</code> </p>

<p>so from the *dentry how can I delete the file's contents? Or should I use <code>*dentry</code> at all?</p>

<p><strong>EDIT</strong></p>

<p>In response to the answers: I just want to overwrite the data. And I am <em>not</em> looking for a perfect result. I have progressed this far:</p>

<p>On one side: using vfs_unlink</p>

<p>I am confused at the following code:</p>

<pre><code>error = security_inode_unlink(dir, dentry);
if (!error) {
error = dir-&gt;i_op-&gt;unlink(dir, dentry);
if (!error)
   dont_mount(dentry)
 }
</code></pre>

<p>Where is the actual unlink going on here?</p>

<p>Another approach: I just went ahead with writing the data using <a href=""http://lxr.linux.no/linux+v3.6.2/fs/sysfs/bin.c#L139"" rel=""nofollow"">write</a> system call:</p>

<p>I could not understand especially these lines:</p>

<pre><code> 143        int size = file-&gt;f_path.dentry-&gt;d_inode-&gt;i_size;
 144        loff_t offs = *off;
 145        int count = min_t(size_t, bytes, PAGE_SIZE);

 151        if (size) {
 152                if (offs &gt; size)
 153                        return 0;
 154                if (offs + count &gt; size)
 155                        count = size - offs;
 156        }
 157
 158        temp = memdup_user(userbuf, count);

 162        mutex_lock(&amp;bb-&gt;mutex);
 163
 164        memcpy(bb-&gt;buffer, temp, count);
 165
 166        count = flush_write(file, bb-&gt;buffer, offs, count);
 167        mutex_unlock(&amp;bb-&gt;mutex);
 168
 169        if (count &gt; 0)
 170                *off = offs + count;
 171
 172        kfree(temp);
 173        return count;
</code></pre>

<p>Can someone explain this to me? So that I can just write null to the file. my function may look like this.</p>

<pre><code>static void write(struct file *file)
</code></pre>

<p>I need help with this. I am not asking for code, but I am lost currently.</p>

<p>Thanks</p>

<p>PS: I know perfectly well how to do this very simple thing in user-level program. But that is not my task. I have to do it in kernel space. And I need help with that (and especially understanding the code as I new to kernel programming).</p>
"
"<p>Can someone tell me in which part of the following code the information about all the files that are present in a directory is present? I'm trying to filter out few files that are to be hidden when <em>ls</em> tries to list all the files in the directory.</p>

<pre><code>int vfs_readdir(struct file *file, filldir_t filler, void *buf)

{

      struct inode *inode = file-&gt;f_path.dentry-&gt;d_inode;
      int res = -ENOTDIR;
      if (!file-&gt;f_op || !file-&gt;f_op-&gt;readdir)
              goto out;

      res = security_file_permission(file, MAY_READ);
      if (res)
              goto out;

      res = mutex_lock_killable(&amp;inode-&gt;i_mutex);
      if (res)
              goto out;

      res = -ENOENT;
      if (!IS_DEADDIR(inode)) {
              res = file-&gt;f_op-&gt;readdir(file, buf, filler);
              file_accessed(file);
      }
      mutex_unlock(&amp;inode-&gt;i_mutex);
   out:
      return res;
}
</code></pre>
"
"<p>I am writing a device driver for Linux. It creates a device with 4 minor numbers. Whenever we attempt to write to the device at minor number 3, we are suppose to kill the device and currently it isn't suppose to do anything else except print it is writing to the booga device. Here is some of my current code and I can post more code if necessary:</p>

<p>Write method:</p>

<pre><code>static ssize_t booga_write (struct file *filp, const char *buf, size_t count, loff_t *f_pose) {
    printk(""Attempting to write to booga device\n"");
    /* need to protect this with a semaphore if multiple processes
       will invoke this driver to prevent a race condition */

    if (down_interruptible (&amp;booga_device_stats-&gt;sem))
        return (-ERESTARTSYS);
    booga_device_stats-&gt;num_bytes_written += count;
    up(&amp;booga_device_stats-&gt;sem);
    return count; // pretend that count bytes were written

}
</code></pre>

<p>How it is tested:</p>

<pre><code>static void run_write_test(char *device, int bufsize)
{
    char *buf;
    int src;
    int out;

    src = open(device, O_WRONLY);
    if (src &lt; 0) {
        perror(""Open for write failed:"");
        exit(1);
    }
    buf = (char *) malloc(sizeof(char)*(bufsize+1));
    fprintf(stderr, ""Attempting to write to booga device\n"");
    out = write(src, buf, bufsize);
    fprintf(stderr, ""Wrote %d bytes.\n"", out);
    free(buf);
    close(src);

}
</code></pre>

<p>I am wondering if there is a way to get the minor number. I looked in linux/fs.h and saw that the file struct has a member called private_data but whenever I attempt to call this, it will crash my system as it is currently set to null.</p>

<p>Or should I not be trying to get the minor number from the struct file at all and should attempt to keep track of it when I first open the device?</p>
"
"<p>Linux 3.2.2 kernel</p>

<p>I examined the source code in fs/namei.c and found do_unlinkat which performs the entire operation but takes a user space pointer. I was wondering if there is a function that does this except in the kernel space (i do have the struct path to the file, inode, and dentry)
I could just copy the code from the function into my own. But I was just wondering how it works as well?</p>
"
"<p>I'm developing a LKM for Linux kernel, and I want it to get some specific information that is file system related. In fact this information is the field <a href=""http://lxr.linux.no/#linux+v3.2/fs/ext4/ext4.h#L655"" rel=""nofollow"">i_crtime</a> (creation time) of a inode structure of a ext4 file system.</p>

<p>My question is, How could I access this field from a lkm? Right now I know how to get the inode of a specific file:</p>

<pre><code>kern_path(&lt;path to file&gt;, LOOKUP_FOLLOW, &amp;path)
</code></pre>

<p>So after this I have the inode via:</p>

<pre><code>path.dentry-&gt;d_inode
</code></pre>

<p>But this inode (d_inode) is the generic VFS <a href=""http://lxr.linux.no/#linux+v3.2/include/linux/fs.h#L749"" rel=""nofollow"">inode</a> structure, not the ext4_inode previously shown (nor ext4_inode_info neither).</p>

<p>Anybody knows how to do that? I'm trying to study the VFS code, the stat (coreutil) code, stracing it and I'm still stucked :-S</p>

<p>TIA.</p>
"
"<ul>
<li>Given a <code>inode</code> that exists in <code>/proc/**/fd/*</code></li>
<li>And a Linux Kernel Module that needs to find the executable path from the symbolic link <code>/proc/**/exe</code></li>
</ul>

<p>How could I implement this so that from a inode number I got the path of the executable using the fd ?</p>
"
"<p>I try to create an entry inside <code>/proc/net</code> from a kernel module, like this:</p>

<pre><code>struct file *filp = filp_open(""/proc/net"", O_RDONLY, 0);
struct proc_dir_entry *parent = PDE(filp-&gt;f_dentry-&gt;d_inode);
filp_close(filp, NULL);

proc_file = create_proc_entry(""test"", 0644, parent);
</code></pre>

<p>Crudely taken from <a href=""http://www.linuxquestions.org/questions/linux-kernel-70/create_proc_entry-path-help-894814/"" rel=""nofollow"">here</a></p>

<p>Why does it create my entry like <code>/proc/test</code> instead of <code>/proc/net/test</code>?</p>

<p>(Note: I'd like too use <code>create_proc_entry</code>, not <code>proc_create</code>.)</p>
"
"<p>I'm implementing a Character Driver. So I'm registering file operations.  When I'm registering <code>read</code> function i extracted <code>minor</code> number this way</p>

<pre><code>     myread(struct file * file, char __user * ubuf, size_t lbuf, loff_t *offset)
     {
         int minor;

         minor = MINOR(file-&gt;f_path.dentry-&gt;d_inode-&gt;f_pos-&gt;i_rdev);
         .......
</code></pre>

<p>This rule will apply to <code>open</code> call too.</p>

<pre><code>     myopen(struct inode * inode, struct file * file)
</code></pre>

<p><code>struct file</code> definition have the reference to <code>struct inode</code>. So one argument is enough for <code>open</code> call.</p>

<p>My questions are:</p>

<ol>
<li>Why <code>open</code> have two arguments? (or) why <code>read</code> don't have <code>struct inode *</code> argument?</li>
<li>To extract minor number in <code>read</code> call, i used above instruction. To find the definions and header files it took 1hr 30min to me. Is there any easy way to find the definitions of structures?</li>
<li>How many ways we can find the reference of <code>struct inode</code> through <code>struct file</code>  and what is the best way?</li>
</ol>
"
"<p>I know that my question has an answer here: <a href=""https://stackoverflow.com/questions/6171403/qfile-seek-performance"">QFile seek performance</a>. But I am not completely satisfied with the answer. Even after looking at the following implementation of <code>generic_file_llseek()</code> for ext4, I can't seem to understand how can the complexity be measured.</p>

<pre><code>/**
 * generic_file_llseek - generic llseek implementation for regular files
 * @file:       file structure to seek on
 * @offset:     file offset to seek to
 * @origin:     type of seek
 *
 * This is a generic implemenation of -&gt;llseek useable for all normal local
 * filesystems.  It just updates the file offset to the value specified by
 * @offset and @origin under i_mutex.
 */
loff_t generic_file_llseek(struct file *file, loff_t offset, int origin)
{
        loff_t rval;

        mutex_lock(&amp;file-&gt;f_dentry-&gt;d_inode-&gt;i_mutex);
        rval = generic_file_llseek_unlocked(file, offset, origin);
        mutex_unlock(&amp;file-&gt;f_dentry-&gt;d_inode-&gt;i_mutex);

        return rval;
}

/**
 * generic_file_llseek_unlocked - lockless generic llseek implementation
 * @file:       file structure to seek on
 * @offset:     file offset to seek to
 * @origin:     type of seek
 *
 * Updates the file offset to the value specified by @offset and @origin.
 * Locking must be provided by the caller.
 */
loff_t
generic_file_llseek_unlocked(struct file *file, loff_t offset, int origin)
{
        struct inode *inode = file-&gt;f_mapping-&gt;host;

        switch (origin) {
        case SEEK_END:
                offset += inode-&gt;i_size;
                break;
        case SEEK_CUR:
                /*
                 * Here we special-case the lseek(fd, 0, SEEK_CUR)
                 * position-querying operation.  Avoid rewriting the ""same""
                 * f_pos value back to the file because a concurrent read(),
                 * write() or lseek() might have altered it
                 */
                if (offset == 0)
                        return file-&gt;f_pos;
               break;
        }

        if (offset &lt; 0 || offset &gt; inode-&gt;i_sb-&gt;s_maxbytes)
                return -EINVAL;

        /* Special lock needed here? */
        if (offset != file-&gt;f_pos) {
                file-&gt;f_pos = offset;

                file-&gt;f_version = 0;
        }

        return offset;
}
</code></pre>

<p>Say, for example, I have a 4GB file, and I know the offset for the middle portion in the file, how exactly does a <code>lseek()</code> get me there without traversing the entire file? Does the OS already know where each byte of the file resides?</p>
"
"<p>Could anyone provide the code to overcome this problem?</p>

<p>Effectively how do we obtain the <code>struct inode*</code> from kernel level given the file <code>/dev/driver1</code>?</p>

<p>Given in user space that:</p>

<pre><code>int fd;
fd = open(""/dev/driver1"", O_RDWR | O_SYNC);
</code></pre>

<p>In Kernel space:</p>

<pre><code>static long dev_ioctl(struct file *file, unsigned cmd, unsigned long arg)
struct dev_handle *handle;
handle = file-&gt;private_data;
</code></pre>

<p>Assuming that, we do not go by that path, </p>

<p>How do we obtain within the kernel itself, by eg. hard coding the <code>file-&gt;private_data</code> to be given to handle?</p>
"
"<p>I am doing kernel programming.
I wanted to know which mutex_locks() are to be held before using vfs_rename(...) function in kernel module.</p>

<p>Prototype of vfs_rename(...)</p>

<p>int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,
               struct inode *new_dir, struct dentry *new_dentry,)</p>

<p>Thanks</p>
"
"<p>I wanted to know which of the following entries of inode contains time at which file was created and time at which file was last modified ?</p>

<p>Thanks</p>
"
"<p>I am writing a driver for a USB device that has three different read/write operations (flash, EEPROM, and I2C), each with a different implementation. I've been scratching my head about this, since I'm new to this whole world of linux kernel development. I've read that I should avoid ioctl at all costs, but I cannot tell how to implement this. Since everything in linux is a file, could I create multiple endpoints to write to for each location? How would I even go about doing this? Would I define multiple <code>usb_class_driver</code> structs?</p>

<p>On the flip side, should I include all the functionality in a single endpoint and use ioctl? Is it better to split the work up from the same driver or to consolidate all the functionality in one place?</p>

<p>I cannot use libusb due to its limitations on isochronous transfers and lack of direct control over dma transfers (both needed the product final product).</p>

<p><strong>UPDATE:</strong>
After trying to use multiple generic file operations for each endpoint and getting a response code of -98 (already registered), I think I am going to have to use the single endpoint with ioctl. The code that isn't working is as follows:</p>

<p><strong>In adriver.h</strong></p>

<pre><code>static struct usb_class_driver adriver_eeprom_class = {
    .name = ""usb/adriver_eeprom%d"",
    .fops = &amp;adriver_eeprom_fops,
    .minor_base = USB_SKEL_MINOR_BASE,
};
static struct usb_class_driver adriver_flash_class = {
    .name = ""usb/adriver_flash%d"",
    .fops = &amp;adriver_flash_fops,
    .minor_base = USB_SKEL_MINOR_BASE,
};
static struct usb_class_driver adriver_i2c_class = {
    .name = ""usb/adriver_i2c%d"",
    .fops = &amp;adriver_i2c_fops,
    .minor_base = USB_SKEL_MINOR_BASE,
};
static struct usb_class_driver driver_fifo_class = {
    .name = ""usb/driver_fifo%d"",
    .fops = &amp;driver_fifo_fops,
    .minor_base = USB_SKEL_MINOR_BASE,
};
static struct usb_class_driver adriver_class = {
    .name = ""usb/adriver%d"",
    .fops = &amp;adriver_fops,
    .minor_base = USB_SKEL_MINOR_BASE,
};
</code></pre>

<p><strong>In adriver.c</strong></p>

<pre><code>static int adriver_probe(struct usb_interface *interface, const struct usb_device_id *id) {
    struct usb_device *udev = interface_to_usbdev(interface);
    struct usb_adriver *gdev;
    int retval = -ENOMEM;
    gdev = kmalloc(sizeof(struct usb_adriver), GFP_KERNEL);
    if(gdev == NULL)
    {
        dev_err(&amp;interface-&gt;dev, ""Out of memory\n"");
        goto error;
    }
    memset(gdev, 0x00, sizeof(*gdev));

    kref_init(&amp;gdev-&gt;kref);

    gdev-&gt;udev = usb_get_dev(udev);

    usb_set_intfdata(interface,gdev);

    retval = usb_register_dev(interface, &amp;adriver_eeprom_class);
    if (retval) {
        /* something prevented us from registering this driver */
        pr_err(""Not able to get a minor for this device."");
        usb_set_intfdata(interface, NULL);
        goto error;
    }
    retval = usb_register_dev(interface, &amp;adriver_flash_class);
    if (retval) {
        /* something prevented us from registering this driver */
        pr_err(""Not able to get a minor for this device."");
        usb_set_intfdata(interface, NULL);
        goto error;
    }
    retval = usb_register_dev(interface, &amp;adriver_i2c_class);
    if (retval) {
        /* something prevented us from registering this driver */
        pr_err(""Not able to get a minor for this device."");
        usb_set_intfdata(interface, NULL);
        goto error;
    }
    retval = usb_register_dev(interface, &amp;adriver_fifo_class);
    if (retval) {
        /* something prevented us from registering this driver */
        pr_err(""Not able to get a minor for this device."");
        usb_set_intfdata(interface, NULL);
        goto error;
    }
    retval = usb_register_dev(interface, &amp;adriver_class);
    if (retval) {
        /* something prevented us from registering this driver */
        pr_err(""Not able to get a minor for this device."");
        usb_set_intfdata(interface, NULL);
        goto error;
    }

    dev_info(&amp;interface-&gt;dev, ""USB adriver device now attached\n"");
    return 0;

error:
    if (gdev)
        kref_put(&amp;gdev-&gt;kref, adriver_delete);
    return retval;
}
</code></pre>
"
"<p>I tried code(Using Linux Kernel Crypto APIs) for calculating HMAC-SHA512 on a file.
Surprisingly, HMAC calculated from the kernel code and from OpenSSL commands are different.</p>

<p>OpenSSL commands are:</p>

<pre><code>openssl rand -base64 16
plakOhrXlfnBENPVBo91kg==
openssl dgst -sha512 -mac hmac -macopt key:plakOhrXlfnBENPVBo91kg== ../hello6.ko
HMAC-SHA512(../hello6.ko)=   9605f40851630f5b7a18fa30c7e5d6f1e77afb011d319efa515556d12ba6930f459825b3695a0d0d910a714724c0d99b36ccea5c878962b32a8de65dcbcc247d
</code></pre>

<p>HMAC-SHA512 from the kernel code is:  </p>

<pre><code>84306723b713379aa666fe9aa75af3192a9707d19136c25dd2286c5f6d86dfd8f76ceaa0ce147b53c0e9f7bfab485f38f5139c687c34c840db7f7fa9438bf8b0d8df8e770088ffffc8de8e770088ffffc3f027a0ffffffff672c00000088fffff0de8e770088ffff1900000000000080672c000000000000e8de8e770088ffff
</code></pre>

<p>How come these HMACs are different for the same content? Any pointers to get rid of this issue is very helpful.  </p>

<p>Base64 encoded key is generated by below command and stored in a file: </p>

<pre><code>openssl rand -base64 -out $Module_name.sha512key 16
</code></pre>

<p>HMAC is generated on a file and stored in a file.
    openssl dgst -sha512 -mac hmac -macopt key:$HMAC_KEY $HMAC_PATH/$Module_name> temp.txt</p>

<p>Key and File content are read by below code:</p>

<pre><code>    static char hmac[HMAC_SHA512_SIZE];
    const char *kofilename = ""/home/sri/Documents/Hello/hello6.ko"";
    const char *hmackey_file = ""/home/sri/Documents/Hello/hello6.ko.sha512key"";
    const char *hmac_file = ""/home/sri/Documents/Hello/hello6.ko.sha512"";

    unsigned char *data = NULL;
    int readkostatus;
    int readkeystatus;
    int readhmacstatus;

    unsigned char *hmackey = NULL;
    unsigned char *stored_hmac = NULL;

    readkeystatus = read_file(hmackey_file, &amp;hmackey);

    if(readkeystatus &lt; 0)
        goto readkeyerr;

    printk(KERN_INFO ""HMAC Key is :%s"", hmackey);

    readkostatus = read_kofile(kofilename, &amp;data);

    if(readkostatus &lt; 0)
        goto readkoerr;

    printk(KERN_INFO ""File data size is :%ld"", strlen(data));
    printk(KERN_INFO ""File data is :%s"", data);

    hmac_sha512(hmackey, data, hmac, sizeof(hmac));
    printk(KERN_INFO ""FINAL HMAC:%s"", hmac);

    readhmacstatus = read_file(hmac_file, &amp;stored_hmac);

    if(readhmacstatus &lt; 0)
    goto readhmacerr;

    printk(KERN_INFO ""Stored HMAC:%s"", stored_hmac);

    if(!memcmp(stored_hmac, hmac, HMAC_SHA512_SIZE))
    printk(KERN_INFO ""HMACs match"");
    else
        printk(KERN_INFO ""HMACs do not match"");

    vfree(stored_hmac);
    vfree(data);
    vfree(hmackey);

    return 0;

   readkeyerr:
   {
       printk(KERN_INFO ""hmac key read error:%d"", readkeystatus);
       return readkeystatus;
   }

   readkoerr:
   {
       printk(KERN_INFO ""ko read error:%d"", readkostatus);
       return readkostatus;
   }

   readhmacerr:
   {
       printk(KERN_INFO ""hmac read error:%d"", readhmacstatus);
       return readhmacstatus;
   }
</code></pre>

<p>Code for reading the files is given below:</p>

<pre><code>    int read_file(const char *filename, unsigned char **data)
    {
        struct file* filp = NULL;
        long filesize;
        int ret = 0;


        mm_segment_t old_fs = get_fs();
        set_fs(get_ds());
        filp = filp_open(filename, O_RDONLY, 0);
        if(IS_ERR(filp)) {
            ret = PTR_ERR(filp);
            printk(KERN_INFO ""kofile is not opened"");
        }
        else
        {
            loff_t offset;
            offset = 0;
            filesize = filp-&gt;f_dentry-&gt;d_inode-&gt;i_size;
            if (filesize &lt;= 0 || filesize &gt; 131072)
            {
                goto fileoperror;
            }

            *data = (unsigned char *)vmalloc(filesize);

            if (*data == NULL)
                goto datanull;

            ret = vfs_read(filp, *data, filesize, &amp;offset);

            if(ret != filesize)
                goto read_error;

            filp_close(filp, NULL);
        }

        set_fs(old_fs);
        return ret;

    fileoperror:
        {
            filp_close(filp, NULL);
            set_fs(old_fs);
            printk(KERN_INFO ""Invalid file operation '%s'\n"", filename);
            return (-EPERM);
        }
    datanull:
        {
            filp_close(filp, NULL);
            set_fs(old_fs);
            printk(KERN_INFO ""Data Buffer is not allocated"");
            return (-EFAULT);
        }

    read_error:
        {
            filp_close(filp, NULL);
            set_fs(old_fs);
            printk(KERN_INFO ""Failed to read '%s'.\n"", filename);
            return (-EFBIG);
        }

    }

int read_kofile(const char* filename, unsigned char **data)
{
   return read_file(filename, data);
}
</code></pre>

<p>HMAC-SHA-512 is calculated on the file by calling Crypto APIs:</p>

<pre><code>#define HMAC_SHA512_SIZE 64

struct hmac_sha512_result {
    struct completion completion;
    int err;
};

static void hmac_sha512_complete(struct crypto_async_request *req, int err) {
    struct hmac_sha512_result *r=req-&gt;data;
    if(err==-EINPROGRESS)
        return;
    r-&gt;err=err;
    complete(&amp;r-&gt;completion);
}

int hmac_sha512(const unsigned char *key, // key
                         const unsigned char *data_in, // data in
                        unsigned char *hash_out, size_t outlen) {  // hash buffer and length

    int rc=0;
    struct crypto_ahash *tfm;
    struct scatterlist sg;
    struct ahash_request *req;
    struct hmac_sha512_result tresult;
    void *hash_buf;
        size_t klen = strlen(key);
        size_t dlen = strlen(data_in);

        int len = HMAC_SHA512_SIZE;
        char hash_tmp[HMAC_SHA512_SIZE];
    char *hash_res = hash_tmp;

        printk(KERN_INFO ""hmac_sha512: HMAC key is %s "", key);

    /* Set hash output to 0 initially */
    memset(hash_out, 0, outlen);

    init_completion(&amp;tresult.completion);
    tfm=crypto_alloc_ahash(""hmac(sha512)"",0,0);
    if(IS_ERR(tfm)) {
        printk(KERN_ERR ""hmac_sha512: crypto_alloc_ahash failed.\n"");
        rc=PTR_ERR(tfm);
        goto err_tfm;
    }
    if(!(req=ahash_request_alloc(tfm,GFP_KERNEL))) {
        printk(KERN_ERR ""hmac_sha512: failed to allocate request for hmac(sha512)\n"");
        rc=-ENOMEM;
        goto err_req;
    }
    if(crypto_ahash_digestsize(tfm)&gt;len) {
        printk(KERN_ERR ""hmac_sha512: tfm size &gt; result buffer.\n"");
        rc=-EINVAL;
        goto err_req;
    }
    ahash_request_set_callback(req,CRYPTO_TFM_REQ_MAY_BACKLOG,
                    hmac_sha512_complete,&amp;tresult);

    if(!(hash_buf=kzalloc(dlen,GFP_KERNEL))) {
        printk(KERN_ERR ""hmac_sha512: failed to kzalloc hash_buf"");
        rc=-ENOMEM;
        goto err_hash_buf;
    }
    memcpy(hash_buf,data_in,dlen);
    sg_init_one(&amp;sg,hash_buf,dlen);

    crypto_ahash_clear_flags(tfm,-0);
    if((rc=crypto_ahash_setkey(tfm,key,klen))){
        printk(KERN_ERR ""hmac_sha512: crypto_ahash_setkey failed\n"");
        goto err_setkey;
    }
    ahash_request_set_crypt(req,&amp;sg,hash_res,dlen);
    rc=crypto_ahash_digest(req);
    switch(rc) {
        case 0:
            while (len--) {
                snprintf(hash_out, outlen, ""%02x"", (*hash_res++ &amp; 0x0FF));
                hash_out += 2;
            }

                break;
        case -EINPROGRESS:
        case -EBUSY:
            rc=wait_for_completion_interruptible(&amp;tresult.completion);
            if(!rc &amp;&amp; !(rc=tresult.err)) {
                INIT_COMPLETION(tresult.completion);
                break;
            } else {
                printk(KERN_ERR ""hmac_sha512: wait_for_completion_interruptible failed\n"");
                goto out;
            }
        default:
            goto out;
    }

    out:
    err_setkey:
        kfree(hash_buf);
    err_hash_buf:
        ahash_request_free(req);
    err_req:
        crypto_free_ahash(tfm);
    err_tfm:
        return rc;
}
</code></pre>

<p>Please let me know, if something is missing.</p>
"
"<p>I am trying to implement a FIFO using character driver. However while writing to the device it doesn't seem to work. It doesn't seems to end the loop. Any help or link is appreciated. I have taken help from many sources so current code is kind of mess with many things which shouldn't be as they are.</p>

<pre><code>static ssize_t dev_write(struct file *filp, const char *buff, size_t len, loff_t *off) {
int mode;
int ind;
ssize_t count = -ENOMEM;
printk(KERN_ALERT ""to be written : %s\n"", buff);
mode = iminor(filp-&gt;f_dentry-&gt;d_inode);
printk(KERN_ALERT ""Device minor : %d\n"", mode);
if ((mode == 1) || (mode ==3))
        return -EINVAL;
if (mode == 0){
    count = 0;
    ind = 0;
    if (buff[ind] == NULL) {
        return -ENOMEM;
    }
    printk(KERN_ALERT ""Write position1 : %d\n"", writePos1);
    while(ind&lt;=len) {  //loop untill we have something to writer
        if (down_interruptible(&amp;buffer1_e)) { //taking flag first isn't right because that won't allow other guyto give access to our turn.
                printk(KERN_ALERT ""buffer1 flag didn't work\t %d"", buffer1_e.count);
                return -ERESTARTSYS;
        }
        else {
            if (down_interruptible(&amp;flag1)){
                up(&amp;buffer1_e);         //must because we couldn't write it properly
                return -EINVAL;
            }
            else {
                queue1[writePos1] = buff[ind];
                printk(KERN_ALERT ""Write %d %c\n"",ind,queue1[writePos1]);
                if (writePos1 == 9){
                     writePos1 = 0;
                }
                else
                     writePos1++;
                count++;
            }
            up(&amp;flag1);
        }
        up(&amp;buffer1_f);
        off += count;
        ind++;
    }
    printk(KERN_ALERT ""Write position1 now: %d\t and count%d\n"", writePos1,count);
    return count-1;
}
</code></pre>
"
"<p>As I understand the system control variable, the first value in <code>kernel.printk</code> is the number that kernel messages must be smaller than in order to be written to the console. So, if it is <code>4</code>, then message produced by this will only be visible with <code>dmesg</code>:</p>

<pre><code>printk(KERN_INFO ""This is a kernel message."");
</code></pre>

<p>The only time a message will appear on the console is if it was preceded by <code>KERN_ERR</code>, <code>KERN_CRIT</code>, <code>KERN_INFO</code>, or <code>KERN_EMERG</code>. Even if something went wrong with a kernel module, I would expect that messages like the above would not appear on my screen.</p>

<p>One of the things I am trying my hand at is system call interception. Some have worked flawlessly and others have not. But on several occasions, messages from my unsuccessful kernel modules marked with <code>KERN_INFO</code> have clogged my console, not giving me enough time between messages to unload them. The screw up is occurring somewhere in these lines of code:</p>

<pre><code>?
#define INODE_IS_DEVICE(inode) (S_ISBLK(inode-&gt;i_mode) || S_ISCHR(inode-&gt;i_mode))
#define INODE_IS_RAW(inode) (imajor(inode) == RAW_MAJOR)
#define INODE_IS_RAW_DEVICE(inode) (INODE_IS_DEVICE(inode) || INODE_IS_RAW(inode))
#define TEST_OPEN_FLAGS(flags) ((flags &amp; O_WRONLY) || (flags &amp; O_RDWR))
?
struct inode *current_inode;
?
struct inode* get_inode_from_pathname(const char pathname) {
    struct path path;
    kern_path(pathname, LOOKUP_FOLLOW, &amp;path);
    return path.dentry-&gt;d_inode;
}

asmlinkage int (*real_open)(const char* __user, int, int);

asmlinkage int custom_open(const char* __user file_name, int flags, int mode) {
    current_inode = get_inode_from_pathname(file_name);
    printk(KERN_INFO ""intercepted: open(\""%s\"", %X, %X)\n"", file_name, flags, mode);
    if (INODE_IS_RAW_DEVICE(inode) &amp;&amp; TEST_OPEN_FLAGS(flags)) {
        printk(KERN_INFO ""Intercepted call to write to block device %s.\n"", file_name);
    }
    return real_open(file_name, flags, mode);
}
?
void hack(void) {
    make_rw((unsigned_long)sys_call_table);
    real_open = (void*)*(sys_call_table + __NR_open);
    *(sys_call_table + __NR_open) = (unsigned_long)custom_open;
    make_ro((unsigned_long)sys_call_table);
}

void restore(void) {
    make_rw((unsigned_long)sys_call_table);
    *(sys_call_table + __NR_open) = (unsigned_long)real_open;
    make_ro((unsigned_long)sys_call_table);
}
</code></pre>

<p>The code for <code>make_rw</code> and <code>make_ro</code> are identical to the ones found <a href=""http://syprog.blogspot.com/2011/10/hijack-linux-system-calls-part-iii.html"" rel=""nofollow"">here</a>. Compiling this code gave me no errors, but loading the modules results in the messages being orinted to the console as well as some kind crash or error. Note, that when the block of code inside <code>custom_open</code> is replaced with</p>

<pre><code>    printk(KERN_INFO ""intercepted: open(\""%s\"", %X, %X)\n"", file_name, flags, mode);
    if (file_name == ""/dev/sda"" &amp;&amp; TEST_OPEN_FLAGS(flags)) {
        printk(""Intercepted call to write to block device."");
        return -EPERM;
    }
    return real_open(file_name, flags, mode);
</code></pre>

<p>everything works the way I want it to. Replacing <code>custom_open</code>'s control flow statement instead with <code>print(KERN_INFO ""i_mode of %s: %hu\n"", file_name, current_inode-&gt;i_mode);</code> produces the exact same problem.</p>

<p>I'm not sure what's producing the error here. Any insights?</p>
"
"<p>I've seen lots of questions about getting a file's path from it's inode, but almost none about doing the reverse. My kernel module needs to do this to get further information about the subjects of requests passed to <code>open()</code>, such as its file flags or whether or not it's a device. From what I was able to scrounge together from mailing lists, manual pages, and the Linux source code, I came up with this small function:</p>

<pre><code>struct inode* get_inode_from_pathname(const char *pathname) {
    struct path path;
    kern_path(pathname, LOOKUP_FOLLOW, &amp;path);
    return path.dentry-&gt;d_inode;
}
</code></pre>

<p>Trying to use it in my replacement system call makes kernel messages get printed to the console, though:</p>

<pre><code>struct inode *current_inode;
...
asmlinkage int custom_open(char const *__user file_name, int flags, int mode) {
    current_inode = get_inode_from_pathname(file_name);
    printk(KERN_INFO ""intercepted: open(\""%s\"", %X, %X)\n"", file_name, flags, mode);
    printk(KERN_INFO ""i_mode of %s:%hu\n"", file_name, current_inode-&gt;i_mode);
    return real_open(file_name, flags, mode);
}
</code></pre>

<p>Is there a better way to do this? I'm almost positive my way is wrong.</p>
"
"<p>I am implementing a simple caeser cipher on <a href=""http://wrapfs.filesystems.org/"" rel=""nofollow"">WrapFS</a> to store encrypted data and decrypt while reading. For that purpose I made minor changes to <code>wrapfs_read() and wrapfs_write()</code> functions provided in the source code to encrypt and decypt the data. My decryption is working fine, but due to my encryption code I am getting an error on write as follows <code>bash: echo: write error: bad address</code>. Any help regarding handling it would be really appreciated.</p>

<pre><code>void caeser_encrypt(char __user *encrypted, size_t count)
{
    int i;
    for(i=0;i&lt;(unsigned int)count;i++)
        encrypted[i]=encrypted[i]+3;
    printk(KERN_INFO ""%s"",encrypted);
    return;
}

static ssize_t wrapfs_write(struct file *file, const char __user *buf,
                size_t count, loff_t *ppos)
{
    int err = 0;
    struct file *lower_file;
    struct dentry *dentry = file-&gt;f_path.dentry;
    char *encrypted = NULL;

    lower_file = wrapfs_lower_file(file);

/*Added by me*/
    encrypted=kmalloc(sizeof(buf),GFP_USER);
    memcpy(encrypted,buf,count);
    printk(KERN_INFO ""%d %d"",(int)sizeof(buf), (int)count);
    caeser_encrypt(encrypted,count);
    err = vfs_write(lower_file, encrypted, count, ppos);
/*Added by me*/

    //err = vfs_write(lower_file, buf, count, ppos);
    /* update our inode times+sizes upon a successful lower write */
    if (err &gt;= 0) {
        fsstack_copy_inode_size(dentry-&gt;d_inode,
                    lower_file-&gt;f_path.dentry-&gt;d_inode);
        fsstack_copy_attr_times(dentry-&gt;d_inode,
                    lower_file-&gt;f_path.dentry-&gt;d_inode);
    }

/*Added by me*/
    kfree(encrypted);
    return err;
}
</code></pre>
"
"<p>I am trying to modify the rm_dir command on the linux kernel. I want to add a confirmation request. something like: ""Are you sure you want to erase this directory (Y/N): ""</p>

<p>I have found the implementation (or at least I think I have) under fs directory for file-systems. I think there must be some sort of a manager that checks what file system is used on the particular architecture, which then calls the appropriate implementation of the deleting process. However, I could not find such a ""manager"" function. All I found was the following macro:</p>

<pre><code>SYSCALL_DEFINE1(rmdir, const char __user *, pathname)
{
    return do_rmdir(AT_FDCWD, pathname);
}
</code></pre>

<p>this simply calls the function do_rmdir just above it. here it is:</p>

<pre><code>static long do_rmdir(int dfd, const char __user *pathname)
{
    int error = 0;
    struct filename *name;
    struct dentry *dentry;
    struct nameidata nd;
    unsigned int lookup_flags = 0;
retry:
    name = user_path_parent(dfd, pathname, &amp;nd, lookup_flags);
    if (IS_ERR(name))
        return PTR_ERR(name);

    switch(nd.last_type) {
    case LAST_DOTDOT:
        error = -ENOTEMPTY;
        goto exit1;
    case LAST_DOT:
        error = -EINVAL;
        goto exit1;
    case LAST_ROOT:
        error = -EBUSY;
        goto exit1;
    }

    nd.flags &amp;= ~LOOKUP_PARENT;
    error = mnt_want_write(nd.path.mnt);
    if (error)
        goto exit1;

    mutex_lock_nested(&amp;nd.path.dentry-&gt;d_inode-&gt;i_mutex, I_MUTEX_PARENT);
    dentry = lookup_hash(&amp;nd);
    error = PTR_ERR(dentry);
    if (IS_ERR(dentry))
        goto exit2;
    if (!dentry-&gt;d_inode) {
        error = -ENOENT;
        goto exit3;
    }
    error = security_path_rmdir(&amp;nd.path, dentry);
    if (error)
        goto exit3;
    error = vfs_rmdir(nd.path.dentry-&gt;d_inode, dentry);
exit3:
    dput(dentry);
exit2:
    mutex_unlock(&amp;nd.path.dentry-&gt;d_inode-&gt;i_mutex);
    mnt_drop_write(nd.path.mnt);
exit1:
    path_put(&amp;nd.path);
    putname(name);
    if (retry_estale(error, lookup_flags)) {
        lookup_flags |= LOOKUP_REVAL;
        goto retry;
    }
    return error;
}
</code></pre>

<p>I tried adding a printk statement, but the result is outside of the actual UML that uses that kernel. The result simply doesn't show in the correct UML window - (the one that uses this kernel). I am not sure how to do I/O in kernel space. Can somebody help? Thanks.</p>
"
"<p>How do I get the parent directory for a <code>struct file*</code> in a linux kernel driver?</p>

<p>I want to get information about the parent, and the parents parent directory.</p>
"
"<p>I'm writing a LKM program to hook <code>sys_read</code> function for reuse 80 TCP port.
But I meet an problem is that I don't know how to access Port by <code>inode</code> struct.
There is a part of my program.</p>

<p><div class=""snippet"" data-lang=""js"" data-hide=""false"">
<div class=""snippet-code"">
<pre class=""snippet-code-html lang-html prettyprint-override""><code>Linux.2.6.3.38

asmlinkage ssize_t new_read(unsigned int fd, void *buf, size_t count){
 //printk(""PID %d called sys_read !\n"",current-&gt;pid);
 char kbuf[MAX_BUF];
 ssize_t ret;
 struct file *file;
 ret=orig_read(fd, buf, count);
 memset(kbuf, 0,MAX_BUF);
 memcpy(kbuf, buf, ret);
 printk(""kbuf:%s\n"",kbuf);
 if( memcmp(kbuf, passwd, strlen(passwd)) == 0 )
 {
  file = fget(fd);
  if(file-&gt;f_dentry-&gt;d_inode-&gt;???? == PORT)
   printk(""get http message\n"");
  fput(file);
 }
}</code></pre>
</div>
</div>
</p>

<p>Thanks for answering.</p>
"
"<p>I want to create a proc entry under /proc/driver/  path, </p>

<p>I am using this code:</p>

<pre><code> struct file *fp = filp_open(""/proc/driver"",O_RDONLY,0);
 struct proc_dir_entry *parent ;
 parent =  PDE(fp-&gt;f_dentry-&gt;d_inode);
 filp_close(fp, NULL);
 proc_create(""leds"",0,parent,&amp;proc_fops);
</code></pre>

<p>But when compile i got error :</p>

<pre><code>error: implicit declaration of function ?PDE? [-Werror=implicit-function-declaration]
</code></pre>

<p>How can i fix this problem?
Thanks in advance.</p>
"
"<p>This is more or less a question about methodology and rationale than anything. In programming various kernel modules for Linux, I'm confounded by what I consider to be a clunky way of designing functions. For example, to retrieve the inode of a file given its path, I had to use something like:</p>

<pre><code>struct inode *inode;
struct path path;
kern_path(path_name, LOOKUP_FOLLOW, &amp;path);
inode = path.dentry-&gt;d_inode;
</code></pre>

<p>Why not just a function that works like:</p>

<pre><code>struct inode inode;
struct path path = kern_path(path_name, LOOKUP_FOLLOW);
inode = path.dentry-&gt;d_inode;
</code></pre>

<p>Seems much more intuitive.</p>
"
"<p>In a kernel module, I have a path, say <em>/tmp/foo</em>, how can I know whether it is directory or a file?</p>
"
"<p>I have run into a very weird scenario, I am writing a custom kernel module for my QNAP 639 Pro. </p>

<p>The module was successfully running under the same kernel version in Ubuntu 12.04:</p>

<blockquote>
  <p>Linux ubuntu 3.4.6-030406-generic #201207191609 SMP i686 i686 i386
  GNU/Linux</p>
</blockquote>

<p>However after many hours of compilation on my qnap, i get a kernel oops with a pointer dereference, here is a dmesg dump:</p>

<pre><code>[ 1491.062409] Got pinode dentry
[ 1491.062434] BUG: unable to handle kernel NULL pointer dereference at   (null)
[ 1491.063351] IP: [&lt;c0605e48&gt;] memcpy+0x18/0x2c
[ 1491.063351] *pde = 00000000
[ 1491.063351] Oops: 0000 [#1] SMP
[ 1491.063351] Modules linked in: nocansee(O+) iscsi_tcp(O) libiscsi_tcp(O) libiscsi(O) scsi_transport_iscsi(O) fbdisk(O) bridge stp ipv6 8021q uvcvideo videobuf2_vmalloc videobuf2_memops videobuf2_core v4l2_common videodev v4l2_int_device snd_usb_caiaq snd_usb_audio hid_logitech snd_usbmidi_lib snd_hwdep snd_seq_midi snd_rawmidi fnotify(PO) xhci_hcd udf isofs ufsd(PO) jnl(O) e1000e(O) usblp iTCO_wdt iTCO_vendor_support rtcmod(O) usbhid cryptodev(O) hal_netlink(O) usb_storage uhci_hcd ehci_hcd usbcore usb_common mv_sata(O) [last unloaded: nocansee]
[ 1491.063351]
[ 1491.063351] Pid: 17279, comm: insmod Tainted: P           O 3.4.6 #1 ICP / iEi ATOM NAS /ATOM NAS (QE05)
[ 1491.063351] EIP: 0060:[&lt;c0605e48&gt;] EFLAGS: 00210286 CPU: 0
[ 1491.063351] EIP is at memcpy+0x18/0x2c
[ 1491.063351] EAX: 0000001a EBX: f8e60978 ECX: 0000001a EDX: 00000068
[ 1491.063351] ESI: 00000000 EDI: f8e60978 EBP: d38a7e64 ESP: d38a7e50
[ 1491.063351]  DS: 007b ES: 007b FS: 00d8 GS: 00e0 SS: 0068
[ 1491.063351] CR0: 8005003b CR2: 00000000 CR3: 35ecd000 CR4: 000007c0
[ 1491.063351] DR0: 00000000 DR1: 00000000 DR2: 00000000 DR3: 00000000
[ 1491.063351] DR6: ffff0ff0 DR7: 00000400
[ 1491.063351] Process insmod (pid: 17279, ti=d38a6000 task=f651c000 task.ti=d38a6000)
[ 1491.063351] Stack:
[ 1491.063351]  d38a7e64 c042588f 00000000 00000013 f8e604b4 d38a7e7c f8e60324 f8e603fd
[ 1491.063351]  d7e39850 d5809400 f8e5daf8 d38a7e8c f8e62060 f8e608a8 00000000 d38a7ea8
[ 1491.063351]  c0401151 f8e62000 00000000 f8e5daf8 00000013 f8e604b4 d38a7fac c04598a6
[ 1491.063351] Call Trace:
[ 1491.063351]  [&lt;c042588f&gt;] ? printk+0x15/0x17
[ 1491.063351]  [&lt;f8e60324&gt;] hook_proc+0x4f/0x65 [nocansee]
[ 1491.063351]  [&lt;f8e62060&gt;] module_init_proc+0x60/0x7a [nocansee]
[ 1491.063351]  [&lt;c0401151&gt;] do_one_initcall+0x71/0x113
[ 1491.063351]  [&lt;f8e62000&gt;] ? 0xf8e61fff
[ 1491.063351]  [&lt;c04598a6&gt;] sys_init_module+0x1060/0x128e
[ 1491.063351]  [&lt;c0422251&gt;] ? kmap_atomic_prot+0x23/0x9c
[ 1491.063351]  [&lt;c0863b64&gt;] syscall_call+0x7/0xb
[ 1491.063351] Code: 08 89 73 50 89 73 54 c6 43 4c 04 88 43 4d 5b 5e 5f 5d c3 55 89 e5 57 56 89 d6 53 89 c3 89 c8 89 ca c1 e8 02 83 ec 08 89 c1 89 df &lt;f3&gt; a5 89 d1 83 e1 03 74 02 f3 a4 5a 89 d8 59 5b 5e 5f 5d c3 55
[ 1491.063351] EIP: [&lt;c0605e48&gt;] memcpy+0x18/0x2c SS:ESP 0068:d38a7e50
[ 1491.063351] CR2: 0000000000000000
[ 1491.314433] ---[ end trace 97a00886892de9ee ]---
</code></pre>

<p>The QNAP is running</p>

<blockquote>
  <p>Linux 3.4.6 #1 SMP i686 unknown.</p>
</blockquote>

<p>This is the mod info:</p>

<pre><code>$ modinfo nocansee.ko
filename:       nocansee.ko
license:        GPL
depends:
vermagic:       3.4.6 SMP mod_unload ATOM
parm:           rc_name:charp
parm:           rc_dir:charp
parm:           mod_name:charp
parm:           mod_dir:charp
</code></pre>

<p>This is the relevant part of the source code, which causes the Oops:</p>

<pre><code>struct path p;
if(kern_path(""/myfolder"", 0, &amp;p))
    return;
pinode = p.dentry-&gt;d_inode;

if(!pinode)
    return;
printk(KERN_DEBUG ""Got pinode dentry"");
// hook folder
proc_fops = *pinode-&gt;i_fop; //Line which causes kernel Oops
proc_original = pinode-&gt;i_fop;
proc_fops.readdir = do_readdir_proc;
pinode-&gt;i_fop = &amp;proc_fops;
</code></pre>

<p>Any help would be most welcome! thank you very much!</p>
"
"<p>I'm working with <code>gcc-3.3.4</code>. What I'm doing is to fake something.
When I compiled my file using <code>gcc -O0 -g -fomit-frame-pointer -I/usr/src/kernel-headers-2.4.26-1/include sleep.c -o sleep.exe</code>
I get the following problem:</p>

<pre><code>msync-sleep.c:47: error: parse error before ""wait_queue_head_t""
msync-sleep.c:47: warning: no semicolon at end of struct or union
msync-sleep.c:81: error: field `i_sem' has incomplete type
msync-sleep.c:83: error: field `i_zombie' has incomplete type
msync-sleep.c:87: error: parse error before ""wait_queue_head_t""
msync-sleep.c:87: warning: no semicolon at end of struct or union
msync-sleep.c:90: error: parse error before '}' token
msync-sleep.c:93: error: parse error before ""atomic_t""
msync-sleep.c:93: warning: no semicolon at end of struct or union
msync-sleep.c:96: error: parse error before '}' token
msync-sleep.c:103: error: parse error before ""atomic_t""
msync-sleep.c:103: warning: no semicolon at end of struct or union
msync-sleep.c:105: error: parse error before '}' token
msync-sleep.c:149: error: field `fake_dentry' has incomplete type
msync-sleep.c:150: error: field `fake_inode' has incomplete type
msync-sleep.c:151: error: field `fake_mapping' has incomplete type
msync-sleep.c:152: error: field `fake_ops' has incomplete type
msync-sleep.c:153: error: field `dirty_page' has incomplete type
</code></pre>

<p>I think the problem comes from my definition part. And here is part of my code:</p>

<pre><code>#include &lt;stdio.h&gt;      /* fprintf */
#include &lt;stdlib.h&gt;     /* exit */
#include &lt;string.h&gt;     /* memset */
#include &lt;sys/mman.h&gt;       /* mmap */
#include &lt;sys/types.h&gt;      /* pthread types */
#include &lt;sys/stat.h&gt;       /* fchmod */
#include &lt;pthread.h&gt;        /* thread primitives */
#include &lt;fcntl.h&gt;      /* open */
#include &lt;unistd.h&gt;     /* ftruncate */
#include &lt;errno.h&gt;      /* errno */

#include ""linux/elf.h""      /* for elf struct defs */

#include ""asm-i386/unistd.h""    /* uselib system call */
#include ""asm-i386/page.h""      /* PAGE_SIZE */

#define LIB_ADDR   0xaabbccdd   /* memorable random address */
#define LIB_FILE   ""sleepylib""
#define UNMAP_FILE ""unmapfile""

/* --------------------------------------------------------
   fake struct defs
   -------------------------------------------------------- */
/* all of these only go as far as the last field we need to access */

struct list_head {
  struct list_head      *next;
  struct list_head      *prev;
};

struct wait_queue_head_t {
  volatile unsigned int lock;
  struct list_head      task_list;
};

struct semaphore {
  volatile int          count;
  int                   sleepers;
  wait_queue_head_t     wait;
};

struct rw_semaphore {
  signed long           count;
  volatile unsigned int wait_lock;
  struct list_head      wait_list;
};

struct inode {
  struct list_head      i_hash;
  struct list_head  i_list;
  struct list_head  i_dentry;

  struct list_head  i_dirty_buffers;
  struct list_head  i_dirty_data_buffers;

  unsigned long     i_ino;
  volatile int      i_count;
  unsigned short    i_dev;
  unsigned short    i_mode;
  unsigned short    i_nlink;
  unsigned short    i_uid;
  unsigned short    i_gid;
  unsigned short    i_rdev;
  long long     i_size;
  long          i_atime;
  long          i_mtime;
  long          i_ctime;
  unsigned int      i_blkbits;
  unsigned long     i_blksize;
  unsigned long     i_blocks;
  unsigned long     i_version;
  unsigned short        i_bytes;
  struct semaphore  i_sem;
  struct rw_semaphore   i_alloc_sem;
  struct semaphore  i_zombie;
  void  *i_op;
  void  *i_fop;
  void  *i_sb;
  wait_queue_head_t i_wait;
  void  *i_flock;
  struct address_space  *i_mapping;
};

struct dentry {
  atomic_t d_count;
  unsigned int d_flags;
  struct inode *d_inode;
};

struct page {
  struct list_head list;
  struct address_space *mapping;
  unsigned long index;
  struct page *next_hash;
  atomic_t count;
  unsigned long flags;
};

struct fakes {
  /* dentry */
  struct dentry fake_dentry;
  struct inode fake_inode;
  struct address_space fake_mapping;
  struct address_space_operations fake_ops;
  struct page dirty_page;
};
</code></pre>

<p>Thanks for your time in advance.</p>
"
"<p>I'm trying something interesting in kernel 2.4.26.
On around line 2367 of <code>mm/filemap.c</code>, there is a statement going like this:
<code>struct inode * inode = file-&gt;f_dentry-&gt;d_inode;</code>
I have already verified that I have made <code>f_dentry</code> be <code>NULL</code> by adding a <code>printk</code> right before this statement. Since here <code>struct inode * inode = file-&gt;f_dentry-&gt;d_inode;</code> dereferences a null pointer, the kernel will crash, right? But my computer still works well. I totally have no idea.
Here is the code I have modified (just add a <code>printk</code>):</p>

<pre><code>if(file-&gt;f_dentry == NULL) {
  printk(""file-&gt;f_dentry is null\n"");
}
struct inode * inode = file-&gt;f_dentry-&gt;d_inode;
</code></pre>

<p>Here is the information from <code>dmesg</code>
<a href=""https://i.stack.imgur.com/1Zx1Y.png"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/1Zx1Y.png"" alt=""enter image description here""></a></p>

<p>I expect that the kernel will totally crash in dereferencing a null pointer, but it doesn't.</p>
"
"<p>I have a simple module like this:</p>

<pre><code>#define MODULE

#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;

int init_module(void) {
    struct inode {
        int i_ino;
    };
    struct dentry {
        struct inode *d_inode;
    };
    struct dentry *f_dentry;
    f_dentry = NULL;
    struct inode * p = f_dentry-&gt;d_inode;
    return 0;
}

void cleanup_module(void) {
        printk(""Goodbye world\n"");
}
</code></pre>

<p>And my <code>Makefile</code> is like this:</p>

<pre><code>obj-m += oops.o

all:
        make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
        make -C /lib/modules$(shell uname -r)/build M=$(PWD) clean
</code></pre>

<p>I expect that the kernel will crash because <code>struct inode * p = f_dentry-&gt;d_inode;</code> has dereferenced a null pointer, right? But it does not. Anything wrong with my idea?
All right, now I'll have one more try. If my module is like this:</p>

<pre><code>#define MODULE

#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;

int init_module(void) {
    *(int *)0 = 0;
    return 0;
}

void cleanup_module(void) {
        printk(""Goodbye world\n"");
}
</code></pre>

<p>My computer really crashes. Or anything wrong with my former example? It doesn't dereference a null pointer?</p>
"
"<p>I am installing the new Kali (2.0) and I am unable to install the guest additions successfully.</p>

<p>I explain you all the steps I have done:</p>

<p>First of all I made sure I have the correct repositories (I think these are the correct ones):</p>

<pre><code>deb http://http.kali.org/kali sana main non-free contrib
deb http://security.kali.org/kali-security sana/updates main contrib non-free
deb-src http://http.kali.org/kali sana main non-free contrib
deb-src http://security.kali.org/kali-security sana/updates main contrib non-free
</code></pre>

<p>I have updated and upgraded.</p>

<p>Then I have installed the linux-headers (maybe the mistake is here, but I don't think so)</p>

<pre><code>apt-get install linux-headers-$(uname -r)
apt-get install dkms linux-source linux-headers-$(uname -r)
</code></pre>

<p>Then I mounted the CD, give it 755 permissions and executed it. This is what I get:</p>

<pre><code>Building the main Guest Additions module ...done.
Building the shared folder support module ...fail!
(Look at /var/log/vboxadd-install.log to find out what went wrong)
Doing non-kernel setup of the Guest Additions ...done.
Installing the Window System drivers
Warning: unknown version of the X Window System installed.  Not installing
X Window System drivers.
 ...done.
Installing graphics libraries and desktop services components ...done.
</code></pre>

<p>I have installed the following:</p>

<pre><code>apt-get install virtualbox-guest-x11
apt-get install open-vm-tools
</code></pre>

<p>But I still get the same result.</p>

<p>For further information, this is my kernel:</p>

<pre><code>root@kali:~# uname -r
4.0.0-kali1-686-pae
</code></pre>

<p>It seems I have the module installed but it doesn't work:</p>

<pre><code>root@kali:~# lsmod | grep vbox
vboxguest             180224  5
</code></pre>

<p>My virtualbox version is 4.3.20
Any idea?? Thank you very much.</p>

<p>/var/log/vboxadd-install.log</p>

<pre><code>In file included from /tmp/vbox.0/dirops.c:19:0:
/tmp/vbox.0/dirops.c: In function ?sf_getdent?:
/tmp/vbox.0/dirops.c:129:29: error: ?struct file? has no member named ?f_dentry?
     sf_g = GET_GLOB_INFO(dir-&gt;f_dentry-&gt;d_inode-&gt;i_sb);
                             ^
/tmp/vbox.0/vfsmod.h:144:60: note: in definition of macro ?GET_GLOB_INFO?
 # define GET_GLOB_INFO(sb)       ((struct sf_glob_info *) (sb)-&gt;s_fs_info)
                                                            ^
/tmp/vbox.0/dirops.c:135:16: error: ?struct file? has no member named ?f_dentry?
     inode = dir-&gt;f_dentry-&gt;d_inode;
                ^
/usr/src/linux-headers-4.0.0-kali1-common/scripts/Makefile.build:263: recipe for target '/tmp/vbox.0/dirops.o' failed
make[4]: *** [/tmp/vbox.0/dirops.o] Error 1
/usr/src/linux-headers-4.0.0-kali1-common/Makefile:1407: recipe for target '_module_/tmp/vbox.0' failed
make[3]: *** [_module_/tmp/vbox.0] Error 2
Makefile:145: recipe for target 'sub-make' failed
make[2]: *** [sub-make] Error 2
Makefile:8: recipe for target 'all' failed
make[1]: *** [all] Error 2
/tmp/vbox.0/Makefile.include.footer:79: recipe for target 'vboxsf' failed
make: *** [vboxsf] Error 2
Creating user for the Guest Additions.
Creating udev rule for the Guest Additions kernel module.
</code></pre>
"
"<p>I'm reading the <em>Understand the Linux Kernel</em> book, and it says that the list of <code>file_lock</code> is stored in the file's inode (of field <code>i_flock</code>).</p>

<p>But in the <code>sys_flock()</code> of <code>Linux 2.6.11.12</code>, which will eventually call <code>flock_lock_file()</code>. It uses <code>filp-&gt;f_dentry-&gt;d_inode-&gt;i_flock</code> to get the list of  <code>file_lock</code> and <code>filp-&gt;f_dentry</code> is an <code>dentry</code> of the directory which ""contains"" the file. </p>

<pre><code>int flock_lock_file(struct file *filp, struct file_lock *new_fl) {
    // ...
    struct inode * inode = filp-&gt;f_dentry-&gt;d_inode;
    // ...
}
</code></pre>

<p>Suppose that the <code>file_lock</code> list are linked with <code>filp-&gt;f_dentry-&gt;d_inode-&gt;i_flock</code>, What will happen when a hard link exists:</p>

<pre><code>/some_path/foo/file.txt
/another_path/bar/file_link
</code></pre>

<p>and file_link is a hard link to file.txt</p>

<p>When we use this two path to <code>open</code> the same file, <code>sys_open()</code> will set <code>filp-&gt;f_dentry</code> to <code>foo</code> and <code>bar</code> separately, isn't it? If my guess is right, how <code>file_lock</code> can work?</p>
"
"<p>I want to access /dev/video0 from a kernel module after camera is initialized.
For that I want to create /dev/video0 node before the ueventd daemon gets started.</p>
"
"<p>I have modified the system-call table such that my own mmap handler will be called upon a user-space call to mmap.
My handler calls the original mmap and according to the result chooses what to do.</p>

<p>Here's a very short code snippet:</p>

<pre><code>asmlinkage unsigned long my_mmap_handler(unsigned long addr,
                                     unsigned long len,
                                     int prot,
                                     int flags,
                                     int fd,
                                     long off)
{
     unsigned long ret_val = old_mmap(addr,len,prot,flags,fd,off);
     if (IS_ERR((void*)ret_val))
         goto end;
     // Do some stuff..
     end:
     return ret_val;
}
</code></pre>

<p>while in ""Do some stuff"" I do some operations on the actual mapped file (i.e. reading from the file).</p>

<p>Here's the problem:</p>

<p>I have encountered programs that try to mmap character/block devices (e.g. /dev/rdi/card0). Whenever I try to read (e.g. using vfs_read) from such a file, the kernel freezes (Not a panic, but it feels like something is blocking). Why exactly does that happen?
Anyway, I don't need to perform operations on character/block devices so I've been trying to find a way of finding out if a given 'struct file' represents a block/character device and in case it is just ignore it. No luck so far.</p>

<p>Help would be appreciated</p>
"
"<p>i write a android driver module,but when i </p>

<pre><code>insmod file1.ko
</code></pre>

<p>this driver does not operate file(read or write),i don't know why!
this is my code:</p>

<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;asm/uaccess.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;linux/slab.h&gt;
MODULE_AUTHOR(""www.banguanshui.com"");
MODULE_DESCRIPTION(""file operation"");
MODULE_LICENSE(""GPL"");

void fileread(const char * filename)
{
  struct file *filp;
  struct inode *inode;
  mm_segment_t fs;
  off_t fsize;
  char *buf;
  unsigned long magic;
  printk(""&lt;1&gt;start....\n"");
  filp=filp_open(filename,O_RDONLY,0);
  inode=filp-&gt;f_dentry-&gt;d_inode;

  magic=inode-&gt;i_sb-&gt;s_magic;
  printk(""&lt;1&gt;file system magic:%li \n"",magic);
  printk(""&lt;1&gt;super blocksize:%li \n"",inode-&gt;i_sb-&gt;s_blocksize);
  printk(""&lt;1&gt;inode %li \n"",inode-&gt;i_ino);
  fsize=inode-&gt;i_size;
  printk(""&lt;1&gt;file size:%i \n"",(int)fsize);
  buf=(char *) kmalloc(fsize+1,GFP_ATOMIC);

  fs=get_fs();
  set_fs(KERNEL_DS);
  filp-&gt;f_op-&gt;read(filp,buf,fsize,&amp;(filp-&gt;f_pos));
  set_fs(fs);

  buf[fsize]='\0';
  printk(""&lt;1&gt;The File Content is:\n"");
  printk(""&lt;1&gt;%s"",buf);


  filp_close(filp,NULL);
}

void filewrite(char* filename, char* data)
{
  struct file *filp;
 mm_segment_t fs;
 filp = filp_open(filename, O_RDWR|O_APPEND, 0644);
 if(IS_ERR(filp))
    {
      printk(""open error...\n"");
      return;
        }

  fs=get_fs();
  set_fs(KERNEL_DS);
  filp-&gt;f_op-&gt;write(filp, data, strlen(data),&amp;filp-&gt;f_pos);
  set_fs(fs);
  filp_close(filp,NULL);
}

int init_module()
{
  char *filename=""/data/local/tmp/x.txt"";

  printk(""&lt;1&gt;Read File from Kernel.\n"");
  fileread(filename);
  filewrite(filename, ""file operation test\n"");
  return 0;
}

void cleanup_module()
{
  printk(""&lt;1&gt;Good,Bye!\n"");
}
</code></pre>

<p>when i insmod file1.ko, i found my file /data/local/tmp/x.txt is not changed,is there any one can help me ?</p>
"
"<p>I have been trying to perform memory acquisition of Ubuntu 16.04 running in VirtualBox. I am aware of LiME as an option but would also like to use fmem which has failed to compile on my machine. I know that compiling fmem on the box under investigation is not advised but this is just a lab environment.</p>

<p>Details of the machine</p>

<pre><code>u64@u64-VirtualBox:~/Desktop/f/fmem_1.6-0$ uname -a
Linux u64-VirtualBox 4.10.0-27-generic #30~16.04.2-Ubuntu SMP Thu Jun 29 16:07:46 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
u64@u64-VirtualBox:~/Desktop/f/fmem_1.6-0$
</code></pre>

<p>List of kernel headers installed</p>

<pre><code>u64@u64-VirtualBox:~/Desktop/f/fmem_1.6-0$ dpkg --list | grep linux-image
ii  linux-image-3.16.0-30-generic              3.16.0-30.40~14.04.1                          amd64        Linux kernel image for version 3.16.0 on 64 bit x86 SMP
ii  linux-image-3.16.0-31-generic              3.16.0-31.43~14.04.1                          amd64        Linux kernel image for version 3.16.0 on 64 bit x86 SMP
ii  linux-image-3.16.35-031635-generic         3.16.35-031635.201605011734                   amd64        Linux kernel image for version 3.16.35 on 64 bit x86 SMP
ii  linux-image-4.10.0-27-generic              4.10.0-27.30~16.04.2                          amd64        Linux kernel image for version 4.10.0 on 64 bit x86 SMP
ii  linux-image-4.8.0-36-generic               4.8.0-36.36~16.04.1                           amd64        Linux kernel image for version 4.8.0 on 64 bit x86 SMP
ii  linux-image-extra-4.10.0-27-generic        4.10.0-27.30~16.04.2                          amd64        Linux kernel extra modules for version 4.10.0 on 64 bit x86 SMP
ii  linux-image-extra-4.8.0-36-generic         4.8.0-36.36~16.04.1                           amd64        Linux kernel extra modules for version 4.8.0 on 64 bit x86 SMP
ii  linux-image-generic-hwe-16.04              4.10.0.27.30                                  amd64        Generic Linux kernel image
u64@u64-VirtualBox:~/Desktop/f/fmem_1.6-0$
</code></pre>

<p>Make Command gives the following error</p>

<pre><code>u64@u64-VirtualBox:~/Desktop/f/fmem_1.6-0$ make
rm -f *.o *.ko *.mod.c Module.symvers Module.markers modules.order \.*.o.cmd \.*.ko.cmd \.*.o.d
rm -rf \.tmp_versions
make -C /lib/modules/`uname -r`/build SUBDIRS=`pwd` modules
make[1]: Entering directory '/usr/src/linux-headers-4.10.0-27-generic'
  CC [M]  /home/u64/Desktop/f/fmem_1.6-0/lkm.o
/home/u64/Desktop/f/fmem_1.6-0/lkm.c: In function ?memory_lseek?:
/home/u64/Desktop/f/fmem_1.6-0/lkm.c:289:42: error: ?struct inode? has no member named ?i_mutex?
  mutex_lock(&amp;file-&gt;f_path.dentry-&gt;d_inode-&gt;i_mutex);
                                          ^
/home/u64/Desktop/f/fmem_1.6-0/lkm.c:310:44: error: ?struct inode? has no member named ?i_mutex?
  mutex_unlock(&amp;file-&gt;f_path.dentry-&gt;d_inode-&gt;i_mutex);
                                            ^
/home/u64/Desktop/f/fmem_1.6-0/lkm.c: In function ?memory_open?:
/home/u64/Desktop/f/fmem_1.6-0/lkm.c:348:19: error: ?struct address_space? has no member named ?backing_dev_info?
    filp-&gt;f_mapping-&gt;backing_dev_info =
                   ^
/home/u64/Desktop/f/fmem_1.6-0/lkm.c:349:6: error: ?directly_mappable_cdev_bdi? undeclared (first use in this function)
     &amp;directly_mappable_cdev_bdi;
      ^
/home/u64/Desktop/f/fmem_1.6-0/lkm.c:349:6: note: each undeclared identifier is reported only once for each function it appears in
scripts/Makefile.build:294: recipe for target '/home/u64/Desktop/f/fmem_1.6-0/lkm.o' failed
make[2]: *** [/home/u64/Desktop/f/fmem_1.6-0/lkm.o] Error 1
Makefile:1524: recipe for target '_module_/home/u64/Desktop/f/fmem_1.6-0' failed
make[1]: *** [_module_/home/u64/Desktop/f/fmem_1.6-0] Error 2
make[1]: Leaving directory '/usr/src/linux-headers-4.10.0-27-generic'
Makefile:12: recipe for target 'fmem' failed
make: *** [fmem] Error 2
u64@u64-VirtualBox:~/Desktop/f/fmem_1.6-0$
</code></pre>
"
"<p>Assuming there are two processes <a href=""http://lxr.free-electrons.com/source/fs/dcache.c#L1923"" rel=""nofollow"">looking up</a> a file at the same time, and this file does not existed in the dcache yet. These two lookups will return NULL (<a href=""http://lxr.free-electrons.com/source/include/linux/dcache.h#L103"" rel=""nofollow"">dentry</a>) to the process. </p>

<p>My question is that how does Linux kernel ensure that after a failed dentry lookup, it only creates one dentry?</p>
"
"<p>My question concerns the trade off between execution speed and memory usage when designing a class that will be instantiated thousands or millions of times and used differently in different contexts.</p>

<p>So I have a class that contains a bunch of numerical properties (stored in int and double). A simple example would be</p>

<pre><code>class MyObject
{
  public:
    double property1;
    double property2;
    ...
    double property14
    int property15;
    int property16;
    ...
    int property25;
    MyObject();
    ~MyObject();
};
</code></pre>

<p>This class is used by different programs that instantiate</p>

<pre><code>std::vector&lt;MyObject&gt; SetOfMyObjects;
</code></pre>

<p>that may contain as much as a few millions of elements. The thing is that depending on the context, some or many properties may remain unused (we do not need to compute them in this given context), implying that the memory for millions of useless int and double is allocated. As I said, the usefulness and uselessness of the properties depend on the context, and I would like to avoid writing a different class for each specific contexts.</p>

<p>So I was thinking about using std::maps to assign memory only for the properties I use. For example</p>

<pre><code>class MyObject
{
  public:
    std::map&lt;std::string, double&gt; properties_double;
    std::map&lt;std::string, int&gt; properties_int;
    MyObject();
    ~MyObject();
};
</code></pre>

<p>such that if ""property1"" has to be computed, it would stored as</p>

<pre><code>MyObject myobject;
myobject.properties_double[""property1""] = the_value;
</code></pre>

<p>Obviously, I would define proper ""set"" and ""get"" methods.</p>

<p>I understand that accessing elements in a std::map goes as the logarithm of its size, but since the number of properties is quite small (about 25), I suppose that this should not slow down the execution of the code too much.</p>

<p>Am I overthinking this too much? Do you think using std::map is a good idea? Any suggestion from more seasoned programmers would be appreciated.</p>
"
"<p>I'm trying to use boost::filesystem to copy files and folders (just like a standard copy a folder and paste it in windows explorer).</p>

<p>Although I've been to the <a href=""http://www.boost.org/doc/libs/1_41_0/libs/filesystem/doc/index.htm"" rel=""nofollow noreferrer"">boost::filesystem documentation</a>, I still don't really know how to go about doing this. </p>

<p>Do you have to recursively go though each directory (creating it) and find each file copying it?</p>

<p>Additionally, how do you copy the file in C++/Boost?</p>

<p>P.S. I'm using Boost 1.40.0</p>

<p><strong>Update</strong>
I think I may have ended up creating an answer to this one, only concern being that I don't do any try-catch errors to check for locked files and folders.  </p>

<p>The following code makes a copy of a directory in the relative path ""../example/ecomm"" and duplicates it to a non-existing path ""../example/dup_ecomm"":</p>

<pre><code>#include &lt;boost/test/unit_test.hpp&gt;
#include &lt;boost/algorithm/string.hpp&gt;
#include &lt;boost/filesystem/operations.hpp&gt;
#include &lt;boost/regex.hpp&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include&lt;string&gt;

bool copy_dir( const boost::filesystem::path &amp; ext_dir_path,         // the existing directory
               const boost::filesystem::path &amp; duplicate_dir_path    // the duplicate directory
             )
{
  std::cout &lt;&lt; ""BEGIN: copy_dir "" &lt;&lt; endl;
  std::cout &lt;&lt; ""- ext_dir_path: "" &lt;&lt; ext_dir_path &lt;&lt; endl;
  std::cout &lt;&lt; ""- duplicate_dir_path: "" &lt;&lt; duplicate_dir_path &lt;&lt; endl;

  // 1. Ensure that the directory we are trying to copy exists.
  if (!boost::filesystem::exists( ext_dir_path ) ) return false;

  bool createdDir = boost::filesystem::create_directory( duplicate_dir_path );

  // cout &lt;&lt; ""createdDir: "" &lt;&lt; createdDir &lt;&lt; endl;


  copy_dir(ext_dir_path,         // the existing directory
           duplicate_dir_path,   // the duplicate directory,
           ext_dir_path,    // the base path for the existing directory
           duplicate_dir_path,
           true);

  std::cout &lt;&lt; ""END: copy_dir "" &lt;&lt; endl;
}


bool copy_dir( const boost::filesystem::path &amp; ext_dir_path,         // the existing directory
               const boost::filesystem::path &amp; duplicate_dir_path,   // the duplicate directory,
               const boost::filesystem::path &amp; base_ext_dir_path,    // the base path for the existing directory
               const boost::filesystem::path &amp; base_duplicate_dir_path, // the base path for the duplicate of the exisiting directory
               bool isRootPath)
{
  // Debug input arguments
  std::cout &lt;&lt; ""BEGIN: copy_dir "" &lt;&lt; endl;
  std::cout &lt;&lt; ""- ext_dir_path: "" &lt;&lt; ext_dir_path &lt;&lt; endl;
  std::cout &lt;&lt; ""- duplicate_dir_path: "" &lt;&lt; duplicate_dir_path &lt;&lt; endl;
  std::cout &lt;&lt; ""- base_ext_dir_path: "" &lt;&lt; base_ext_dir_path &lt;&lt; endl;
  std::cout &lt;&lt; ""- base_duplicate_dir_path: "" &lt;&lt; base_duplicate_dir_path &lt;&lt; endl;
  std::cout &lt;&lt; ""- isRootPath: "" &lt;&lt; isRootPath &lt;&lt; endl;

  boost::filesystem::directory_iterator end_itr; // default construction yields past-the-end

  cout &lt;&lt; ""--Beginning itr loop"" &lt;&lt; endl;
  for ( boost::filesystem::directory_iterator itr( ext_dir_path );
        itr != end_itr;
        ++itr )
  {

    if ( boost::filesystem::is_directory(itr-&gt;status()) )
    {
     cout &lt;&lt; ""---itr-&gt;path(): "" &lt;&lt; itr-&gt;path() &lt;&lt; endl;


     boost::filesystem::path newExtDir(itr-&gt;path());

     string dup_path = itr-&gt;path().string();
     boost::algorithm::replace_first(dup_path, base_ext_dir_path.string(), base_duplicate_dir_path.string());
     cout &lt;&lt; ""dup_path: "" &lt;&lt; dup_path &lt;&lt; endl;

     boost::filesystem::path new_dup_dir(dup_path);

     bool createdDir = boost::filesystem::create_directory( new_dup_dir );

     cout &lt;&lt; ""creating directory "" &lt;&lt; dup_path &lt;&lt; "" created: "" &lt;&lt; createdDir &lt;&lt; endl;

     boost::filesystem::path newDuplicateDir(duplicate_dir_path);

     copy_dir(newExtDir,         // the existing directory
          newDuplicateDir,   // the duplicate directory,
          base_ext_dir_path,
          base_duplicate_dir_path,
          false);
    }
    else
    {
            cout &lt;&lt; ""---isLeaf: "" &lt;&lt; itr-&gt;path() &lt;&lt; endl;

        string dup_path = itr-&gt;path().string();

        boost::algorithm::replace_first(dup_path, base_ext_dir_path.string(), base_duplicate_dir_path.string());

        string src_path = itr-&gt;path().string();

        cout &lt;&lt; ""src_path: "" &lt;&lt; src_path &lt;&lt; endl;
        cout &lt;&lt; ""dup_path: "" &lt;&lt; dup_path &lt;&lt; endl;

        boost::filesystem::path s_path(src_path);
        boost::filesystem::path d_path(dup_path);

        boost::filesystem::copy_file(s_path, d_path);
    }

  }
  std::cout &lt;&lt; ""--Ending itr loop"" &lt;&lt; endl;


  std::cout &lt;&lt; ""END: copy_dir "" &lt;&lt; endl;

  return false;
}

test_suite*
init_unit_test_suite( int, char* [] ) {

    boost::filesystem::path ext_dir(""..\\example\\ecomm"");
    boost::filesystem::path dir_dup(""..\\example\\dup_ecomm"");

    copy_dir(ext_dir,
             dir_dup);   // the duplicate directory,

        // ... unit tests...etc...
}
</code></pre>

<p>My question now is what I'm I forgetting to do in regards to locked files and directories?</p>
"
"<p>I am reading one property file which contains some file paths using shell script. Now depending on this file path I want to create name of zip file. Something like this...My property file contents::</p>

<pre><code>path=tmp/inputs/logs/abc
path=tmp/backup/inte/xyz
destpath=abc/xyz
</code></pre>

<p>Now I am able to create file name as abc.zip and xyz.zip as:</p>

<pre><code>paths=`grep path myfile.property |cut -d= -f2`
d_path=`grep destpath myfile.property |cut -d= -f2`
filename=$d_path/$(basename $paths).zip
</code></pre>

<p>Which create abc.zip and xyz.zip. But I want to create name by taking last three parameter of the path. Something like this...</p>

<ul>
<li>for <code>abc.zip</code> it should be <code>inputs_logs_abc.zip</code> and</li>
<li>for <code>xyz.zip</code> it should be <code>backup_inte_xyz.zip</code></li>
</ul>

<p><strong>EDIT</strong></p>

<pre><code>Paths=`grep path myfile.txt |cut -d= -f2`

d_Path=`grep destpath myfile.txt |cut -d= -f2`

for s_Path in $Paths

   do

       prefix=${Paths%%/*/*/*}
       without_prefix=${Paths##${prefix}/}
       slashes_to_underscores=${without_prefix//\//_}
       zipFile=$d_Path/${slashes_to_underscores}.zip
       find $s_Path -type f -name ""*.log"" | xargs zip -mT $zipFile -@

   done
</code></pre>

<p>Above is my code.By using this i am not able to achieve my target.
Can somebody help me in this?</p>
"
"<p>I'm trying to write an ftp server on Linux. In this matter how can I list files in the directory on terminal by a C program? Maybe I can use exec function to run find command but I want file name as a string to send client program. How can I do this?</p>

<p>Thanks for answers.</p>
"
"<p>I have the filedescriptor and like to get the real path. Currently i call sys_readlink <code>/proc/self/fd/&lt;fd&gt;</code> which works sometimes, but often i get an error -14 (-EFAULT).</p>

<p>Here some Code:</p>

<pre><code>fs = get_fs();
set_fs(KERNEL_DS);
err = sys_readlink(path, buf, size-1);
set_fs(fs);
</code></pre>

<p>Is there an alternative (probably better) way to get the realpath from kernel?</p>
"
"<p>I need to get the name of a file from a given file descriptor, inside a small linux kernel module that I wrote. I tried the solution given at <a href=""https://stackoverflow.com/questions/1188757/getting-filename-from-file-descriptor-in-c"">Getting Filename from file descriptor in C</a>, but for some reason, it prints out garbage values (on using <code>readlink</code> on <code>/proc/self/fd/NNN</code> as mentioned in the solution). How can I do it?</p>
"
"<p>In the Linux Kernel: I have a file (ie, a 'struct file') of a directory.  Let's call it f_child.  I need a file reference for the parent directory.</p>

<p>I'm currently retrieving this like so:</p>

<p>1) Create a 'struct path' from the f_dentry->d_parent and f_vfsmnt of f_child.  I check, of course, that the d_parent is non-null.</p>

<p>2) Get the path (ie, a string, not a struct path... a char *) of the parent of f_child using d_path, passing in the path we retrieved from step 1.</p>

<p>3) Pass that string to filp_open, which returns the struct file * that I want.</p>

<p>It seems to work.  I'm worried though about the assumption I'm making at step 1 that the vfs mount of the parent and child will be the same.  Will that bite me at some point?  Is there a better way of doing this?  Clearly, I don't understand the vfs mount structure well enough.  Do all dentries belonging to the same super block have the same vfs mount?</p>

<p>btw: I anticipate, and a appreciate, the rebuke for opening a file in the Kernel, but what I'm doing really does require it. :)</p>

<p>Thanks!</p>
"
"<p>I am working on a small project .My OS is Linux (Ubuntu 11.04). I want to connect to the DBus Daemon signal NameOwnerChanged in order to be indicated which app is shutdown or startup.I wrote a small program to do this. It failed though. I used glib dbus only, without dbus lowlevel.</p>

<p>Here is my code:</p>

<p>/<em>gcc -o test main.c <code>pkg-config --libs --cflags glib-2.0 dbus-1  dbus-glib-1</code></em>/</p>

<pre><code>#include &lt;dbus/dbus.h&gt;
#include &lt;dbus/dbus-glib.h&gt;
#include &lt;dbus/dbus-glib-bindings.h&gt;
#include &lt;dbus/dbus-glib-lowlevel.h&gt;

#define D_SERVICE     ""org.freedesktop.DBus""
#define D_PATH        ""/""
#define D_INTERFACE   ""org.freedesktop.DBus""

GMainLoop* loop;
DBusGConnection* conn;
DBusGProxy*     d_proxy;

static void dbus_name_owner_changed(DBusGProxy *proxy, char* name, char* old, char* new, gpointer user_data)
{
    g_print(""%s owner change \n"", name);
}

int main(int argc,char** argv)
{
    g_type_init();
    loop = g_main_loop_new(NULL, FALSE);
    conn = dbus_g_bus_get(DBUS_BUS_SESSION,NULL);
    d_proxy = dbus_g_proxy_new_for_name(conn, D_SERVICE, D_PATH, D_INTERFACE);

    guint ret;
    GError * error = NULL;

    dbus_g_proxy_call(  d_proxy, ""RequestName"", &amp;error,
                        G_TYPE_STRING, ""com.asianux.test"",
                        G_TYPE_UINT, DBUS_NAME_FLAG_DO_NOT_QUEUE,
                        G_TYPE_INVALID,
                        G_TYPE_UINT, &amp;ret,
                        G_TYPE_INVALID);

    if(error==NULL &amp;&amp; ret==DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER)
    {
        g_print(""Request Name Success \n"");
    }
    else
    {
        if(error)
        {
            g_print(""Request Name Failed %s\n"", error-&gt;message);
        }
    }

    dbus_g_proxy_add_signal(d_proxy,""NameOwnerChanged"",
                            G_TYPE_STRING,
                            G_TYPE_STRING,
                            G_TYPE_STRING,
                            G_TYPE_INVALID);

    dbus_g_proxy_connect_signal(d_proxy,""NameOwnerChanged"",
                                G_CALLBACK(dbus_name_owner_changed),
                                NULL,NULL);

    g_main_loop_run(loop);
}
</code></pre>

<p>I compiled it and ran it, but the function dbus_name_owner_changed never ran. Why  can't I connect the signal successfully?</p>

<p>I know I missed <code>dbus_g_object_register_marshaller</code> before add signal and connect the signal. But, even if I add the <code>dbus_g_object_register_marshaller</code> on my code, it still fails. Why?</p>
"
"<p>I've found several questions and answers to ""How do I find the path to the users desktop"", but in my mind they are all defunct (those I found at least). The reason is that if the user has a installation of Linux that is not English, he or she may well have the desktop somewhere other than in <code>~/Desktop</code>. E.g. for Swedish, I believe it is in <code>~/Skrivbord</code>. And who knows where the user decided to place his or her desktop?</p>

<p>For that reason the following won't do (or any variant of it):</p>

<pre><code>os.sep.join((os.path.expanduser(""~""), ""Desktop""))
</code></pre>

<p>So the question is: </p>

<p>On linux, how do I, in python, get the true path to the user's desktop without presupposing English default directory structure?</p>
"
"<p>I am developing a kernel module using kernel version 3.x.</p>

<p>I have a function that is responsible to determine if a running process has a given file opened.</p>

<p>Here is my code (see my comments after):</p>

<pre><code>struct task_struct *    process = NULL;
struct files_struct *   task_files = NULL;
struct fdtable *        fdt = NULL;
int                     fd_i;
char                    tmpbuf[256];
char *                  process_path = """";

for_each_process(process)
{
    // Ignore processes without files
    if (process-&gt;files == NULL)
        continue;

    printk(KERN_INFO ""task_lock()...\n"");
    task_lock(process);
    printk(KERN_INFO ""task_lock() DONE\n"");
    task_files = process-&gt;files;
    printk(KERN_INFO ""task_unlock()...\n"");
    task_unlock(process);
    printk(KERN_INFO ""task_unlock() DONE\n"");

    printk(KERN_INFO ""files_fdtable()...\n"");
    fdt = files_fdtable(task_files);
    printk(KERN_INFO ""files_fdtable() DONE\n"");

    printk(KERN_INFO ""Iterating files...\n"");
    for (fd_i = 0; fd_i &lt; fdt-&gt;max_fds; fd_i++)
    {
        if (fcheck_files(task_files, fd_i) == my_file)
        {
            if (process-&gt;mm)
            {
                if (process-&gt;mm-&gt;exe_file)
                {

                    process_path = d_path(&amp;process-&gt;mm-&gt;exe_file-&gt;f_path, tmpbuf, sizeof(tmpbuf));
                    break;
                } else {
                    printk(KERN_INFO ""process-&gt;mm-&gt;exe_file is NULL\n"");
                }
            } else {
                printk(KERN_INFO ""process-&gt;mm is NULL\n"");
            }
        }
    }
    printk(KERN_INFO ""Files iteration finished\n"");
}
</code></pre>

<p>This code is working and the variable <code>process_path</code> contains the path of the process where the given file is opened.
But when there is huge load on the machine (so going through this code really often), the machine freeze (after a certain amount of time) and the latest printed debug is:</p>

<pre><code>task_unlock() DONE
</code></pre>

<p>Then I don't see what I'm doing wrong.</p>

<ul>
<li><a href=""http://lxr.free-electrons.com/source/include/linux/sched.h?v=3.2#L2284"" rel=""nofollow"">for_each_process</a> isn't calling <a href=""http://lxr.free-electrons.com/source/include/linux/spinlock.h?v=3.2#L283"" rel=""nofollow"">spin_lock</a> and <a href=""http://lxr.free-electrons.com/source/include/linux/spinlock.h?v=3.2#L323"" rel=""nofollow"">spin_unlock</a> on processes so I'm using <a href=""http://lxr.free-electrons.com/source/include/linux/sched.h?v=3.2#L2350"" rel=""nofollow"">task_lock</a> and <a href=""http://lxr.free-electrons.com/source/include/linux/sched.h?v=3.2#L2355"" rel=""nofollow"">task_unlock</a>.</li>
<li><a href=""http://lxr.free-electrons.com/source/include/linux/fdtable.h?v=3.2#L67"" rel=""nofollow"">files_fdtable</a> is calling <a href=""http://lxr.free-electrons.com/source/include/linux/spinlock.h?v=3.2#L283"" rel=""nofollow"">spin_lock</a> and <a href=""http://lxr.free-electrons.com/source/include/linux/spinlock.h?v=3.2#L323"" rel=""nofollow"">spin_unlock</a> so I don't.</li>
<li><a href=""http://lxr.free-electrons.com/source/include/linux/fdtable.h?v=3.2#L83"" rel=""nofollow"">fcheck_files</a> is also calling <a href=""http://lxr.free-electrons.com/source/include/linux/spinlock.h?v=3.2#L283"" rel=""nofollow"">spin_lock</a> and <a href=""http://lxr.free-electrons.com/source/include/linux/spinlock.h?v=3.2#L323"" rel=""nofollow"">spin_unlock</a> so I don't.</li>
<li><a href=""http://lxr.free-electrons.com/source/fs/dcache.c?v=3.2#L2600"" rel=""nofollow"">d_path</a> is taking care to lock so I don't do it.</li>
</ul>

<p>Could you please explain me why my code is freezing the machine and how to fix it ?</p>
"
"<p>I want to know on what file in <code>/sys/*</code> the function<code>static ssize_t
sysfs_write_file(struct file *file, const char __user *buf, size_t count, loff_t *ppos)</code> were called. the question is how to get the file name/path by having <code>struct file *file</code> ?</p>

<pre><code>struct file {
  mode_t f_mode;
  loff_t f_pos;
  unsigned short f_flags;
  unsigned short f_count;
  unsigned long f_reada, f_ramax, f_raend, f_ralen, f_rawin;
  struct file *f_next, *f_prev;
  int f_owner;         /* pid or -pgrp where SIGIO should be sent */
  struct inode * f_inode;
  struct file_operations * f_op;
  unsigned long f_version;
  void *private_data;  /* needed for tty driver, and maybe others */
};
</code></pre>

<hr>

<p><em><strong>EDIT:</em></strong>
I understand there is no one-to-one mapping between inode to a name, but I must know the major/minor/file descriptor and can search for some of the inode's name in the file system.</p>
"
"<p>I'm trying to view the filename via kgdb, so I cannot call functions and macros to get it programatically.  I need to find it by manually inspecting data structures.</p>

<p>Like if I had a breakpoint here in gdb, how could I look around with gdb and find the filename?</p>

<p>I've tried looking around in <code>filp.f_path</code>, <code>filp.f_inode</code>, etc.  I cannot see the filename anywhere.</p>

<pre class=""lang-c prettyprint-override""><code>ssize_t do_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)
{
     struct iovec iov = { .iov_base = (void __user *)buf, .iov_len = len };
     struct kiocb kiocb;
     ssize_t ret;

     init_sync_kiocb(&amp;kiocb, filp);
     kiocb.ki_pos = *ppos;
     kiocb.ki_left = len;
     kiocb.ki_nbytes = len;

     ret = filp-&gt;f_op-&gt;aio_write(&amp;kiocb, &amp;iov, 1, kiocb.ki_pos);
     if (-EIOCBQUEUED == ret)
             ret = wait_on_sync_kiocb(&amp;kiocb);
     *ppos = kiocb.ki_pos;
     return ret;
}
</code></pre>
"
"<p>I want to get full process name from <code>struct task_struct</code>. The <code>comm</code> field stores only 16 characters, while process name can be longer. Is there any way to get full process name? <br>
This can be done through by getting <code>struct vm_area_struct</code> from <code>task_struct</code>, and further obtain file to which vm_area is mapped, but this is unreliable.</p>
"
"<p>In order to retrieve file permissions of the running program, I need to do a <code>kstat</code> on the program currently running. Then I need to get the absolute path of the ELF image loaded.</p>

<p>Is that possible? <code>current-&gt;comm</code> only records the program name without path.</p>

<p>Or what other ways to do it?</p>
"
"<p>i think that i don't understand very well how the find command in Unix works; i have this code for counting the number of files in each folder but i want to count the number of lines of each file found and save the total in variable.</p>

<pre><code>find ""$d_path"" -type d -maxdepth 1 -name R -print0 | while IFS= read -r -d '' file; do


     nb_fichier_R=""$(find ""$file"" -type f -maxdepth 1 -iname '*.R' | wc -l)""

     nb_ligne_fichier_R= ""$(find ""$file"" -type f -maxdepth 1 -iname '*.R' -exec wc -l {} +)""
     echo ""$nb_ligne_fichier_R""

done
</code></pre>

<p>output:</p>

<pre><code>  43 .//system d exploi/r-repos/gbm/R/basehaz.gbm.R
  90 .//system d exploi/r-repos/gbm/R/calibrate.plot.R
  45 .//system d exploi/r-repos/gbm/R/checks.R
 178 total: File name too long
</code></pre>

<p>can i just save to total number of lines in my variable? here in my example just save 178 and that for each files in my folder ""$d_path""</p>

<p>Many Thanks</p>
"
"<p>This is my first time really editing a batch-file.
See my script below which moves all files (except first file from month) to a folder.  Now I'd like it to keep all files from current month in folder, so it should not loop and move files.</p>

<pre><code>@Echo Off
SETLOCAL enabledelayedexpansion
SET ""sourcedir=D:\ftproot\ftp_db-backup\""
SET /a month=99
SET /a year=99
PUSHD ""%sourcedir%""
FOR /f ""skip=4tokens=1,2,3,5,*delims=/- "" %%a IN (
  'dir /tc /a-d /-c /od ""*"" '
  ) DO (
IF ""%%d""=="""" GOTO done
 IF %%b-%%c neq !month!-!year! (
  ECHO(leave ""%%e"" ""%sourcedir%""
      SET month=%%b
      SET year=%%c

     ) ELSE (
//please note I removed the MOVE part here, it should be right here as the echo shows.

      ECHO(MOVE ""%%e"" ""D:\ftproot\ftp_db-backup\__REMOVE\"" )

    )
:done
POPD


GOTO :EOF
</code></pre>

<p>What should I add, and what is the correct syntax to get it to work?</p>

<p>I tried adding <code>IF ""%%d""==""08"" ECHO(this is current month) ELSE GOTO done</code></p>

<p>but that claims ELSE is incorrect.</p>
"
"<p>I am writing a kernel module to get the list of pids with their complete process name. The <code>proc_pid_cmdline()</code> gives the complete process name;using same function <code>/proc/*/cmdline</code> gets the complete process name. <code>(struct task_struct) -&gt; comm</code> gives hint of what process it is, but not the complete path.</p>

<p>I have included the function name, but it gives error because it does not know where to find the function. </p>

<p>How to use <code>proc_pid_cmdline()</code> in a module ?</p>
"
"<p>Currently I can find in kern.log entries like this:</p>

<pre><code>[6516247.445846] ex3.x[30901]: segfault at 0 ip 0000000000400564 sp 00007fff96ecb170 error 6 in ex3.x[400000+1000]
[6516254.095173] ex3.x[30907]: segfault at 0 ip 0000000000400564 sp 00007fff0001dcf0 error 6 in ex3.x[400000+1000]
[6516662.523395] ex3.x[31524]: segfault at 7fff80000000 ip 00007f2e11e4aa79 sp 00007fff807061a0 error 4 in libc-2.13.so[7f2e11dcf000+180000]
</code></pre>

<p>(You see, apps causing segfault are named ex3.x, means exercise 3 executable).</p>

<p>Is there a way to ask kern.log to log the complete path? Something like:</p>

<pre><code>[6...] /home/user/cclass/ex3.x[3...]: segfault at 0 ip 0564 sp 07f70 error 6 in ex3.x[4...]
</code></pre>

<p>So I can easily figure out from who (user/student) this ex3.x is?</p>

<p>Thanks!
Beco</p>
"
"<p>Been working on a project for a few weeks now and I've hit a pretty significant roadblock and I was hoping somebody here might be able to offer some guidance. </p>

<p>All I need to do is write a system call that reports statistics of a process?s virtual address space when called. Those statistics, according to the assignment criteria, need to include the size of the process?s virtual address space, each virtual memory area?s access permissions, and the names of files mapped to these virtual memory areas. </p>

<p>The first two I have working, the last appears to not be possible, at least from what my research and attempts so far have turned up. I've isolated it down to accessing the vm_file struct within the vm_area_struct of the process and using that to get to the f_path, but past that I'm still stuck on how to get from there to a format that can actually be put into a printk statement, and everything I've tried hasn't output anything when I finally get the kernel recompiled.</p>

<p>Here's where the code sits at the moment. Am I even on the right track?</p>

<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/mm_types.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/path.h&gt;
#include &lt;linux/dcache.h&gt;

asmlinkage int sys_project3a1(unsigned int processID)
{
    struct task_struct *task;
    for_each_process(task)
    {
     if (task-&gt;pid == processID)
     {
         unsigned long  virtualAddressSpace = 0;
         struct vm_area_struct *vmlist;

         printk(""Process ID: %d"", task-&gt;pid);

         for (vmlist = task-&gt;mm-&gt;mmap; vmlist!=NULL; vmlist=vmlist-&gt;vm_next)
         {
             unsigned long space = vmlist-&gt;vm_end - vmlist-&gt;vm_start;
             char *tmp;
             char *pathname;
             struct file *file;
             struct path *path;
             printk(""Process Access Permissions: %lu"", (unsigned long)(vmlist-&gt;vm_page_prot.pgprot));

             file = vmlist-&gt;vm_file;

             path = &amp;file-&gt;f_path;
             path_get(path);

             tmp = (char *)__get_free_page(GFP_TEMPORARY);

             pathname = d_path(path, tmp, PAGE_SIZE);

             printk(""Path Name: %s"", pathname);
             free_page((unsigned long)tmp);
             virtualAddressSpace += space;
         }
         printk(""Process Virtual Address Space: %lu"", virtualAddressSpace);

     }
    }
    return 1;
}
</code></pre>
"
"<p>I'm working on some linux kernel stuff and I have a fake path called /dev/blah/whatever that points to /dev/block/real_device</p>

<p>The issue is that lookup_bdev will fail to follow the symlink so I'd like to massage the path upfront by getting the real path (/dev/block/real_device) so I can hand that off to lookup_bdev so it returns successfully instead of an error.</p>

<p>Or any other kernel call that would correctly retrieve the block_device information given the initial path.</p>

<p>Thanks</p>
"
"<p>I'm trying to get the actual executable path of a running process through my kernel driver.</p>

<p>I've done the following:</p>

<pre><code>static struct kretprobe do_fork_probe = {
    .entry_handler = (kprobe_opcode_t *) process_entry_callback,
    .handler = (kprobe_opcode_t *) NULL,
    .maxactive = 1000,
    .data_size = 0
};

do_fork_probe.kp.addr =     (kprobe_opcode_t*)kallsyms_lookup_name(""do_fork"");

if ((ret = register_kretprobe(&amp;do_fork_probe)) &lt; 0)
    return -1;

static int process_entry_callback(struct kretprobe_instance *ri, struct pt_regs *regs)
{

    printk(""Executable path = %s\n"", executable_path(current));
    return 0;
}
</code></pre>

<p>The executable_path function:</p>

<pre><code>char* executable_path(struct task_struct* process)
{
#define PATH_MAX 4096
char* p = NULL, *pathname;
struct mm_struct* mm = current-&gt;mm;
if (mm)
{
    down_read(&amp;mm-&gt;mmap_sem);
    if (mm-&gt;exe_file)
    {
        pathname = kmalloc(PATH_MAX, GFP_ATOMIC);
        if (pathname)
            p = d_path(&amp;mm-&gt;exe_file-&gt;f_path, pathname, PATH_MAX);
    }
    up_read(&amp;mm-&gt;mmap_sem);
}

return p;
}
</code></pre>

<p>The problem is that if I run an executable using bash as follows:</p>

<pre><code>./execname
</code></pre>

<p>I'm getting the following output:</p>

<pre><code>Executable path = /bin/bash
</code></pre>

<p>While what I really want is the : execname (Actually its full path but lets start with the name)</p>

<p>Any suggestions?</p>
"
"<p>I am trying to hook unlinkat.my hooking function.</p>

<p>but i get only file name instead of absolute path.so i want absolute path to compare string.when i try rm -r than i get only file name if i get absolute path then it works.so please tell me how i get absolute path.<br>
 my code is</p>

<pre><code>long mw_sys_unlink(int dfd, const char *filename ,int flag)
{
        long ret;
        if( strstr(filename,""/tmp/a/""))
        {
                printk(KERN_INFO ""file %s has not been deleted by kernel module\n"", filename);
                return -1;
        }
        else
        {
                ret = orig_sys_unlink(dfd ,filename,flag);
                printk(KERN_INFO ""file %s has been deleted"", filename);
                return ret;
        }
}
</code></pre>
"
"<p>I am currently developing a simple kernel module that can steal system calls such as <code>open</code>, <code>read</code>, <code>write</code> and replace them with a simple function which logs the files being opened, read, written, into a file and return the original system calls.</p>

<p>My query is, I am able to get the File Descriptor in <code>read</code> and <code>write</code> system calls, but I am not able to understand how to obtain file name using the same.</p>

<p>Currently I am able to access the file structure associated with given FD using following code:</p>

<pre class=""lang-c prettyprint-override""><code>struct file *file;
file = fcheck(fd);
</code></pre>

<p>This file structure has two important entities in it, which are of my concern I believe:</p>

<ol>
<li><code>f_path</code></li>
<li><code>f_inode</code></li>
</ol>

<p>Can anybody help me get <code>dentry</code> or <code>inode</code> or the path name associated with this fd using the file structure associated with it?
Is my approach correct? Or do I need to do something different?</p>

<p>I am using Ubuntu 14.04 and my kernel version is 3.19.0-25-generic, for the kernel module development.</p>
"
"<p>Below is a snippet of the Linux dentry struct from <a href=""http://lxr.free-electrons.com/source/include/linux/dcache.h#L150"" rel=""nofollow"">http://lxr.free-electrons.com/source/include/linux/dcache.h#L150</a>. The struct contains a member struct qstr d_name - definition below. I would like to know if this is the name of the particular file that would correspond to this dentry at runtime. What confuses me is that proc/PID/maps uses struct dentry_operations -> d_name (another member of dentry) to generate the file name...so then waht is the purpose of struct qstr d_name? Please note, I am approaching this from a pure memory introspection point of view (libvmi) and thus I will be ""walking memory"" for these structures and retrieval using C/C++ code is not so straightforward.</p>

<pre><code> struct dentry {

     /* RCU lookup touched fields */
     unsigned int d_flags;           /* protected by d_lock */
     seqcount_t d_seq;               /* per dentry seqlock */
     struct hlist_bl_node d_hash;    /* lookup hash list */
     struct dentry *d_parent;        /* parent directory */
     struct qstr d_name;

              ....

struct qstr {
     union {
             struct {
                      HASH_LEN_DECLARE;
             };
              u64 hash_len;
      };
     const unsigned char *name;
};
</code></pre>
"
"<p>I'm trying to get parent path from <code>kern_path()</code> function, it is returning error <code>-2</code> in new Amazon Linux kernels 4.4.* machines.</p>

<p><strong>How to get parent path in 4.4.* Linux kernel?</strong></p>

<p><code>/tmp/TestFVT/files/fileXX-12345678989 ===&gt; /tmp/TestFVT/files</code></p>

<p>Similar to <a href=""http://www.gossamer-threads.com/lists/linux/kernel/2460069?do=post_view_threaded#2460069"" rel=""nofollow"">this issue</a>.</p>

<p>Below is the source code and output displayed.</p>

<p><strong>hello.c</strong></p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;linux/module.h&gt;    // included for all kernel modules
#include &lt;linux/kernel.h&gt;    // included for KERN_INFO
#include &lt;linux/init.h&gt;      // included for __init and __exit macros
#include &lt;linux/mount.h&gt;
#include &lt;linux/path.h&gt;
#include &lt;linux/namei.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/string.h&gt;

MODULE_LICENSE(""GPL"");
MODULE_DESCRIPTION(""A Simple Hello World module"");

char *path_name1 = ""/tmp/TestFVT/files/fileXX-1234567898""; //Existing FIle
char *path_name3 = ""/tmp/TestFVT/files/fileXX-12345678989""; //NON Existing FILE
static int __init hello_init(void)
{
    struct path path1, path3;
    int err = kern_path(path_name1, LOOKUP_PARENT, &amp;path1);
    printk(""Path name1 : %s, err: %d\n"", path_name1, err);
    err = kern_path(path_name3, LOOKUP_DIRECTORY, &amp;path3);
    printk(""Path name3-1 : %s, err: %d\n"", path_name3, err);
    err = kern_path(path_name3, LOOKUP_PARENT, &amp;path3);
    printk(""Path name3-2 : %s, err: %d\n"", path_name3, err);
    return 0;    // Non-zero return means that the module couldn't be loaded.
}

static void __exit hello_cleanup(void)
{
    printk(KERN_INFO ""Cleaning up module.\n"");
}

module_init(hello_init);
module_exit(hello_cleanup);
</code></pre>

<p><strong>Output:</strong></p>

<pre><code>[  120.167328] Path name1 : /tmp/TestFVT/files/fileXX-1234567898, err: 0
[  120.184955] Path name3-1 : /tmp/TestFVT/files/fileXX-12345678989, err: -2
[  120.189614] Path name3-2 : /tmp/TestFVT/files/fileXX-12345678989, err: -2
</code></pre>

<p><strong>Expected output:</strong></p>

<p><code>""/tmp/TestFVT/files""</code> for non existing files, which is worked fine in previous versions.</p>
"
"<p>I use a driver that have many files, each file I have an ID to it, when I open theses files I store the files descriptors in strcut array that contain the ID with the file descriptor, each opened file can be blocking or not.</p>

<p>I want to read the file from another program or from an other function in the program, when I try to read a blocking file with its file descriptor, it don't still blocking until I write on it, it return no data in the buffer, but when I use it in the same function It still blocking.</p>

<p>Where is the problem ?</p>

<pre><code>if (vg_bufObj[indice].protocolType == _NO_BLOC)
vg_bufObj[indice].dev_fd = open(d_path, O_RDONLY | O_NONBLOCK);
else
vg_bufObj[indice].dev_fd = open(d_path, O_RDONLY);
</code></pre>

<p>vg_bufObj is struct and declared extern</p>

<p>in other function I read the file with </p>

<pre><code>read_size = read(vg_bufObj[indice].dev_fd, data, 8);
</code></pre>

<p>When the protocolType  is specified _BLOC the file is open blocking, but when I read it from the another function it return empty data and the read size return the max value of the variable.</p>
"
"<p>I receive filesystem events from fanotify. Sometimes I want to get an absolute path to a file that's being accessed.</p>

<p>Usually, it's not a problem - <code>fanotify_event_metadata</code> contains a file descriptor <code>fd</code>, so I can call <code>readlink</code> on <code>/proc/self/fd/&lt;fd&gt;</code> and get my path.</p>

<p>However, if a path exceeds <code>PATH_MAX</code> <code>readlink</code> can no longer be used - it fails with <code>ENAMETOOLONG</code>. I'm wondering if there's a way to get a file path in this case.</p>

<p>Obviously, I can <code>fstat</code> the descriptor I get from a fanotify and traverse the entire filesystem looking for files with identical device ID and inode number. But this approach is not feasible for me performance-wise (even if I optimize it to ignore paths shorter than <code>PATH_MAX</code>).</p>

<p>I've tried getting a parent directory by reopening <code>fd</code> with <code>O_PATH</code> and calling <code>openat(fd, "".."", ...)</code>. Obviously, that failed because <code>fd</code> doesn't refer to a directory. I've also tried examining contents of a buffer after a failed <code>readlink</code> call (hoping it contains partial path). That didn't work either.</p>

<p>So far I've managed to get long paths for files inside the working directory of a process that opened them (fanotify events contain a <code>pid</code> of a target process, so I can read <code>/proc/&lt;pid&gt;/cwd</code> and get the path to the root from there). But that is a partial solution.</p>

<p>Is there a way to get an absolute path from a file descriptor without traversing the whole filesystem? Preferably the one that will work with kernel 2.6.32/glibc 2.11.</p>

<p><em>Update:</em> For the curious. I've figured out why calling <code>readlink(""/proc/self/fd/&lt;fd&gt;"",  ...</code> with a buffer large enough to store the entire path doesn't work.</p>

<p>Look at the implementation of <a href=""http://lxr.free-electrons.com/source/fs/proc/base.c#L1599"" rel=""nofollow"">do_proc_readlink</a>. Notice that it doesn't use provided <code>buffer</code> directly.  Instead, it allocates a single page and uses it as a temporary buffer when it calls <a href=""http://lxr.free-electrons.com/source/fs/dcache.c#L3236"" rel=""nofollow"">d_path</a>. In other words, no matter how large is <code>buffer</code>, <code>d_path</code> will always be limited to a size of a page. Which is 4096 bytes on amd64. Same as <code>PATH_MAX</code>! The <code>-ENAMETOOLONG</code> itself is returned by <a href=""http://lxr.free-electrons.com/source/fs/dcache.c#L2988"" rel=""nofollow"">prepend</a> when it runs out of mentioned page.</p>
"
"<p>My goal is to modify a process's open file descriptor's access permission. For eg, there is a process whose PID is known, which has 2 file descriptors open apart from the standard 3. One was opened with read only permission and other was opened with write only permission. I want to modify the file descriptors permission from read only to read and write. After which, the file descriptor can be used to write the object it was created with.</p>

<p>I have written a kernel module that gives me access to the file descriptor of the process identified by its PID. I searched the header and forums to understand how the linux data structure works for handling the file descriptor but I am still confused. What I found out is, every process has its own <strong><em>task_struct</em></strong>, which contains a member for all open files under, which contains an array of open file descriptor. I do not know how it links from here on with the inode.</p>

<p>I found out that there is member of struct file, called as <strong><em>f_mode</em></strong> that gives us the permissions but I cannot find a method to call it. When I access it directly, it gives me an unsigned int but I don't know what value maps to what? Also, I am not sure if this is the data member which stores the access permissions. If I modify this would it change the access permissions for file descriptor? </p>

<p>The code is given below:</p>

<pre><code>static int __init mainInit(void){

    int pid=13433;
    struct task_struct * task;
    struct files_struct * files;
    struct fdtable * filestable;
    struct path files_path;

    //Get Task structure from PID
    task = pid_task(find_vpid(pid), PIDTYPE_PID );
    //Get open FIles from the task tstructure
    files = task-&gt;files;

    filestable=files_fdtable(files);

    int i=0;
    char *cwd;
    char *buf = (char *)kmalloc(GFP_KERNEL,100*sizeof(char));

    while(filestable-&gt;fd[i] != NULL){
        files_path = filestable-&gt;fd[i]-&gt;f_path;
        cwd=d_path(&amp;files_path,buf, 100*sizeof(char));

        printk(KERN_INFO ""Open FD with %d with name %s with access %x\n"", i, cwd,filestable-&gt;fd[i]-&gt;f_mode);

        //printk(KERN_INFO ""FMode read:%x Fmodewrite:%x\n"",FMODE_READ,FMODE_WRITE);


        //Check access mode
        if(filestable-&gt;fd[i]-&gt;f_mode==FMODE_READ){
            printk(KERN_INFO ""File has access FMODE_READ\n"");
        }else if(filestable-&gt;fd[i]-&gt;f_mode==FMODE_WRITE){
            printk(KERN_INFO ""File has access FMODE_WRTIE\n"");
        }
        i++;
    }
    return 0;
}

static void __exit mainExit(void){
    printk(KERN_INFO ""Goodbye Kernel!. Returning to normal useless world!\n"");
}

module_init(mainInit);
module_exit(mainExit);
</code></pre>
"
"<p>i want get words from files (*.txt) from path. but i am getting <strong><em>error free() invalid next size (normal)</em></strong> , i could not understand what is the problem about the code below.
File format is like :</p>

<pre><code>apple
banana
lemonade
berry
</code></pre>

<p>I also check with wExtra in gcc for extra warning but there is no sign about the problem. My aim is get file names with path from the first function and read files from second function.</p>

<pre><code>void openFilesInPath(const char* path, int level)
{
    DIR *dir;
    struct dirent *entry;

    if (!(dir = opendir(path)))
        return;
    if (!(entry = readdir(dir)))
        return;
    char* filePath;
    do
    {
        if (entry-&gt;d_type == 4)
        {
            char path[1024];
            int len = snprintf(path, sizeof(path)-1, ""%s/%s"", path, entry-&gt;d_path);
            path[len] = 0;
            if (strcmp(entry-&gt;d_path, ""."") == 0 || strcmp(entry-&gt;d_path, "".."") == 0)
                continue;
            openFilesInPath(root,path, level + 1);
        }
        else if(strstr(entry-&gt;d_path,"".txt"")!=0)
        {
            filePath = path;
            filePath = append(filePath,'/');
            strcat(filePath,entry-&gt;d_path);

            if(root==NULL)
            {
                printf(""root loc: %s\n"",filePath);
                root = read_from_file(filePath);
            }
            else
            {
                printf(""leaf loc: %s\n"",filePath);
                read_file(filePath);
                display_tree(root,0);
            }
        }

    }
    while (entry = readdir(dir));
    closedir(dir);
}

void read_file(const char* filename)
{
    FILE* file = fopen(filename,""r"");
    if (file == NULL)  /*error check*/
    {
        printf(""Could not locate file\n"");
        return ;
    }
    char name[MAX_NAME_LEN];
    fscanf(file,""%s"",name);
    /*****************************************************/
    /*
    Get name of the file from its name
    */
    char  *basec, *bname;
    basec = strdup(filename);
    bname = basename(basec);
    /*****************************************************/
    while(1)
    {
        fscanf(file,""%s"",name);
        printf(""%s %s"",name,bname);
        if(feof(file))/*check for the end of the list*/
            break;
    }
    fclose(file);
}
</code></pre>
"
"<p>I'm working to create a function that takes in a path and reads all the files within it and creates a linked lists. Reading the directory works well but I'm having difficulty creating and storing the relevant information in a linked list for use later. </p>

<p>Heres the structure I'm using currently: </p>

<pre><code>typedef struct searchPool searchPool;
struct searchPool{

    char * path;
    char * fileName;
    char *pathFile;

    searchPool * next;

};
</code></pre>

<p>The function to create a new element of the type 'SearchPool' is defined as such: </p>

<pre><code>searchPool * mallocStructPool (char * path, char * fileName, char * filePath ) {

    searchPool * element = (searchPool*)malloc(sizeof(searchPool));
    element-&gt;path = malloc(sizeof(char * ));
    element-&gt;fileName = malloc(sizeof(char * ));
    element-&gt;pathFile = malloc(sizeof(char * ));

    element-&gt;path = path;
    element-&gt;fileName = fileName;
    element-&gt;pathFile = filePath;

    element-&gt;next = NULL;

    return element;
}
</code></pre>

<p>Finally the recursive function that take the list's head is written as such (code commented if you scroll to the right):</p>

<pre><code>void listDir(char * path, searchPool * head){
    DIR * d = opendir(path);        // open the path

    searchPool * element;                                                                   // create new Element of type SearchPool
    struct dirent * dir;                                                                    // for the directory entries

    while ((dir = readdir(d)) != NULL) {                                                    // if we were able to read somehting from the directory
        if(dir-&gt; d_type != DT_DIR) {                                                        // if the type is not directory just print it with blue

            char * s = malloc(sizeof(char*)+1);                                             // variable to concatenate
            s = concat(path, dir-&gt;d_name);                                                  // concatenate path and filename together
            //printf(""%s\n"",s);

            element = mallocStructPool(dir-&gt;d_name, path, s);                               // malloc new element and set variables

            head-&gt;next = element;
            element-&gt;next = NULL;

            free(s);

        } else
        if(dir -&gt; d_type == DT_DIR &amp;&amp; strcmp(dir-&gt;d_name,""."")!=0 &amp;&amp; strcmp(dir-&gt;d_name,"".."")!=0 ) {// if it is a directory
            char d_path[255];                                                               // here I am using sprintf which is safer than strcat
            sprintf(d_path, ""%s/%s"", path, dir-&gt;d_name);
            listDir(d_path, element);                                                       // recall with the new path
        }
    }
    closedir(d);                                                                            // finally close the directory
}
</code></pre>

<p>The problem is that when the function listDir() is called it only ends up printing the first path that I give it in it's parameters and the rest is ignored. Do I have to return the new element in listDir() after each run? I don't see where I'm going wrong.</p>

<p>Any help is appreciated. Thanks for your time.</p>
"
"<p>the following code opens a path and recursively reads through the directories and prints the files within it. At the moment it just prints the path to the directory and then every file within it but I would like to implement a linked list that will contain 1 char* variable that contains the full path to every file visited.</p>

<p>Here's the code :</p>

<pre><code>#include &lt;dirent.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void show_dir_content(char * path)
{
    DIR * d = opendir(path);
    if(d==NULL) return;
    struct dirent * dir;
    while ((dir = readdir(d)) != NULL)
    {
        if(dir-&gt; d_type != DT_DIR)          // if the type is not directory just print it
            printf(""\t%s\n"",dir-&gt;d_name);
        else
            if(dir -&gt; d_type == DT_DIR &amp;&amp; strcmp(dir-&gt;d_name,""."")!=0 &amp;&amp; strcmp(dir-&gt;d_name,"".."")!=0 )   // if it is a directory
            {
                char d_path[255];                               // here I am using sprintf which is safer than strcat
                sprintf(d_path, ""%s/%s"", path, dir-&gt;d_name);
                printf(""%s\n"",d_path);
                show_dir_content(d_path);
            }
    }
    closedir(d);
}

int main(int argc, char **argv)
{
    show_dir_content(argv[1]);
    return(0);
}
</code></pre>

<p>The struct used for the linked list can be quite simple such as :</p>

<pre><code>typedef struct search search;
struct search {
    char *path;
    char *fileName;
    char *fullPathToFile;
    search *next;
};
</code></pre>

<p>I'm just having a difficult time using mallocs for the struct and creating the actual linked list within the recursive function. Any help is appreciated. </p>
"
"<p>The following code allows me to read a directory recursively and print all the files and their paths in a struct variable using linked lists. The problem I'm having is within the function when I print out the full path it shows it correctly but in the main when I was read through the linked lists, the fullpaths show up as null. Where am I going wrong? </p>

<p>Code : </p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;dirent.h&gt;

const char *path_format = ""%s/%s"";

typedef struct search search;
struct search {
    char *path;
    char *fileName;
    char *fullPathToFile;
    search *next;
};

// Modified to take a node ptr. This should be the last node in the list
// Returns a node ptr. This is the new last node in the list
search * show_dir_content(char * path, search *node) {
    DIR * d = opendir(path);
    if(d==NULL) return node;
    struct dirent * dir;

    while ((dir = readdir(d)) != NULL) {
        if(dir-&gt; d_type != DT_DIR) {
            // Found a file. Alloc a new search node and fill in

            search *new_node = malloc(sizeof(search));

            char f_path[512];
            sprintf(f_path, path_format, path, dir-&gt;d_name);
            printf(""%s\n"",f_path);



            new_node-&gt;fullPathToFile = f_path;
            new_node-&gt;fileName = dir-&gt;d_name;
            new_node-&gt;path = path;
            new_node-&gt;next = NULL;
            // Append to end of list
            node-&gt;next = new_node;
            // Update node pointer to now point to the new node
            node = node-&gt;next;
        }
        else
            // if it is a directory
            if(dir -&gt; d_type == DT_DIR &amp;&amp; strcmp(dir-&gt;d_name,""."")!=0 &amp;&amp; strcmp(dir-&gt;d_name,"".."")!=0 ) {
                char d_path[512];
                sprintf(d_path, path_format, path, dir-&gt;d_name);
                node = show_dir_content(d_path, node);
            }
    }
    closedir(d);
    // Return the last node (this may be same as input parameter if no files found
    return node;
}


int main(int argc, char **argv) {
    search root = {0};
    show_dir_content(argv[1], &amp;root);       // Note that root is a dummy node.
                                            // The list actually begins at root-&gt;next

    // Also, before you exit, free all mem
    search *node = root.next, *next, *clr;

    while (NULL != node) {
        //printf(""f_path : \t%s\n"", node-&gt;fullPathToFile);
        next = node-&gt;next;
        node = next;
    }

    while (NULL != node) {
        free(node-&gt;path);
        free(node-&gt;fileName);
        free(node-&gt;fullPathToFile);
        clr = node-&gt;next;
        free(node);
        node = next;
    }

    return(0);
}
</code></pre>

<p>Printing the fullpath within the function seems to work well with <code>printf(""%s\n"",f_path);</code> but when I try to store <code>f_path</code> into my  <code>new_node-&gt;fullPathToFile</code> and then try printing it in the main it doesn't go as I had hoped. You can try uncommenting <code>printf(""f_path : \t%s\n"", node-&gt;fullPathToFile);</code> to understand what I mean. </p>

<p>Any help is appreciated. </p>
"
"<p>I'm having some trouble with the code below it sould take the path to a folder as input (in my case ""pack"") and put the pathes to each .wav file it can find in the folder or in subfolders into an array of string.</p>

<p>The code you can see below crashes.</p>

<p>Before asking you guys some help I've search by myself and the crash seems to append while in the second subfolder when trying to realloc for the first file of that folder</p>

<p>The folder structure I'm testing with goes like this :</p>

<pre><code>pack
+-- _subfolder1
|   +-- wavefile1.wav
|   +-- wavefile2.wav
|   +-- wavefile3.wav
+-- _subfolder2
|   +-- wavefile4.wav
+-- _subfolder3
|   +-- wavefile5.wav
|   +-- wavefile6.wav
</code></pre>

<p>code : </p>

<pre><code>#include &lt;dirent.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void find_dir_content(char* path, char** filepathlist, int* size)
{

    DIR* d = opendir(path);
    if(d == NULL)
        return;
    struct dirent* dir;

    while((dir = readdir(d)) != NULL)
    {
        int isdir = 0;
        DIR* tmp;
        char f_path[255];
        sprintf(f_path, ""%s/%s"", path, dir-&gt;d_name);
        if((tmp = opendir(f_path))) {
            closedir(tmp);
            isdir = 1;
        }

        if(!isdir) {

            char *dot = strrchr(dir-&gt;d_name, '.');
            if (dot &amp;&amp; !strcmp(dot, "".wav"")){
                char** tmp = realloc(filepathlist, sizeof(char*) * ((*size)  + 1));
                if (tmp == NULL)
                {
                    return;
                }
                else
                {
                    filepathlist = tmp;
                }
                char d_path[256];
                sprintf(d_path, ""%s/%s"", path, dir-&gt;d_name);
                filepathlist[*size] = d_path;
                //printf(""%d : %s\n"", *size, filepathlist[*size]);
                (*size)++;

            }
        }
        else if(isdir &amp;&amp; strcmp(dir-&gt;d_name, ""."") != 0 &amp;&amp;
            strcmp(dir-&gt;d_name, "".."") != 0)
        {
            char d_path[256];
            sprintf(d_path, ""%s/%s"", path, dir-&gt;d_name);
            //printf(""%s\n"", d_path);
            find_dir_content(d_path, filepathlist, size);


        }
    }
    closedir(d);

}

int main(int argc, char** argv)
{
    int sizefilepathlist = 0;
    char** filepathlist = (char**) malloc(0*sizeof(char*));
    find_dir_content(""pack"", filepathlist, &amp;sizefilepathlist);
    for(int i = 0; i&lt; sizefilepathlist; i++){
        printf(""%s"", filepathlist[i]);
    }

    return 0;
}
</code></pre>

<p>Edit: I'm on windows, I use codelite with minGW(gcc), and there is no error message, windows just gives me the old ""has stopped working"" error.</p>
"
"<p>I am having some trouble counting only the regular files in a directory.</p>

<p>This is my code: </p>

<pre><code>int show_regular_files(char ** path) {
    DIR * dp = opendir(*path); // open the path
    char d_path[BUFSIZE]; //
    struct dirent *ep;
    struct stat sb;
    int number=0;
    int rv;
    if (dp != NULL){
        while (ep = readdir (dp)){
            sprintf(d_path,""%s/%s "",*path,ep-&gt;d_name);
            rv= stat(d_path, &amp;sb);
            if(rv&lt;0)
            continue;
            else{
                if((sb.st_mode &amp; S_IFMT)==S_IFREG){ // checks if a file is regular or not
                    if(sb.st_mode &amp; S_IXOTH || sb.st_mode &amp; S_IXGRP){// search permission  &amp; group owner of the file
                        number++;
                    }
                }
            }
        }
    }
    else
        perror(""can't open the file "");
            closedir(dp); // finally close the directory
    return number;
}
</code></pre>

<p>It always prints 0 unless I remove the REGULARFILE condition check and stat line, then it lists all the files in the directory.</p>
"
"<pre><code>#include &lt;dirent.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/wait.h&gt;

int show_dir_content(char *path);

int show_dir_content(char *path)
{
    char readbuffer[80];
    char buffer[150];
    char uzun[9999];
    int totalfound = 0;
    DIR *d = opendir(path);
    if(d == NULL)
        return -3;
    struct dirent *dir;
    int piper[2];
    pid_t typer = 0;

    while((dir = readdir(d)) != NULL)
    {
        pipe(piper);
        typer = fork();

        if(typer == 0)
        {
            close(piper[0]);
            if(dir-&gt;d_type != DT_DIR)
            {   // if the type is not directory  blue
                // printf(""%s\n"",dir-&gt;d_name);
                sprintf(buffer, ""%s"", dir-&gt;d_name);
                write(piper[1], buffer, (strlen(buffer) + 1));
            }

            else if(dir-&gt;d_type == DT_DIR &amp;&amp; strcmp(dir-&gt;d_name, ""."") != 0 &amp;&amp;
                    strcmp(dir-&gt;d_name, "".."") != 0) // if it is a directory

            {

                char d_path[255]; // here I am using sprintf which is safer than
                                  // strcat
                sprintf(d_path, ""%s/%s"", path, dir-&gt;d_name);
                show_dir_content(d_path); // recall with the new path
            }
            exit(0);

            close(piper[1]);
        }
        else if(typer &gt; 0)
        {
            close(piper[1]);
            read(piper[0], readbuffer, sizeof(readbuffer));
            // strcat(uzun,readbuffer);
            // close(piper[0]);

            break;
        }
    }

    while(wait(NULL) &gt; 0)
        ;
    closedir(d);
    // printf(""%s x_x\n"",uzun);
    return totalfound + 1; // finally close the directory
}

int main(int argc, char **argv)
{

    show_dir_content(argv[1]);

    return (0);
}
</code></pre>

<p>It doesn't execute on forked child, only on parent and only once.
I use Linux Mint 18 and gcc comes with it.
i don't what causes it, it doesn't seems to be Segmentation fault because it exits correctly. I would be more then happy if anyone can see my errors here</p>

<p>I'm debugging on CLion.</p>
"
"<p>I'm building custom kernel linux for my device (like embeded device). I want to log all information of kill system call. So I modify code in kill system call and get pid to kill. But I can't get full process path for it, I have just get full path of current process.
This is my code to get process path from pid.</p>

<pre><code>long GetProcessPathFromPid(const pid_t p_id, char* pszProcessPath, int iSize)
{
    struct task_struct *task = NULL;
    struct pid *pid_struct = NULL;
    struct mm_struct *mm = NULL;
    //struct file *exe_file = NULL;
    //char buf[256] = {0};
    //char *result = ERR_PTR(-ENOENT);
    //int iResultLength = 0;

    pid_struct = find_get_pid(p_id);
    if (pid_struct == NULL)
    {
        printk(""Fail to find_get_pid.\n"");
    }
    task = pid_task(pid_struct, PIDTYPE_PID);                               // Get task_struct
    if (task == NULL)
    {
        printk(""Fail to pid_task.\n"");
    }
    mm = get_task_mm(task);                                                // Get mm of task_struct
    mmput(mm);

    printk(""Finish hook kill process\n."");
    return 0;                                              // Get mm of task_struct
}
</code></pre>

<p>And this is error when I update firmware:</p>

<pre><code>Call Trace:
[&lt;8042971c&gt;] printk+0x24/0x30
[&lt;800c37c8&gt;] GetProcessPathFromPid+0x38/0x88
[&lt;800c3b60&gt;] LogKillProcess+0x64/0xf4
[&lt;800443d4&gt;] sys_kill+0x30/0x1d8
[&lt;800354b0&gt;] do_wait+0x11c/0x220
[&lt;8042e234&gt;] wait_for_completion_killable+0x18/0x30
[&lt;80043a3c&gt;] set_current_blocked+0x30/0x48
[&lt;80533210&gt;] repair_env_string+0x0/0x94
[&lt;8003664c&gt;] sys_wait4+0x80/0xfc
[&lt;800344d8&gt;] child_wait_callback+0x0/0x8c
[&lt;80533210&gt;] repair_env_string+0x0/0x94
[&lt;8001b59c&gt;] stack_done+0x20/0x40
[&lt;800b07a8&gt;] sys_close+0x0/0x158
[&lt;80533210&gt;] repair_env_string+0x0/0x94


Call Trace:
[&lt;8042fe88&gt;] _raw_spin_lock+0x10/0x3c
[&lt;8002ef68&gt;] get_task_mm+0x20/0x7c
[&lt;800c37c8&gt;] GetProcessPathFromPid+0x38/0x88
[&lt;800c3b60&gt;] LogKillProcess+0x64/0xf4
[&lt;800443d4&gt;] sys_kill+0x30/0x1d8
[&lt;8001b59c&gt;] stack_done+0x20/0x40


Code: 24630001  af830014  3c020001 &lt;c0830000&gt; 00622821  e0850000  10a0fffc  00032c02  3063ffff
pe=GPON

---[ end trace aee100dae37dfc66 ]---
note: init[1] exited with preempt_count 1
FinWLmngr Daeish hook kill process
.mon is running
 !!!!   PLL locked !!!!!!     !!!!   RX CDR locked !!!!!!     !!!!   TX CDR locked !!!!!!    GPON BEN Calibration Done
GPON SerDes Initialization Sequence Done
Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b
</code></pre>

<p>Can you help me? Thanks!</p>
"
"<p>We need to change/reimplement standard DFT implementation in GSL, which is </p>

<pre><code>int
FUNCTION(gsl_dft_complex,transform) (const BASE data[],
                                     const size_t stride, const size_t n,
                                     BASE result[],
                                     const gsl_fft_direction sign)
{

  size_t i, j, exponent;

  const double d_theta = 2.0 * ((int) sign) * M_PI / (double) n;

  /* FIXME: check that input length == output length and give error */

  for (i = 0; i &lt; n; i++)
    {
      ATOMIC sum_real = 0;
      ATOMIC sum_imag = 0;

      exponent = 0;

      for (j = 0; j &lt; n; j++)
        {
          double theta = d_theta * (double) exponent;
          /* sum = exp(i theta) * data[j] */

          ATOMIC w_real = (ATOMIC) cos (theta);
          ATOMIC w_imag = (ATOMIC) sin (theta);

          ATOMIC data_real = REAL(data,stride,j);
          ATOMIC data_imag = IMAG(data,stride,j);

          sum_real += w_real * data_real - w_imag * data_imag;
          sum_imag += w_real * data_imag + w_imag * data_real;

          exponent = (exponent + i) % n;
        }
      REAL(result,stride,i) = sum_real;
      IMAG(result,stride,i) = sum_imag;
    }

  return 0;
}
</code></pre>

<p>In this implementation, GSL iterates over input vector twice for sample/input size. However, we need to construct for different frequency bins. For instance, we have 4096 samples, but we need to calculate DFT for 128 different frequencies. Could you help me to define or implement required DFT behaviour? Thanks in advance.</p>

<p>EDIT: We do not search for first <code>m</code> frequencies.</p>

<p>Actually, is below approach correct for finding DFT result with given frequency bin number?
N = sample size
B = frequency bin size</p>

<pre><code>k = 0,...,127 X[k] = SUM(0,N){x[i]*exp(-j*2*pi*k*i/B)}
</code></pre>

<p>EDIT: I might have not explained the problem for DFT elaborately, nevertheless, I am happy to provide the answer below:</p>

<pre><code>void compute_dft(const std::vector&lt;double&gt;&amp; signal,
                 const std::vector&lt;double&gt;&amp; frequency_band,
                 std::vector&lt;double&gt;&amp; result,
                 const double sampling_rate)
{
    if(0 == result.size() || result.size() != (frequency_band.size() &lt;&lt; 1)){
        result.resize(frequency_band.size() &lt;&lt; 1, 0.0);
    }

    //note complex signal assumption
    const double d_theta = -2.0 * PI * sampling_rate;

    for(size_t k = 0; k &lt; frequency_band.size(); ++k){
        const double f_k = frequency_band[k];
        double real_sum = 0.0;
        double imag_sum = 0.0;

        for(size_t n = 0; n &lt; (signal.size() &gt;&gt; 1); ++n){
            double theta = d_theta * f_k * (n + 1);

            double w_real = cos(theta);
            double w_imag = sin(theta);

            double d_real = signal[2*n];
            double d_imag = signal[2*n + 1];

            real_sum += w_real * d_real - w_imag * d_imag;
            imag_sum += w_real * d_imag + w_imag * d_real;
        }

        result[2*k] = real_sum;
        result[2*k + 1] = imag_sum;
    }
}
</code></pre>
"
"<p>I have created an eventfd instance in a userspace program using eventfd(). Is there a way in which I can pass some reference (a pointer to its struct or pid+fd pair) to this created instance of eventfd to a kernel module so that it can update the counter value?</p>

<p>Here is what I want to do:
I am developing a userspace program which needs to exchange data and signals with a kernel space module which I have written.
For transferring data, I am already using ioctl. But I want the kernel module to be able to signal the userspace program whenever new data is ready for it to consume over ioctl.</p>

<p>To do this, my userspace program will create a few eventfds in various threads. These threads will wait on these eventfds using select() and whenever the kernel module updates the counts on these eventfds, they will go on to consume the data by requesting for it over ioctl.</p>

<p>The problem is, how do I resolve the ""struct file *"" pointers to these eventfds from kernelspace? What kind of information bout the eventfds can I sent to kernel modules so that it can get the pointers to the eventfds? what functions would I use in the kernel module to get those pointers?</p>

<p>Is there better way to signal events to userspace from kernelspace?
I cannot let go of using select().</p>
"
"<p>I need to check and update files if the files are updated on the same day. if it is older, making the script to sleep for some time and again checking the file update time. The issue is the variable which I am using for reassigning the file time is not working. Its holding the older time and not the updated time if the file updated during script running. Please help me !</p>

<p>using filemtime to get file update time.
using while loop to check the time.</p>

<p>Thanks in advance..</p>

<p>thanks for the quick response. Here is the code</p>

<pre><code>$current_date=date(""Y-m-d 00:00:00"");
$file_update_time=date(""Y-m-d H:i:s"", filemtime(""/path/filename""));

while(new DateTime($file_update_time) &lt; new DateTime($current_date))
{
sleep (120);
$file_update_time=date(""Y-m-d H:i:s"", filemtime(""/path/filename""));
}
</code></pre>
"
"<p>I want to write a small script of parsing all the comments of the C file using shell script but I am not even getting the read o/p correct,I am getting the file o/p mixed with other garbage data.</p>

<pre><code>&gt;/.1432804547.3007 /.1432804567.3007 /.1432804587.3007 /.1432804608.4021 /.1432804628.4021 /.1432804648.4021 /.1432804668.4021 /.1432804688.4021 /bin &gt;/boot /dev /etc /home /lib /lib64 /lost+found /media /misc /mnt /net /opt /proc &gt;/root /sbin /selinux /srv /sys /tmp /usr /var
&gt;parsed_comments.tmp parse_func.sh file_update_time - update mtime and ctime time
&gt;parsed_comments.tmp parse_func.sh @file: file accessed
&gt;parsed_comments.tmp parse_func.sh
&gt;parsed_comments.tmp parse_func.sh Update the mtime and ctime members of an inode and mark the inode
&gt;parsed_comments.tmp parse_func.sh for writeback. Note that this function is meant exclusively for
&gt;parsed_comments.tmp parse_func.sh usage in the file write path of filesystems, and filesystems may
&gt;parsed_comments.tmp parse_func.sh choose to explicitly ignore update via this function with the
&gt;parsed_comments.tmp parse_func.sh S_NOCMTIME inode flag, e.g. for network filesystem where these
&gt;parsed_comments.tmp parse_func.sh timestamps are handled by the server.
&gt;*/
&gt;void file_update_time(struct file *file)
</code></pre>

<p>Here is what I am doing..</p>

<pre><code>   parse_comments() {
    local filename=""$1""
    while read line; do
    echo $line | grep ""*""
    done &lt; ""$filename""
    parse_comments ""/root/rpmbuild/linux-2.6.32-431.17.1.el6.x86_64/fs/inode.c""
</code></pre>

<p>I have tried all the solutions(like- while read -r, while read -u 3 and other too) told on SO for while read problem none of the solution worked for me.
I don't know whats wrong with read with while loop please help...
If I use 'awk' for the same work it works fine. But 'awk' doesn't serve my purpose.</p>
"
"<p>I am trying to print some information inside of <code>__generic_file_write_iter()</code> from within <a href=""http://lxr.free-electrons.com/source/mm/filemap.c?v=4.5#L2696"" rel=""nofollow"">mm/filemap.c</a>.</p>

<p>I have modified the function as follows:</p>

<pre><code>struct file *file = iocb-&gt;ki_filp;
struct address_space * mapping = file-&gt;f_mapping;
struct inode    *inode = mapping-&gt;host;
ssize_t         written = 0;
ssize_t         err;
ssize_t         status;

/* We can write back this queue in page reclaim */
current-&gt;backing_dev_info = inode_to_bdi(inode);
err = file_remove_privs(file);
if (err)
        goto out;

err = file_update_time(file);
if (err)
        goto out;

/* This if() is all I have added */
if(io_tracing_on) {
        ssize_t write_size = iov_length(from-&gt;iov, from-&gt;nr_segs);
        printk(KERN_INFO ""write size=%zu, pid=%d, inode=%lu\n"", write_size, task_pid_nr(current), inode-&gt;i_ino);
}

if (iocb-&gt;ki_flags &amp; IOCB_DIRECT) {
        loff_t pos, endbyte;
        ...
</code></pre>

<p>io_tracing_on is a variable that I set via a /proc entry (created by my module, which is built in to the kernel).  When I flip the switch on and run dd (via <code>dd if=/dev/urandom of=/tmp/gibberish bs=1M count=1</code>), I get a continuous stream of output to <code>/var/log/syslog</code>, i.e.:</p>

<pre><code>Jun 27 15:00:41 malka kernel: [  463.424155] write size=168, pid=715, inode=7864653
Jun 27 15:00:41 malka kernel: [  463.428064] write size=168, pid=715, inode=7864354
Jun 27 15:00:41 malka kernel: [  463.428126] write size=168, pid=715, inode=7864653
Jun 27 15:00:41 malka kernel: [  463.432061] write size=168, pid=715, inode=7864354
Jun 27 15:00:41 malka kernel: [  463.432121] write size=168, pid=715, inode=7864653
Jun 27 15:00:41 malka kernel: [  463.436075] write size=168, pid=715, inode=7864354
Jun 27 15:00:41 malka kernel: [  463.436133] write size=168, pid=715, inode=7864653
Jun 27 15:00:41 malka kernel: [  463.440060] write size=168, pid=715, inode=7864354
Jun 27 15:00:41 malka kernel: [  463.440121] write size=168, pid=715, inode=7864653
etc
</code></pre>

<p>Yet, when I run the ftrace (using the ""function"" tracer), I never see <code>__generic_file_write_iter()</code> get called.  So, why would my <code>printk()</code> statement get called continuously without <code>__generic_file_write_iter()</code> showing up in the ftrace output?</p>

<p>The kernel version is 4.5.5.</p>

<p><strong>UPDATE</strong></p>

<p>Previously, I was not able to associate the pid with any valid process.  After changing my code to print pid and tgid, I was able to associate tgid with a process.  It seems that the syslog is calling my <code>printk()</code> every time it writes, causing the continuous stream of output.  However, ftrace still does not show <code>__generic_file_write_iter()</code> being called near enough times to reflect the amount of times my <code>printk()</code> is called.  So, my question remains -- if ftrace is working as I expect, I would imagine there to be one call to <code>__generic_file_write_iter()</code> in ftrace for every <code>printk()</code> that I see in the syslog.</p>
"
"<pre><code>const struct file_operations generic_ro_fops = {
  .llseek         = generic_file_llseek,
  .read           = do_sync_read,
  .aio_read       = generic_file_aio_read,
  .mmap           = generic_file_readonly_mmap,
  .splice_read    = generic_file_splice_read,
  };
</code></pre>

<p>What do those "". "" mean in this code?</p>

<p>This is from linux kernel fs/read_write.c</p>

<p>FYI
<a href=""http://lxr.linux.no/linux+v3.2.8/fs/read_write.c"" rel=""nofollow"">http://lxr.linux.no/linux+v3.2.8/fs/read_write.c</a></p>
"
"<p>I am trying to follow how Linux deals with EXT3 files.
I am looking at <code>fs/ext3/file.c</code> where there are file operations that deal with the files are present: </p>

<pre><code>const struct file_operations ext3_file_operations = {
    .llseek         = generic_file_llseek,
    .read           = do_sync_read,
    .write          = do_sync_write,
    .aio_read       = generic_file_aio_read,
    .aio_write      = generic_file_aio_write,
    .unlocked_ioctl = ext3_ioctl,
#ifdef CONFIG_COMPAT
    .compat_ioctl   = ext3_compat_ioctl,
#endif
    .mmap           = generic_file_mmap,
    .open           = dquot_file_open,
    .release        = ext3_release_file,
    .fsync          = ext3_sync_file,
    .splice_read    = generic_file_splice_read,
    .splice_write   = generic_file_splice_write,
};
</code></pre>

<p>How can I find when does .open is replaced by the function ""dquot_file_open"" for example?
Should I follow the system call defined in <code>fs/open.c</code>:</p>

<pre><code>SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)
</code></pre>

<p>Or should I be looking at other functions? </p>

<p>I am working on Linux 3.7.6 for User-Mode-Linux </p>
"
"<p>I've skimmed through the <a href=""http://www.tldp.org/LDP/lkmpg/2.6/html/lkmpg.html"" rel=""nofollow"">Linux Kernel Module Programming</a> guide, but can't figure out: </p>

<p>When I say <code>cat image.iso &gt; /dev/sda</code>, will it cause the <code>write</code> function of <a href=""http://www.tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN567"" rel=""nofollow"">file_operations structure</a> to be executed by the <code>sda</code> device driver? Or is the file interface not applied to block device nodes?</p>

<p>Where do I find that function's implementation? (the respective driver within the <a href=""http://lxr.free-electrons.com/"" rel=""nofollow"">Linux code tree</a>)?</p>
"
"<p>Hi I was hoping someone might help me understand the read section of the <strong>read_write.c</strong> kernel file when I look at it I don't really understand a thing.</p>

<p>I can't really tell which part is actually reading the file considering there are several instances where read functions are called. I ask because I have to know where to modify it and how for an assignment I have where I have to modify the output of the read without actually modifying the file.</p>

<p>By the way I am using the latest version of the Linux kernel from kernel.org version 4.9 any and all help is appreciated thank you. Below is where I believe the the read is happening.</p>

<pre><code>typedef ssize_t (*iter_fn_t)(struct kiocb *, struct iov_iter *);

const struct file_operations generic_ro_fops = {
.llseek     = generic_file_llseek,
.read_iter  = generic_file_read_iter,
.mmap       = generic_file_readonly_mmap,
.splice_read    = generic_file_splice_read,
};

static ssize_t do_iter_readv_writev(struct file *filp, struct iov_iter   *iter,
    loff_t *ppos, iter_fn_t fn, int flags)
{
    struct kiocb kiocb;
    ssize_t ret;

    if (flags &amp; ~(RWF_HIPRI | RWF_DSYNC | RWF_SYNC))
        return -EOPNOTSUPP;

        init_sync_kiocb(&amp;kiocb, filp);
    if (flags &amp; RWF_HIPRI)
        kiocb.ki_flags |= IOCB_HIPRI;
    if (flags &amp; RWF_DSYNC)
        kiocb.ki_flags |= IOCB_DSYNC;
    if (flags &amp; RWF_SYNC)
        kiocb.ki_flags |= (IOCB_DSYNC | IOCB_SYNC);
        kiocb.ki_pos = *ppos;

    ret = fn(&amp;kiocb, iter);
    BUG_ON(ret == -EIOCBQUEUED);
    *ppos = kiocb.ki_pos;
    return ret;
}

ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
              unsigned long nr_segs, unsigned long fast_segs,
              struct iovec *fast_pointer,
              struct iovec **ret_pointer)
{
    unsigned long seg;
    ssize_t ret;
    struct iovec *iov = fast_pointer;

    /*
     * SuS says ""The readv() function *may* fail if the iovcnt argument
     * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has
     * traditionally returned zero for zero segments, so...
     */
    if (nr_segs == 0) {
        ret = 0;
        goto out;
    }

    /*
     * First get the ""struct iovec"" from user memory and
     * verify all the pointers
     */
    if (nr_segs &gt; UIO_MAXIOV) {
        ret = -EINVAL;
        goto out;
    }
    if (nr_segs &gt; fast_segs) {
        iov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);
        printk(KERN_DEBUG ""Hello from read_write.c\n"");
        printk(KERN_DEBUG ""Inside the copy check uvector method\n"");
        if (iov == NULL) {
            ret = -ENOMEM;
            goto out;
    }
    }
    if (copy_from_user(iov, uvector, nr_segs*sizeof(*uvector))) {
        ret = -EFAULT;
        goto out;
    }

    /*
     * According to the Single Unix Specification we should return EINVAL
     * if an element length is &lt; 0 when cast to ssize_t or if the
     * total length would overflow the ssize_t return value of the
     * system call.
     *
     * Linux caps all read/write calls to MAX_RW_COUNT, and avoids the
     * overflow case.
     */
     ret = 0;
     for (seg = 0; seg &lt; nr_segs; seg++) {
        void __user *buf = iov[seg].iov_base;
        ssize_t len = (ssize_t)iov[seg].iov_len;

        /* see if we we're about to use an invalid len or if
         * it's about to overflow ssize_t */
        if (len &lt; 0) {
            ret = -EINVAL;
            goto out;
        }
        if (type &gt;= 0
            &amp;&amp; unlikely(!access_ok(vrfy_dir(type), buf, len))) {
            ret = -EFAULT;
            goto out;
        }
        if (len &gt; MAX_RW_COUNT - ret) {
            len = MAX_RW_COUNT - ret;
            iov[seg].iov_len = len;
        }
        ret += len;
    }
out:
    *ret_pointer = iov;
    return ret;
}


/* Do it by hand, with file-ops */
static ssize_t do_loop_readv_writev(struct file *filp, struct iov_iter *iter,
    loff_t *ppos, io_fn_t fn, int flags)
{
    ssize_t ret = 0;

    if (flags &amp; ~RWF_HIPRI)
        return -EOPNOTSUPP;

    while (iov_iter_count(iter)) {
            struct iovec iovec = iov_iter_iovec(iter);
            ssize_t nr;

            nr = fn(filp, iovec.iov_base, iovec.iov_len, ppos);

            if (nr &lt; 0) {
                if (!ret)
                    ret = nr;
                break;
            }
            ret += nr;
            if (nr != iovec.iov_len)
                break;
            iov_iter_advance(iter, nr);
        }

        return ret;
}

static ssize_t do_readv_writev(int type, struct file *file,
                               const struct iovec __user * uvector,
                               unsigned long nr_segs, loff_t *pos,
                               int flags)
{
    size_t tot_len;
    struct iovec iovstack[UIO_FASTIOV];
    struct iovec *iov = iovstack;
    struct iov_iter iter;
    ssize_t ret;
    io_fn_t fn;
    iter_fn_t iter_fn;

    ret = import_iovec(type, uvector, nr_segs,
                       ARRAY_SIZE(iovstack), &amp;iov, &amp;iter);
    if (ret &lt; 0)
        return ret;

    tot_len = iov_iter_count(&amp;iter);
    if (!tot_len)
        goto out;
    ret = rw_verify_area(type, file, pos, tot_len);
    if (ret &lt; 0)
        goto out;

    if (type == READ) {
        fn = file-&gt;f_op-&gt;read;
        iter_fn = file-&gt;f_op-&gt;read_iter;
    } else {
        fn = (io_fn_t)file-&gt;f_op-&gt;write;
        iter_fn = file-&gt;f_op-&gt;write_iter;
        file_start_write(file);
    }

    if (iter_fn)
        ret = do_iter_readv_writev(file, &amp;iter, pos, iter_fn, flags);
    else
        ret = do_loop_readv_writev(file, &amp;iter, pos, fn, flags);

    if (type != READ)
        file_end_write(file);

    out:
        kfree(iov);
        if ((ret + (type == READ)) &gt; 0) {
            if (type == READ)
                fsnotify_access(file);
            else
                fsnotify_modify(file);
        }
        return ret;
}

ssize_t vfs_readv(struct file *file, const struct iovec __user *vec,
                  unsigned long vlen, loff_t *pos, int flags)
{
    if (!(file-&gt;f_mode &amp; FMODE_READ))
        return -EBADF;
    if (!(file-&gt;f_mode &amp; FMODE_CAN_READ))
        return -EINVAL;

    return do_readv_writev(READ, file, vec, vlen, pos, flags);
}

EXPORT_SYMBOL(vfs_readv);
static ssize_t do_readv(unsigned long fd, const struct iovec __user *vec,
                        unsigned long vlen, int flags)
{
    struct fd f = fdget_pos(fd);
    ssize_t ret = -EBADF;

    if (f.file) {
        loff_t pos = file_pos_read(f.file);
        ret = vfs_readv(f.file, vec, vlen, &amp;pos, flags);
        if (ret &gt;= 0)
            file_pos_write(f.file, pos);
        fdput_pos(f);
    }

    if (ret &gt; 0)
        add_rchar(current, ret);
    inc_syscr(current);
    return ret;
}

static ssize_t do_preadv(unsigned long fd, const struct iovec __user *vec,
                         unsigned long vlen, loff_t pos, int flags)
{
    struct fd f;
    ssize_t ret = -EBADF;

    if (pos &lt; 0)
        return -EINVAL;

    f = fdget(fd);
    if (f.file) {
        ret = -ESPIPE;
        if (f.file-&gt;f_mode &amp; FMODE_PREAD)
            ret = vfs_readv(f.file, vec, vlen, &amp;pos, flags);
        fdput(f);
    }

    if (ret &gt; 0)
        add_rchar(current, ret);
    inc_syscr(current);
    return ret;
}


static ssize_t compat_do_readv_writev(int type, struct file *file,
               const struct compat_iovec __user *uvector,
               unsigned long nr_segs, loff_t *pos,
               int flags)
{
    compat_ssize_t tot_len;
    struct iovec iovstack[UIO_FASTIOV];
    struct iovec *iov = iovstack;
    struct iov_iter iter;
    ssize_t ret;
    io_fn_t fn;
    iter_fn_t iter_fn;

    ret = compat_import_iovec(type, uvector, nr_segs,
              UIO_FASTIOV, &amp;iov, &amp;iter);
    if (ret &lt; 0)
        return ret;

    tot_len = iov_iter_count(&amp;iter);
    if (!tot_len)
        goto out;
        ret = rw_verify_area(type, file, pos, tot_len);
    if (ret &lt; 0)
        goto out;

    if (type == READ) {
        fn = file-&gt;f_op-&gt;read;
        iter_fn = file-&gt;f_op-&gt;read_iter;
    } else {
            fn = (io_fn_t)file-&gt;f_op-&gt;write;
            iter_fn = file-&gt;f_op-&gt;write_iter;
            file_start_write(file);
    }

    if (iter_fn)
        ret = do_iter_readv_writev(file, &amp;iter, pos, iter_fn, flags);
    else
        ret = do_loop_readv_writev(file, &amp;iter, pos, fn, flags);

    if (type != READ)
        file_end_write(file);

    out:
        kfree(iov);
        if ((ret + (type == READ)) &gt; 0) {
            if (type == READ)
                fsnotify_access(file);
            else
                fsnotify_modify(file);
        }
        return ret;
}

static size_t compat_readv(struct file *file,
           const struct compat_iovec __user *vec,
           unsigned long vlen, loff_t *pos, int flags)
{
    ssize_t ret = -EBADF;

    if (!(file-&gt;f_mode &amp; FMODE_READ))
       goto out;

    ret = -EINVAL;
    if (!(file-&gt;f_mode &amp; FMODE_CAN_READ))
        goto out;

    ret = compat_do_readv_writev(READ, file, vec, vlen, pos, flags);

     out:
        if (ret &gt; 0)
            add_rchar(current, ret);
        inc_syscr(current);
        return ret;
}

static size_t do_compat_readv(compat_ulong_t fd,
             const struct compat_iovec __user *vec,
             compat_ulong_t vlen, int flags)
{
    struct fd f = fdget_pos(fd);
    ssize_t ret;
    loff_t pos;

    if (!f.file)
        return -EBADF;
    pos = f.file-&gt;f_pos;
    ret = compat_readv(f.file, vec, vlen, &amp;pos, flags);
    if (ret &gt;= 0)
        f.file-&gt;f_pos = pos;
    fdput_pos(f);
    return ret;

}

COMPAT_SYSCALL_DEFINE3(readv, compat_ulong_t, fd,
        const struct compat_iovec __user *,vec,
        compat_ulong_t, vlen)
{
    return do_compat_readv(fd, vec, vlen, 0);
}

static long do_compat_preadv64(unsigned long fd,
              const struct compat_iovec __user *vec,
              unsigned long vlen, loff_t pos, int flags)
{
    struct fd f;
    ssize_t ret;

    if (pos &lt; 0)
        return -EINVAL;
    f = fdget(fd);
    if (!f.file)
        return -EBADF;
    ret = -ESPIPE;
        if (f.file-&gt;f_mode &amp; FMODE_PREAD)
            ret = compat_readv(f.file, vec, vlen, &amp;pos, flags);
        fdput(f);
        return ret;
}
</code></pre>
"
"<p>Since <code>Ramfs</code> stores files into memory and that memory is bound to certain <code>NUMA</code> node, I think there exist some ways to keep track of <code>nodes</code> that requested a file(<code>a.txt</code> for example).</p>

<p>For example, if there are <strong>4 NUMA</strong> nodes with its local memory, list of nodes that accessed <code>a.txt</code> could be <code>0 0 0 1 1 0 2 2 2 0 3 3 3 3 3</code>.</p>

<p>One possible solution might be as following:</p>

<ol>
<li>Find low-level <code>ramfs</code> file operation function(like <code>read</code> or <code>write</code>)</li>
<li>Get the node number of the thread that is executing that function</li>
<li>Store that node number into somewhere (like <code>inode</code> of a.txt or something)</li>
</ol>

<p>But I failed to find such a low-level function of ramfs and I can't go ahead.</p>

<p>Is there a way to achieve this?</p>
"
"<p>Conventional filesystems create a <strong>struct file_operations</strong> structure to implement the VFS functions. For example, in the ext4 (Linux 4.0 and before) the <strong>struct file_operations ext4_file_operations</strong> make the read pointer point to new_sync_read.</p>

<p>Linux 4.0 <a href=""http://elixir.free-electrons.com/linux/v4.0.9/source/fs/ext4/file.c#L630"" rel=""nofollow noreferrer"">/fs/ext4/file.c</a></p>

<pre><code>const struct file_operations ext4_dax_file_operations = {
    .read       = new_sync_read,
    .read_iter  = generic_file_read_iter,
     ....
}
</code></pre>

<p>However, in Linux 4.1 and later, there is no such assignment for the read pointer, but a splice_read pointer is added.</p>

<p>Linux 4.1 <a href=""http://elixir.free-electrons.com/linux/v4.1.22/source/fs/ext4/file.c#L635"" rel=""nofollow noreferrer"">/fs/ext4/file.c</a></p>

<pre><code>const struct file_operations ext4_file_operations = {
    .read_iter  = generic_file_read_iter,
    .splice_read    = generic_file_splice_read,
    ...
}
</code></pre>

<p>But the <strong>struct file_operations</strong> defined in ""/include/linux/fs.h"" still has the read pointer. So, which function in ext4 now is responsible for the conventional read function?</p>
"
"<p>I'm modifying the minix filesystem linux kernel module (LKM) so that I can intercept the data, and cipher it when writing, and decipher when reading.</p>

<p>I figured that I can customize the file.c source file so that I can customize the method implementations: </p>

<pre><code>const struct file_operations minix_file_operations = {
    .llseek     = generic_file_llseek,
    .read_iter  = crypto_file_read_iter, // Customised decyphed file read
    .write_iter = crypto_file_write_iter, // Customised cyphed file write
    .mmap       = generic_file_mmap,
    .fsync      = generic_file_fsync,
    .splice_read    = generic_file_splice_read,
};
</code></pre>

<p>And these are the prototypes/signatures of the custom methods:</p>

<p><code>ssize_t crypto_file_write_iter(struct kiocb *iocb, struct iov_iter *from);</code></p>

<p><code>ssize_t crypto_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)</code></p>

<p>I need to read/write from/to the <code>iov_iter</code> struct so that I have a char buffer that I can cipher/decipher.</p>

<p>I tried methods like <code>readv</code>/<code>writev</code>, <code>vfs_readv</code>/<code>vsf_writev</code>, <code>copy_to_iter</code>/<code>copy_from_iter</code>, none with success. Some of them are not available in my kernel version.</p>

<p><strong>How can I extract the data that is being written/read as a char buffer?</strong></p>

<p>System specs: Linux Ubuntu, kernel version 4.10.0-35-generic</p>
"
"<p>In the <code>EXT2 file.c</code> the open file operation <code>(.open)</code> is being pointed to <code>dquot_file_open</code> which furthur points to <code>generic_file_open</code> which is present in <code>fs/open.c</code>. </p>

<p>The <code>generic_file_open</code> looks like it just has the below code</p>

<pre><code>int generic_file_open(struct inode * inode, struct file * filp)
{
    if (!(filp-&gt;f_flags &amp; O_LARGEFILE) &amp;&amp; i_size_read(inode) &gt; MAX_NON_LFS)
        return -EOVERFLOW;
    return 0;
}
</code></pre>

<p><strong>Where are the ACL permissions being checked when a file is about to be opened?</strong></p>

<p>When is I googled and went through the code using LXR I found the below path.</p>

<p><strong><code>do_sys_open -&gt; do_filp_open -&gt; path_openat -&gt; do_last -&gt; may_open -&gt; inode_permission -&gt; do_inode_permission -&gt; generic_permission -&gt; acl_permission_check -&gt; check_acl -&gt; posix_acl_permission</code></strong></p>

<p><strong>but I could not understand how the .open of EXT2 is linked to do_sys_open.</strong></p>

<p>Any help in letting me know the path to checking the acl permissions during a file open would be greatly appreciated.</p>
"
"<p>I have a character device driver. It includes a 4MB coherent DMA buffer. The buffer is implemented as a ring buffer. I also implemente the splice_read call for the driver to improve the performance. But this implementation does not work well. Below is the using example:
  (1)splice the 16 pages of device buffer data to a pipefd[1]. (the DMA buffer is managed as in page unit).
  (2)splice the pipefd[0] to the socket.
  (3)the receiving side (tcp client) receives the data, and then check the correctness.
I found that the tcp client got errors. The splice_read implementation is show below (I steal it from the vmsplice implementation):</p>

<pre><code>/* splice related functions */
static void rdma_ring_pipe_buf_release(struct pipe_inode_info *pipe,
                struct pipe_buffer *buf)
{
    put_page(buf-&gt;page);
    buf-&gt;flags &amp;= ~PIPE_BUF_FLAG_LRU;
}

void rdma_ring_spd_release_page(struct splice_pipe_desc *spd, unsigned int i)
{
    put_page(spd-&gt;pages[i]);
}

static const struct pipe_buf_operations rdma_ring_page_pipe_buf_ops = {
    .can_merge = 0,
    .map = generic_pipe_buf_map,
    .unmap = generic_pipe_buf_unmap,
    .confirm = generic_pipe_buf_confirm,
    .release = rdma_ring_pipe_buf_release,
    .steal = generic_pipe_buf_steal,
    .get = generic_pipe_buf_get,
};

/* in order to simplify the caller work, the parameter meanings of ppos, len
 * has been changed to adapt the internal ring buffer of the driver. The ppos
 * indicate wich page is refferred(shoud start from 1, as the csr page are
 * not allowed to do the splice), The len indicate how many pages are  needed.
 * Also, we constrain that maximum page number for each splice shoud not
 * exceed 16 pages, if else, a EINVAL will return. If a high speed device
 * need a more big page number, it can rework this routing. The off is also
 * used to return the total bytes shoud be transferred, use can compare it
 * with the return value to determint whether all bytes has been transfered.
 */
static ssize_t do_rdma_ring_splice_read(struct file *in, loff_t *ppos,
           struct pipe_inode_info *pipe, size_t len,
           unsigned int flags)
{
    struct rdma_ring *priv = to_rdma_ring(in-&gt;private_data);
    struct rdma_ring_buf *data_buf;
    struct rdma_ring_dstatus *dsta_buf;
    struct page *pages[PIPE_DEF_BUFFERS];
    struct partial_page partial[PIPE_DEF_BUFFERS];
    ssize_t total_sz = 0, error;
    int i;
    unsigned offset;

    struct splice_pipe_desc spd = {
        .pages = pages,
        .partial = partial,
        .nr_pages_max = PIPE_DEF_BUFFERS,
        .flags = flags,
        .ops = &amp;rdma_ring_page_pipe_buf_ops,
        .spd_release = rdma_ring_spd_release_page,
    };

    /* init the spd, currently we omit the packet header, if a control
     * is needed, it may be implemented by define a control variable in
     * the device struct */
    spd.nr_pages = len;
    for (i = 0; i &lt; len; i++) {
        offset = (unsigned)(*ppos) + i;
        data_buf = get_buf(priv, offset);
        dsta_buf = get_dsta_buf(priv, offset);
        pages[i] = virt_to_page(data_buf);
        get_page(pages[i]);
        partial[i].offset = 0;
        partial[i].len = dsta_buf-&gt;bytes_xferred;
        total_sz += partial[i].len;
    }

    error = _splice_to_pipe(pipe, &amp;spd);

    /* use the ppos to return the theory total bytes shoud transfer */
     *ppos = total_sz;

    return error;
}

/* splice read */
static ssize_t rdma_ring_splice_read(struct file *in, loff_t *ppos,
    struct pipe_inode_info *pipe, size_t len, unsigned int flags)
{
    ssize_t ret;

    MY_PRINT(""%s: *ppos = %lld, len = %ld\n"", __func__, *ppos, (long)len);

    if (unlikely(len &gt; PIPE_DEF_BUFFERS))
        return -EINVAL;

    ret = do_rdma_ring_splice_read(in, ppos, pipe, len, flags);
    return ret;
}
</code></pre>

<p>The _splice_to_pipe is just the same one as the splice_to_pipe in kernel. As this function is not an exported symbol, so I re-implemented it.
I think the main cause is that the some kind of lock of pages are omitted, but
I don't know where and how.</p>

<p>My kernel version is 3.10.</p>
"
"<p>I am stuck in a strange problem.</p>

<p>I have two scripts (C program executables) running on ARM linux machine that are mounting the same USB device (containing chinese character filenames) on two different paths, as soon as the device is inserted.</p>

<pre><code>int mount(const char *source, const char *target,
                 const char *filesystemtype, unsigned long mountflags,
                 const void *data);
</code></pre>

<p>In the last parameter,
Script A passes ""utf8"" and Script B passes 0.</p>

<p>So, as soon as I insert the USB device, the scripts race to mount the device. </p>

<p>If Script A mounts first (which passes utf8 parameter), I get proper filenames. This is the <code>mount</code> command output [Notice that even second mount has utf8 as parameter, even if its not passed. Why?]</p>

<pre><code>/dev/sdb1 on /home/root/script1 type vfat (ro,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,utf8,errors=remount-r
o)
/dev/sdb1 on /home/root/script2 type vfat (ro,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed
,utf8,errors=remount-ro)
</code></pre>

<p>But if script B mounts first(which passes 0 as last parameter to mount), I get broken filenames <code>?????.mp3</code> from <code>readdir()</code>. This is the <code>mount</code> command output.            </p>

<pre><code>/dev/sdb1 on /home/root/script2 type vfat (ro,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro)
/dev/sdb1 on /home/root/script1 type vfat (ro,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed
,errors=remount-ro)
</code></pre>

<p><strong>EDIT</strong></p>

<p>This is the basic mount code of both the scripts developed for testing(only difference in last mount argument). Both scripts are executed immediately on reboot using a service.</p>

<pre><code>//mount the device
        ret = mount(""/dev/sda1"", ""/home/root/script1/"", ""vfat"", 1, ""utf8"");
        if (ret == 0) {
                fprintf(stdout,""mount() succeeded.\n"");
                sleep(2000);
        } else {
                ret = mount(""/dev/sdb1"", ""/home/root/script1/"", ""vfat"", 1, ""utf8"");
                if(ret == 0)
                {
                    fprintf(stdout,""mount() succeeded\n"");
                    sleep(2000);
                }
                else
                {
                    fprintf(stdout,""/dev/sdb1 mount() failed: %d, %s\n"", errno, strerror(errno));
                    ret = mount(""/dev/sdc1"", ""/home/root/script1/"", ""vfat"", 1, ""utf8"");
                    if(ret == 0)
                    {
                        fprintf(stdout,""mount() succeeded\n"");
                        sleep(2000);
                    }
                    else
                        fprintf(stdout,""mount() failed: %d, %s\n"", errno, strerror(errno));
                }
        }
</code></pre>
"
"<p>I have recently read the <a href=""http://www.artima.com/cppsource/safebool.html"" rel=""nofollow noreferrer"">safe bool idiom</a> article.  I had seen this technique used a few times, but had never understood quite why it works, or exactly why it was necessary (probably like many, I get the gist of it: simply using <strong>operator bool () const</strong> allowed some implicit type conversion shenanigans, but the details were for me always a bit hazy).</p>

<p>Having read this article, and then looked at a few of its implementations in boost's shared_ptr.hpp, I thought I had a handle on it.  But when I went to implement it for some of the classes that we've borrowed and extended or developed over time to help manage working with Windows APIs, I found that my naive implementation fails to work properly (the source compiles, but the usage generates a compile-time error of no valid conversion found).</p>

<p>Boost's implementations are littered with conditions for various compilers level of support for C++.  From using the naive <strong>operator bool () const</strong>, to using a pointer to member function, to using a pointer to member data.  From what I gather, pointer to member data is the most efficient for compilers to handle IFF they handle it at all.</p>

<p>I'm using MS VS 2008 (MSVC++9).  And below is a couple of implementations I've tried.  Each of them results in <em>Ambiguous user-defined-conversion</em> or <em>no operator found</em>.</p>

<pre><code>template&lt;typename HandlePolicy&gt;
class AutoHandleTemplate
{
public :
    typedef typename HandlePolicy::handle_t handle_t;
    typedef AutoHandleTemplate&lt;HandlePolicy&gt; this_type;
    {details omitted}
    handle_t get() const { return m_handle; }
    operator handle_t () const { return m_handle; }

#if defined(NAIVE)
    // The naive implementation does compile (and run) successfully
    operator bool () const { return m_handle != HandlePolicy::InvalidHandleValue(); }
    bool operator ! () const { return m_handle == HandlePolicy::InvalidHandleValue(); }
#elif defined(FUNC_PTR)
    // handle intrinsic conversion to testable bool using unspecified_bool technique
    typedef handle_t (this_type::*unspecified_bool_type)() const;
    operator unspecified_bool_type() const // never throws
    {
        return m_handle != HandlePolicy::InvalidHandleValue() ? &amp;this_type::get() : NULL;
    }
#elif defined(DATA_PTR)

    typedef handle_t this_type::*unspecified_bool_type;
    operator unspecified_bool_type() const // never throws
    {
        return m_handle != HandlePolicy::InvalidHandleValue() ? &amp;this_type::m_handle : NULL;
    }
#endif
private :
    handle_t m_handle;
{details omitted}
};
</code></pre>

<p>And here's a snippet of code that either works (naive implementation), or errors (either of the unspecified_bool techniques, above):</p>

<pre><code>// hModule is an AutoHandleTemplate&lt;ModuleHandlePolicy&gt;
if (!hModule)
</code></pre>

<p>and:</p>

<pre><code>if (hModule)
</code></pre>

<p>I have already tried enabling the operator! in all cases - but although the first case then works, the second fails to compile (ambiguous).</p>

<p>This class seems to me to be so very like a smart_ptr (or auto_ptr).  It should support implicit conversion to its underlying handle type (HMODULE) in this case, but it should also handle <strong>if (instance)</strong> and <strong>if (!instance)</strong>.  But if I define both the operator handle_t and the unspecified_bool technique, I get errors.</p>

<p>Can someone please explain to me why that is so, and perhaps suggest a better approach?  (or should I be content with the naive approach, at least until C++0x is complete and explicit operators are implemented in my compiler)?</p>

<p>EDIT:</p>

<p>It seems that the answer may well be that if I define an implicit conversion to an integral, that C++ will use that conversion for any if (instance) type expressions.  And that, at least for the above class, the only reason to define any other operators (operator bool) is to explicitly override using the implicit integral conversion to something else (in the above case, forcing it to be a comparison to INVALID_HANDLE_VALUE instead of the implicit NULL).</p>

<p>And using the unspecified_bool technique only really makes sense when you're not providing an integral conversion operator?</p>
"
"<p><strong>Is there a simple, efficient weak/guarded pointer?</strong> I need multiple pointers to the same object that are all automatically set to NULL when the object is deleted. There is one ""master"" pointer that is always used to delete the object, but there can be several other pointers that reference the same object.</p>

<p><strong>Here are some solutions that don't quite match my needs:</strong></p>

<ul>
<li><a href=""https://stackoverflow.com/questions/909437/is-there-a-smart-pointer-that-is-automatically-nulled-when-its-target-is-destroye"">QPointer</a>: I am not developing a QT app; I do not wish to include this libary/derive from QObject.</li>
<li><a href=""http://www.boost.org/doc/libs/1_41_0/libs/smart_ptr/weak_ptr.htm"" rel=""nofollow noreferrer"">boost::weak_ptr</a>: <s>an exception is thrown when accessing a deallocated object. Too expensive for my situation: it should be normal to test a weak pointer; I plan to do some manual clean-up when a weak pointer is no longer valid.</s> <strong>update</strong>:weak_ptr can be tested without throwing exceptions</li>
<li><a href=""http://lukepalmer.wordpress.com/2006/07/11/low-overhead-weak-pointers/"" rel=""nofollow noreferrer"">Low-Overhead Weak Pointers</a>: This is very close to what I am looking for, except I don't like the fact ""This scheme is only guaranteed to work as long as you don?t allocate 2**sizeof(int) times in the same location.""</li>
</ul>

<p><strong>Why I need these weak/guarded pointers:</strong>
I have a game with a list of game objects. Some objects are dependent on others, for example a debug/stats object that is associated with a game entity. The debug/status object displays useful info about the game entity, but it only makes sense while the game entity exists. So if the game entity is deleted, the debug/stats object should realize this and delete itself. (Another idea is a tracking missile: instead of deleting itself, it may search for a new target.)</p>

<p>I wish to keep the debug/stats logic separate from the game entity. The game entity should not have to know a debug/stats object is attached to it. While I'd prefer an answer for weak/guarded pointers, I also welcome different ways to approach my specific task. I am thinking I may have to implement a <a href=""http://www.gamasutra.com/view/feature/4015/managing_data_relationships.php?print=1"" rel=""nofollow noreferrer"">game object manager</a> that tracks object lifetimes and uses handles instead of raw pointers to memory addresses.</p>

<p>I am developing in C++.</p>
"
"<p>I often come accross the problem that I have a class that has a pair of Register/Unregister-kind-of-methods. e.g.:</p>

<pre><code>class Log {
public:
    void AddSink( ostream &amp; Sink );
    void RemoveSink( ostream &amp; Sink );
};
</code></pre>

<p>This applies to several different cases, like the Observer pattern or related stuff. My concern is, how safe is that? From a <a href=""https://stackoverflow.com/questions/1307547/determine-object-identity-from-a-reference-to-a-superclass"">previous question</a> I know, that I cannot safely derive object identity from that reference. <a href=""http://accu.org/index.php/journals/372"" rel=""nofollow noreferrer"">This approach</a> returns an iterator to the caller, that they have to pass to the unregister method, but this exposes implementation details (the iterator type), so I don't like it. I could return an integer handle, but that would require a lot of extra internal managment (what is the smallest free handle?). How do you go about this?</p>
"
"<p>I have a package that compiles and works fine on a 32-bit machine. I am now trying to get it to compile on a 64-bit machine and find the following error-</p>

<pre><code> error: cast from ?void*? to ?int? loses precision
</code></pre>

<p>Is there a compiler flag to suppress these errors? or do I have to manually edit these files to avoid these casts?</p>
"
"<p>Sample eg:</p>

<p>messageStruct.hpp</p>

<pre><code>class MessageStructure_t{

public:

struct MsgData_t {

   float a;
   int i;

}__attribute__((packed))msgdata_m;

};//classs end
</code></pre>

<p>I have a file in my project Application.c. I need to access the structure variables here.
Both are different, one .hpp and the other .c </p>

<p>How can I do this ?</p>

<p>Hoping your kind attention.</p>
"
"<p>I have the need to open a file, read-lock it, then attempt to get a write lock but keep the read lock if it fails.</p>

<p>This works great in POSIX using fcntl locking.</p>

<p>In Windows I can use LockFileEx to get file locks. I can get both read and write locks (shared and exclusive).</p>

<p>However, it seems that in Windows I must take the exclusive write lock <em>first</em> and then add the read lock. This is the opposite order of what I do on POSIX and it causes problems for my abstraction layer. When I do it in that order in POSIX I lose the write lock by taking the read lock because fcntl replaces the existing lock instead of adding locks as Windows does.</p>

<p>I can hack it with #ifdefs to change the locking order at the call sites, but I am looking for good ideas to fix my abstraction code.</p>

<pre><code>// This is the header file
struct LockFileImpl;
class LockFile {
    protected:
    boost::scoped_ptr&lt;LockFileImpl&gt; p;

    public:
    LockFile(const File &amp;);
    virtual ~LockFile();

    void unlock() const;
    void rd_lock() const;
    void wr_lock() const;
    bool rd_try() const;
    bool wr_try() const;
};

class LockFileRead : public LockFile{
    public:
    LockFileRead(const File &amp;f) : LockFile(f)
    { rd_lock(); }
};

class LockFileWrite : public LockFile{
    public:
    LockFileWrite(const File &amp;f) : LockFile(f)
    { wr_lock(); }
};

// This is the Win32 implementation file. There's a different one for POSIX.
struct LockFileImpl
{
    handle_t hFile;
    bool rd_locked;
    bool wr_locked;

    LockFileImpl(handle_t x) : hFile(x), rd_locked(false), wr_locked(false)
    {}
};

LockFile::LockFile(const File &amp;f)
    : p( new LockFileImpl(f.handle()) )
{
}

LockFile::~LockFile()
{
    unlock();
}


void LockFile::unlock() const
{
    if(p-&gt;wr_locked) {
        throw_win32_err_if( UnlockFile(p-&gt;hFile, 0, 0, 1, 0) == 0 );
        p-&gt;wr_locked = false;
    }
    if(p-&gt;rd_locked) {
        throw_win32_err_if( UnlockFile(p-&gt;hFile, 0, 0, 1, 0) == 0 );
        p-&gt;rd_locked = false;
    }
}

void LockFile::rd_lock() const
{
    OVERLAPPED over = {0};
    over.Offset = 0;
    throw_win32_err_if( !LockFileEx(p-&gt;hFile, 0, 0, 1, 0, &amp;over) );
    p-&gt;rd_locked = true;
    if(p-&gt;wr_locked) {
        throw_win32_err_if( UnlockFile(p-&gt;hFile, 0, 0, 1, 0) == 0 );
        p-&gt;wr_locked = false;
    }
}

void LockFile::wr_lock() const
{
    OVERLAPPED over = {0};
    over.Offset = 0;
    throw_win32_err_if( !LockFileEx(p-&gt;hFile, LOCKFILE_EXCLUSIVE_LOCK, 0, 1, 0, &amp;over) );
    p-&gt;wr_locked = true;
}

bool LockFile::rd_try() const
{
    OVERLAPPED over = {0};
    over.Offset = 0;
    bool r = !!LockFileEx(p-&gt;hFile, LOCKFILE_FAIL_IMMEDIATELY, 0, 1, 0, &amp;over);
    if(r) {
        p-&gt;rd_locked = true;
        if(p-&gt;wr_locked) {
            throw_win32_err_if( UnlockFile(p-&gt;hFile, 0, 0, 1, 0) == 0 );
            p-&gt;wr_locked = false;
        }
    }
    return r;
}

bool LockFile::wr_try() const
{
    OVERLAPPED over = {0};
    over.Offset = 0;
    bool r = !!LockFileEx(p-&gt;hFile, LOCKFILE_FAIL_IMMEDIATELY|LOCKFILE_EXCLUSIVE_LOCK, 0, 1, 0, &amp;over);
    if(r) {
        p-&gt;wr_locked = true;
    }
    return r;
}
</code></pre>
"
"<p>gcc 4.4.4 c89</p>

<p>Not sure why I am getting this error.</p>

<p>In my header file I have the following</p>

<p>handle.h</p>

<pre><code>typedef struct Handle_t Handle
</code></pre>

<p>In my implementation file</p>

<p>handle.c</p>

<pre><code>struct Handle {
    size_t id;
    char *name;
};

Handle* create_handle(size_t id)
{
    Handle *hdev = NULL;
    hdev = malloc(sizeof(*hdev)); /* Error */
    .
    .
}
</code></pre>

<p>Many thanks for any suggestions,</p>
"
"<p>Maybe my Google-fu just isn't strong enough.</p>

<p>Using GCC 4.4.3, I've got a set of classes like this:</p>

<pre><code>template &lt;typename storage_t, typename index_t = std::size_t, typename
    leaf_payload_t = std::size_t&gt;
struct btree_node {
    public:
    typedef btree_node&lt;storage_t, index_t, leaf_payload_t&gt; this_t;
    typedef boost::shared_ptr&lt;this_t&gt; handle_t;

    // [...]
};

template &lt;typename storage_t, typename index_t = std::size_t, typename
    leaf_payload_t = std::size_t&gt;
class btree {
    public:
    class caching_storage_t;
    typedef btree_node&lt;caching_storage_t, index_t, leaf_payload_t&gt; node_t;
    typedef typename node_t::handle_t nodehandle_t;

    // [...]

    class caching_storage_t {
        public:
        //typedef typename btree::nodehandle_t nodehandle_t; // Fails -- why?
        typedef typename boost::shared_ptr&lt;node_t&gt; nodehandle_t;

        // [...]
    };
};
</code></pre>

<p>As you can see, I've had to redefine <code>nodehandle_t</code> in <code>caching_storage_t</code>, because if I try it with the commented-out typedef line (which I'd prefer), I get an error ""no type named ?handle_t? in ?struct btree_node&lt;...>?"" -- which is obviously incorrect, and the compiler knows it since the typedef works fine in <code>btree</code>. I've also tried a <code>using typename btree::nodehandle_t;</code>, and every variation I've been able to think of on both, to no avail.</p>

<p>Is this a language/syntax problem (and if so, what is the right syntax), or is it a compiler bug?</p>

<p>(There's a similar question <a href=""https://stackoverflow.com/questions/2285718/how-do-we-typedef-or-redefine-a-templated-nested-class-in-the-subclass"">here</a>, but it doesn't seem to apply because the thing I'm trying to <code>typedef</code> isn't itself a template. Nothing else I've been able to find seems even close.)</p>
"
"<p>Very often malloc() is absolutely not allowed when programming for embedded systems. Most of the time I'm pretty able to deal with this, but one thing irritates me: it keeps me from using so called 'opaque types' to enable data hiding. Normally I'd do something like this:</p>

<pre><code>// In file module.h
typedef struct handle_t handle_t;

handle_t *create_handle();
void operation_on_handle(handle_t *handle, int an_argument);
void another_operation_on_handle(handle_t *handle, char etcetera);
void close_handle(handle_t *handle);


// In file module.c
struct handle_t {
    int foo;
    void *something;
    int another_implementation_detail;
};

handle_t *create_handle() {
    handle_t *handle = malloc(sizeof(struct handle_t));
    // other initialization
    return handle;
}
</code></pre>

<p>There you go: create_handle() performs a malloc() to create an 'instance'. A construction often used to prevent having to malloc() is to change the prototype of create_handle() like this:</p>

<pre><code>void create_handle(handle_t *handle);
</code></pre>

<p>And then the caller could create the handle this way:</p>

<pre><code>// In file caller.c
void i_am_the_caller() {
    handle_t a_handle;    // Allocate a handle on the stack instead of malloc()
    create_handle(&amp;a_handle);
    // ... a_handle is ready to go!
}
</code></pre>

<p>But unfortunately this code is obviously invalid, the size of handle_t isn't known!</p>

<p>I never really found a solution to solve this in a proper way. I'd very like to know if anyone has a proper way of doing this, or maybe a complete different approach to enable data hiding in C (not using static globals in the module.c of course, one must be able to create multiple instances).</p>
"
"<p>I was looking at the source code for the implementation of journaling in ext3 and I came across the types <code>handle_t</code>, <code>transaction_t</code> and <code>journal_t</code>.</p>

<p><code>handle_t</code> represents a single atomic update being performed by a process. <code>transaction_t</code> represents a compound set of atomic updates and <code>journal_t</code> maintains all journaling information for a single filesystem.</p>

<p>I have the following doubts:-</p>

<ol>
<li>How are a set of disk interactions grouped into various transactions?</li>
<li>An example of a handle and a transaction, please.</li>
</ol>
"
"<p>I'm getting to grips with RPC in Windows and I've got a basic client/server model setup and working and I can pass a string over between the 2 OK but I now need to extend it to pass a binary structure between the 2 and I can't figure out how to. Obviously trying to pass a void* will not work as the MIDL compiler would have no idea of the structure size but I'm hoping there's a way to define a structure in IDL to make this work. My current IDL looks like this:</p>

<pre><code>[uuid(""1D51414D-150C-4F4C-8742-0C08AFBE409E""), version(1.0)]
interface RpcVendor
{
    void SendMessage([in] handle_t hBinding, [in, string] char *message);
}
</code></pre>

<p>And my structure looks like this:</p>

<pre><code>struct {
    char *title;
    char *message;
    int type;
}
</code></pre>

<p>Is there any way to define that in IDL and pass it across?</p>

<p>Thanks,
J</p>
"
"<p>I'm trying to make an RPC call which requests 2 numbers and a string from the RPC server, the IDL looks like this:</p>

<pre><code>void GetCurrentStatus([in] handle_t hBinding, [out, ref] DWORD *dwRef1, [out, ref] DWORD *dwRef2, UINT *nLength, [out, size_is(, *nLength)] LPWSTR *pszName);
</code></pre>

<p>In the server-side call I do this:</p>

<pre><code>// name = std::wstring
*pszName = (wchar_t*)midl_user_allocate(name.length()+1 * sizeof(wchar_t));
_tcscpy(*pszName, name.c_str());
*nLength = name.length();
</code></pre>

<p>But any attempt to call from the client-side results in nothing returned the error <code>The array bounds are invalid.</code></p>

<p>What is the correct way to return a string from an RPC call?</p>

<p>Thanks,
J</p>
"
"<p>When a program needs to communicate using Microsoft RPC developers typically write a IDL definition for all methods, for example:</p>

<pre><code>error_status_t rpcMyInterfaceGetFile( [in] const GUID fileId, [out] BYTE_PIPE filePipe );
</code></pre>

<p>which is compiled by MIDL compiler and produces a wrapper function:</p>

<pre><code>/* [fault_status][comm_status] */ error_status_t rpcMyInterfacerGetFile(
/* [in] */ handle_t IDL_handle,
/* [in] */ const GUID fileId,
/* [out] */ BYTE_PIPE filePipe)
{
    CLIENT_CALL_RETURN _RetVal;
    _RetVal = NdrClientCall2(
              ( PMIDL_STUB_DESC  )&amp;IMyInterfaceRpc_StubDesc,
              (PFORMAT_STRING) &amp;MyInterfaceRpc__MIDL_ProcFormatString.Format[SomeNumberHere],
              ( unsigned char * )&amp;IDL_handle);
    return ( error_status_t  )_RetVal.Simple;
}
</code></pre>

<p>Here the call is forwarded to <a href=""http://msdn.microsoft.com/en-us/library/aa374215%28v=vs.85%29.aspx"" rel=""nofollow""><code>NdrClientCall2()</code> RPC runtime function</a> that is declared to have <code>...</code> as the third parameter and does actual job. <code>MyInterfaceRpc__MIDL_ProcFormatString</code> is just a sequence of hardcoded bytes generated by MIDL, so the second parameter is a start of a subsection in that array declared in the same .c file as the wrapper function and having static storage duration.</p>

<p>How do the parameters (<code>fileId</code> and <code>filePipe</code>) get passed into <code>NdrClientCall2()</code>? I don't see them being passed. How do they happen to get from the wrapper to <code>NdrClientCall2()</code>?</p>
"
"<p>I am trying to determine if an element exists in a boost::heap::binomial_heap because I need  to know if I should call update() (if the node already exists) or push() (if the node does not exist). Some queues provide a push_or_update() function for exactly this purpose. The only thing I could figure out to do is keep a property map with the same index type as the nodes in the queue and value_type 'handle_t'. Then I can lookup in the map if the item has a valid handle so that I can push if it does not, or update if it does. </p>

<p>Is there a better way to do this?</p>

<p><a href=""http://www.boost.org/doc/libs/1_51_0/doc/html/boost/heap/binomial_heap.html"" rel=""nofollow"">Here is the doc for reference</a>.</p>
"
"<pre><code>        class TestGet : public ::testing::Test
        {
        protected:
            TestGet()
                : _txHandle(11)
            {
                _interface.get = mockGet;
            }

            Interface_T _interface;
            Handle_T _txHandle;
            DB _db;
        };
</code></pre>

<p>If I change <code>DB</code> so that it only has the following constructor:</p>

<pre><code>        explicit DB(Interface_T&amp; _interface):
            _interface(interface)
        {
        }
</code></pre>

<p>Do I now need to declare <code>_db</code> using a <code>std::shared_ptr</code> in my <code>TestGet</code> class, initialising it with <code>_interface</code> in the constructor?</p>

<p>UPDATE:</p>

<p>The issue was that I had:</p>

<pre><code>    private:
        Interface_T _interface;
</code></pre>

<p>in the DB class instead of a reference.</p>
"
"<p>Code that was built using VS 2003 for generating 32 bit binary was built without a single warning.</p>

<p>Same code , without a single code change, Compile and Link is successful using Visual studio 2010 compiler for generating 64 bit binary BUT with below list of warnings.</p>

<p>So, My question is,
Is any warning in the below list a concern at runtime ?</p>

<pre><code>pcd.c(248) : warning C4996: 'getenv': This function or variable may be unsafe. Consider using _dupenv_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.

pcd.c(377) : warning C4244: '=' : conversion from 'uintptr_t' to 'ULONG', possible loss of data

pcd.c(236) : warning C4100: 'argv' : unreferenced formal parameter


i.c(183) : warning C4100: 'lpReserved' : unreferenced formal parameter

api.c(506) : warning C4996: 'stricmp': The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _stricmp. See online help for details.

api.c(554) : warning C4310: cast truncates constant value

api.c(719) : warning C4996: 'strcpy': This function or variable may be unsafe. Consider using strcpy_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.

api.c(2217) : warning C4996: 'sprintf': This function or variable may be unsafe. Consider using sprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.

api.c(2892) : warning C4312: 'type cast' : conversion from 'ULONG_T' to 'HANDLE_T' of greater size

api.c(559) : warning C4702: unreachable code


stdio.h(234) : see declaration of 'fopen'


api.c(2217) : warning C4996: 'sprintf': This function or variable may be unsafe. Consider using sprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.

prm.c(681) : warning C4996: 'fopen': This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
        C:\Program Files (x86)\Microsoft Visual Studio 10.0\VC\INCLUDE\stdio.h(234) : see declaration of 'fopen'


host.c(410) : warning C4311: 'type cast' : pointer truncation from 'PVOID_T' to 'unsigned long'


stub.c(138) : warning C4295: 'eye' : array is too small to include a terminating null character


isv.c(372) : warning C4310: cast truncates constant value


chp.c(250) : warning C4244: '=' : conversion from 'SOCKET' to 'ULONG_T', possible loss of data

api.c(665) : warning C4311: 'type cast' : pointer truncation from 'HANDLE_T' to 'LONG'

api.c(1216) : warning C4057: 'function' : 'LPDWORD' differs in indirection to slightly different base types from 'LONG_T *'

hlp.c(1171) : warning C4057: 'function' : 'LPDWORD' differs in indirection to slightly different base types from 'LONG_T *'


neto.c(435) : warning C4057: 'function' : 'PLONG_T' differs in indirection to slightly different base types from 'ULONG_T *'


neto.c(595) : warning C4152: nonstandard extension, function/data pointer conversion in expression

neto.c(2115) : warning C4213: nonstandard extension used : cast on l-value

neto.c(2209) : warning C4057: 'function' : 'int *' differs in indirection to slightly different base types from 'LONG *'

td.c(760) : warning C4244: '=' : conversion from 'uintptr_t' to 'int', possible loss of data

td.c(2104) : warning C4054: 'type cast' : from function pointer 'FARPROC' to data pointer 'PVOID'

msc.c(287) : warning C4133: 'function' : incompatible types - from 'long *' to 'time_t *'


msc.c(1009) : warning C4702: unreachable code


inf.c(400) : warning C4057: 'function' : 'PLONG_T' differs in indirection to slightly different base types from 'ULONG *'

arb.c(166) : warning C4267: '=' : conversion from 'size_t' to 'LONG_T', possible loss of data

arb.c(226) : warning C4244: '=' : conversion from 'int' to 'CHAR_T', possible loss of data

sl.c(441) : warning C4054: 'type cast' : from function pointer 'int (__cdecl *)(unsigned char *,int,int,void *)' to data pointer 'void *'


pco.c(369) : warning C4057: 'function' : 'PLONG_T' differs in indirection to slightly different base types from 'ULONG_T *'

exit1.c(157) : warning C4295: 'publickey' : array is too small to include a terminating null


env.c(341) : warning C4267: 'function' : conversion from 'size_t' to 'DWORD', possible loss of data

hook.c(221) : warning C4245: 'return' : conversion from 'int' to 'SOCKET', signed/unsigned mismatch

hook.c(817) : warning C4311: 'type cast' : pointer truncation from 'unsigned char *' to 'int'

tor.c(128) : warning C4244: 'function' : conversion from 'time_t' to 'unsigned int', possible loss of data


cth.c(1012) : warning C4244: '=' : conversion from '__int64' to 'int', possible loss of data


cntrl.c(427) : warning C4996: 'strnicmp': The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: _strnicmp. See online help for details.


api.c(263) : warning C4057: 'function' : 'int *' differs in indirection to slightly different base types from 'LONG_T *'

api.c(706) : warning C4057: 'function' : 'int *' differs in indirection to slightly different base types from 'DWORD *'

ii.c(252) : warning C4244: '=' : conversion from 'time_t' to 'long', possible loss of data
</code></pre>

<p>Thx</p>
"
"<p>In ext3 file system, if it is on journal mode, would indirect block, double indirect block and triple indirect block be considered as metadata blocks and get journaled?</p>
"
"<p>New (bad) C++ programmer here (so please don't mind all the non-essentially errors / simplifications for readability):</p>

<p>I'm having consistent problems while using Boost::heap handles. I generally either seg fault or get into a state that doesn't make sense (which eventually causes a seg fault).  Essentially what I have is a vector of maps. I map integers (indices) to handles of EdgeStructs. I first populate the heap with EdgeStructs. The heap is keyed on EdgeStruct.value.</p>

<pre><code>typedef boost::heap::binomial_heap&lt;EdgeStruct*&gt;::handle_type handle_t;
std::vector&lt;std::map&lt;int,handle_t&gt; &gt; indexToIndex;
boost::heap::binomial_heap&lt;EdgeStruct*&gt; heap;

void class::populateStructures(void) {
  while (populating data structures) {
    ...
    EdgeStruct* q = new EdgeStruct;
    q-&gt;value = -error;
    q-&gt;index1 = index1;
    q-&gt;index2 = index2;
    q-&gt;alive = true;
    handle_t handyq = heap.push(q);
    indexToIndex[index1][index2] = handyq;
    indexToIndex[index2][index1] = handyq;
  }
}
</code></pre>

<p>I then iterate over the heap, popping structs as I go along.</p>

<pre><code>void class::iterateOverHeap(void) {
  populateStructures();
  while (!heap.empty()) {
    this-&gt;bestEdgeStruct = heap.top();
    if (this-&gt;bestEdgeStruct-&gt;alive)
      destroyIndices(this-&gt;bestEdgeStruct-&gt;index1, this-&gt;bestEdgeStruct-&gt;index2);
    heap.pop();
  }
}
</code></pre>

<p>In destroyIndices(), I update the values of these structs in the heap in some other function:</p>

<pre><code>void class::someOtherFunction(void) {
  map&lt;int,handle_t&gt;::iterator iter;
  ...
    for (iterating using iter) {
      (*(iter-&gt;second))-&gt;value = error;
      heap.update(iter-&gt;second);
    }
}
</code></pre>

<p>I also add new structs to the heap and new handles to these structs in both old and new maps in indexToIndex at certain points. No real problems yet. But I also want to erase some of structs that become invalid entirely from the heap during destroyIndices(). What I do is find certain structs by iterating over certain indexToIndex maps, deleting their handles from these maps, and then setting the struct pointed to by the handle to dead so that destroyIndices() in iterateOverHeap() is not called on it, and it is instead popped and forgotten. I also call this function in destroyIndices():</p>

<pre><code>void class::killStructInMapsAndHeap(int index, int otherIndex) {
  map&lt;int,handle_t&gt;::iterator it;
  map&lt;int,handle_t&gt;::iterator otherIt;

  it = indexToIndex[index].begin();
  while (it != indexToIndex[index].end()) {
    otherIt = indexToIndex[it-&gt;first].find(index);
    handle_t handle = it-&gt;second;

    if (*handle != bestEdgeStruct) {
      cout &lt;&lt; ""Seg faults can happen here\n"";
      (*handle)-&gt;alive = false;
      cout &lt;&lt; ""Or here\n"";
      heap.update(handle);
    }

    if (otherIt != indexToIndex[it-&gt;first].end()) {
        indexToIndex[it-&gt;first].erase(otherIt);
    } else {
        cout &lt;&lt; ""Problem!""
    }

    indexToIndex[index].erase(it++);
  }
}
</code></pre>

<p>I pretty much seg fault at the lines after the couts every time. I've tried other things (like erasing the handle directly instead of waiting to pop it from the heap), but those had the same issue.</p>

<p><a href=""http://www.boost.org/doc/libs/1_53_0/doc/html/heap/concepts.html#heap.concepts.mutability"" rel=""nofollow"">Based on the documentation here</a>, it seems that there should be no problem storing the handles in a vector and then iterating over them and updating the corresponding structs, even if I have updated or added other structs to the heap. But after a (somewhat) random number of loops in iterateOverHeap(), either accessing the struct pointed to by the handle or updating that handle in the heap causes a seg fault. </p>

<p>Does this mean I can't store handles in a vector, because after a while they become invalid? Or is there some bug that, even after rewriting some of these functions in different ways, causes my handles to become invalid? Or maybe when I run populateStructures(), I don't obtain the EdgeStruct handle correctly?</p>

<p>One way I ""solved"" this is by never updating the heap and instead clearing it and repopulating it every time I make a change to my data structures. But this is can become enormously slow as the size of my data increases (100,000+ elements), so it is impractical. Thanks for your help (and let me know how I can make this question better)!</p>
"
"<p>I'm looking for a good data structure that can <em>maintain</em> its elements sorted. Currently I'm trying <a href=""http://www.boost.org/doc/libs/1_53_0/doc/html/heap.html"" rel=""nofollow"">Boost.Heap</a>.</p>

<p>I frequently need to orderly traverse the data structure and when reaching an element based on some property, update its priority. Boost.Heap priority queues provide ordered and non-ordered iterators. Element updates occurs through a node handle, a handle can be obtained from a ordinary non-ordered iterator, but not directly from a ordered one as in the following example:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;boost/heap/fibonacci_heap.hpp&gt;

using namespace boost::heap;

int main()
{
    fibonacci_heap&lt;int&gt; fib_heap;

    fib_heap.push(1);
    fib_heap.push(2);
    fib_heap.push(3);

    for(auto i = fib_heap.ordered_begin(); i != fib_heap.ordered_end(); ++i)
    {
        // no viable conversion here
        auto h = fibonacci_heap&lt;int&gt;::s_handle_from_iterator(i);

        if(*h == 2) // dumb test
        {
            fib_heap.increase(h, *h + 2);
            break;
        }
    }

    std::for_each(fib_heap.ordered_begin(), fib_heap.ordered_end(),
    [](const int &amp;e)
    {
        std::cout &lt;&lt; e &lt;&lt; std::endl;
    });
}
</code></pre>

<p>How can I orderly traverse the queue and update an element in the traversal?</p>

<p>Note that I leave traversal after the update.</p>

<p>(Suggestions of alternative libraries for such purpose are welcome)</p>
"
"<p>I am basically trying to figure out, is the whole ""move semantics"" concept something brand new, or it is just making existing code simpler to implement? I am always interested in reducing the number of times I call copy/constructors but I usually pass objects through using  reference (and possibly const) and ensure I always use initialiser lists. With this in mind (and having looked at the whole ugly &amp;&amp; syntax) I wonder if it is worth adopting these principles or simply coding as I already do? Is anything new being done here, or is it just ""easier"" syntactic sugar for what I already do?</p>
"
"<p>Is it legal to forward-declare a <code>struct</code> as a C-<code>struct</code></p>

<pre><code>// api.h
#ifdef __cplusplus
extern ""C"" {
#endif

    typedef struct handle_tag handle_t;

    handle_t *construct();
    void destruct(handle_t *h);

    void func(handle_t *h);

#ifdef __cplusplus
}
#endif
</code></pre>

<p>and subsequently define it as a C++-<code>struct</code>, i.e. as a non-POD type?</p>

<pre><code>// api.cpp
struct handle_tag {
    void func();
    std::string member;
};

void func(handle_t *h) {
    h-&gt;func();
}
</code></pre>

<p>The general intention is to get via a C interface an externally accessible opaque type <code>handle_t</code> which is internally implemented as an C++ data type.</p>
"
"<p>I have shared memory block created in another module.<br>
This wasn't created via boost (that module is written in C). </p>

<p>Can i somehow envelop that shared memory block with a <code>boost::interprocess::managed_shared_memory</code> ?  </p>

<p>I'd really like to reduce handling complexity by wrapping it up neatly with a <code>managed_shared_memory</code> object.</p>

<p>Or, if this can't be done, can i at least access it nicely with a <code>managed_shared_memory::handle_t</code> handle ? or <code>boost::interprocess::offset_ptr</code> ?</p>
"
"<p>I have some small classes including references to external ressources. As they are small but heavily passed around and often stack allocated, I do not pass pointers but the instances itself. So usually the copy-constructor, and sometimes assignment is used. </p>

<p>This however results in unbalanced ressource management, where external ressources gets freed as soon the first instance leaves some scope, while there are still copies around. </p>

<p>For pointers, there are smart but often pricy things like <code>std::shared_ptr</code>. </p>

<p>However, how to handle the instance-passing situation? It seems it's almost impossible to know by one instance if it is the last of its kind getting destructed?</p>
"
"<p>I'm trying to use the Boost d_ary_heap but I cannot figure out how to get the handle for a pushed element. In my case, I will need to update the value in a later iteration, so I need that handle. I was able to do it with the Fibonacci heap but in this case it looks much more complex.</p>

<p>This is what I have so far:</p>

<pre><code>struct compare_cells_d_ary {
inline bool operator()
(const myType * c1 , const myType * c2) const {

    return c1-&gt;getValue() &gt; c2-&gt;getValue(); // I want a min heap.
}
};


class MyHeap {

typedef typename boost::heap::d_ary_heap&lt;const myType *, boost::heap::mutable_&lt;true&gt;, boost::heap::arity&lt;2&gt;, boost::heap::compare&lt;compare_cells_d_ary&gt;&gt;::handle_type handle_t;

protected:
    boost::heap::d_ary_heap&lt;const myType *, boost::heap::arity&lt;2&gt;, boost::heap::mutable_&lt;true&gt;, boost::heap::compare&lt;compare_cells_d_ary&gt;&gt; heap_;
    std::vector&lt;handle_t&gt; handles_; // I store the handles in an specific order.

public:
 /****/
    void push (const myType * c) {
        handles_[c-&gt;getIndex()] = heap_.push(c);
    }

 /****/
};
</code></pre>

<p>The push function is how I use it in the Fibonacci heap, which returns a handle_type. But in this case I cannot understand what it is supposed to return (<a href=""http://www.boost.org/doc/libs/1_55_0/doc/html/boost/heap/d_ary_heap.html#idp52218904-bb"" rel=""nofollow"">http://www.boost.org/doc/libs/1_55_0/doc/html/boost/heap/d_ary_heap.html#idp52218904-bb</a>)</p>

<p>Any help in how to get the handle when pushing is welcome! Thanks.</p>
"
"<p>In the embedded application I'm working on we have a serial port abstraction, and I'm currently working on a simulated variant of said abstraction to use when you are not running on the 'real' hardware. I'm using FIFO files for this, as you can then plug in whathever software you want to communicate with the actual application but I'm having trouble with the ""read"" function, which flags that you gave it an invalid fd. Though I have used debugging tools to verify that the fd passed to it is the same as has been opened earlier so it should be valid. I cannot find any cause for this problem.</p>

<p>FIFO files are opened through this function:</p>

<pre><code>int createOpenFifo(const std::string&amp; path, int flags)
{
   int fd = open(path.c_str(), flags);
   if (fd &lt; 0)
   {
      mkfifo(path.c_str(), 0777);
      fd = open(path.c_str(), flags);
      if (fd &lt; 0)
      {
         return -1;
      }
   }
   return fd;
}
</code></pre>

<p>And the FIFOs are then written to using the following function:</p>

<pre><code>int write_serial(handle_t handle, size_t length, const uint8_t* pData)
{
    SerialFifoData* data = static_cast&lt;SerialFifoData*&gt;(handle);

    size_t written = 0;
    while (written &lt; length)
    {
        int result = write(data-&gt;writeFd, pData + written, length - written);
        if (result &lt; 0)
        {
           return -1;
        }
        written += result;
    }

    return 0;
}
</code></pre>

<p>And finally read from using this function:</p>

<pre><code>int read_serial(handle_t handle, size_t buffer_size, uint8_t* pBuffer, size_t* bytes_read)
{
    SerialFifoData* data = static_cast&lt;SerialFifoData*&gt;(handle);

    int return_val = read(data-&gt;readFd, pBuffer, buffer_size);

    if (return_val &lt; 0)
    {
        if (errno == EAGAIN || errno == EWOULDBLOCK) // Non-blocking, no data
                                                     // which flag is raised
                                                     // varies between POSIX
                                                     // implementations
        {
            *bytes_read = 0;
            return -2;
        }
        return -1;
    }

    *bytes_read = return_val;
    return 0;
}
</code></pre>

<p>I have verified that each function recieves correct input, and the read and write calls are nearly identical to those used for the actual serial port code (the only difference is how the FD is extracted from the handle) where they work just fine.</p>
"
"<p>I want to use a custom class as the type for a boost::heap::fibonacci_heap and also be able to iterate and modify the elements of the heap. I'm experimenting with the code provided by <a href=""https://stackoverflow.com/questions/15102406/how-to-orderly-traverse-a-boost-heap-priority-queue-and-update-a-given-element/15104309#15104309"">How to orderly traverse a Boost.Heap Priority Queue and update a given element?</a> . </p>

<p>I've come up with a working example, but my Visual Studio 2010 compilier warns me that my class EdgeHeap has multiple copy constructors ( <a href=""http://msdn.microsoft.com/en-us/library/e02fwk4s.aspx"" rel=""nofollow noreferrer"">warning documentation</a> ). </p>

<p>Here's the warning (roughly):</p>

<pre><code>filepath\boost\heap\fibonacci_heap.hpp(762): warning C4521: 'boost::heap::fibonacci_heap&lt;T&gt;': Multiple constructors
          with
          [
              T=EdgeHeap
          ]
</code></pre>

<p>I'm confused because I haven't declared any copy constructors, so the only ones should be those automatically added by the compiler. Where are the multiple constructors coming from? Also is this something that I should worry about?</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;boost/heap/fibonacci_heap.hpp&gt;

class Edge
{
    public:
        int index;
        double weight;
        std::pair&lt;int, int&gt; vertices;

        Edge(int i, double w, int start, int end)
        {
            index = i;
            weight = w;
            vertices.first = start;
            vertices.second = end;
        }
};

class EdgeHeap
{
    typedef boost::heap::fibonacci_heap&lt;EdgeHeap&gt;::handle_type handle_t;

    public:
        handle_t handle;
        Edge data;

        EdgeHeap(const Edge &amp;data_) : data(data_) {}

        bool operator&lt;(EdgeHeap const &amp; rhs) const
        {
            return data.weight &lt; rhs.data.weight;
        }
};

void setup_handle(boost::heap::fibonacci_heap&lt;EdgeHeap&gt;::handle_type &amp;&amp;handle)
{
    (*handle).handle = handle;
}

int main()
{
    boost::heap::fibonacci_heap&lt;EdgeHeap&gt; heap;

    Edge e(0, 10, 0, 1);
    setup_handle(heap.push(e));
    Edge e1(1, 2, 1, 2);
    setup_handle(heap.push(e1));
    Edge e2(2, 80, 2, 0);
    setup_handle(heap.push(e2));

    std::find_if(heap.ordered_begin(), heap.ordered_end(),
    [&amp;heap](const EdgeHeap &amp;e) -&gt; bool
    {
        if(e.data.index == 2)
        {
            const_cast&lt;EdgeHeap &amp;&gt;(e).data.weight += 2;
            heap.increase(e.handle);
            return true;
        }
        return false;
    });

    std::for_each(heap.ordered_begin(), heap.ordered_end(),
    [](const EdgeHeap &amp;e)
    {
        std::cout &lt;&lt; e.data.weight &lt;&lt; std::endl;
    });
}
</code></pre>
"
"<p>Suppose there's API like below:</p>

<pre><code>typedef void callback_t(void* data);

void addCallback(handle_t h, callback_t callback, void* data);
</code></pre>

<p>I'd like to wrap this API to a higher order C++ interface:</p>

<pre><code>template&lt;class F, bool emplace = IsEmplaceable&lt;F&gt;::value&gt;
struct MakeCallback;

class Handle
{
    template&lt;class F&gt;
    void addCallback(F f)
    {
        ::addCallback(_h, MakeCallback&lt;F&gt;::f, MakeCallback&lt;F&gt;::create(f));
    }

    handle_t _h;
};
</code></pre>

<p>so that the user can pass any callable object (e.g. lambda function).</p>

<p>I'd like to apply small object optimization to avoid dynamic alloc (e.g. for empty lambdas), the trait <code>IsEmplaceable&lt;F&gt;</code> decides whether <code>F</code> can be emplaced in a <code>void*</code>.</p>

<p>For <code>F</code> that is not emplaceable, <code>MakeCallback</code> can be implemented like below:</p>

<pre><code>template&lt;class F&gt;
struct MakeCallback&lt;F, false&gt;
{
    static void f(void* data)
    {
        auto f = static_cast&lt;F*&gt;(data);
        (*f)(status);
        delete f;
    }

    static void* create(F&amp; f)
    {
        return new F(std::move(f));
    }
};
</code></pre>

<p>For <code>F</code> that is emplaceable, how could I properly implement the following?</p>

<pre><code>template&lt;class F&gt;
struct MakeCallback&lt;F, true&gt;
{
    static void f(void* data)
    {
        // from void* to F
    }

    static void* create(F&amp; f)
    {
        // form F to void*
    }
};
</code></pre>

<p>More basically, can a <code>void*</code> hold a non-address value if we don't use it as a pointer? will it be UB?</p>
"
"<p>I am implementing a Fast Marching algorithm using the boost::fibonacci_heap library, and I was getting started with manipulating elements using their handles.</p>

<p>I have written the basic code below, it compiles well but I do not understand its behaviour:</p>

<p>I first store the handles of each pushed element in an array. Then I pop out the first element from the heap, and I check that the heap size has decreased.</p>

<p>But then I attempt to update the value of the element that was popped out, using its handle. This operation works (surprisingly ?), and the updated element is now at the top of the heap. But the heap size remains the same, since I haven't properly pushed a new element in.</p>

<p>So what happens when a popped out element is updated and back in the heap ? Is the heap still valid ?</p>

<pre class=""lang-cpp prettyprint-override""><code># include &lt;boost/heap/fibonacci_heap.hpp&gt;
# include &lt;iostream&gt;

using namespace std;
using namespace boost::heap;

struct node
{
  int index;
  double time;

  node(const int&amp; i, double t) : index(i), time(t) {}
};

struct compare_node
{
  bool operator()(const node&amp; n1, const node&amp; n2) const
  {
    return (n1.time &gt; n2.time);
  }
};

int main()
{
  fibonacci_heap&lt; node, compare&lt;compare_node&gt; &gt; heap;
  typedef fibonacci_heap&lt; node, compare&lt;compare_node&gt;  &gt;::handle_type handle_t;
  handle_t tab_handle[10];
  int n;
  double tt[10];

  // assign a set of arbitrary numbers to initialise array tt:
  tt[0] = 5.3;
  tt[1] = 0.25;
  tt[2] = 3.6;
  tt[3] = 1.75;
  tt[4] = 9.1;
  tt[5] = 2.54;
  tt[6] = 3.8;
  tt[7] = 6.1;
  tt[8] = 1.23;
  tt[9] = 7.32;

  // push the values of tt into the heap, and keep track of the handle of each element in the heap:
    for (n=0; n&lt;10; n++)
      {
        tab_handle[n] = heap.push(node(n, tt[n]));
      }


    // display first element in heap
    cout &lt;&lt; ""first element in heap is :"" &lt;&lt; heap.top().index &lt;&lt; "" "" &lt;&lt; heap.top().time &lt;&lt; ""\n"";

    // check size of the heap
    cout &lt;&lt; ""size of heap is :"" &lt;&lt; heap.size() &lt;&lt; ""\n"";

    // remove top element
    heap.pop();

    // check size of the heap
    cout &lt;&lt; ""size of heap after pop is :"" &lt;&lt; heap.size() &lt;&lt; ""\n"";

    // display first element in heap
    cout &lt;&lt; ""first element in heap is now :"" &lt;&lt; heap.top().index &lt;&lt; "" "" &lt;&lt; heap.top().time &lt;&lt; ""\n"";

    // access value of a given element by index:
    cout &lt;&lt; ""element index 2 has time :"" &lt;&lt; (*tab_handle[2]).time &lt;&lt; ""\n"";

    // attempt to access the element with handle tab_handle[1]: this element was actually popped out of the heap previously. But I can access it:
    cout &lt;&lt; ""element index 1 has time :"" &lt;&lt; (*tab_handle[1]).time &lt;&lt; ""\n"";

    // update the time of an element using its handle. This is quite standard.
    heap.update(tab_handle[2],node(2, tt[2]/10));

    // but now I can also update the element that was popped out of the heap:
    heap.update(tab_handle[1],node(1, tt[1]/10));

    // display first element in heap
    cout &lt;&lt; ""first element in heap is now :"" &lt;&lt; heap.top().index &lt;&lt; "" "" &lt;&lt; heap.top().time &lt;&lt; ""\n"";

    // check size of the heap
    cout &lt;&lt; ""size of heap after pop is :"" &lt;&lt; heap.size() &lt;&lt; ""\n"";

    return 0;

}
</code></pre>

<p>the terminal outputs:</p>

<pre><code>first element in heap is :1 0.25
size of heap is :10
size of heap after pop is :9
first element in heap is now :8 1.23
element index 2 has time :3.6
element index 1 has time :0.25
first element in heap is now :1 0.025
size of heap after pop is :9
</code></pre>
"
"<p><a href=""https://i.stack.imgur.com/8G2SU.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/8G2SU.jpg"" alt=""No Bridge""></a>
<br>
<br>
As you can see I have an interface for Debug Events and two operations Attach and Detach. On top of this I have to implement a Windows and Linux version so the current design does not scale at all.</p>

<p>Imagine that I have to add:</p>

<ul>
<li>DebugEventThread &lt;- DebugEventThreadAttach &lt;- DebugEventThreadDetach</li>
<li>DebugEventProcess &lt;- DebugEventProcessAttach &lt;- DebugEventProcessDetach</li>
</ul>

<p>This design blows out of proportions...</p>

<p>I know Bridge pattern would be a solution to this problem but how would it be applied in this case?</p>

<p><strong>Update:</strong>
As a first fix I'm thinking of adding a member Operation (Attach/Detach) to DebugEventModule. This way no more subclass is needed for different type of attach/detach operations:
<br>
<br>
<strong>1.</strong>
<br>
<a href=""https://i.stack.imgur.com/CXY7d.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/CXY7d.jpg"" alt=""Bridge""></a>
<br>
The bridge between DebugEventModule -> DebugEventModuleImpl seems useless to me at this point, can you see any benefit of having a bridge here? Without a bridge I would have:
<br>
<br>
<strong>2.</strong>
<br>
<a href=""https://i.stack.imgur.com/9rhTq.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/9rhTq.jpg"" alt=""Inheritance""></a>
<br>
What about moving platform specific stuff (OS stuff) out of the way with a Bridge? Something like this:
<br>
<br>
<strong>3.</strong>
<br>
<a href=""https://i.stack.imgur.com/G0Uvb.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/G0Uvb.jpg"" alt=""Platform abstraction""></a>
<br>
I'm thinking that in this last design the platform_specific() functions would be Module, Thread, Process specific and this goes against the ""One Responsibility Principal"", I wouldn't want this class to become a ""mammoth"", to become a combination of unrelated functions.</p>

<p><strong>Update 2:</strong>
Current implementation for DebugEvent + DebugEventModule:</p>

<pre><code>    class DebugEvent {
    public:
      DebugEvent(uint32_t processId,
                 uint32_t threadId);
      virtual ~DebugEvent();
      virtual void Process() = 0;
    private:
      uint32_t _processId;
      uint32_t _threadId;
    };

    class DebugEventModule : public DebugEvent {
    public:
      DebugEventModule (uint32_t processId,
                        uint32_t threadId,
                        handle_t fileHandle,
                        hmodule_t baseOfDll,
                        address_t imageName,
                        uint16_t isUnicode);
      virtual ~DebugEventModule();
      virtual void Process();
    private:
      handle_t _fileHandle;
      hmodule_t _baseOfDll;
      address_t _imageName;
      uint16_t _isUnicode;
    };

    class DebugEventModuleAttach : public DebugEventModule {};
    class DebugEventModuleDetach : public DebugEventModule {};

    class DebugEventModuleAttachWindows : public DebugEventModuleAttach {};
    class DebugEventModuleAttachLinux : public DebugEventModuleAttach {};

    class DebugEventModuleDetachWindows : public DebugEventModuleDetach {};
    class DebugEventModuleDetachLinux : public DebugEventModuleDetach {};
</code></pre>

<p><br>
The idea is to make a platform independent version of Windows DEBUG_EVENT:
<a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/ms679308%28v=vs.85%29.aspx"" rel=""nofollow noreferrer"">https://msdn.microsoft.com/en-us/library/windows/desktop/ms679308%28v=vs.85%29.aspx</a></p>

<p>Windows DEBUG_EVENT looks like this:</p>

<pre><code>    typedef struct _DEBUG_EVENT {
      DWORD dwDebugEventCode;
      DWORD dwProcessId;
      DWORD dwThreadId;
      union {
        EXCEPTION_DEBUG_INFO      Exception;
        CREATE_THREAD_DEBUG_INFO  CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO    ExitThread;
        EXIT_PROCESS_DEBUG_INFO   ExitProcess;
        LOAD_DLL_DEBUG_INFO       LoadDll; // - This was DebugEventModuleAttach in the original design
        UNLOAD_DLL_DEBUG_INFO     UnloadDll; // - This was DebugEventModuleDetach in the original design
        OUTPUT_DEBUG_STRING_INFO  DebugString;
        RIP_INFO                  RipInfo;
      } u;
    } DEBUG_EVENT, *LPDEBUG_EVENT;
</code></pre>
"
"<p>Suppose I want to have different handlers for different kind of messages, each message is identified by an <code>int</code>. I want to define each handler as an instantiation of a template method.</p>

<p>The idea is something like this:</p>

<p>handlers.h</p>

<pre><code>enum Handler {
    MESSAGE1,
    MESSAGE2
};

template&lt;MESSAGE1&gt;
void handle() {
}
</code></pre>

<p>main.cpp</p>

<pre><code>int main()
{
    handle&lt;Handler::MESSAGE&gt;();
}
</code></pre>

<p>Of course this code does not compile because <code>MESSAGE1</code> is not a type.
So, how could I create a different type for each message ? Also, I'd like to maintain the use of these types as meaningful as possible (hence the use of enums).</p>
"
"<p>I'm trying to write an abstraction layer to let my code run on different platforms. Let me give an example for two classes that I ultimately want to use in the high level code:</p>

<pre><code>class Thread
{
public:
    Thread();
    virtual ~Thread();

    void start();
    void stop();

    virtual void callback() = 0;
};

class Display
{
public:
    static void drawText(const char* text);
};
</code></pre>

<p>My trouble is: What design pattern can I use to let low-level code fill in the implementation?
Here are my thoughs and why I don't think they are a good solution:</p>

<ol>
<li><p>In theory there's no problem in having the above definition sit in <code>highLevel/thread.h</code> and the platform specific implementation sit in <code>lowLevel/platformA/thread.cpp</code>. This is a low-overhead solution that is resolved at link-time. The only problem is that the low level implementation can't add any member variables or member functions to it. This makes certain things impossible to implement.</p></li>
<li><p>A way out would be to add this to the definition (basically the Pimpl-Idiom):</p>

<pre><code>class Thread
{
    // ...
private:
    void* impl_data;
}
</code></pre>

<p>Now the low level code can have it's own struct or objects stored in the void pointer. The trouble here is that its ugly to read and painful to program.</p></li>
<li><p>I could make <code>class Thread</code> pure virtual and implement the low level functionality by inheriting from it. The high level code could access the low level implementation by calling a factory function like this:</p>

<pre><code>// thread.h, below the pure virtual class definition
extern ""C"" void* makeNewThread();

// in lowlevel/platformA/thread.h
class ThreadImpl: public Thread
{ ... };

// in lowLevel/platformA/thread.cpp
extern ""C"" void* makeNewThread() { return new ThreadImpl(); }
</code></pre>

<p>This would be tidy enough but it fails for static classes. My abstraction layer will be used for hardware and IO things and I would really like to be able to have <code>Display::drawText(...)</code> instead of carrying around pointers to a single <code>Display</code> class.</p></li>
<li><p>Another option is to use only C-style functions that can be resolved at link time like this <code>extern ""C"" handle_t createThread()</code>. This is easy and great for accessing low level hardware that is there only once (like a display). But for anything that can be there multiple times (locks, threads, memory management) I have to carry around handles in my high level code which is ugly or have a high level wrapper class that hides the handles. Either way I have the overhead of having to associate the handles with the respective functionality on both the high level and the low level side.</p></li>
<li><p>My last thought is a hybrid structure. Pure C-style <code>extern ""C""</code> functions for low level stuff that is there only once. Factory functions (see 3.) for stuff that can be there multiple times. But I fear that something hybrid will lead to inconsistent, unreadable code.</p></li>
</ol>

<p>I'd be very grateful for hints to design patterns that fit my requirements.</p>
"
"<p>I'm trying to use Windows RPC for communcation between two processes (C/C++, 32bit, Win7).</p>

<p>I've followed the example here <a href=""http://www.codeproject.com/Articles/4837/Introduction-to-RPC-Part?msg=4458017#xx4458017xx"" rel=""nofollow"" title=""Instruction to RPC"">Instruction to RPC</a> and successfully got RPC to work. Now I have difficulties getting the proxy / stub thing to work too.</p>

<p>The IDL file looks like this:</p>

<pre><code>[ uuid(3cb112c0-688a-4611-83b6-31d33d87ea28), object ]
interface IDemo : IUnknown
{
    HRESULT ThisIsAMethod([in, string] const char* test);
}

[ uuid(60ad6a21-ba49-483a-b0a2-faa5187b8299), version(1.0),
  implicit_handle(handle_t hDemoBinding)]
interface IDemoRPC
{
    void SimpleTest();
    void GetDemo([out] IDemo** service);
    void Shutdown();
}
</code></pre>

<p>I can invoke <code>SimpleTest()</code> remotely on the server from the client. Works just fine. But <code>GetDemo()</code> gives me an access violation when the server 'returns' something else than <code>NULL</code>.</p>

<p>Here's what I've done:</p>

<ul>
<li><p>Build a DLL based on the generated demo_i.c, demo_p.c, dlldata.c. With <code>REGISTER_PROXY_DLL</code> set and a def file containing the five private entries. I've registered it with <code>regsvr32</code> (the one from WOW64).</p></li>
<li><p>Created a <code>DemoImpl</code> class in the server process that extends <code>IDemo</code> and implements <code>ThisIsAMethod</code> as well as <code>AddRef</code> and friends.</p></li>
<li><p>Implemented <code>GetDemo(IDemo** service)</code> with a one-liner <code>*service = new DemoImpl();</code></p></li>
</ul>

<p>When I invoke <code>GetDemo</code> from the client process, the <em>server</em> process terminates with an access violation (0x00000014). The stacktrace shows that it happens in a separate thread deep within rpcrt4.</p>

<p>I would have expected that the thing returns a proxy to the client.</p>

<p>I have the suspicion that I'm doing something fundamentally wrong here. For one thing, I can't find an example where instances of interface-objects are created with <code>new</code>. There always some some magic with <code>CoGetClassObject</code> or something. No clue how these functions should know where to find the implementation.</p>
"
"<p>Is the following code safe :</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;cstdint&gt;

struct A{
  int i = 0;
  virtual int foo() {return i;}
};
struct B : A{
  int foo() override {return i+2;}
};

using handle_t = std::uintptr_t;
handle_t get(B&amp; a){
  return reinterpret_cast&lt;handle_t&gt;(&amp;a);
}

void use(handle_t h){
  auto p= reinterpret_cast&lt;A*&gt;(h); //
  std::cout &lt;&lt; p-&gt;foo() &lt;&lt; ""\n"";
}

int main(int argc, char *argv[])
{
  B a;
  auto h = get(a);
  use(h);
  return 0;
}
</code></pre>

<p><a href=""http://en.cppreference.com/w/cpp/language/reinterpret_cast"" rel=""nofollow"">CppReference's page</a> says one can :</p>

<ul>
<li>reinterpret_cast from B* to std::uintptr_t </li>
<li>reinterpret_cast from std::uintptr_t to B* (because it's the same type back and forth)</li>
<li>reinterpret_cast from B* to A*</li>
</ul>

<p>So, is it safe to merge the last two ?</p>
"
"<p>I have a function whose call I need to detect i.e.</p>

<p><code>EXPECT_CALL(MockClass_obj, target_func());</code></p>

<p>The signature is:</p>

<p><code>void MockClass::target_func(HANDLE_t handle);</code></p>

<p>Argument <code>handle</code> is an opaque type and it's a global set in some other function so yes, I will need to stub it.</p>

<p>Here's the problem: inside the function I am testing, I call <code>MockClass::target_func</code> with a few different arguments depending on the branches taken:</p>

<pre><code>//MockClass inherits Class, call f1() with instance of MockClass
void f1(int a, Class &amp; obj)
{
    switch(a):
    {
    case 0:
        obj.target_func(global_handle_1);
        break;
    case 1:
        obj.target_func(global_handle_2);
        break;
    default:
        obj.target_func(global_handle_3);

    }
}
</code></pre>

<p><strong>QUESTION</strong></p>

<p>How do I do an expect call based on the NAME of the argument? I need to detect which path was taken.</p>

<p>Since all the <code>global_handle_[x]</code> variables will be stubbed out i.e. set to arbitrary value, I could set them to <code>global_handle_&lt;x&gt;=&lt;x&gt;</code> and then <code>EXPECT_CALL(MockClass_obj, target_func(&lt;x&gt;));</code></p>

<p>I guess that's good enough but to be more robust, ideally I'd like to EXPECT_CALL on a variable name?</p>

<p>Is this possible?</p>
"
"<p>I am following the code in Chapter 3 of ""Learning Linux Binary Analysis"". The code is, ""A simple ptrace-based debugger"".</p>

<p>I am trying to write this in my Raspberry Pi 3, which has an ARM processor. I know that the error means that I have not included the correct header file, but I cannot find what the correct header file is.</p>

<p>I get this error message:</p>

<pre><code>field ?pt_reg? has incomplete type struct user_regs_struct pt_reg
</code></pre>

<p>After doing some research, I found asm/ptrace.h, which includes some macros for the registers struct specific to ARM. Am I on the right track? How in the world can I make this work with an ARM processor?</p>

<p>Here are the headers:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;signal.h&gt;
#include &lt;elf.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/user.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/ptrace.h&gt;
#include &lt;sys/mman.h&gt;

typedef struct handle {
  Elf64_Ehdr *ehdr;
  Elf64_Phdr *phdr;
  Elf64_Shdr *shdr;
  uint8_t *mem;
  char *symname;
  Elf64_Addr symaddr;
  struct user_regs_struct pt_reg;
  char *exec;
} handle_t;
</code></pre>
"
"<p>I am trying to write a debugger for my Raspberry Pi 3 as a learning exercise. It it an ARMv7.</p>

<p>This section of code is how you set the breakpoint on the x86 architecture:</p>

<pre><code>if ((orig = ptrace(PTRACE_PEEKTEXT, pid, h.symaddr, NULL)) &lt; 0) {
        perror(""PTRACE_PEEKTEXT"");
        exit(-1);
      }
      trap = (orig &amp; ~0xff) | 0xcc;
      if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) &lt; 0) {
        perror(""PTRACE_POKETEXT"");
        exit(-1);
      }
</code></pre>

<p>Specifically, the line <code>trap = (orig &amp; ~0xff) | 0xcc;</code> is how you change the first byte to the opcode of the <code>int 3</code> syscall. This sets a breakpoint on the x86. However, I am at a loss on how to do it for ARM. I have tried searching the GDB source files to see how they do, and I have found the *-tdep.c family of files. They have arm-linux-tdep.c and arm-tdep.c. Within these files I found:</p>

<pre><code>/* Under ARM GNU/Linux the traditional way of performing a breakpoint
   is to execute a particular software interrupt, rather than use a
   particular undefined instruction to provoke a trap.  Upon exection
   of the software interrupt the kernel stops the inferior with a
   SIGTRAP, and wakes the debugger.  */

?static const gdb_byte arm_linux_arm_le_breakpoint[] = { 0x01, 0x00, 0x9f, 0xef };

?static const gdb_byte arm_linux_arm_be_breakpoint[] = { 0xef, 0x9f, 0x00, 0x01 };

/* However, the EABI syscall interface (new in Nov. 2005) does not look at
   the operand of the swi if old-ABI compatibility is disabled.  Therefore,
   use an undefined instruction instead.  This is supported as of kernel
   version 2.5.70 (May 2003), so should be a safe assumption for EABI
   binaries.  */

?static const gdb_byte eabi_linux_arm_le_breakpoint[] = { 0xf0, 0x01, 0xf0, 0xe7 };

?static const gdb_byte eabi_linux_arm_be_breakpoint[] = { 0xe7, 0xf0, 0x01, 0xf0 };

/* All the kernels which support Thumb support using a specific undefined
   instruction for the Thumb breakpoint.  */

?static const gdb_byte arm_linux_thumb_be_breakpoint[] = {0xde, 0x01};

?static const gdb_byte arm_linux_thumb_le_breakpoint[] = {0x01, 0xde};

/* Because the 16-bit Thumb breakpoint is affected by Thumb-2 IT blocks,
   we must use a length-appropriate breakpoint for 32-bit Thumb
   instructions.  See also thumb_get_next_pc.  */

?static const gdb_byte arm_linux_thumb2_be_breakpoint[] = { 0xf7, 0xf0, 0xa0, 0x00 };

?static const gdb_byte arm_linux_thumb2_le_breakpoint[] = { 0xf0, 0xf7, 0x00, 0xa0 };
</code></pre>

<p>I have tried replacing <code>trap = (orig &amp; ~0xff) | 0xcc;</code> with the values from the arm-linux-tdep.c file as so(I use little endian since my system is little endian):</p>

<p><code>trap = (orig &amp; ~0xff) | 0x01009fef; // doesn't work</code>
<code>trap = (orig &amp; ~0xff) | 0xf001f0e7; // doesn't work</code></p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;signal.h&gt;
#include &lt;elf.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/user.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/ptrace.h&gt;
#include &lt;sys/mman.h&gt;

typedef struct handle {
  Elf64_Ehdr *ehdr;
  Elf64_Phdr *phdr;
  Elf64_Shdr *shdr;
  uint8_t *mem;
  char *symname;
  Elf64_Addr symaddr;
  struct user_regs_struct pt_reg;
  char *exec;
} handle_t;

Elf64_Addr lookup_symbol(handle_t *, const char *);

int main(int argc, char **argv, char **envp)
{
  int fd;
  handle_t h;
  struct stat st;
  long trap, orig;
  int status, pid;
  char * args[2];
  if (argc &lt; 3) {
    printf(""Usage: %s &lt;program&gt; &lt;function&gt;\n"", argv[0]);
    exit(0);
  }
  if ((h.exec = strdup(argv[1])) == NULL) {
    perror(""strdup"");
    exit(-1);
  }
  args[0] = h.exec;
  args[1] = NULL;
  if ((h.symname = strdup(argv[2])) == NULL) {
    perror(""strdup"");
    exit(-1);
  }
  if ((fd = open(argv[1], O_RDONLY)) &lt; 0) {
    perror(""open"");
    exit(-1);
  }
  if (fstat(fd, &amp;st) &lt; 0) {
    perror(""fstat"");
    exit(-1);
  }
  h.mem = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
  if (h.mem == MAP_FAILED) {
    perror(""mmap"");
    exit(-1);
  }
  h.ehdr = (Elf64_Ehdr *)h.mem;
  h.phdr = (Elf64_Phdr *)(h.mem + h.ehdr-&gt;e_phoff);
  h.shdr = (Elf64_Shdr *)(h.mem + h.ehdr-&gt;e_shoff);
  if+ (h.mem[0] != 0x7f || strcmp((char *)&amp;h.mem[1], ""ELF"")) {
    printf(""%s is not an ELF file\n"",h.exec);
    exit(-1);
  }
  if (h.ehdr-&gt;e_type != ET_EXEC) {
    printf(""%s is not an ELF executable\n"", h.exec);
    exit(-1);
  }
  if (h.ehdr-&gt;e_shstrndx == 0 || h.ehdr-&gt;e_shoff == 0 || h.ehdr-&gt;e_shnum == 0) {
    printf(""Section header table not found\n"");
    exit(-1);
  }
  if ((h.symaddr = lookup_symbol(&amp;h, h.symname)) == 0) {
    printf(""Unable to find symbol: %s not found in executable\n"", h.symname);
    exit(-1);
  }
  close(fd);
  if ((pid = fork()) &lt; 0) {
    perror(""fork"");
    exit(-1);
  }
  if (pid == 0) {
    if (ptrace(PTRACE_TRACEME, pid, NULL, NULL) &lt; 0) {
      perror(""PTRACE_TRACEME"");
      exit(-1);
    }
    execve(h.exec, args, envp);
    exit(0);
  }
  wait(&amp;status);
  printf(""Beginning analysis of pid: %d at %lx\n"", pid, h.symaddr);
  if ((orig = ptrace(PTRACE_PEEKTEXT, pid, h.symaddr, NULL)) &lt; 0) {
    perror(""PTRACE_PEEKTEXT"");
    exit(-1);
  }
  trap = (orig &amp; ~0xff) | 0xcc;
  if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) &lt; 0) {
    perror(""PTRACE_POKETEXT"");
    exit(-1);
  }
  trace:
  if (ptrace(PTRACE_CONT, pid, NULL, NULL) &lt; 0) {
    perror(""PTRACE_CONT"");
    exit(-1);
  }
  wait(&amp;status);
  if (WIFSTOPPED(status) &amp;&amp; WSTOPSIG(status) == SIGTRAP) {
    if (ptrace(PTRACE_GETREGS, pid, NULL, &amp;h.pt_reg) &lt; 0) {
      perror(""PTRACE_GETREGS"");
      exit(-1);
    }
    printf(""\nExecutable %s (pid: %d) has hit breakpoint 0x%lx\n"",
    h.exec, pid, h.symaddr);
    printf(""%%rcx: %llx\n%%rdx: %llx\n%%rbx: %llx\n""
    ""%%rax: %llx\n%%rdi: %llx\n%%rsi: %llx\n""
    ""%%r8: %llx\n%%r9: %llx\n%%r10: %llx\n""
    ""%%r11: %llx\n%%r12 %llx\n%%r13 %llx\n""
    ""%%r14: %llx\n%%r15: %llx\n%%rsp: %llx"",
    h.pt_reg.rcx, h.pt_reg.rdx, h.pt_reg.rbx,
    h.pt_reg.rax, h.pt_reg.rdi, h.pt_reg.rsi,
    h.pt_reg.r8, h.pt_reg.r9, h.pt_reg.r10,
    h.pt_reg.r11, h.pt_reg.r12, h.pt_reg.r13,
    h.pt_reg.r14, h.pt_reg.r15, h.pt_reg.rsp);
    printf(""\nPlease hit any key to continue: "");
    getchar();
    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, orig) &lt; 0) {
      perror(""PTRACE_POKETEXT"");
      exit(-1);
    }
    h.pt_reg.rip = h.pt_reg.rip - 1;
    if (ptrace(PTRACE_SETREGS, pid, NULL, &amp;h.pt_reg) &lt; 0) {
      perror(""PTRACE_SETREGS"");
      exit(-1);
    }
    if (ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) &lt; 0) {
      perror(""PTRACE_SINGLESTEP"");
      exit(-1);
    }
    wait(NULL);
    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) &lt; 0) {
      perror(""PTRACE_POKETEXT"");
      exit(-1);
    }
    goto trace;
    }
    if (WIFEXITED(status))
    printf(""Completed tracing pid: %d\n"", pid);
    exit(0);
  }

  Elf64_Addr lookup_symbol(handle_t *h, const char *symname)
  {
    int i, j;
    char *strtab;
    Elf64_Sym *symtab;
    for (i = 0; i &lt; h-&gt;ehdr-&gt;e_shnum; i++) {
      if (h-&gt;shdr[i].sh_type == SHT_SYMTAB) {
        strtab = (char *)&amp;h-&gt;mem[h-&gt;shdr[h-&gt;shdr[i].sh_link].sh_offset];
        symtab = (Elf64_Sym *)&amp;h-&gt;mem[h-&gt;shdr[i].sh_offset];
        for (j = 0; j &lt; h-&gt;shdr[i].sh_size/sizeof(Elf64_Sym); j++) {
          if(strcmp(&amp;strtab[symtab-&gt;st_name], symname) == 0)
          return (symtab-&gt;st_value);
          symtab++;
        }
      }
    }
  return 0;
  }
}
</code></pre>

<p>Can anyone help me implement breakpoints for ARM? I have spent hours researching but I cannot figure it out.</p>
"
"<p>I'm passing a variable by reference into a function, and then in that function passing the variable by pointer into another function. In the final function the variable is assigned to and when I print it out in the final function it prints successfully.</p>

<p>When I then try to access the variable in the outer functions the variable has changed. </p>

<p>The variable <code>p</code> is a local variable in the outermost function, and I am passing the address in. I don't know why the variable is changing since I am passing a pointer in.</p>

<p>Here's what my code looks like. I have simplified the code to make it easier to understand without needing to paste too much other code.</p>

<p>I pass <code>p</code> into <code>get_dsp(root, &amp;p)</code></p>

<pre><code>b_error
run_activate(int argc, char **argv){
    b_error ret = B_SUCCESS;
    char *root = ""example_root"";

    char *p;

    if ((ret = get_dsp(root, &amp;p)) != B_FAILURE) {
        fprintf(stdout, ""run_activate: %s.\n"", p);
    }
    return ret;
}
</code></pre>

<p>I then pass it into another function within <code>get_dsp(...)</code>.</p>

<pre><code>b_error
get_dsp(char *ds, char **p) {
    handle_t *hdl;
    b_e_t *b_be = NULL;
    b_error ret = B_SUCCESS;

    if((hdl = zl_init()) != NULL) {

        if (zl_get_dsp(hdl, ds, p) != ZL_SUCCESS) {
            fprintf(stderr, ""b: Error getting p'\n"");
            ret = B_FAILURE;
        }

        zl_fini(hdl);
    } else {
        fprintf(stderr, ""b: Error initializing zl\n"");
        ret = B_FAILURE;
    }
    fprintf(stdout, ""get_dsp: p: %s'\n"", *p);
    return ret;
}
</code></pre>

<p>In the last function <code>zl_get_dsp</code>, <code>p</code> is printed properly. </p>

<pre><code>zl_error
zl_get_dsp(handle_t *hdl, const char *ds, char **p){
    z_handle_t *z = NULL;
    zl_error ret = ZL_SUCCESS;

    if (hdl == NULL) {
        fprintf(stderr, ""zl: zl isn't initialized\n"");
        ret = ZL_FAILURE;
    } else {
        if ((z = z_open(hdl, ds)) == NULL) {
            fprintf(stderr, ""zfslib: Failure opening handle to zl '%s'\n"", dataset);
            ret = ZL_FAILURE;
        } else {

            if ((*p = get_pn(z)) != NULL){
                fprintf(stdout, ""zl_get_dsp: '%s'\n"", *p);
            } else {
                fprintf(stderr, ""zl: Failure getting pn\n"");
                ret = ZL_FAILURE;
            }

            z_close(z);
        }
    }
    return ret;
}
</code></pre>

<p>The function <code>get_pn</code> returns a string.</p>

<pre><code>const char *get_pn(z_handle_t *z){
    return (z-&gt;zp_hdl-&gt;pn);
}

typedef struct z_handle z_handle_t;
typedef struct zp_handle zp_handle_t;

struct z_handle {
    zp_handle_t *zp_hdl;
    // ...
};

struct zp_handle {
    char pn[MAX_LEN];
};
</code></pre>

<p>When it returns to the two other functions and attempts to print <code>p</code>, nothing is printed.</p>

<p>Here's the output. <code>p</code> prints correctly once in the last function <code>zl_get_dsp</code>, but not in the outer two.</p>

<pre><code>zl_get_dsp: 'v_printed'
get_dsp: p: '
run_activate: .
</code></pre>

<p>I have tried dynamically allocating the variable, but it doesn't help. I've also tried passing in a pointer directly, or passing in the address of a variable and it makes no difference. </p>

<p>I would think since I'm using a local variable in the first function that my variable shouldn't change by itself. I would understand if I was attempting to return a pointer that I hadn't passed in, but that's not what I'm doing. </p>

<p>Is there something obvious I'm doing wrong?</p>

<hr>

<p>I was getting frustrated and couldn't make it work, I saw a post about using <code>strcpy</code>, I tried that which works. </p>

<pre><code>char *temp_p;
// ...
if ((temp_p = get_pn(zhp)) != NULL){
// ...
strcpy(*p,temp_p);
</code></pre>

<p>Would this be because the variable I was pointing to is being changed by another function somehow? And when I used strcpy it made a copy of it so it doesn't matter that the other variable was changed?</p>
"
"<p>I'm writing server and client using Interface Definition Language and Remote Procedure Call in C++. I can send data from client to server with [in] attribute. Now I want server to send data back to client. But I failed receiving correct data.  </p>

<p>I define the function in .idl interface as below:</p>

<pre><code>[
    //uuid and verison define here
]

interface utility{
    void sendData([in] int numIn, [out] int *numOut);
}
</code></pre>

<p>The <a href=""https://msdn.microsoft.com/en-us/library/windows/desktop/aa367136(v=vs.85).aspx"" rel=""nofollow noreferrer"">MIDL</a> document says that </p>

<blockquote>
  <p>An [out]-only parameter is assumed to be undefined when the remote procedure is called and memory for the object is allocated by the server. </p>
</blockquote>

<p>So in client.cpp, I instantiate the variable and call the funciton.</p>

<pre><code>RpcTryExcept{
    int *num;
    sendData(hBinding, 123, num);
}
</code></pre>

<p>In server.cpp,</p>

<pre><code>void sendData(handle_t IDL_handle, int numIn, int *numOut){
    numOut = new int[3];
    numOut[0] = 1;
    numOut[1] = 2;
    numOut[2] = 3;
}
</code></pre>

<p>I printed the int array in client, and get 3 random numbers. I also tried to define the size in client first.
<code>int *num = new int[3]</code>. This time it can pass the value of numOut[0] to client, but the other indexes are all messed up. I tried char array as well but no good. Maybe I misunderstanding something. Can anyone give me some ideas? Thanks. </p>
"
"<p>this is quite hard to explain but I'll try my best. So, I have a RenderComponent, EventManager and RenderSystem. In my RenderComponents constructor, I raise a renderComponentCreated event which the RenderSystem subscribes to. Using an event args object, I pass a RenderNode as data which contains the information the renderSystem needs to draw the thing (drawable, position and type).</p>

<p>So far so good. Now, when the renderComponent is deleted, I want the RenderNode to be removed from the RenderSystem automatically while still leaving the option to remove it manually e.g. as a reaction to some event. This could be done using a RenderComponentRemoveNodeEvent which again the RenderSystem subscribes to.</p>

<p>Now the 'problem'. From my understanding (and from what I want) the renderNode should be something uniquely owned by the RenderComponent (hence unique_ptr). However, this would require me to either copy (and implement a comparison operator for the renderNode --> to be able to find it when I want to remove it) or pass a reference / raw pointer to the renderNode. However, (If I'm correct) there is no way to know whether a reference still refers to a valid object which would mean that automatic removal could not be implemented.</p>

<p>My solution was to make the RenderNode (that is uniquely owned by the RenderComponent) shared and pass weak pointers to the event. The RenderSystem also now maintains a list of weak pointers that it checks for whether they are still pointing to a valid object and automatically removes them if not. So essentially what I would have wanted is creating a weak pointer from a unique one. However, the way it is now, someone could just create a shared pointer from the weak pointer and keep the RenderNode alive longer than it should. Since the managed object itself (RenderNode) contains references to other objects that will not exist longer than the RenderComponent this may cause serious issues.</p>

<p>My question now: can this be considered good design or have I missed something?</p>

<p>PS: Sorry if this explanation reads a bit clunky (English is not my native) and thanks for your help!</p>
"
"<p>I saw the following comment atop the <code>iput</code> function:</p>

<pre><code>/**
 *  iput    - put an inode
 *  @inode: inode to put
 *
 *  Puts an inode, dropping its usage count. If the inode use count hits
 *  zero, the inode is then freed and may also be destroyed.
 *
 *  Consequently, iput() can sleep.
 */
</code></pre>

<p>To me that sounds like it's not ""putting"" anything, but ""dropping"" it. I'm aware of the <code>drop_inode</code> function, which gets called from <code>iput</code> in some cases, so the usage of the term ""put"" is even more confusing here.</p>
"
"<p>I'm writing a simple IDictionary abstraction in C# that wraps a
Dictionary&lt;K, ICollection&lt;V&gt;&gt;. Basically, it maps multiple values to one key.  I can't decide whether to remove a key and its empty list when the last item in a values list is removed, or leave it (to avoid instantiating a new collection if the key is reused) and do checks on a key's values' Count when determining whether a key exists.</p>
"
"<p>I'd like a generic method for retrieving the data from a vector.</p>

<p>I have a the following class and vector:</p>

<pre><code>class myClass
{
    public:

    myClass(int myX, float myZ, std::string myFoo)
        : x ( myX )
        , z ( myZ )
        , foo ( myFoo )
    {

    }
    myClass()
    {

    }

    int x;
    float z;
    std::string foo;

} ;
std::vector &lt; myClass &gt; myVector;
</code></pre>

<p>(The complete code can be seen here: <a href=""http://codepad.org/iDD1Wme5"" rel=""nofollow noreferrer"">http://codepad.org/iDD1Wme5</a> )</p>

<p>In this example I would like to be able to retrieve objects in the vector based on the ""z"" or ""foo"" members without having to write another 2 functions similar to ""FindDataById"".</p>

<p>Is that possible?</p>
"
"<p>it has a property:
string Code
and 10 other.</p>

<p>common codes is list of strings(string[] )
cars a list of cars(Car[])
filteredListOfCars is List.</p>

<pre><code>for (int index = 0; index &lt; cars.Length; index++)
{
    Car car = cars[index];
    if (commonCodes.Contains(car.Code))
    {
         filteredListOfCars.Add(car);
    }
}
</code></pre>

<p>Unfortunately this piece of methodexecutes too long.</p>

<p>I have about 50k records</p>

<p>How can I lower execution time??</p>
"
"<p>Why does this LINQ query (Id is a property of type long in the Structure object):</p>

<pre><code>IList&lt;Structure&gt; theStructures = new List&lt;Structure&gt;();
public int GetChildrenSlow(Structure aStructure){
   IEnumerable&lt;Structure&gt; childrenQuery =
                         from structure in theStructures
                         where structure.ParentStructureId == aStructure.Id
                         select structure;
   int count = childrenQuery.Count();
   //Functionality continues...
}
</code></pre>

<p>Run slower than this one:</p>

<pre><code>IList&lt;Structure&gt; theStructures = new List&lt;Structure&gt;();
public int GetChildrenFast(long aStructureId){
   IEnumerable&lt;Structure&gt; childrenQuery =
                         from structure in theStructures
                         where structure.ParentStructureId == aStructureId
                         select structure;
   int count = childrenQuery.Count();
   //Functionality continues...
}
</code></pre>

<p>I am making this call thousands of time (recursively) and using the property is much slower than using the long directly.  If I pull the Id out and store it in a long variable <em>before</em> I execute the LINQ command the speed is pretty much equivalent to the speed of <code>GetChildrenFast</code>.  Why is using an object property in LINQ slower than using a primitive?</p>

<p>Working Example:</p>

<pre><code>namespace ConsoleApplication1
{
   class Structure
   {
      public int Id
      {
         get; set;
      }

      public int ParentStructureId
      {
         get; set;
      }
   }

   class Program
   {
      private IList&lt;Structure&gt; theStructures = new List&lt;Structure&gt;();
      public Structure FirstStructure
      {
         get; set;
      }

      private int FastCountStructureChildren(long aStructureId)
      {
         IEnumerable&lt;Structure&gt; childrenQuery =
                         from structure in theStructures
                         where structure.ParentStructureId == aStructureId
                         select structure;

         int count = childrenQuery.Count();
         foreach(Structure childStructure in childrenQuery)
         {
            count += FastCountStructureChildren(childStructure.Id);
         }
         return count;
      }

      private int SlowCountStructureChildren(Structure aStructure)
      {
         IEnumerable&lt;Structure&gt; childrenQuery =
                         from structure in theStructures
                         where structure.ParentStructureId == aStructure.Id
                         select structure;

         int count = childrenQuery.Count();
         foreach(Structure childStructure in childrenQuery)
         {
            count += SlowCountStructureChildren(childStructure);
         }
         return count;
      }

      public void BuildStructure()
      {
         FirstStructure = new Structure{Id = 0, ParentStructureId = -1};
         theStructures.Add(FirstStructure);
         //The loop only goes to 6000 as any more than that causes
         //a StackOverflowException my development machine.
         for(int i=1; i&lt;6000; i++)
         {
            Structure newStructure = new Structure{Id = i,ParentStructureId = i - 1};
            theStructures.Add(newStructure);
         }
      }

      static void Main(string[] args)
      {
         Program program = new Program();
         program.BuildStructure();

         Stopwatch fastStopwatch = new Stopwatch();
         fastStopwatch.Start();
         program.FastCountStructureChildren(0);
         fastStopwatch.Stop();

         Stopwatch slowStopwatch = new Stopwatch();
         slowStopwatch.Start();
         program.SlowCountStructureChildren(program.FirstStructure);
         slowStopwatch.Stop();

         Console.WriteLine(""Fast time: "" + fastStopwatch.Elapsed);
         Console.WriteLine(""Slow time: "" + slowStopwatch.Elapsed);
         Console.ReadLine();
      }
   }
}
</code></pre>
"
"<p>I have set of 'codes' Z that are valid in a certain time period.</p>

<p>Since I need them a lot of times in a large loop (million+) and every time I have to lookup the corresponding code I cache them in a List&lt;>. After finding the correct codes, i'm inserting (using SqlBulkCopy) a  million rows.</p>

<p>I lookup the id with the following code (<code>l_z</code> is a <code>List&lt;T&gt;</code>)</p>

<pre><code>var z_fk = (from z in l_z
            where z.CODE == lookupCode &amp;&amp;
                  z.VALIDFROM &lt;= lookupDate &amp;&amp;
                  z.VALIDUNTIL &gt;= lookupDate
            select z.id).SingleOrDefault();
</code></pre>

<p>In other situations I have used a Dictionary with superb performance, but in those cases I only had to lookup the id based on the code.</p>

<p>But now with searching on the combination of fields, I am stuck.</p>

<p>Any ideas? Thanks in advance.</p>
"
"<p>I need to implement a search algoritm with efficient o(1). If I use HashSet and will try search by User.FirstName for example, whether it is right? If not, give me an advice, please, how can I realize this search?</p>
"
"<p>Is constructing and using a manual lookup (<code>ILookup&lt;T&gt;</code>) approach any faster than using a join with <code>Join</code> or <code>GroupJoin</code> on a local <code>IEnumerable&lt;T&gt;</code> sequence in LINQ?</p>

<p>I read somewhere that the compiler actually translates the inner sequence of <code>Join</code> and <code>GroupJoin</code> to <code>ILookup&lt;T&gt;</code> anyway.</p>

<p>What would <code>ILookup&lt;T&gt;</code> benefits of using it on it's own be?</p>
"
"<p>What is the efficient way to get all the inodes for a filesystem? In theory something like fsck would need to do it.</p>
"
"<p>I need to improve performance a desktop application (.net) which was designed to read the database and create xml files based on XBRL (eXtensible Bussiness Reporting Language). It is using UBMatrix for creating XBRL Taxonomies. </p>

<p>The application works fine if the size of particular data is small. But the application will take more than 30 min to generate files if the data is big. The client data is always huge/big. So the application requires more time to generate files. </p>

<p>My task is to optimise the application in order to reduce the time taken to create the xml files. When I checked the application I found that the application is running on this way.</p>

<p>Starts  </p>

<ul>
<li>Create connection to db</li>
<li>gets the first set of data ( this table (table1) is too Large ). And the query will returns around 15-30 K rows to dataTable</li>
<li>for loop 0 to datatable.Rows.count
<ul>
<li>checks some condition   </li>
<li>get data from db. (this table (table2) is also too large than (table1).</li>
<li>send data to form xbrl and writes to xml ( this is done by thrid party application called UBMatrix). It is not possible to edit the code which creates xbrl-xml file.</li>
</ul></li>
</ul>

<p>Similarly there are 3 to 4 set of data will process</p>

<p>In my observation, we can avoid db calls in for loop. Get all the data before the loop. When I checked the queries, there were subqueries,not exists(select * from table) etc can be replaced with joins, not exists (select 1 from table)</p>

<p>But still the application need to process in loop. I am also thinking of using threading so that the I can create threads based on the size of data and process it simultaneosly. </p>

<p>Eg </p>

<ul>
<li>if there are 100 rows.there will be 100 entries to xml file (XBRL)</li>
<li>So i will make 50,50 and run in two threads which will generate two xml file. at the end I will combine two into one xml file.</li>
</ul>

<p>So processing of 0th question and 50th question can be start at same time. Currently in for loop, 0th will process and 99th will be  process at the end only. I am not sure about the idea. Can any suggest /share your ideas . any help will be appreciated. Thanks in advance</p>
"
"<p>I have a function that return a <code>IDictionary&lt;TKey, List&lt;TValue&gt; &gt;</code>.<br>
I have another function that takes a <code>IDictionary&lt;TKey, IEnumerable&lt;TValue&gt; &gt;</code>.  </p>

<p>I need to pass the return of the first function to the second function.<br>
The compiler doesn't want to implicitlty convert the first into the second. So how could I convert the first into the second in O(1)?  </p>

<p>I could always write a conversion function</p>

<pre><code>public static IDictionary&lt;TKey, IEnumerable&lt;TValue&gt;&gt; ToIEnumerable&lt;TKey, TValue&gt;(this IDictionary&lt;TKey, List&lt;TValue&gt;&gt; source)
{
    return source.ToDictionary(s =&gt; s.Key, s =&gt; s.Value.AsEnumerable());
}
</code></pre>

<p>But I'm pretty sure this is not O(1), more like O(log n).</p>

<p>A related question here : <a href=""https://stackoverflow.com/questions/10399568/nested-interfaces-cast-idictionarytkey-ilisttvalue-to-idictionarytkey-ie?rq=1"">Nested Interfaces: Cast IDictionary&lt; TKey, IList&lt; TValue > > to IDictionary&lt; TKey, IEnumerable &lt; TValue> >?</a></p>
"
"<p>I have the following LINQ query.</p>

<p>There is a list of about 55 000 items. I need to do a search on <strong>three</strong> of the attributes within the items.</p>

<p>here is my code:</p>

<pre><code>private List&lt;Device&gt; Devices = _db.Devices.ToList();

public Device TryFindDeviceInNetworks(ALL_Sims sim)
{
    var ips = new List&lt;string&gt;();
    if (sim.IP1 != null)
    {
        ips.Add(sim.IP1);
    }
    if (sim.IP2 != null)
    {
        ips.Add(sim.IP2);
    }

    var device =
        Devices.FirstOrDefault(
            x =&gt; ips.Contains(x.IPaddress1)
                 || ips.Contains(x.IPaddress2)
                 || ips.Contains(x.IPaddress3));

    return device;
}
</code></pre>

<p>Currently this operation takes some time.</p>

<p>I have a for loop going through about 100k items and in each iteration of it calls this function <code>TryFindDeviceInNetworks()</code>. It runs 8 - 10 hours plus on intel i5. Obviously this is single threaded.</p>

<p>My question is how can I speed this up? I have converted a few of my lists to dictionaries where I can in the application and this has helped drastically, however in this case I cant search on only one key?</p>

<p>Is there some sort of data structure which would be better suited than the <code>List&lt;T&gt;</code>?</p>

<p>The database is not located locally on on a LAN, so estimated ping of at least ~40ms + query time would be added to every iteration.</p>
"
"<p>i'm trying to have duplicate keys in ini file like this:</p>

<pre><code>[section]
key1 = ""value1""
key2 = ""value2""
key1 = ""value.....""

Private Declare Ansi Function WritePrivateProfileString _
  Lib ""kernel32.dll"" Alias ""WritePrivateProfileStringA"" _
  (ByVal lpApplicationName As String, _
  ByVal lpKeyName As String, ByVal lpString As String, _
  ByVal lpFileName As String) As Integer
</code></pre>
"
"<p>Okay, I'm reading about Linux kernel development and there are some code snippets using kernel's data structures and stuff. Let's say I'd like to experiment with them, e.g. there's a <em>very</em> simple snippet:</p>

<pre><code>#include &lt;../../linux-2.6.37.1/include/linux/sched.h&gt;
struct task_struct *task;
for_each_process(task) {
    printk(""%s[%d]\n"", task-&gt;comm, task-&gt;pid);
}
</code></pre>

<p>Seems pretty simple, eh? Now then, I can't possibly build the thing. I am using NetBeans. The  sched.h is the correct file as if one can CTRL+clicks on it, one is brought to the right file.</p>

<p>Do I need to include somehow my sample file and build the <strong>whole</strong> kernel from the Makefile? I just wished to see that it builds and possibly that it would work. If I need to build the whole kernel how would I actually test my stuff?</p>

<p>I must be making something really stupid as I am very new to kernel development. I am quite a bit lost.</p>

<p>Thanks guys!</p>
"
"<p>I'm somewhat stuck on this, being my first attempt at any type of kernel development. My project is a bit more complex than this, but what I'm stuck on is very basic.</p>

<p>I want a read only file system with some directories in the root dir, and files within them. That's it, nothing further. If I could get this hard coded, it'd be a piece of cake to modify it later to make it all dynamic, as long as I can load on the fly.</p>

<p>Basically, my question is this:</p>

<p>How do I create a filesystem so that every time I mount it and call 'ls' from the command line, I get a fresh list of files from within my module (hard coded for now, in the future will be dynamically pulled).</p>

<p>I have quite a bit more code than this, but this is what I am confident with so far:</p>

<pre><code>int testfs_super(struct super_block *superblock, void *data, int silent) {
static struct inode_operations inode_operations = {
    .lookup = simple_lookup,
};
struct inode *inode = new_inode(superblock);
struct dentry *root;
save_mount_options(superblock, data);
superblock -&gt; s_op = &amp;testfs_ops;
/*
superblock -&gt; s_maxbytes = 10000000;
superblock -&gt; s_blocksize = PAGE_SIZE;
superblock -&gt; s_blocksize_bits = PAGE_SHIFT;*/
inode -&gt; i_ino = 0;
inode_init_owner(inode, NULL, S_IFDIR | testfs_DIRECTORY_MODE);
inode -&gt; i_op = &amp;inode_operations;
inode -&gt; i_fop = &amp;simple_dir_operations;
root = d_make_root(inode);
if (!root) {
    return -ENOMEM;
}
superblock -&gt; s_root = root;
return 0;
}

struct dentry *testfs_mount(struct file_system_type *fs_type, int flags, const char *dev_name, void *data) {
return mount_nodev(fs_type, flags, data, testfs_super);
}
</code></pre>

<p>To elaborate, what I want to wind up with is something like this:</p>

<pre><code>? list_files(inode* dir) {
  item1 = inode and dentry with id of 1 and random name
  item2 = inode and dentry with id of 2 and random name
  item3 = inode and dentry with id of 3 and random name
}
</code></pre>

<p>As long as I can get the files listed, I can implement the read/open based on the inode pretty easily.</p>
"
"<p>I was wondering at what stage the attributes on a file was checked by the kernel in Linux. An example of what I mean would be if I attempt to edit a file with the immutable attribute is created. At what point does the kernel return an error indicating the file cannot be changed. If I wanted to change how an attribute works, what would be the best way of accomplishing this process. I was thinking a kernel module that would redirect the read/write/append function to my own series of functions.</p>

<p>Thanks</p>

<p><strong>EDIT :</strong></p>

<p>What I am really interested in is adding a new file attribute through a kernel module.</p>
"
"<p>I am writing an USB serial adapter device driver. The kernel is 3.17.4. The driver works fine except that the kernel opens the adapter twice and writes some commands when the adapter is plugged in. Here are dump_stack() for the driver's open() and write().</p>

<p>1st open() and write(). The kernel writes ""ATE1 E0"" three times.</p>

<pre><code>&lt;4&gt;[19964.897631] Call Trace:
&lt;4&gt;[19964.897642]  [&lt;ffffffff8173f929&gt;] dump_stack+0x45/0x56
&lt;4&gt;[19964.897649]  [&lt;ffffffffa04aa1ef&gt;] c0087_open+0x2f/0x160    [usb_com_1p_driver]
&lt;4&gt;[19964.897654]  [&lt;ffffffff81744bb2&gt;] ? down_write+0x12/0x40
&lt;4&gt;[19964.897661]  [&lt;ffffffff81566f75&gt;] serial_port_activate+0x65/0x90
&lt;4&gt;[19964.897667]  [&lt;ffffffff8145e864&gt;] ? tty_port_tty_set+0x64/0xa0
&lt;4&gt;[19964.897671]  [&lt;ffffffff8145edf9&gt;] tty_port_open+0x89/0xe0
&lt;4&gt;[19964.897675]  [&lt;ffffffff81567bf3&gt;] serial_open+0x33/0x70
&lt;4&gt;[19964.897679]  [&lt;ffffffff814560eb&gt;] tty_open+0x17b/0x700
&lt;4&gt;[19964.897684]  [&lt;ffffffff8149cf72&gt;] ? kobj_lookup+0x112/0x170
&lt;4&gt;[19964.897690]  [&lt;ffffffff81211017&gt;] chrdev_open+0xb7/0x1a0
&lt;4&gt;[19964.897694]  [&lt;ffffffff81210f60&gt;] ? cdev_put+0x30/0x30
&lt;4&gt;[19964.897698]  [&lt;ffffffff81209832&gt;] do_dentry_open+0x1d2/0x320
&lt;4&gt;[19964.897702]  [&lt;ffffffff81209b61&gt;] finish_open+0x31/0x50
&lt;4&gt;[19964.897706]  [&lt;ffffffff8121cd7c&gt;] do_last+0xc0c/0x11d0
&lt;4&gt;[19964.897710]  [&lt;ffffffff81217bd8&gt;] ? inode_permission+0x18/0x50
&lt;4&gt;[19964.897713]  [&lt;ffffffff812180e9&gt;] ? link_path_walk+0x99/0xee0
&lt;4&gt;[19964.897717]  [&lt;ffffffff8121d40b&gt;] path_openat+0xcb/0x6d0
&lt;4&gt;[19964.897722]  [&lt;ffffffff8121e2ad&gt;] do_filp_open+0x4d/0xc0
&lt;4&gt;[19964.897726]  [&lt;ffffffff812178db&gt;] ? getname_flags+0x4b/0x180
&lt;4&gt;[19964.897731]  [&lt;ffffffff8122b01e&gt;] ? __alloc_fd+0x7e/0x120
&lt;4&gt;[19964.897735]  [&lt;ffffffff8120b61b&gt;] do_sys_open+0x13b/0x250
&lt;4&gt;[19964.897738]  [&lt;ffffffff8120b74e&gt;] SyS_open+0x1e/0x20
&lt;4&gt;[19964.897743]  [&lt;ffffffff81746ae9&gt;] system_call_fastpath+0x16/0x1b


&lt;4&gt;[19965.026562]  [&lt;ffffffff8173f929&gt;] dump_stack+0x45/0x56
&lt;4&gt;[19965.026569]  [&lt;ffffffffa04aa094&gt;] c0087_write+0x24/0x100 [usb_com_1p_driver]
&lt;4&gt;[19965.026575]  [&lt;ffffffff81567890&gt;] serial_write+0x50/0xc0
&lt;4&gt;[19965.026581]  [&lt;ffffffff814584e5&gt;] n_tty_write+0x495/0x560
&lt;4&gt;[19965.026586]  [&lt;ffffffff810c2850&gt;] ? wake_up_state+0x20/0x20
&lt;4&gt;[19965.026590]  [&lt;ffffffff81454a04&gt;] tty_write+0x174/0x300
&lt;4&gt;[19965.026594]  [&lt;ffffffff81458050&gt;] ? process_echoes+0x70/0x70
&lt;4&gt;[19965.026599]  [&lt;ffffffff8120c597&gt;] vfs_write+0xb7/0x1f0
&lt;4&gt;[19965.026603]  [&lt;ffffffff8120d1c5&gt;] SyS_write+0x55/0xd0
&lt;4&gt;[19965.026608]  [&lt;ffffffff81746ae9&gt;] system_call_fastpath+0x16/0x1b
</code></pre>

<p>2nd open() and write(). The kernel writes ""7e 0 78 f0 7e"" twice.</p>

<pre><code>&lt;4&gt;[19977.011908] Call Trace:
&lt;4&gt;[19977.011918]  [&lt;ffffffff8173f929&gt;] dump_stack+0x45/0x56
&lt;4&gt;[19977.011925]  [&lt;ffffffffa04aa1ef&gt;] c0087_open+0x2f/0x160 [usb_com_1p_driver]
&lt;4&gt;[19977.011930]  [&lt;ffffffff81744bb2&gt;] ? down_write+0x12/0x40
&lt;4&gt;[19977.011936]  [&lt;ffffffff81566f75&gt;] serial_port_activate+0x65/0x90
&lt;4&gt;[19977.011941]  [&lt;ffffffff8145e864&gt;] ? tty_port_tty_set+0x64/0xa0
&lt;4&gt;[19977.011945]  [&lt;ffffffff8145edf9&gt;] tty_port_open+0x89/0xe0
&lt;4&gt;[19977.011949]  [&lt;ffffffff81567bf3&gt;] serial_open+0x33/0x70
&lt;4&gt;[19977.011952]  [&lt;ffffffff814560eb&gt;] tty_open+0x17b/0x700
&lt;4&gt;[19977.011958]  [&lt;ffffffff81211017&gt;] chrdev_open+0xb7/0x1a0
&lt;4&gt;[19977.011961]  [&lt;ffffffff81210f60&gt;] ? cdev_put+0x30/0x30
&lt;4&gt;[19977.011965]  [&lt;ffffffff81209832&gt;] do_dentry_open+0x1d2/0x320
&lt;4&gt;[19977.011968]  [&lt;ffffffff81209b61&gt;] finish_open+0x31/0x50
&lt;4&gt;[19977.011972]  [&lt;ffffffff8121cd7c&gt;] do_last+0xc0c/0x11d0
&lt;4&gt;[19977.011975]  [&lt;ffffffff81217bd8&gt;] ? inode_permission+0x18/0x50
&lt;4&gt;[19977.011979]  [&lt;ffffffff812180e9&gt;] ? link_path_walk+0x99/0xee0
&lt;4&gt;[19977.011983]  [&lt;ffffffff8121d40b&gt;] path_openat+0xcb/0x6d0
&lt;4&gt;[19977.011986]  [&lt;ffffffff81455de0&gt;] ? tty_release+0x4c0/0x650
&lt;4&gt;[19977.011990]  [&lt;ffffffff8121e2ad&gt;] do_filp_open+0x4d/0xc0
&lt;4&gt;[19977.011993]  [&lt;ffffffff812178db&gt;] ? getname_flags+0x4b/0x180
&lt;4&gt;[19977.011998]  [&lt;ffffffff8122b01e&gt;] ? __alloc_fd+0x7e/0x120
&lt;4&gt;[19977.012002]  [&lt;ffffffff8120b61b&gt;] do_sys_open+0x13b/0x250
&lt;4&gt;[19977.012025]  [&lt;ffffffff8120b74e&gt;] SyS_open+0x1e/0x20
&lt;4&gt;[19977.012031]  [&lt;ffffffff81746ae9&gt;] system_call_fastpath+0x16/0x1b



&lt;4&gt;[19977.026758]  [&lt;ffffffff8173f929&gt;] dump_stack+0x45/0x56
&lt;4&gt;[19977.026766]  [&lt;ffffffffa04aa094&gt;] c0087_write+0x24/0x100 [usb_com_1p_driver]
&lt;4&gt;[19977.026772]  [&lt;ffffffff81567890&gt;] serial_write+0x50/0xc0
&lt;4&gt;[19977.026777]  [&lt;ffffffff814584e5&gt;] n_tty_write+0x495/0x560
&lt;4&gt;[19977.026782]  [&lt;ffffffff810c2850&gt;] ? wake_up_state+0x20/0x20
&lt;4&gt;[19977.026786]  [&lt;ffffffff81454a04&gt;] tty_write+0x174/0x300
&lt;4&gt;[19977.026789]  [&lt;ffffffff81458050&gt;] ? process_echoes+0x70/0x70
&lt;4&gt;[19977.026794]  [&lt;ffffffff8120c597&gt;] vfs_write+0xb7/0x1f0
&lt;4&gt;[19977.026797]  [&lt;ffffffff8120d1c5&gt;] SyS_write+0x55/0xd0
&lt;4&gt;[19977.026802]  [&lt;ffffffff81746ae9&gt;] system_call_fastpath+0x16/0x1b
</code></pre>

<p>Anybody knows what happens here?</p>

<p>Thanks!</p>
"
"<p>I know how to generate a core dump on OS X when a process crashes, but what I really need to do is attach to a process, generate a core dump, then resume that process (without killing it).</p>

<p>A long time ago (maybe a year and a half ago) I had C code that would do this...  It used the OS X kernel libraries to connect to a process, read all of its thread states and memory, and write that into a Mach-O file on disk.  This worked great (and it's exactly what I'm looking for), but now I can't seem to find that code for the life of me.  I seem to recall that code was related somewhat to the OS X system internals book, but that's just a vague recollection.</p>

<p>Does anyone know the code I'm talking about and could point me at it?  If not does anyone know a good way of doing this preferably with some example code?</p>

<p>Edit:  Here is the answer.</p>

<p>Information:  <a href=""http://osxbook.com/book/bonus/chapter8/core/"" rel=""noreferrer"">http://osxbook.com/book/bonus/chapter8/core/</a></p>

<p>Program that will do it for you:  <a href=""http://osxbook.com/book/bonus/chapter8/core/download/gcore-1.3.tar.gz"" rel=""noreferrer"">http://osxbook.com/book/bonus/chapter8/core/download/gcore-1.3.tar.gz</a></p>
"
"<p>I want to get a list of all PFNs which belong to the pagecache. One way is to go over each open file/inode and get the <code>address_space</code> pages.
Is there a simpler way? Cannot seem to find a big list of cache-pages .
Is there any such list/API i can use ?</p>
"
"<p>I am working on modifying the didactic OS xv6 (written in c) to support symbolic links (AKA shortcuts).
A symbolic link is a file of type T_SYM that contains a path to it's destination.
For doing that, i wrote a recursive function that gets a path and a buffer and fills the buffer with the ""real"" path (i.e. if the path contains a link, it should be replaced by the real path, and a link can occur at any level in the path).</p>

<p>Basically, if i have a path a/b/c/d, and a link from f to a/b, the following operations should be equivalent:</p>

<p>cd a/b/c/d</p>

<p>cd f/c/d</p>

<p>Now, the code is written, but the problem that i try to solve is the problem of starting the path with ""/"" (meaning that the path is absolute and not relative).
Right now, if i run it with a path named /dir1 it treats it like dir1 (relative instead of absolute).</p>

<p>This is the main function, it calls the recursive function.
pathname is the given path, buf will contain the real path.</p>

<pre><code>int readlink(char *pathname, char *buf, size_t bufsize){
    char name[DIRSIZ];
    char realpathname[100];

    memset(realpathname,0,100);
    realpathname[0] = '/';

    if(get_real_path(pathname, name, realpathname, 0, 0)){
       memmove(buf, realpathname, strlen(realpathname));
       return strlen(realpathname);
    }

    return -1;
}
</code></pre>

<p>This is the recursive part.
the function returns an inode structure (which represents a file or directory in the system). it builds the real path inside realpath.
ilock an iunlock are being used to use the inode safely.</p>

<pre><code>struct inode* get_real_path(char *path, char *name, char* realpath, int position){
    struct inode *ip, *next;
    char buf[100];
    char newpath[100];

    if(*path == '/')
        ip = iget(ROOTDEV, ROOTINO);// ip gets the root directory
    else
        ip = idup(proc-&gt;cwd); // ip gets the current working directory

    while((path = skipelem(path, name)) != 0){name will get the next directory in the path, path will get the rest of the directories
        ilock(ip);
        if(ip-&gt;type != T_DIR){//if ip is a directory
            realpath[position-1] = '\0';
            iunlockput(ip);
            return 0;
        }

        if((next = dirlookup(ip, name, 0)) == 0){//next will get the inode of the next directory
            realpath[position-1] = '\0';
            iunlockput(ip);
            return 0;
        }
        iunlock(ip);

        ilock(next);

        if (next-&gt;type == T_SYM){ //if next is a symbolic link
            readi(next, buf, 0, next-&gt;size); //buf contains the path inside the symbolic link (which is a path)
            buf[next-&gt;size] = 0;
            iunlockput(next);

            next = get_real_path(buf, name, newpath, 0);//call it recursively (might still be a symbolic link)

            if(next == 0){
                realpath[position-1] = '\0';
                iput(ip);

                return 0;
            }

            name = newpath;
            position = 0;
        }
        else
        iunlock(next);

        memmove(realpath + position, name, strlen(name));
        position += strlen(name);
        realpath[position++]='/';
        realpath[position] = '\0';

        iput(ip);

        ip = next;
    }
    realpath[position-1] = '\0';

    return ip;
}
</code></pre>

<p>I have tried many ways to do it right but with no success. If anyone sees the problem, i'd be happy to hear the solution.
Thanks,
Eyal</p>
"
"<p>I have this piece of code for instance:</p>

<pre><code>while(true){
    printf(""looping"");
    getch();
}
</code></pre>

<p>Instead of waiting for user input on each loop, the loop just continues without me; printing</p>

<pre><code>loop
loop
loop
</code></pre>

<p>until I close the program.</p>

<p>Is there a better way to read a single character ? All i really want to do is to have the user input a 'y' or a 'n'</p>
"
"<p>Assuming this is my file:</p>

<pre><code>$ cat file.txt
A:1:i
B:2:ii
X:9:iv
</code></pre>

<p>With a for loop like this I can print all the fields separately and redirect to sub-file</p>

<pre><code>$ for i in $(seq 1 3); do echo $i; awk -F "":"" -v FL=$i '{print $FL}' file.txt &gt; $i.out; done
</code></pre>

<p>So that:</p>

<pre><code>$ cat 1.out
A
B
X

$ cat 2.out
1
2
9

$ cat 3.out
i
ii
iv
</code></pre>

<p>Question:
I have to perform this on nearly 70 columns and on file size of nearly 10 GB. It works, but slow.
Can anyone suggest a better/efficient split to work on this big data set. Thanks. </p>

<pre><code>$ for i in $(seq 1 70); do echo $i; awk -F "":"" -v FL=$i '{print $FL}' *.data &gt; $i.out; done
</code></pre>
"
"<p>I am not sure what I am doing wrong, I did a similar problem but with reading numbers and it work, what this program is suppose to do is read in a names.txt this document contains names (last,first)</p>

<p>so the text has</p>

<blockquote>
  <p>washington, george</p>

  <p>adams, john</p>

  <p>jefferson, thomas
  etc....</p>
</blockquote>

<p>My program reads in the names but my output is not right, the output is: </p>

<blockquote>
  <p>Washington, George</p>

  <p>WAdams, GJohn</p>

  <p>WAJefferson, GJThomas</p>
</blockquote>

<p>So when it reads the next line it retains the first letter of the previous name?  </p>

<pre><code>#include &lt;stdio.h&gt;

int main(void)
{

    char first_n[70];
    char last_n[70];

    int i=0;
    FILE *oput;
    FILE *iput;

    iput = fopen( ""names.txt"",""r"" );
    while ( fscanf( iput,""%s %s"", &amp;last_n[i],&amp;first_n[i] ) !=  EOF )
    {
        i++;
        printf(""%s %s\n"",last_n,first_n);
    }

    oput=fopen(""user_name_info.txt"",""wt""); //opens output file
    fprintf(oput, ""Last\t\tFirst\n------------\t-------------\n%s\t%s\n"",last_n,first_n);

    return 0;
}
</code></pre>

<p>What am I doing wrong?</p>
"
"<p>Using the same machine and IDE as reffered in my other question (third paragraph at <a href=""https://stackoverflow.com/questions/13987812/problems-in-code-or-my-ide-comp-is-bugged"">Problems in code or my IDE/comp is bugged?</a>)</p>

<p>I try to run this code:</p>

<pre><code>#include &lt;stdio.h&gt;
#define n 3
int main()
{
    int i;
    float values[n],sumval,svmean,tmp;
    for(i=0;i&lt;n;++i)
    {
        scanf(""%f"",&amp;tmp);
        values[i]=tmp;
        sumval = sumval + values[i];
    }
    svmean = sumval/n;
    printf(""%f \n"",svmean);
    return(0);
}
</code></pre>

<p>The above code is supposed to run this formula </p>

<p><img src=""https://i.stack.imgur.com/EqaJv.jpg"" alt=""http://img850.imageshack.us/img850/6894/95871186.jpg""></p>

<p>That means that it has to add some values and divide the result by their total number.</p>

<p>As you see above I made an array with random <code>n</code> positions and I ask the user to fill in a value for each position then add them all up and divide them.</p>

<p>The problem is that it doesnt work. It outputs only the result 7 no matter what the iput is.</p>

<p>BUT if I include stdlib.h to the code it works fine.</p>

<p>so</p>

<ul>
<li><strong>Question A</strong>: why the code does not work properly using only the
stdio.h library? which element of the code does require the stdlib.h
library?</li>
</ul>

<p>As you see the array <code>values[n]</code> seems to have an random <code>n</code> number of cells but actually I have already set this numer to be equal to 3 (using <code>#define</code>)</p>

<ul>
<li><strong>Question B</strong>: Is there a way to run a code with the same porpuse but letting the user to define the size of the array <code>values[n]</code> or in other words let the user input an integer  that sets the value of <code>n</code> in <code>values[n]</code>?</li>
</ul>
"
"<p>I'm trying to ask the user to type in a string so I will print the length of the string.  My code is built succeeded. However, when I entered a word and pressed 'enter', the program keeps running.  I had to enter a second word, then the length of the first string displays.  I'm confused at argv[1].  Can someone give me some tips and hint on how to fix this? Thanks in advance for your time.</p>

<p>Please note that I'm not allowed to use any string function. </p>

<pre><code>   int main(int argc, char* argv[]){

    char* s=argv[1];

    char input[256];
    s = input;
    printf(""Please enter a string: "");
    scanf(""%s\n"", s);
    int str_length = 0;
    while (s[str_length] != '\0')
    {
        str_length++;
        if (s[str_length] == '\0') break;
    }

    printf(""%d\n"", str_length);


    return 0;
}
</code></pre>
"
"<p>Here is what I have:</p>

<pre><code>char* input = new char [input_max]
char* inputPtr = iput;
</code></pre>

<p>I want to use the inputPtr to traverse the input array. However I am not sure what will correctly check whether or not I have reached the end of the string:</p>

<pre><code>while (*inputPtr++)
{
    // Some code
}
</code></pre>

<p>or</p>

<pre><code>while (*inputPtr != '\0')
{
    inputPtr++;
    // Some code
}
</code></pre>

<p>or a more elegant option?</p>
"
"<p>I have a string variable containing date in <code>yyyy/mm/dd</code> format. How to convert it into <code>time_t</code> type in C++? eg: <code>string date_details = ""2012/09/12""</code></p>

<p>Also, how to compare two variables containing date as to decide which is the earliest in C++? eg: <code>string curr_date = ""2012/09/13"" string user_date = ""2012/09/12""</code></p>

<p>Thanks.</p>
"
"<p><strong>The Situation</strong>  </p>

<p>After reading <em>Unix Socket Programming</em>, <em>W.Richard Steven</em>, I'm writing a P2P program in which the main thread creates thread pool in which five sub-threads live. it then monitors 50 sockets with <code>kqueue()</code>. when a event occurs in a specified socket (e.g, receiving data on the socket.), the main thread copies socket descriptor into a shared array and awakes one thread in the thread pool. the sub thread then processes a request from the socket. Also, I have protected the shared array using both mutex variable and conditional variable.  </p>

<p><strong>Question</strong>  </p>

<p>The Author presents the source codes ""server/serv08.c"" and ""server/pthread08.c"" in the Section 30.12 and 30.13 in the book, respectively, as if there is no something wrong with this code. But, when I've written a code snippet similar to one author present, thread synchronization doesn't work well.  Why does <code>iput</code> become equal to <code>iget</code> in main thread?  </p>

<p><strong>Code</strong><br>
--Global variable--</p>

<pre><code>typedef struct tagThread_information
{

    int     sockfd;

} Thread_information;
Thread_information      peer_fds[MAX_THREAD];
pthread_mutex_t         peerfd_mutex;
pthread_cond_t          peerfd_cond;
pthread_mutex_t         STDOUT_mutex;
int                     iput;
int                     iget;
</code></pre>

<p>--Main thread--  </p>

<pre><code>void Wait_for_Handshake(download_session *pSession, int nMaxPeers)
{
struct kevent   ev[50], result[50];
int             kq, i, nfd;
int c = 1;

if( (kq = kqueue()) == -1)
{
    fprintf(stderr, ""fail to initialize kqueue.\n"");
    exit(0);
}

for(i = 0 ; i &lt; nMaxPeers; i++)
{
    EV_SET(&amp;ev[i], pSession-&gt;Peers[i].sockfd, EVFILT_READ, EV_ADD, 0, 0, 0);
    printf(""socket : %d\n"", (int)ev[i].ident);
}

// create thread pool. initialize mutex and conditional variable.
iput = 0;
iget = 0;
pthread_mutex_init(&amp;STDOUT_mutex, NULL);
pthread_mutex_init(&amp;peerfd_mutex, NULL);
pthread_cond_init(&amp;peerfd_cond, NULL);

// Assume that MAX_THREAD is set to 5.
for(i = 0 ; i &lt; MAX_THREAD; i++)
    thread_make(i);


while(1)
{
    nfd = kevent(kq, ev, nMaxPeers, result, nMaxPeers, NULL);

    if(nfd == -1)
    {
        fprintf(stderr, ""fail to monitor kqueue. error : %d\n"", errno);
        nMaxPeers           =   Update_peer(ev, pSession-&gt;nPeers);
        pSession-&gt;nPeers    =   nMaxPeers;
        continue;
    }

    for(i = 0 ; i &lt; nfd; i++)
    {

        pthread_mutex_lock(&amp;peerfd_mutex);
        peer_fds[iput].sockfd = (int)result[i].ident;
        if( ++iput == MAX_THREAD)
            iput = 0;
        if(iput == iget) // Here is my question.
        {
            exit(0);
        }

        pthread_cond_signal(&amp;peerfd_cond);
        pthread_mutex_unlock(&amp;peerfd_mutex);


    }

}

}
</code></pre>

<p>--sub thread--</p>

<pre><code>void * thread_main(void *arg)
{
    int     connfd, nbytes;
    char    buf[2048];
    for( ; ; )
    {
        /* get socket descriptor */
        pthread_mutex_lock(&amp;peerfd_mutex);
        while( iget == iput)
            pthread_cond_wait(&amp;peerfd_cond, &amp;peerfd_mutex);
        connfd  =   peer_fds[iget].sockfd;
        if ( ++iget == MAX_THREAD )
            iget = 0;
        pthread_mutex_unlock(&amp;peerfd_mutex);


    /* process a request on socket descriptor. */
    nbytes  =   (int)read(connfd, buf, 2048);

    if(nbytes == 0)
    {
        pthread_mutex_lock(&amp;STDOUT_mutex);
        printf(""\n\nthread %ld, socket : %d, nbytes : %d\n\n\n"", (long int)pthread_self(), connfd, nbytes);
        printf(""socket closed\n\n"");
        pthread_mutex_unlock(&amp;STDOUT_mutex);
        close(connfd);
        continue;
    }
    else if(nbytes == -1)
    {
        close(connfd);
        pthread_mutex_lock(&amp;STDOUT_mutex);
        printf(""\n\nthread %ld, socket : %d, nbytes : %d\n\n\n"", (long int)pthread_self(), connfd, nbytes);
        perror(""socket error : "");
        write(STDOUT_FILENO, buf, nbytes);
        printf(""\n\n\n\n"");
        pthread_mutex_unlock(&amp;STDOUT_mutex);

        continue;
    }

    pthread_mutex_lock(&amp;STDOUT_mutex);
    printf(""\n\nthread %ld, socket : %d, nbytes : %d\n\n\n"", (long int)pthread_self(), connfd, nbytes);
    write(STDOUT_FILENO, buf, nbytes);
    printf(""\n\n\n\n"");
    pthread_mutex_unlock(&amp;STDOUT_mutex);

}
}
</code></pre>
"
"<p>I want to show an uploaded image before clicking on an upload button. I tried but its not working, please check my code below. when I select an image to load then no image will come and after with the help of firebug I found that my code is making weird url's. you can also check fiddle here: <strong><a href=""http://jsfiddle.net/XdXLJ/"" rel=""nofollow"">http://jsfiddle.net/XdXLJ/</a></strong></p>

<p><strong>Script</strong></p>

<pre><code>$(document).ready(function(e) {
    $('#upload').click(function(){
        $('input[type=""file""]').show().focus().click().hide();
        $('input[type=""file""]').change(function(){

            var val = $('this').val;
            $('.img').append('&lt;img src=""'+val+'"" /&gt;')

            })
        })
})
</code></pre>

<p><strong>HTML</strong></p>

<pre><code>&lt;form id=""form1"" name=""form1"" method=""post"" action=""""&gt;
&lt;input name="""" type=""file"" /&gt;
&lt;div id=""upload""&gt;Upload&lt;/div&gt;
&lt;div class=""img""&gt;&lt;/div&gt;
&lt;/form&gt;
</code></pre>

<p><strong>Style</strong></p>

<pre><code>#upload{float:left; padding:8px 10px; color:#000; background:#CCC; border:1px solid #000;}
input[type=""file""]{display:none;}
</code></pre>
"
"<p>I receive the following error:</p>

<pre><code>kernel/proc.c:516: error: expected declaration or statement at end of input
</code></pre>

<p>Can you please help me figure out how to fix this error?
Here is the code:</p>

<pre><code>#include ""types.h""
#include ""defs.h""
#include ""param.h""
#include ""mmu.h""
#include ""x86.h""
#include ""proc.h""
#include ""spinlock.h""

struct {
  struct spinlock lock;
  struct proc proc[NPROC];
} ptable;

static struct proc *initproc;

static int num_tickets=0;  //mona2
unsigned long winner;
int nextpid = 1;
extern void forkret(void);
extern void trapret(void);


///// mona2  lcg invariant //not working because of uint32_t

/*
static uint32_t temper(uint32_t x)
{
    x ^= x&gt;&gt;11;
    x ^= x&lt;&lt;7 &amp; 0x9D2C5680;
    x ^= x&lt;&lt;15 &amp; 0xEFC60000;
    x ^= x&gt;&gt;18;
    return x;
}
uint32_t lcg64_temper(uint64_t *seed)
{
    *seed = 6364136223846793005ULL * *seed + 1;
    return temper(*seed &gt;&gt; 32);
}
*/

static
unsigned long
lcg_rand(unsigned long a)
{
  return (a * 279470273UL) % 4294967291UL;
}




static void wakeup1(void *chan);


void
pinit(void)
{
  initlock(&amp;ptable.lock, ""ptable"");
}

// Look in the process table for an UNUSED proc.
// If found, change state to EMBRYO and initialize
// state required to run in the kernel.
// Otherwise return 0.
static struct proc*
allocproc(void)
{
  struct proc *p;
  char *sp;

  acquire(&amp;ptable.lock);
  for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)
    if(p-&gt;state == UNUSED)
      {
        goto found;
        p-&gt;tickets=CREATION_TICKET; //mona2
        num_tickets+=CREATION_TICKET; //mona2
      }
  release(&amp;ptable.lock);
  return 0;

found:
  p-&gt;state = EMBRYO;
  p-&gt;pid = nextpid++;
  release(&amp;ptable.lock);

  // Allocate kernel stack if possible.
  if((p-&gt;kstack = kalloc()) == 0){
    p-&gt;state = UNUSED;
    return 0;
  }
  sp = p-&gt;kstack + KSTACKSIZE;

  // Leave room for trap frame.
  sp -= sizeof *p-&gt;tf;
  p-&gt;tf = (struct trapframe*)sp;

  // Set up new context to start executing at forkret,
  // which returns to trapret.
  sp -= 4;
  *(uint*)sp = (uint)trapret;

  sp -= sizeof *p-&gt;context;
  p-&gt;context = (struct context*)sp;
  memset(p-&gt;context, 0, sizeof *p-&gt;context);
  p-&gt;context-&gt;eip = (uint)forkret;

  return p;
}

// Set up first user process.
void
userinit(void)
{
  struct proc *p;
  extern char _binary_initcode_start[], _binary_initcode_size[];

  p = allocproc();
  acquire(&amp;ptable.lock);
  initproc = p;
  if((p-&gt;pgdir = setupkvm()) == 0)
    panic(""userinit: out of memory?"");
  inituvm(p-&gt;pgdir, _binary_initcode_start, (int)_binary_initcode_size);
  p-&gt;sz = PGSIZE;
  memset(p-&gt;tf, 0, sizeof(*p-&gt;tf));
  p-&gt;tf-&gt;cs = (SEG_UCODE &lt;&lt; 3) | DPL_USER;
  p-&gt;tf-&gt;ds = (SEG_UDATA &lt;&lt; 3) | DPL_USER;
  p-&gt;tf-&gt;es = p-&gt;tf-&gt;ds;
  p-&gt;tf-&gt;ss = p-&gt;tf-&gt;ds;
  p-&gt;tf-&gt;eflags = FL_IF;
  p-&gt;tf-&gt;esp = PGSIZE;
  p-&gt;tf-&gt;eip = 0;  // beginning of initcode.S

  safestrcpy(p-&gt;name, ""initcode"", sizeof(p-&gt;name));
  p-&gt;cwd = namei(""/"");

  p-&gt;state = RUNNABLE;
  p-&gt;tickets=CREATION_TICKET;
  release(&amp;ptable.lock);
}

// Grow current process's memory by n bytes.
// Return 0 on success, -1 on failure.
int
growproc(int n)
{
  uint sz;

  sz = proc-&gt;sz;
  if(n &gt; 0){
    if((sz = allocuvm(proc-&gt;pgdir, sz, sz + n)) == 0)
      return -1;
  } else if(n &lt; 0){
    if((sz = deallocuvm(proc-&gt;pgdir, sz, sz + n)) == 0)
      return -1;
  }
  proc-&gt;sz = sz;
  switchuvm(proc);
  return 0;
}

// Create a new process copying p as the parent.
// Sets up stack to return as if from system call.
// Caller must set state of returned proc to RUNNABLE.
int
fork(void)
{
  int i, pid;
  struct proc *np;

  // Allocate process.
  if((np = allocproc()) == 0)
    return -1;

  // Copy process state from p.
  if((np-&gt;pgdir = copyuvm(proc-&gt;pgdir, proc-&gt;sz)) == 0){
    kfree(np-&gt;kstack);
    np-&gt;kstack = 0;
    np-&gt;state = UNUSED;
    return -1;
  }
  np-&gt;sz = proc-&gt;sz;
  np-&gt;parent = proc;
  *np-&gt;tf = *proc-&gt;tf;

  // Clear %eax so that fork returns 0 in the child.
  np-&gt;tf-&gt;eax = 0;

  for(i = 0; i &lt; NOFILE; i++)
    if(proc-&gt;ofile[i])
      np-&gt;ofile[i] = filedup(proc-&gt;ofile[i]);
  np-&gt;cwd = idup(proc-&gt;cwd);

  pid = np-&gt;pid;
  np-&gt;state = RUNNABLE;
  safestrcpy(np-&gt;name, proc-&gt;name, sizeof(proc-&gt;name));
  return pid;
}

// Exit the current process.  Does not return.
// An exited process remains in the zombie state
// until its parent calls wait() to find out it exited.
void
exit(void)
{
  struct proc *p;
  int fd;

  if(proc == initproc)
    panic(""init exiting"");

  // Close all open files.
  for(fd = 0; fd &lt; NOFILE; fd++){
    if(proc-&gt;ofile[fd]){
      fileclose(proc-&gt;ofile[fd]);
      proc-&gt;ofile[fd] = 0;
    }
  }

  iput(proc-&gt;cwd);
  proc-&gt;cwd = 0;

  acquire(&amp;ptable.lock);

  // Parent might be sleeping in wait().
  wakeup1(proc-&gt;parent);

  // Pass abandoned children to init.
  for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){
    if(p-&gt;parent == proc){
      p-&gt;parent = initproc;
      if(p-&gt;state == ZOMBIE)
        wakeup1(initproc);
    }
  }

  // Jump into the scheduler, never to return.
  proc-&gt;state = ZOMBIE;
  sched();
  panic(""zombie exit"");
}

// Wait for a child process to exit and return its pid.
// Return -1 if this process has no children.
int
wait(void)
{
  struct proc *p;
  int havekids, pid;

  acquire(&amp;ptable.lock);
  for(;;){
    // Scan through table looking for zombie children.
    havekids = 0;
    for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){
      if(p-&gt;parent != proc)
        continue;
      havekids = 1;
      if(p-&gt;state == ZOMBIE){
        // Found one.
        pid = p-&gt;pid;
        kfree(p-&gt;kstack);
        p-&gt;kstack = 0;
        freevm(p-&gt;pgdir);
        p-&gt;state = UNUSED;
        p-&gt;pid = 0;
        p-&gt;parent = 0;
        p-&gt;name[0] = 0;
        p-&gt;killed = 0;
        release(&amp;ptable.lock);
        return pid;
      }
    }

    // No point waiting if we don't have any children.
    if(!havekids || proc-&gt;killed){
      release(&amp;ptable.lock);
      return -1;
    }

    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
    sleep(proc, &amp;ptable.lock);  //DOC: wait-sleep
  }
}

// Per-CPU process scheduler.
// Each CPU calls scheduler() after setting itself up.
// Scheduler never returns.  It loops, doing:
//  - choose a process to run
//  - swtch to start running that process
//  - eventually that process transfers control
//      via swtch back to the scheduler.
void
scheduler(void)
{
  struct proc *p;
  int seed=0;
  for(;;){
    // Enable interrupts on this processor.
    sti();
    seed++;
   // winner = lcg64_temper(seed) % num_tickets;
    winner = lcg_rand(seed) % num_tickets;


    // Loop over process table looking for process to run.
    acquire(&amp;ptable.lock);
    for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){
      if(p-&gt;state != RUNNABLE)
        continue;

      // Switch to chosen process.  It is the process's job
      // to release ptable.lock and then reacquire it
      // before jumping back to us.
      proc = p;
      switchuvm(p);
      p-&gt;state = RUNNING;
      swtch(&amp;cpu-&gt;scheduler, proc-&gt;context);
      switchkvm();

      // Process is done running for now.
      // It should have changed its p-&gt;state before coming back.
      proc = 0;
    }
    release(&amp;ptable.lock);

  }
}

// Enter scheduler.  Must hold only ptable.lock
// and have changed proc-&gt;state.
void
sched(void)
{
  int intena;

  if(!holding(&amp;ptable.lock))
    panic(""sched ptable.lock"");
  if(cpu-&gt;ncli != 1)
    panic(""sched locks"");
  if(proc-&gt;state == RUNNING)
    panic(""sched running"");
  if(readeflags()&amp;FL_IF)
    panic(""sched interruptible"");
  intena = cpu-&gt;intena;
  swtch(&amp;proc-&gt;context, cpu-&gt;scheduler);
  cpu-&gt;intena = intena;
}

// Give up the CPU for one scheduling round.
void
yield(void)
{
  acquire(&amp;ptable.lock);  //DOC: yieldlock
  proc-&gt;state = RUNNABLE;
  sched();
  release(&amp;ptable.lock);
}

// A fork child's very first scheduling by scheduler()
// will swtch here.  ""Return"" to user space.
void
forkret(void)
{
  // Still holding ptable.lock from scheduler.
  release(&amp;ptable.lock);

  // Return to ""caller"", actually trapret (see allocproc).
}

// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
void
sleep(void *chan, struct spinlock *lk)
{
  if(proc == 0)
    panic(""sleep"");

  if(lk == 0)
    panic(""sleep without lk"");

  // Must acquire ptable.lock in order to
  // change p-&gt;state and then call sched.
  // Once we hold ptable.lock, we can be
  // guaranteed that we won't miss any wakeup
  // (wakeup runs with ptable.lock locked),
  // so it's okay to release lk.
  if(lk != &amp;ptable.lock){  //DOC: sleeplock0
    acquire(&amp;ptable.lock);  //DOC: sleeplock1
    release(lk);
  }

  // Go to sleep.
  proc-&gt;chan = chan;
  proc-&gt;state = SLEEPING;
  sched();

  // Tidy up.
  proc-&gt;chan = 0;

  // Reacquire original lock.
  if(lk != &amp;ptable.lock){  //DOC: sleeplock2
    release(&amp;ptable.lock);
    acquire(lk);
  }
}

// Wake up all processes sleeping on chan.
// The ptable lock must be held.
static void
wakeup1(void *chan)
{
  struct proc *p;

  for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)
    if(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan)
      p-&gt;state = RUNNABLE;
}

// Wake up all processes sleeping on chan.
void
wakeup(void *chan)
{
  acquire(&amp;ptable.lock);
  wakeup1(chan);
  release(&amp;ptable.lock);
}

// Kill the process with the given pid.
// Process won't exit until it returns
// to user space (see trap in trap.c).
int
kill(int pid)
{
  struct proc *p;

  acquire(&amp;ptable.lock);
  for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){
    if(p-&gt;pid == pid){
      p-&gt;killed = 1;
      // Wake process from sleep if necessary.
      if(p-&gt;state == SLEEPING)
        p-&gt;state = RUNNABLE;
      release(&amp;ptable.lock);
      return 0;
    }
  }
  release(&amp;ptable.lock);
  return -1;
}

// Print a process listing to console.  For debugging.
// Runs when user types ^P on console.
// No lock to avoid wedging a stuck machine further.

int
lottery(int tickets, int pid)
{
  int i;
  struct proc *p;

  //acquire(&amp;proc_table_lock);
  acquire(&amp;ptable.lock); //mona2
  for(i = 0; i &lt; NPROC; i++){
    p = &amp;proc[i];

    if(p-&gt;pid != pid)
      continue;

    if(p-&gt;state == UNUSED)
      return -1;

    if(p-&gt;state == RUNNING || p-&gt;state == RUNNABLE)
      num_tickets += (tickets - p-&gt;tickets);

    p-&gt;tickets = tickets;
    //release(&amp;proc_table_lock);

    release(&amp;ptable.lock); //mona2
    return 0;
   }

}


void
procdump(void)
{
  static char *states[] = {
  [UNUSED]    ""unused"",
  [EMBRYO]    ""embryo"",
  [SLEEPING]  ""sleep "",
  [RUNNABLE]  ""runble"",
  [RUNNING]   ""run   "",
  [ZOMBIE]    ""zombie""
  };
  int i;
  struct proc *p;
  char *state;
  uint pc[10];

  for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++){
    if(p-&gt;state == UNUSED)
      continue;
    if(p-&gt;state &gt;= 0 &amp;&amp; p-&gt;state &lt; NELEM(states) &amp;&amp; states[p-&gt;state])
      state = states[p-&gt;state];
    else
      state = ""???"";
    cprintf(""%d %s %s"", p-&gt;pid, state, p-&gt;name);
    if(p-&gt;state == SLEEPING){
      getcallerpcs((uint*)p-&gt;context-&gt;ebp+2, pc);
      for(i=0; i&lt;10 &amp;&amp; pc[i] != 0; i++)
        cprintf("" %p"", pc[i]);
    }
    cprintf(""\n"");

}
</code></pre>
"
"<p>can any one help me about this</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;stdio.h&gt;

using namespace std;
int main () {



int A[100] , B[100] , C[100];

int i=0 ,j=0, h=0;

int connctive=0 ;

cout &lt;&lt; ""THE PROGRAM TAKE 3 GRAGHS ONLY\n"";


cout &lt;&lt; ""\n enter the Graph 1 \n"";
cin &gt;&gt; A[i];

cout &lt;&lt; ""\n enter the Graph 2 \n"";

cin &gt;&gt; B[j];

cout &lt;&lt; ""\n enter the Graph 3 \n"";
cin &gt;&gt; C[h];

for(i=0;i&lt;=100;i++ ){

for (j=0;j&lt;=100;j++){

        for(h=0;h&lt;=100;h++){

            if (A[i]==B[j]) {
                connctive = connctive +1;}

            if (A[i]==C[h]){
                connctive = connctive +1;}

            if (B[j]==C[h]){
                connctive = connctive +1;
            } else
       { if (A[i]!=B[j]!=C[h])
           cout &lt;&lt; ""non of graphs is connective"" &lt;&lt;endl;}}}
}




cout &lt;&lt; connctive &lt;&lt;""connctive "" &lt;&lt;endl;



return 0;

}
</code></pre>

<p>i'm working to solve this program i want to Compare 3 arrays and print out the Union numbers with name connective or not Can someone please explain to me why the output from the following code is saying that arrays are not connective all the time :( ?? even when i entered different numbers</p>
"
"<p>My code is as follows:</p>

<pre><code>double a,b; //These variable are inputs to the function
double *inArr; //This is also an iput to the function whose size is NumElements
double *arr = new double[numElements]; //NumElements is ~ 10^6
double sum = 0.0;
for(unsigned int i=0;i&lt;numElements;++i)
{
    double k = a*inArr[i] + b; //This doesn't take any time
    double el = arr[i]; //This doesn't take any time
    el *= k; //This doesn't take any time
    sum += el; //This takes a long time!!!
}
</code></pre>

<p>This code goes over the elements of an array each time calculating a value k, for each element it adds k times that element to sum. I separated the code into so many steps so that when my profiler tells me which line takes a long time I will know exactly which calculation is the culprit. My profiler tells me that adding el to sum is what's slowing down my program (this might seem a little strange that a simple addition would be slow but I call this function hundreds of times and each time it performs millions of calculations). My only theory is that because sum is in a different scope operations using it take longer. So I edited the code to be: </p>

<pre><code>double a,b; //These variable are inputs to the function
double *inArr; //This is also an iput to the function whose size is NumElements
double *arr = new double[numElements]; //NumElements is ~ 10^6
double sum = 0.0;
for(unsigned int i=0;i&lt;numElements;++i)
{
    double k = a*inArr[i] + b; //This doesn't take any time
    double el = arr[i]; //This doesn't take any time
    el *= k; //This doesn't take any time
    double temp = sum + el; //This doesn't take any time
    sum = el; //This takes a long time!!!
}
</code></pre>

<p>And now the sum operation takes very little time even though it accesses the sum variable. The assignment takes a long time now. Is my theory correct that the reason this happens is that it takes longer to assign to variables that aren't in the current scope? If so why is that true? Is there any way to make this assignment work quickly? I know I can optimize this using parallelization, I want to know if I can do any better serially. I am using VS 2012 running in release mode, I am using the VS performance analyzer as a profiler.</p>

<p><strong>Edit:</strong></p>

<p>Once I removed the optimization it turns out that the access to inArr is what is taking the most time.</p>
"
"<p>I am new in c++ programmation on Qt.
I do two classes Personnage and Arme.
I have 5 files Personnage.h, personnage.cpp, Arme.h and Arme.cpp</p>

<p>Arme.h</p>

<pre><code>#ifndef ARME_H
#define ARME_H
#include&lt;iostream&gt;
class Arme
{
public:
Arme();
Arme(int m_idArme,std::string m_nomArme);
void armeAffich() const;
public:
int idArme;
std::string nomArme;
};
#endif // ARME_H
</code></pre>

<p>Arme.cpp</p>

<pre><code>#include ""Arme.h""
#include&lt;string&gt;
#include&lt;iostream&gt;
using namespace std;
Arme::Arme():idArme(0),nomArme(0)
{

}
Arme::Arme(int m_idArme,string m_nomArme)
{
idArme=m_idArme;
nomArme=m_nomArme;
}

void Arme::armeAffich() const
{
cout&lt;&lt;""identifiant d'arme""&lt;&lt;idArme&lt;&lt;endl;
cout&lt;&lt;""nom d'arme""&lt;&lt;nomArme&lt;&lt;endl;
}
</code></pre>

<p>Personnage.h</p>

<pre><code>#ifndef PERSONNAGE_H
#define PERSONNAGE_H
#include ""Arme.h""
class Personnage
{
Personnage(std::string nom,std::string prenom);
Personnage();
~Personnage();
void affichPers() const;
public:
std::string nomPers;
std::string prenomPers;
Arme *arme;
};
#endif // PERSONNAGE_H
</code></pre>

<p>Personnage.cpp</p>

<pre><code>#include ""Arme.h""
#include&lt;string&gt;
#include&lt;iostream&gt;
using namespace std;
Arme::Arme():idArme(0),nomArme(0)
{

}
Arme::Arme(int m_idArme,string m_nomArme)
{
idArme=m_idArme;
nomArme=m_nomArme;
}

void Arme::armeAffich() const
{
cout&lt;&lt;""identifiant d'arme""&lt;&lt;idArme&lt;&lt;endl;
cout&lt;&lt;""nom d'arme""&lt;&lt;nomArme&lt;&lt;endl;
}
</code></pre>

<p>and in the main.cpp file, iput two instructions just for compiling.</p>

<pre><code>#include""Personnage.h""
#include&lt;iostream&gt;
using namespace std;
int main()
{
    cout&lt;&lt;""Hello word!"";
    return 1;
}
</code></pre>

<p>When I compiling i get these errors:</p>

<pre><code>duplicate symbol __ZN4ArmeC1Ev in:
    Arme.o
    Personnage.o
duplicate symbol __ZN4ArmeC2Ev in:
    Arme.o
    Personnage.o
duplicate symbol __ZN4ArmeC1EiSs in:
    Arme.o
    Personnage.o
duplicate symbol __ZN4ArmeC2EiSs in:
    Arme.o
    Personnage.o
duplicate symbol __ZNK4Arme10armeAffichEv in:
    Arme.o
    Personnage.o
ld: 5 duplicate symbols for architecture x86_64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
make: *** [ExempleClasses] Error 1
18:55:46: The process ""/usr/bin/make"" exited with code 2.
Error while building/deploying project ExempleClasses (kit: Desktop Qt 5.2.0 clang 64bit)
When executing step 'Make'
</code></pre>

<p>Any help please?</p>
"
"<p>I've got a stack consumption issue with my C code and I cannot figure out exactly what's going on. The issue has started to trigg stack overflow crashes (not related to recursion that isn't used in my program). I suspect it is because:<br>
- all of my functions take at least one home made debug interface (a structure I use to ease debugging) which is quite large (~1 or 2kB)<br>
- some of my functions (for example one that implements an initalization sequence for some hardware) are too long (i.e. make too much sub-function calls)  </p>

<p>Note: my C code is used in several applications, some being compiled with gcc, some with visual studio 2010, some with a C++ top layer. All suffer from this high stack usage issue.</p>

<p>I've made the following simple test code in order to demonstrate the problem:</p>

<pre><code>typedef struct tDbgIf2 {
   int               verbose                          ;                                         // verbose level (0:no verbose)
   int               callLevel                        ;                                         // context depth in function call
   char              lhd[1024]                        ;                                         // configurable line header for log formating
} tDbgIf;                                                                                       // function debug interface

//----------------------------------------------------------------------------------------------
tDbgIf mfunc(tDbgIf i) {
//----------------------------------------------------------------------------------------------
   tDbgIf   v = i;

   v.verbose++;

   return v;
}

//----------------------------------------------------------------------------------------------
tDbgIf test1call(tDbgIf i) {
//----------------------------------------------------------------------------------------------
   tDbgIf   v = i;

   v = mfunc(v);

   return v;
}

//----------------------------------------------------------------------------------------------
tDbgIf test2call(tDbgIf i) {
//----------------------------------------------------------------------------------------------
   tDbgIf   v = i;

   v = mfunc(v);
   v = mfunc(v);

   return v;
}

//----------------------------------------------------------------------------------------------
tDbgIf test(tDbgIf i) {
//----------------------------------------------------------------------------------------------
   tDbgIf   v = i;

   v           = test1call(v);
   v           = test2call(v);

   return v;
}

//----------------------------------------------------------------------------------------------
int main(int argc, char *argv[]) {
//----------------------------------------------------------------------------------------------
   tDbgIf   v;

   v           = test(v);

   return 0;
}
</code></pre>

<p>Using gcc 4.7.2 (MinGW on XP) with option -fstack-usage gives the follwing strange result:</p>

<pre><code>cmd=gcc -fstack-usage -S test.c -o test.exe
test.c:8:8:mfunc        1060    static
test.c:18:8:test1call   2100    static
test.c:28:8:test2call   3164    static
test.c:39:8:test        3168    static
test.c:50:5:main        2128    static
</code></pre>

<p>If I understand correctly:<br>
- main stack usage &lt; test stack usage => the statistics are not cumulative<br>
- gcc considers that test2call needs more stack than test1call, despite those two function have the same iput/output parameters + local variables  </p>

<p>I can't understand why is this ? It would suggest that: <strong>(1) stack usage of a function would be proportional to the number of sub-call it makes</strong>
(1) seems strange to me because it would imply that in the real life, function size (in the sense of how much sub-call it makes) would be limited by stack availability. I've never heard about such a limitation (unlike the recursion depth limitation for example which is well explained on Internet). And even more, I've always thought that stack state should be restored at all (sub-)call return. </p>

<p>The generated assembly looks like:</p>

<pre><code>...
_test:                             - start of test
LFB3:                              -
    .cfi_startproc                   -
    pushl   %ebp                       - return context saved
    .cfi_def_cfa_offset 8            -
    .cfi_offset 5, -8                -
    movl    %esp, %ebp                 - new context activated
    .cfi_def_cfa_register 5          -
    pushl   %edi                       -
    pushl   %esi                       -
    pushl   %ebx                       -
    subl    $3148, %esp                - stack static alloc (for test)
    .cfi_offset 7, -12               -
    .cfi_offset 6, -16               -
    .cfi_offset 3, -20               -
    leal    -1056(%ebp), %edx          - v &lt;- i (not sure)
    leal    12(%ebp), %ebx             - v &lt;- i (not sure)
    movl    $258, %eax                 - v &lt;- i (not sure)
    movl    %edx, %edi                 - v &lt;- i (not sure)
    movl    %ebx, %esi                 - v &lt;- i (not sure)
    movl    %eax, %ecx                 - v &lt;- i (not sure)
    rep movsl                        - ???
    leal    -1056(%ebp), %eax          - ???
    movl    %eax, -2108(%ebp)          - ???
    leal    4(%esp), %edx              - ???
    leal    -1056(%ebp), %ebx          - ???
    movl    $258, %eax                 - ???
    movl    %edx, %edi                 - ???
    movl    %ebx, %esi                 - ???
    movl    %eax, %ecx                 - ???
    rep movsl                        -
    movl    -2108(%ebp), %eax          -
    movl    %eax, (%esp)               -
    call    _test1call                 - sub call
    leal    -2104(%ebp), %eax          - v &lt;- ans (not sure)
    movl    %eax, -2112(%ebp)          - v &lt;- ans (not sure)
    leal    4(%esp), %edx              - v &lt;- ans (not sure)
    leal    -1056(%ebp), %ebx          - v &lt;- ans (not sure)
    movl    $258, %eax                 - v &lt;- ans (not sure)
    movl    %edx, %edi                 - v &lt;- ans (not sure)
    movl    %ebx, %esi                 - v &lt;- ans (not sure)
    movl    %eax, %ecx                 - v &lt;- ans (not sure)
    rep movsl                        -
    movl    -2112(%ebp), %eax          -
    movl    %eax, (%esp)               -
    call    _test2call                 - sub call
    leal    -1056(%ebp), %edx          - v &lt;- ans (not sure)
    leal    -2104(%ebp), %ebx          - v &lt;- ans (not sure)
    movl    $258, %eax                 - v &lt;- ans (not sure)
    movl    %edx, %edi                 - v &lt;- ans (not sure)
    movl    %ebx, %esi                 - v &lt;- ans (not sure)
    movl    %eax, %ecx                 - v &lt;- ans (not sure)
    rep movsl                        - ans &lt;- v (not sure)
    movl    8(%ebp), %eax              - ans &lt;- v (not sure)
    movl    %eax, %edx                 - ans &lt;- v (not sure)
    leal    -1056(%ebp), %ebx          - ans &lt;- v (not sure)
    movl    $258, %eax                 - ans &lt;- v (not sure)
    movl    %edx, %edi                 - ans &lt;- v (not sure)
    movl    %ebx, %esi                 - ans &lt;- v (not sure)
    movl    %eax, %ecx                 - ans &lt;- v (not sure)
    rep movsl                        -
    movl    8(%ebp), %eax              -
    addl    $3148, %esp                - stack released
    popl    %ebx                       -
    .cfi_restore 3                   -
    popl    %esi                       -
    .cfi_restore 6                   -
    popl    %edi                       -
    .cfi_restore 7                   -
    popl    %ebp                       - context restored
    .cfi_restore 5                   -
    .cfi_def_cfa 4, 4                -
    ret                              -
    .cfi_endproc                     -
LFE3:
    .def    ___main;    .scl    2;  .type   32; .endef
    .globl  _main
    .def    _main;  .scl    2;  .type   32; .endef
_main:
...
</code></pre>

<p>If I understand correctly:<br>
- the stack is not immediatly cleared after a sub-call return<br>
- (1) is true (at least with default gcc/visual studio otpimization options)  </p>

<p>Could someone confirm ?</p>
"
"<p>I'm having trouble debugging the following program I wrote. The idea is to have two seperate threads; one thread executes a 5 second countdown while the other waits for key input from the user. Whichever thread completes first should cancel the sibling thread and exit the program. However, the following code just hangs.</p>

<p>Any help would be appreciated, but I would be most grateful for an explanation as to the problem.</p>

<pre><code>#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt; // For sleep()

#define NUM_THREADS 2

// The stuct to be passed as an argument to the countdown routine
typedef struct countdown_struct {
pthread_t *thread;
signed int num_secs;
} CountdownStruct;

// Struct for passing to the input wait routine
typedef struct wait_struct {
pthread_t *thread;
int *key;
} WaitStruct;

// Countdown routine; simply acts as a timer counting down
void * countdown(void *args)
{
CountdownStruct *cd_str = (CountdownStruct *)args;
signed int secs = cd_str-&gt;num_secs;
printf(""Will use default setting in %d seconds..."", secs);
while (secs &gt;= 0)
{
    sleep(1);
    secs -= 1;
    printf(""Will use default setting in %d seconds..."", secs);
}

// Cancel the other struct
pthread_cancel(*(cd_str-&gt;thread));
return NULL;
}

// Waits for the user to pass input through the tty
void * wait_for_input(void *args)
{
WaitStruct *wait_str = (WaitStruct *) args;
int c = 0;
do {
    c = getchar();
} while (!(c == '1' || c == '2'));
*(wait_str-&gt;key) = c;

// Cancel the other thread
pthread_cancel(*(wait_str-&gt;thread));
return NULL;
}

int main(int argc, char **argv)
{
pthread_t wait_thread;
pthread_t countdown_thread;
pthread_attr_t attr;
int key=0;
long numMillis=5000;
int rc=0;
int status=0;

// Create the structs to be passe as paramaters to both routines
CountdownStruct *cd_str = (CountdownStruct *) malloc(sizeof(CountdownStruct));
if (cd_str == NULL)
{
    printf(""Couldn't create the countdown struct. Aborting..."");
    return -1;
}
cd_str-&gt;thread = &amp;wait_thread;
cd_str-&gt;num_secs = 5;

WaitStruct *wait_str = (WaitStruct *) malloc(sizeof(WaitStruct));
if (wait_str == NULL)
{
    printf(""Couldn't create the iput wait struct. Aborting..."");
    return -1;
}
wait_str-&gt;thread = &amp;countdown_thread;
wait_str-&gt;key = &amp;key;

// Create the joinable attribute
pthread_attr_init(&amp;attr);
pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);

// Create both threads
rc = pthread_create(&amp;countdown_thread, &amp;attr, countdown, (void *) cd_str);
if (rc) { printf(""Error with the thread creation!""); exit(-1); }
rc = pthread_create(&amp;wait_thread, &amp;attr, wait_for_input, (void *) wait_str);
if (rc) { printf(""Error with the thread creation!""); exit(-1); }

// Destroy the pthread_attribute
pthread_attr_destroy(&amp;attr);

// now join on the threads and wait for main
pthread_join(wait_thread, NULL);
pthread_join(countdown_thread, NULL);

// Call pthread_exit
pthread_exit(NULL);

// Free the function structs
free(cd_str);
free(wait_str);
}
</code></pre>
"
"<p>I need to execute ksh script from java, where I want to exit with error and provide error message.</p>

<p>exit 1 - exits with error code 1     </p>

<p>But what should I do in script in order to catch the error message with getErrorStream?</p>

<pre><code> proc =    Runtime.getRuntime().exec(SCRIPT_PATH);

 int exitV = proc.waitFor();
if(exitV !=0){
  InputStream iputStream= proc.getErrorStream();
  BufferedReader iput = new BufferedReader(new InputStreamReader(iputStream));
  while ((line = iput.readLine()) != null){
   msg.append(line);
  }
}
</code></pre>
"
"<p>This is my requirement -</p>

<p>I have to get the inputs from Command line in the form</p>

<pre><code>-des &lt;destIP&gt; -prot &lt;tcp/udp&gt; -min &lt;minutes&gt;
</code></pre>

<p>There are several programs that suggest how to parse these values through the argc and argv parameters of main() function. But I want a function which gets the iput line and then parse it.</p>

<p>The function would be -</p>

<pre><code>void GetArguments()
{
    cout &lt;&lt; ""Enter arguments ..."" &lt;&lt; endl;
    cin &gt;&gt; inputStr;//eg: inputStr = ""-des 127.0.0.1 -prot tcp -min 60""

    //code to parse the input arguments and get values of dest IP, protocol and time
}
</code></pre>

<p>How do I get the values I need?</p>
"
"<p>I faced a problem to send 1 SMS if an input is HIGH,and if it is LOW==> no SMS to send,if LOW to HIGH==> send 1 SMS.
this code not working,just sent SMS when I turn the GPRS on,and after nothing is happened.</p>

<h1>mclopez helped me,thank you,but not working :( , this is the new code that I wrote with the delay()s,but the same problem.</h1>

<p>Thank you for helping in advance.</p>

<pre><code>   #include &lt;SoftwareSerial.h&gt;
   #include ""TimerOne.h""

   const int DI = 2;
   const int DT = 3;
   const int DGP1 = 4;
   const int DGP2 = 5;
   const long interval = 100000; // in microseconds

   int value1 = 0;
   int value2 = 0;
   int value3 = 0;
   int value4 = 0;

   int value1_old = 0;
   int value2_old = 0;
   int value3_old = 0;
   int value4_old = 0;

   boolean changed1 = false;
   boolean changed2 = false;
   boolean changed3 = false;
   boolean changed4 = false;

   SoftwareSerial SIM900 (7, 8);

   void SIM900power(){
     digitalWrite(9, HIGH);
     delay(1000);
     digitalWrite(9, LOW);
     delay(5000);
   }

  void initia(){
  SIM900.print(""AT+CMGF=1\r"");
  delay(100);
  SIM900.println(""AT + CMGS = \""xxxxxxxxxx\"""");
  delay(100);
  }

  void Send_SMS(){
  SIM900.println((char)26);
  delay(100);
  SIM900.println();
  delay(5000);

 }

  void isr_timer(){
    if (changed2) {
    initia();
    SIM900.println(""Station 85: Defaut electrique"");
    delay(100);
    Send_SMS();
    value2_old = value2;
    changed2 = false;
  }

  if (changed3) {
    initia();
    SIM900.println(""Station 85: DefautGP1"");
    delay(100);
    Send_SMS();
    value3_old = value3;
    changed3 = false;
   }

   if (changed4) {
     initia();
     SIM900.println(""Station 85:DD&gt;1000"");
     delay(100);
     Send_SMS();
     value4_old = value4;
     changed4 = false;
    }
 }

  void setup() {
   pinMode(DI, INPUT);
   pinMode(DT, INPUT);
   pinMode(DGP1, INPUT);
   pinMode(DGP2, INPUT);

   SIM900.begin(19200);
   Timer1.initialize(interval);
   Timer1.attachInterrupt(isr_timer);
  }

 void loop() {
   value1 = digitalRead (DI);
   value2 = digitalRead (DT);
   value3 = digitalRead (DGP1);
   value4 = digitalRead (DGP2);

   if (value1 != value1_old &amp;&amp; value1 == HIGH) changed1 = true;
   if (value2 != value2_old &amp;&amp; value2 == HIGH) changed2 = true;
   if (value3 != value3_old &amp;&amp; value3 == HIGH) changed3 = true;
   if (value4 != value4_old &amp;&amp; value4 == HIGH) changed4 = true;

   value1_old = value1;
   value2_old = value2;
   value3_old = value3;
   value4_old = value4;

 }
</code></pre>
"
"<p>other than counting how many spaces i moved. is there a simple way to get the buffer back to the beginning of a line for reading? am trying to read in strings and then go back to read a different string and numbers. its not in order so i have to go back and look for them specifically. how do i do it.</p>

<p>i use <code>rewind(fp);</code> but that goes back to the beginning of the file.</p>

<p>also am trying to read in integers after the strings. the problem is its hard to read in double, triple digit numbers. i was able to do. but as you see the function down there is a mess. is there an easier way to read multi-digit integers;</p>

<pre><code>void get_total(FILE*fp, int* ptotal, int* pscores, int* pnum_quiz){

    char c;

    int i = 0;

    int total=0;

    int digits;
    int first, second, third;

    *pnum_quiz = 0;

    int number_of_conversions;

    number_of_conversions = fscanf(fp, ""%c"", &amp;c);

    while (isdigit(c) || isspace(c) &amp;&amp; c !='\n' &amp;&amp; c !=NULL &amp;&amp; number_of_conversions!=0 &amp;&amp; number_of_conversions !=EOF){


        if (isspace(c)){
            number_of_conversions = fscanf(fp, ""%c"", &amp;c);

        }

        else if (isdigit(c)){
            first = c - '0'; // convert a character integer to integer

            *(pscores + i) = first;
            i++;

            number_of_conversions = fscanf(fp, ""%c"", &amp;c);

            digits = 1;

            if (isdigit(c)){

                second = c - '0';

                *(pscores + i) = second;

                i++;

                number_of_conversions = fscanf(fp, ""%c"", &amp;c);

                digits = 2;

                if (isdigit(c)){

                    third = c - '0';

                    *(pscores + i) = third;
                    i++;

                    digits = 3;
                }
                else{
                    fseek(fp, -1, SEEK_CUR);
                    *(pscores + i) = -1;
                    i++;
                }


            }
            else{
                fseek(fp, -1, SEEK_CUR);
                *(pscores + i) = -1;
                i++;
                *(pscores + i) = -1;
                i++;
            }

            if (digits==3){
                total = total + (first * 100) + (second * 10) + third;
            }
            else if (digits==2){
                total = total + (first * 10) + second;
            }
            else {
                total = total + first;
            }


            number_of_conversions = fscanf(fp, ""%c"", &amp;c);



        }

        number_of_conversions = fscanf(fp, ""%c"", &amp;c);

        *pnum_quiz = *pnum_quiz + 1;
    }

    *ptotal = total;

}
</code></pre>
"
"<p>I have ruby <a href=""https://stackoverflow.com/questions/32716100/how-to-re-create-each-time-create-new-array-in-ruby"">version</a> of this program &amp; trying to do the same in C++</p>

<p>The input must be:</p>

<pre><code>2 # Number of pairs
562 -881 # First pair
310 -385 # Second pair
</code></pre>

<p>And output:</p>

<pre><code>-319
-75
</code></pre>

<p>It's working fine with one array of 2 numbers and breaks if pairs > 2. What's wrong in my for loops?</p>

<pre><code>#include &lt;iostream&gt;

using namespace std;

int main() {
    int sum = 0;
    int iter;

    cin &gt;&gt; iter;
    int arr[2];

    for (int i=0; i&lt;iter; i++) {
        for (int n=0; n&lt;2; n++) {
            // Enter numbers
            cin &gt;&gt; arr[n];
        }
    }

    for (int num=0; num&lt;2; num++) {
        sum+=arr[num];
    }

    for (int i=0; i&lt;iter; i++) {
        // Get the sum of numbers
        cout &lt;&lt; sum &lt;&lt; endl;
    }
    return 0;
}
</code></pre>

<p>Thanks for any help!</p>
"
"<p>I want to create a file in proc.c (kernel mode) and write something to it but the provided system call (open) is for user mode in user.h header and I can't include user.h in proc.c, Is there any other way to do this in proc.c?</p>
"
"<p>I have iput two double variable in c and I need if one of the input is string terminate with print message i try something like this</p>

<pre><code>double a, b;
printf(""Input two variables:\n"");
scanf(""%lf %lf"", &amp;a, &amp;b);
printf(""%lf\n"", a);
printf(""%lf\n"", b);
if(( a &lt;= 0.0 ) || (b &lt;= 0.0))
{
  printf(""Bad input\n"");
  return 2;
}
</code></pre>

<p>if I try input 4 fff (or fff 5) the program not print Bad input message.
Why this program not print Bad input message if set a=444 b=fff or a=ddd b=78?</p>
"
"<p>I want to make an array of 6 elements , by for loop the user will enter the value of the element each time , then by for loop add each element with 4 and print it .</p>

<p>This is the code it gives me ""Go: execution terminated with errors.""</p>

<pre><code>.text

#Show the Hello Message :D

li $v0 , 4      #4 because it is a string , 1 if it is integer message , V0 is function register
la $a0 , Message    #add the Hello message in the reserved assembler register a0
syscall         #execute the V0 ---&gt;4 function with a0 parameter

#for loop to take the values
add $t0,$zero,$zero

For :
    slti $t1,$t0,24
    beq $t1,$zero,Exit

    #Display Prompt message
    li $v0,4
    la $a0, Prompt
    syscall

    #Get the iput
    li $v0,5    #5 for int input
    syscall

    #Move the input from the the function to a register

    move $t2,$v0

    add $s0,$zero,$t2
    #save value to the array
    sw $s0,MyArray($t0)

    addi $t0,$t0,4

    j For

Exit:       # End for loop

    add $t0,$zero,$zero

    addi $t4,$zero,4
While:
    beq $t0,24,Exit2

    lw $t6, MyArray($t0)

    addi $t0,$t0, 4

    add $t6,$t6,$t4
    add $t6,$t6,$t4
    add $t6,$t6,$t4
    add $t6,$t6,$t4


    li $v0 , 1
    move $a0 , $t6
    syscall


    li $v0 , 4
    la $a0 , Space
    syscall

    j While

Exit2:


    li $v0 , 4      #4 because it is a string , 1 if it is integer message , V0 is function register
    la $a0 , Message2   #add the End message in the reserved assembler register a0
    syscall



.data #This for all the data for the program like variables in c++

Message : .asciiz ""Hello world !\n"" #Display this message on the simulator
MyArray : .space 24
Prompt : .asciiz ""Enter the value\n ""
Message2: .asciiz ""End world !\n""
Space : .asciiz "" , ""
</code></pre>
"
"<p>When I tried to input in the first name and last name in the string it, once I run it, the program only outputs the first name and does not output the second name or word.</p>

<p>here is my code</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;

class ClassOne
{
    public:
    void setName(string xName)
        {
            name = xName;
        }
        string getName()
        {
            return name;
        }
    private:
        string name;
};

int main()
{
    string inputName;
    cout &lt;&lt; ""Please input your name: "";
    cin &gt;&gt; inputName;
    ClassOne objClassOne;
    objClassOne.setName(inputName);
    cout &lt;&lt; ""Your Name is "" &lt;&lt; objClassOne.getName() &lt;&lt; endl;
    return 0;
}
</code></pre>

<p>Once I input Michael Jordan it only shows Michael</p>

<p>I'm just a beginner in C++.</p>

<p>Thank you in advance!</p>
"
"<p>I am learning the EXT2 file system. I am confused about how the removal of a file works for EXT2. My understanding is that, upon deletion, it doesn't actually deletes the inode, instead it marks some metadata as unused. My question is that, what metadata does it modify upon deletion, and how does the file system know that the file is deleted?  Thanks.</p>
"
"<p>I want to create a basic parsing method which takes a <code>vector &lt;uint8_&gt;</code> as an input using C++. Based on the actual values of the individual bytes this method should return a struct representing this data. </p>

<p>For example:</p>

<p>Input 1: <code>{0x10, 0x02, 0x03}</code><br>
Input 2 <code>{0x20, 0x05, 0x02}</code></p>

<p>The first byte should represent the type of the object with 0x10 = cube and 0x20 = sphere.<br>
The second byte is depending on the type either width of the cube or diameter of the sphere.<br>
The third byte is either the volume of the cube or the mass of the sphere. </p>

<p>Can I create a method which takes the input vector and returns based on the values inside this vector one of these two different structs: </p>

<pre><code>struct cube
{
    int width;
    int volume;
};

struct sphere
{
    int diameter;
    int mass;
};
</code></pre>
"
"<p>I've been trying to implement a SystemV message queue server/client app in C, with multiple client processes, each of which sending severeal messages to the server queue.</p>

<p>Now, the server (one separate app) works just fine, and the client does too.</p>

<p>But the clients it will not spawn into separate daemon instances, as desired. Instead, only one new process group is spawned with <code>fork()</code> and <code>setsid()</code> and each client messages job will only follow up after finishing the last one. What I want to achieve, is to have a separate proc group running for each client job processing and sending its own set of messages.</p>

<p>Stdout and stderr should go to the same spawning terminal (which seems to work already, if not started from IDE, but from terminal). </p>

<p>Here's my client code:</p>

<pre><code>#include ""msgQueue.h""

#define MAX_INSTANCES 2
#define MAX_MESSAGES 4

#define MAX_TX_TRIES_PER_MSG 3
#define ALRM_ARY_YDIM 2

#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1

static const char nl = '\n';
const char initSendAlrmMsg[] = ""CLIENT_ERROR: Sending msg to server queue failed, retrying...\n"";
size_t initSendAlrmMsgLen;

// Debug message switch
static int DEBUG = 1;
static pid_t *clientAlarms[2];

// User-provided or overriden max. values for all client instance signal handlers
static int instancesToRun = MAX_INSTANCES;
static int messagesToSendEach = MAX_MESSAGES;

// Thread signal handler
void sigHandler(int signal);

char *appendInt(char *str1, int i);
char *appendStr(char *str1, char *str2);
static void daemonize(void);

static void sendMessages(int instCount, char *createClientMessageMsg, int messagesToSendEach) {

    //  daemonize();

    // Get message queue ID for KEY
    int msgId;
    if (( msgId = msgget(MSGQ_KEY, 0)) &lt; 0) {
        perror(""\nCLIENT_INIT_ERROR: getting message queue failed, exiting...\n"");
        exit(1);
    }

    long pid = (long)getpid();
    printf(""\nCLIENT_INIT: CREATED INSTANCE WITH PID: %ld\n"", pid);

    printf(""CLIENT_INIT: MSGQ ID is %d\n"", msgId);

    struct msg *txMsg;
    char *strBuilder;
    int receiving = 1;
    MESSAGE rxMsg;
    int msgRes = 0;

    // Declare signal action var and set handler method
    struct sigaction act = {0};
    act.sa_handler = sigHandler;
    sigaction(SIGALRM, &amp;act, NULL);

    // Create client messages loop
    for(int msgCount = 0; msgCount &lt; messagesToSendEach; msgCount++) {

        clientAlarms[0][msgCount] = pid;
        clientAlarms[1][msgCount] = MAX_TX_TRIES_PER_MSG;

        // Build instance count info string
        char *prnStrBuilder = appendInt(createClientMessageMsg, msgCount + 1);
        prnStrBuilder = appendStr(prnStrBuilder, "" from "");
        prnStrBuilder = appendInt(prnStrBuilder, messagesToSendEach);

        // Print instance count info string
        write(1, prnStrBuilder, strlen(prnStrBuilder));
        write (1, &amp;nl, 1);

        // Allocating memory for CLIENT SEND MESSAGE from msg struct template
        txMsg = (struct msg *)malloc((unsigned)(sizeof(struct msg) - sizeof txMsg-&gt;message + MAX_MSG_LEN));
        if (txMsg == NULL) {
            perror(""CLIENT_ERROR: allocating SEND MSG memory failed, exiting...\n"");
            exit(1);
        }

        // Set clientMsg.type long value (1)
        txMsg-&gt;msgType = 1l;

        // Get clientMsg.message pointer adr and add amount of bytes to append to pointer adr / set string value from client pid
        strBuilder = txMsg-&gt;message;
        strBuilder += snprintf(strBuilder, MAX_MSG_LEN, ""%ld"", pid);

        //  // Re-allocate memory for args array's next element
        //  msgStr = realloc(msgStr, sizeof(char) * (splitCount + 1));
        //  if (msgStr == NULL) {
        //      perror(""CLIENT_INIT_ERROR: Message string realloc for argument failed"");
        //      exit(1);
        //  }

        printf(""CLIENT_INFO: SENDING message = %s / type = %ld\n\n"", txMsg-&gt;message, txMsg-&gt;msgType);

        // SEND CLIENT MESSAGE
        if (msgsnd(msgId, txMsg, MAX_MSG_LEN, 0) &lt; 0) {
            printf(""CLIENT_WARNING: MSG SEND FAILED: %s\n"", txMsg-&gt;message);
        }

        while(receiving) {

            // Delay (re-)sending of message
            sleep(1);

            // Set alarm in case of non-responding server
            alarm(2);

            printf(""CLIENT_WAITING: LISTENING FOR MSG OR SIGNAL\n"");
            // Waiting to receive next msg of type client pid
            if ((msgRes = msgrcv(msgId, &amp;rxMsg, MAX_MSG_LEN, pid, 0) &lt; 0)) {
                printf(""CLIENT_CONTINUE: MSG OR ALARM SIGNAL RECEIVED\n"");
            }

            // Job failed
            if (clientAlarms[1][msgCount] &lt;= 0) {
                printf(""CLIENT_TX_FAIL: could not send send clientPid msg to queue: %ld.\nTerminating job...\n"", pid);
                break;
            }

            if (errno == EINVAL) {
                printf(""CLIENT_WARNING: invalid msg or type received for clientPid: %ld\n"", pid);
                clientAlarms[1][msgCount] -= 1;
                continue;
            }

            if (pid == rxMsg.msgType) {
                printf(""CLIENT_INFO: RECEIVED message = %s / type = %ld\n"", rxMsg.message, rxMsg.msgType);

                receiving = 0;
                printf(""CLIENT_TX_SUCCESS: server acknowledged message type = %ld\n"", rxMsg.msgType);
            }
        }

        // Job failed
        if (clientAlarms[1][msgCount] &lt;= 0) {
            // Clear job failure register
            clientAlarms[0][msgCount] = 0;
            clientAlarms[1][msgCount] = 0;
            continue;
        }

        printf(""\nCLIENT_FINISH: ALL MESSAGES SENT, EXITING...\n\n"");
    }
}


static void daemonize(void) {
    pid_t pid, sid;

    /* already a daemon */
    if ( getppid() == 1 ) {
        printf(""\nCLIENT_DAEMONIZING: ALREADY DONE\n"");
        return;
    }

    /* Fork off the parent process */
    pid = fork();
    if (pid &lt; 0) {
        printf(""\nCLIENT_DAEMONIZING: FORKING FAILED\n"");
        exit(EXIT_FAILURE);
    }

    /* If we got a good PID, then we can exit the parent process. */
    if (pid &gt; 0) {
        printf(""\nCLIENT_DAEMONIZING: CREATED INSTANCE PID is %d\n"", pid);
        exit(EXIT_SUCCESS);
    }

    /* At this point we are executing as the child process */

    /* Change the file mode mask */
    //  printf(""\nCLIENT_DAEMONIZING: UMASK IS %ld\n"", getumask());
    umask(0);
    //  printf(""\nCLIENT_DAEMONIZING: UMASK NOW %ld\n"", getumask());

    /* Create a new SID for the child process */
    sid = setsid();
    if (sid &lt; 0) {
        printf(""\nCLIENT_DAEMONIZING: SID CREATION FAILED\n"");
        exit(EXIT_FAILURE);
    }

    printf(""\nCLIENT_DAEMONIZING: CREATED INSTANCE SID is %d\n"", pid);

    /* Change the current working directory.  This prevents the current
     *      directory from being locked; hence not being able to remove it. */
    if ((chdir(""/"")) &lt; 0) {
        printf(""\nCLIENT_DAEMONIZING: CHDIR FAILED\n"");
        exit(EXIT_FAILURE);
    }

    /* Redirect standard files to /dev/null */
    //    freopen( ""/dev/null"", ""r"", stdin);
    //    freopen( ""/dev/null"", ""w"", stdout);
    //    freopen( ""/dev/null"", ""w"", stderr);
    printf(""\nCLIENT_DAEMONIZING: SUCCESS\n\n"");
}


int main( int argc, char *argv[] ) {

    char *createClientMessageMsg = ""CREATING CLIENT MESSAGE: "";
    char *createClientSessionMsg = ""CREATING CLIENT SESSION: "";

    initSendAlrmMsgLen = strlen(initSendAlrmMsg);

    // Init clientAlarms for failed messages
    int x = 0, y = 0, rows = ALRM_ARY_YDIM, cols = MAX_INSTANCES;
    for (x = 0; x &lt; rows; x++) {
        clientAlarms[x] = (pid_t *)malloc(cols * sizeof(pid_t));
    }

    for (x = 0; x &lt; rows; x++) {
        for (y = 0; y &lt; cols; y++) {
            clientAlarms[x][y] = 0;
        }
    }

    if (DEBUG) {
        for (x = 0; x &lt; rows; x++) {
            printf(""\nR: %d "", x);
            for (y = 0; y &lt; cols; y++) {
                printf(""%d "", clientAlarms[x][y]);
            }
        }
    }

    // User iput command spliter delims
    const char *delims = {"" ;,-/_""};

    // Max. char buf size
    size_t bSize = 32;

    printf(""\nCLIENT MESSAGE QUEUE FEEDER (PID: %d)\n\n"", getpid());

    puts(""Enter how many clients to start / how many messages to send by each (comma- or space-saparated) or 'EXIT': "");

    // Input user command buffer allocation
    char *input = (char *)malloc(sizeof(char) + 1);
    if( NULL == input) {
        perror(""INPUT buffer allocation failure!"");
        exit(1);
    }

    // Getline does automatic realloc on oversized line / Input user command adr
    ssize_t inputAdr = getline(&amp;input,&amp;bSize, stdin);
    if (0 == strcasecmp(""exit\n"", input)) {
        puts(""EXITING..."");
        exit(0);
    }

    // Seed string tokenizer with args from delim-separated arguments and store command / first arg
    // Tmp input split buffer

    char *strBuf = (char *)malloc(bSize* sizeof(char));
    if( NULL == strBuf) {
        perror(""STR BUF allocation failure!"");
        exit(1);
    }
    // Parse client instances count arg string
    if ((strBuf = strtok (input, delims)) == NULL || strlen(strBuf) &lt; 1) {
        perror(""CLIENT INSTANCES ARG EMPTY!"");
        exit(1);
    }

    // Allocate memory for user input args array
    char **args = malloc(sizeof(char *) * 1);
    if (args == NULL) {
        perror(""COMMAND ARGS buffer allocation failed!"");
        exit(1);
    }

    args[0] = strBuf;

    // Parse messages count arg string
    if ((strBuf = strtok (NULL, delims)) == NULL || strlen(strBuf) &lt; 1) {
        perror(""MESSAGES EACH ARG EMPTY!"");
        exit(1);
    }  else {
        // Re-allocate memory for args array's next element
        args = realloc(args, sizeof(char *) * 2);
        if (args == NULL) {
            perror(""realloc for argument failed"");
            exit(1);
        }
        args[1] = strBuf;
    }

    int userValue = 0;
    if ((userValue = strtol(args[0], NULL, 10)) &lt;= 0) {
        puts(""CLIENT INSTANCE VALUE SET TO [1]\n"");
    } else if (userValue &gt; MAX_INSTANCES) {
        printf(""\nMAX_INSTANCES OF %d ENFORCED\n"", instancesToRun);
    } else {
        instancesToRun = userValue;
    }

    if ((userValue = strtol(args[1], NULL, 10)) &lt;= 0) {
        puts(""CLIENT MESSAGE VALUE SET TO [1]\n"");
    } else if (userValue &gt; MAX_MESSAGES) {
        printf(""\nMAX_MESSAGES OF %d EACH ENFORCED\n"", messagesToSendEach);
    } else {
        messagesToSendEach = userValue;
    }

    write (1, &amp;nl, 1);

    // Create client instances loop
    for(int instCount = 0; instCount &lt; instancesToRun; instCount++) {

        // Build instance count info string
        char *prnStrBuilder = appendInt(createClientSessionMsg, instCount + 1);
        prnStrBuilder = appendStr(prnStrBuilder, "" from "");
        prnStrBuilder = appendInt(prnStrBuilder, instancesToRun);

        // Print instance count info string
        write(1, prnStrBuilder, strlen(prnStrBuilder));
        write (1, &amp;nl, 1);

        daemonize();

        sendMessages(instCount, createClientMessageMsg, messagesToSendEach);
    }

    return 0;
}

void sigHandler(int signal) {

    const char *sigName;

    // Handle inconming signal
    switch (signal) {

        case SIGHUP:
            sigName = ""Caught SIGHUP\n"";
            write (1, sigName, strlen(sigName));
            break;

        case SIGALRM:

            write (1, initSendAlrmMsg, initSendAlrmMsgLen);
            //          write(1, &amp;nl, 1);

            pid_t pid = getpid();

            // If current PID caused ALRM, count msg bailout
            for (int i = 0; i &lt; messagesToSendEach; i++) {
                if (pid == clientAlarms[0][i]) {
                    clientAlarms[1][i] -= 1;
                    printf(""CLIENT_ALARM: MSG SEND TRIES LEFT: %d\n\n"", clientAlarms[1][i]);
                }
            }

            break;
            ...
</code></pre>

<p>My common header file (server + client):</p>

<pre><code>#ifndef MSGQUEUE_H_INCLUDED
#define MSGQUEUE_H_INCLUDED

#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;fcntl.h&gt;

/* server-/client message queue id */
#define MSGQ_KEY 0x1a1a1a1a

/* message queue creation flags */
#define MSG_FLAGS IPC_CREAT | IPC_EXCL | 0666

/* max. length of message */
#define MAX_MSG_LEN 20

/* message stucture */
typedef struct msg
{
    /* message type */
    long msgType;

    /* message */
    char message[MAX_MSG_LEN];
    //  long message;

} MESSAGE;

#endif
</code></pre>

<p>EDIT:</p>

<p>I needed quick results, so I've been sticking with a single proc in the code and added some cmd args parsing, working around the daemonizing problem with an improvised shell script instead (C solution, as with the code above, is still welcome):</p>

<pre><code>#! /bin/bash

CMD=mqClient

CMD_PID=$(pgrep -f $CMD)
echo ""TERMINAL PID: $$"";

INSTANCES_ARG=""$1""
MESSAGES_ARG=""$2""

# No INSTANCES arg - start single client
if [[ -z ""${INSTANCES_ARG// }"" ]]; then
    echo ""MOD INST ARG: $INSTANCES_ARG"";
    INSTANCES_ARG=1;
fi

# No MESSAGES arg - keep default
if [[ -z ""${MESSAGES_ARG// }"" ]]; then
    echo ""MOD MSG ARG: $MESSAGES_ARG"";
    MESSAGES_ARG=1;
fi

start() {

    ipcs -q
    ipcs -qi 0

    # Starting clients daemonized
    for i in $(seq 1 $INSTANCES_ARG);
    do
        echo ""##### RUN CLIENT $i OF $INSTANCES_ARG WITH $MESSAGES_ARG MESSAGES #####"";

    logfile=""client$i.log"";
    :&gt;$logfile;
    chmod go+rw $logfile;

    stdbuf -oL -eL nohup ./$CMD $MESSAGES_ARG &amp;&gt;$logfile &amp;
    disown;
    done

    sleep 2
    ipcs -qi 0

    exit 0;
}

start
</code></pre>
"
"<p>I'm working on a system that involves some custom hardware and a custom Linux device driver I wrote for the hardware.  The system occasionally needs to move large amounts of data very rapidly and therefore my driver dynamically (i.e. when needed) allocates large (1 GB) DMA buffers which are used and then freed when they are no longer needed.  To allocate such large buffers I actually allocate a bunch of smaller buffers (256 X 4MB) using <code>dma_alloc_coherent</code> and then map them contiguously into user space using <code>remap_pfn_range</code>. This works very well most of the time.</p>

<p>During testing, after the system has been running test cases for a long time, I sometimes see DMA allocation failures where one of the <code>dma_alloc_coherent</code> calls in my driver fails which causes my application layer software to crash.  I was finally able to track down this problem and I discovered that when I see DMA allocation failures the Linux kernel page cache is very full. </p>

<p>For example, on the last failure that I captured the page cache filled 27 GB of the 32 GB of RAM on my system.  I suspected that the page cache ""fullness"" was causing <code>dma_alloc_coherent</code> calls to fail.  To test this theory I manually emptied the page cache using:</p>

<pre><code># echo 1 &gt; /proc/sys/vm/drop_caches
</code></pre>

<p>This dropped the size of the cache from 27 GB to 94 MB and I was able to allocate 20+ 1 GB DMA buffers with no issues. </p>

<p>Clearly the page cache is a beneficial thing so I would prefer not to have to completely empty it every time I run out of space when allocating DMA buffers. My questions is this: how can I dynamically shrink the page cache in kernel space such that if a call to <code>dma_alloc_coherent</code> fails I can recover just enough space so that I can retry the call and have it succeed?</p>

<p>My system is x86_64 based running a 3.16.x Linux kernel.</p>

<p>I have found some vague references that suggest what I'm attempting may be possible, for example ""These objects are automatically
reclaimed by the kernel when memory is needed elsewhere on the system."" (from: <a href=""https://www.kernel.org/doc/Documentation/sysctl/vm.txt"" rel=""nofollow"">https://www.kernel.org/doc/Documentation/sysctl/vm.txt</a>). But I have not yet found any specifics that indicate how the memory is reclaimed.</p>

<p>Any assistance with this would be greatly appreciated!</p>
"
"<p>I'm having a problem with inode number. When I mount one usb disk (let's say usb-a) and then mount another usb disk (usb-b) the inode number in usb-a is changed.</p>

<p>Is this normal? what may cause this issue? I'm using Linux Kernel 2.6.
usb-a is vfat and usb-b is ntfs.</p>

<p>Thanks in advance guys.</p>
"
"<p>I have the following table which contains some bidirectional hits in V1 and V2 for each unique V1. I want to remove one of each bidrectional hit (random choice)</p>

<pre><code>V1 V2 V3
1  T  Y
1  Y  T
1  O  P
2  Q  E
2  E  Q
2  C  V
2  V  C
2  Y  T
</code></pre>

<p>the result table should be like this:</p>

<pre><code>V1 V2 V3
1  T  Y
1  O  P
2  E  Q
2  V  C
2  Y  T
</code></pre>

<p>this can be done using a for loop, but i need a more efficient way.</p>

<p>what is the fastest way to do this in R?</p>
"
"<p>What is the difference between <code>VFS</code> i-node and <code>FS</code> (e.g. <code>EXT</code>) i-node? </p>

<p>Is it possible that <code>EXT</code> i-node is persistent (contains/points to data blocks), but <code>VFS</code> i-node is created just in i-node cache after read/use of <code>EXT</code> i-node?</p>

<p>Or the <code>VFS</code> i-node is just an image of <code>FS</code> i-node (it's the same) and i-nodes in those systems, which are not working with i-nodes (e.g. <code>FAT, NTFS</code>) has to be emulated (HOW?) to allow <code>VFS</code> work with those <code>FS</code> like they would support i-nodes?</p>
"
"<p>Are there any ways to optimize this program?</p>

<pre><code>CPU: Intel Sandy Bridge microarchitecture, speed 3.3e+06 MHz (estimated)
Counted CPU_CLK_UNHALTED events (Clock cycles when not halted) with a unit mask of 0x00 (No unit mask) count 100000
samples  %        image name               app name                 symbol name
84683    12.3219  tyn_indexer              tyn_indexer              tyn_cmp_term32
61380     8.9311  tyn_indexer              tyn_indexer              tyn_binary_heap_heapify
60187     8.7576  tyn_indexer              tyn_indexer              tyn_p4d_encode32
29849     4.3432  tyn_indexer              tyn_indexer              tyn_exsorter_sort
29526     4.2962  tyn_indexer              tyn_indexer              tyn_cmp_node_term32
25441     3.7018  libc-2.14.90.so          libc-2.14.90.so          __memcpy_ssse3_back
25283     3.6788  tyn_indexer              tyn_indexer              tyn_binary_heap_insert
20537     2.9883  tyn_indexer              tyn_indexer              nodes_term32_flush
11966     1.7411  vmlinux                  vmlinux                  jbd2_journal_commit_transaction
11733     1.7072  vmlinux                  vmlinux                  __strnlen_user
10741     1.5629  vmlinux                  vmlinux                  nobh_truncate_page
9728      1.4155  vmlinux                  vmlinux                  generic_file_buffered_write
9443      1.3740  vmlinux                  vmlinux                  mpage_da_map_and_submit
9023      1.3129  vmlinux                  vmlinux                  do_get_write_access
7283      1.0597  vmlinux                  vmlinux                  invalidate_interrupt31
5894      0.8576  vmlinux                  vmlinux                  write_cache_pages_da
5332      0.7758  vmlinux                  vmlinux                  journal_submit_commit_record
5316      0.7735  vmlinux                  vmlinux                  hugetlbfs_symlink
5166      0.7517  vmlinux                  vmlinux                  mount_ns
4750      0.6912  vmlinux                  vmlinux                  threshold_interrupt
4680      0.6810  tyn_indexer              tyn_indexer              tyn_cmp_node_attr32
4526      0.6586  vmlinux                  vmlinux                  list_locations
4473      0.6508  vmlinux                  vmlinux                  generic_write_checks
4415      0.6424  vmlinux                  vmlinux                  hotplug_hrtick
4398      0.6399  vmlinux                  vmlinux                  rb_erase
4373      0.6363  libglib-2.0.so.0.3000.1  libglib-2.0.so.0.3000.1  /lib64/libglib-2.0.so.0.3000.1
4365      0.6351  vmlinux                  vmlinux                  fput
4356      0.6338  vmlinux                  vmlinux                  jbd2_journal_dirty_metadata
4197      0.6107  vmlinux                  vmlinux                  kmem_cache_open
4178      0.6079  vmlinux                  vmlinux                  generic_file_aio_read
3871      0.5633  libc-2.14.90.so          libc-2.14.90.so          __libc_disable_asynccancel
3869      0.5630  libc-2.14.90.so          libc-2.14.90.so          __libc_enable_asynccancel
3762      0.5474  vmlinux                  vmlinux                  __bread
3697      0.5379  vmlinux                  vmlinux                  bdi_writeback_thread
3608      0.5250  vmlinux                  vmlinux                  ext4_alloc_da_blocks
3537      0.5147  vmlinux                  vmlinux                  add_page_to_unevictable_list
3296      0.4796  vmlinux                  vmlinux                  hugetlbfs_read
3047      0.4434  vmlinux                  vmlinux                  audit_free
3041      0.4425  vmlinux                  vmlinux                  fget_raw_light
2872      0.4179  vmlinux                  vmlinux                  copy_from_user_nmi
</code></pre>
"
"<p>Occasionally one of our Linux MySQL database servers will hang for a while, creating a long queue of active queries. After 10-20 mins, service resumes as normally.</p>

<p>This happens in kern.log:</p>

<pre><code>May 14 13:58:05 edu02 kernel: [2375521.716786] INFO: task jbd2/md2-8:1419 blocked for more than 120 seconds.
May 14 13:58:05 edu02 kernel: [2375521.716870] ""echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs"" disables this message.
May 14 13:58:05 edu02 kernel: [2375521.716953] jbd2/md2-8    D ffff88043b5a23f0     0  1419      2 0x00000000
May 14 13:58:05 edu02 kernel: [2375521.716958]  ffff88043b5a23f0 0000000000000046 00000000000000ff ffff88043b4e69c0
May 14 13:58:05 edu02 kernel: [2375521.716963]  00000000ffffffff ffffffff8118bac3 000000000000f9e0 ffff88043d099fd8
May 14 13:58:05 edu02 kernel: [2375521.716967]  00000000000157c0 00000000000157c0 ffff88043a411cc0 ffff88043a411fb8
May 14 13:58:05 edu02 kernel: [2375521.716971] Call Trace:
May 14 13:58:05 edu02 kernel: [2375521.716981]  [&lt;ffffffff8118bac3&gt;] ? generic_make_request+0x299/0x2f9
May 14 13:58:05 edu02 kernel: [2375521.716988]  [&lt;ffffffff810168ec&gt;] ? read_tsc+0xa/0x20
May 14 13:58:05 edu02 kernel: [2375521.716994]  [&lt;ffffffff810757f6&gt;] ? timekeeping_get_ns+0xe/0x2e
May 14 13:58:05 edu02 kernel: [2375521.716999]  [&lt;ffffffff8111a5f2&gt;] ? sync_buffer+0x0/0x40
May 14 13:58:05 edu02 kernel: [2375521.717004]  [&lt;ffffffff8130b4a2&gt;] ? io_schedule+0x73/0xb7
May 14 13:58:05 edu02 kernel: [2375521.717007]  [&lt;ffffffff8111a62d&gt;] ? sync_buffer+0x3b/0x40
May 14 13:58:05 edu02 kernel: [2375521.717010]  [&lt;ffffffff8130b9af&gt;] ? __wait_on_bit+0x41/0x70
May 14 13:58:05 edu02 kernel: [2375521.717014]  [&lt;ffffffff8111a5f2&gt;] ? sync_buffer+0x0/0x40
May 14 13:58:05 edu02 kernel: [2375521.717017]  [&lt;ffffffff8130ba49&gt;] ? out_of_line_wait_on_bit+0x6b/0x77
May 14 13:58:05 edu02 kernel: [2375521.717021]  [&lt;ffffffff81066210&gt;] ? wake_bit_function+0x0/0x23
May 14 13:58:05 edu02 kernel: [2375521.717035]  [&lt;ffffffffa0138a22&gt;] ? jbd2_journal_commit_transaction+0xbe5/0x115b [jbd2]
May 14 13:58:05 edu02 kernel: [2375521.717043]  [&lt;ffffffffa013e8c1&gt;] ? kjournald2+0xbe/0x206 [jbd2]
May 14 13:58:05 edu02 kernel: [2375521.717046]  [&lt;ffffffff810661e2&gt;] ? autoremove_wake_function+0x0/0x2e
May 14 13:58:05 edu02 kernel: [2375521.717052]  [&lt;ffffffffa013e803&gt;] ? kjournald2+0x0/0x206 [jbd2]
May 14 13:58:05 edu02 kernel: [2375521.717055]  [&lt;ffffffff81065f15&gt;] ? kthread+0x79/0x81
May 14 13:58:05 edu02 kernel: [2375521.717058]  [&lt;ffffffff81011baa&gt;] ? child_rip+0xa/0x20
May 14 13:58:05 edu02 kernel: [2375521.717062]  [&lt;ffffffff81065e9c&gt;] ? kthread+0x0/0x81
May 14 13:58:05 edu02 kernel: [2375521.717064]  [&lt;ffffffff81011ba0&gt;] ? child_rip+0x0/0x20
May 14 13:58:05 edu02 kernel: [2375521.717080] INFO: task mysqld:5879 blocked for more than 120 seconds.
May 14 13:58:05 edu02 kernel: [2375521.717132] ""echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs"" disables this message.
May 14 13:58:05 edu02 kernel: [2375521.717215] mysqld        D ffff88000facfb30     0  5879   2279 0x00000000
May 14 13:58:05 edu02 kernel: [2375521.717219]  ffff88043e46f300 0000000000000082 ffff88043c703d08 ffff88043c703d04
May 14 13:58:05 edu02 kernel: [2375521.717223]  0000000000000008 ffffffffa017942a 000000000000f9e0 ffff88043c703fd8
May 14 13:58:05 edu02 kernel: [2375521.717226]  00000000000157c0 00000000000157c0 ffff88043ad09cc0 ffff88043ad09fb8
May 14 13:58:05 edu02 kernel: [2375521.717230] Call Trace:
May 14 13:58:05 edu02 kernel: [2375521.717247]  [&lt;ffffffffa017942a&gt;] ? ext4_journal_start_sb+0xd4/0x10e [ext4]
May 14 13:58:05 edu02 kernel: [2375521.717256]  [&lt;ffffffffa0179350&gt;] ? __ext4_journal_stop+0x63/0x69 [ext4]
May 14 13:58:05 edu02 kernel: [2375521.717264]  [&lt;ffffffffa01634de&gt;] ? ext4_da_writepages+0x4e2/0x65c [ext4]
May 14 13:58:05 edu02 kernel: [2375521.717269]  [&lt;ffffffff810be235&gt;] ? sync_page+0x0/0x46
May 14 13:58:05 edu02 kernel: [2375521.717272]  [&lt;ffffffff8130b4a2&gt;] ? io_schedule+0x73/0xb7
May 14 13:58:05 edu02 kernel: [2375521.717275]  [&lt;ffffffff810be276&gt;] ? sync_page+0x41/0x46
May 14 13:58:05 edu02 kernel: [2375521.717278]  [&lt;ffffffff8130b9af&gt;] ? __wait_on_bit+0x41/0x70
May 14 13:58:05 edu02 kernel: [2375521.717282]  [&lt;ffffffff810be3fa&gt;] ? wait_on_page_bit+0x6b/0x71
May 14 13:58:05 edu02 kernel: [2375521.717285]  [&lt;ffffffff81066210&gt;] ? wake_bit_function+0x0/0x23
May 14 13:58:05 edu02 kernel: [2375521.717289]  [&lt;ffffffff810c6222&gt;] ? pagevec_lookup_tag+0x1a/0x21
May 14 13:58:05 edu02 kernel: [2375521.717293]  [&lt;ffffffff810bebda&gt;] ? wait_on_page_writeback_range+0x69/0x11b
May 14 13:58:05 edu02 kernel: [2375521.717297]  [&lt;ffffffff810bed00&gt;] ? __filemap_fdatawrite_range+0x4b/0x54
May 14 13:58:05 edu02 kernel: [2375521.717301]  [&lt;ffffffff810bed4c&gt;] ? filemap_write_and_wait_range+0x43/0x52
May 14 13:58:05 edu02 kernel: [2375521.717305]  [&lt;ffffffff81118106&gt;] ? vfs_fsync_range+0x55/0x9e
May 14 13:58:05 edu02 kernel: [2375521.717308]  [&lt;ffffffff811181ce&gt;] ? do_fsync+0x28/0x39
May 14 13:58:05 edu02 kernel: [2375521.717311]  [&lt;ffffffff811181fd&gt;] ? sys_fsync+0xb/0x10
May 14 13:58:05 edu02 kernel: [2375521.717315]  [&lt;ffffffff81010b42&gt;] ? system_call_fastpath+0x16/0x1b
May 14 14:04:05 edu02 kernel: [2375881.716569] INFO: task mysqld:20799 blocked for more than 120 seconds.
May 14 14:04:05 edu02 kernel: [2375881.716626] ""echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs"" disables this message.
May 14 14:04:05 edu02 kernel: [2375881.716710] mysqld        D 0000000000000000     0 20799   2279 0x00000000
May 14 14:04:05 edu02 kernel: [2375881.716716]  ffff88043e46d640 0000000000000082 0000000000000000 ffff8800839be930
May 14 14:04:05 edu02 kernel: [2375881.716720]  ffff88043b4e4680 ffff88043b4e4680 000000000000f9e0 ffff88009592ffd8
May 14 14:04:05 edu02 kernel: [2375881.716724]  00000000000157c0 00000000000157c0 ffff880014059cc0 ffff880014059fb8
May 14 14:04:05 edu02 kernel: [2375881.716729] Call Trace:
May 14 14:04:05 edu02 kernel: [2375881.716740]  [&lt;ffffffff81066103&gt;] ? bit_waitqueue+0x10/0xa0
May 14 14:04:05 edu02 kernel: [2375881.716766]  [&lt;ffffffffa01371ba&gt;] ? do_get_write_access+0x22c/0x452 [jbd2]
May 14 14:04:05 edu02 kernel: [2375881.716771]  [&lt;ffffffff81066210&gt;] ? wake_bit_function+0x0/0x23
May 14 14:04:05 edu02 kernel: [2375881.716777]  [&lt;ffffffffa0137402&gt;] ? jbd2_journal_get_write_access+0x22/0x33 [jbd2]
May 14 14:04:05 edu02 kernel: [2375881.716796]  [&lt;ffffffffa017fee6&gt;] ? __ext4_journal_get_write_access+0x4e/0x56 [ext4]
May 14 14:04:05 edu02 kernel: [2375881.716804]  [&lt;ffffffffa015fe4c&gt;] ? ext4_reserve_inode_write+0x37/0x73 [ext4]
May 14 14:04:05 edu02 kernel: [2375881.716811]  [&lt;ffffffffa015fec3&gt;] ? ext4_mark_inode_dirty+0x3b/0x1c4 [ext4]
May 14 14:04:05 edu02 kernel: [2375881.716820]  [&lt;ffffffffa017942a&gt;] ? ext4_journal_start_sb+0xd4/0x10e [ext4]
May 14 14:04:05 edu02 kernel: [2375881.716826]  [&lt;ffffffff8130b4c2&gt;] ? io_schedule+0x93/0xb7
May 14 14:04:05 edu02 kernel: [2375881.716833]  [&lt;ffffffffa016016e&gt;] ? ext4_dirty_inode+0x30/0x46 [ext4]
May 14 14:04:05 edu02 kernel: [2375881.716840]  [&lt;ffffffff811148f1&gt;] ? __mark_inode_dirty+0x25/0x14a
May 14 14:04:05 edu02 kernel: [2375881.716844]  [&lt;ffffffff8110b958&gt;] ? touch_atime+0x10a/0x133
May 14 14:04:05 edu02 kernel: [2375881.716850]  [&lt;ffffffff810bf8f0&gt;] ? generic_file_aio_read+0x499/0x536
May 14 14:04:05 edu02 kernel: [2375881.716855]  [&lt;ffffffff810f9c45&gt;] ? do_sync_read+0xce/0x113
May 14 14:04:05 edu02 kernel: [2375881.716858]  [&lt;ffffffff810661e2&gt;] ? autoremove_wake_function+0x0/0x2e
May 14 14:04:05 edu02 kernel: [2375881.716862]  [&lt;ffffffff81105a05&gt;] ? user_path_at+0x52/0x79
May 14 14:04:05 edu02 kernel: [2375881.716866]  [&lt;ffffffff810fa668&gt;] ? vfs_read+0xa6/0xff
May 14 14:04:05 edu02 kernel: [2375881.716869]  [&lt;ffffffff810fa77d&gt;] ? sys_read+0x45/0x6e
May 14 14:04:05 edu02 kernel: [2375881.716873]  [&lt;ffffffff81010b42&gt;] ? system_call_fastpath+0x16/0x1b
</code></pre>

<p>The stack trace leads me to think it is file system/journaling or disk related, but I cannot be sure. There will usually be other errors in dmesg when a drive is failing, and the S.M.A.R.T. status is fine for both drives in the server.</p>

<p>What would cause such hangs?</p>
"
"<p>My server trigged OOM killer and I am trying to understand why. System has lot of RAM 128 GB and it looks like around 70GB of it was actually used. Reading through previous questions about OOM, it looks like this might be a case of memory fragmentation. See the syslog output</p>

<pre><code>Jun 23 17:20:10 server1 kernel: [517262.504589] gmond invoked oom-killer: gfp_mask=0x201da, order=0, oom_score_adj=0
Jun 23 17:20:10 server1 kernel: [517262.504593] gmond cpuset=/ mems_allowed=0-1
Jun 23 17:20:10 server1 kernel: [517262.504598] CPU: 4 PID: 1522 Comm: gmond Tainted: P           OE 3.15.1-031501-lowlatency #201406161841
Jun 23 17:20:10 server1 kernel: [517262.504599] Hardware name: Dell Inc. PowerEdge R420/0K29HN, BIOS 2.3.3 07/10/2014
Jun 23 17:20:10 server1 kernel: [517262.504601]  0000000000000000 ffff880fce2ab848 ffffffff817746ec 0000000000000007
Jun 23 17:20:10 server1 kernel: [517262.504603]  ffff880f74691950 ffff880fce2ab898 ffffffff8176a980 ffff880f00000000
Jun 23 17:20:10 server1 kernel: [517262.504605]  000201da81383df8 ffff881470376540 ffff881dcf7ab2a0 0000000000000000
Jun 23 17:20:10 server1 kernel: [517262.504607] Call Trace:
Jun 23 17:20:10 server1 kernel: [517262.504615]  [&lt;ffffffff817746ec&gt;] dump_stack+0x4e/0x71
Jun 23 17:20:10 server1 kernel: [517262.504618]  [&lt;ffffffff8176a980&gt;] dump_header+0x7e/0xbd
Jun 23 17:20:10 server1 kernel: [517262.504620]  [&lt;ffffffff8176aa16&gt;] oom_kill_process.part.6+0x57/0x30a
Jun 23 17:20:10 server1 kernel: [517262.504623]  [&lt;ffffffff811654e7&gt;] oom_kill_process+0x47/0x50
Jun 23 17:20:10 server1 kernel: [517262.504625]  [&lt;ffffffff81165825&gt;] out_of_memory+0x145/0x1d0
Jun 23 17:20:10 server1 kernel: [517262.504628]  [&lt;ffffffff8116c1ba&gt;] __alloc_pages_nodemask+0xb1a/0xc40
Jun 23 17:20:10 server1 kernel: [517262.504634]  [&lt;ffffffff811adba3&gt;] alloc_pages_current+0xb3/0x180
Jun 23 17:20:10 server1 kernel: [517262.504636]  [&lt;ffffffff81161737&gt;] __page_cache_alloc+0xb7/0xd0
Jun 23 17:20:10 server1 kernel: [517262.504638]  [&lt;ffffffff81163f80&gt;] filemap_fault+0x280/0x430
Jun 23 17:20:10 server1 kernel: [517262.504642]  [&lt;ffffffff8118a0d9&gt;] __do_fault+0x39/0x90
Jun 23 17:20:10 server1 kernel: [517262.504644]  [&lt;ffffffff8118e31e&gt;] do_read_fault.isra.59+0x10e/0x1d0
Jun 23 17:20:10 server1 kernel: [517262.504646]  [&lt;ffffffff8118e870&gt;] do_linear_fault.isra.61+0x70/0x80
Jun 23 17:20:10 server1 kernel: [517262.504647]  [&lt;ffffffff8118e986&gt;] handle_pte_fault+0x76/0x1b0
Jun 23 17:20:10 server1 kernel: [517262.504652]  [&lt;ffffffff81095fe0&gt;] ? lock_hrtimer_base.isra.25+0x30/0x60
Jun 23 17:20:10 server1 kernel: [517262.504654]  [&lt;ffffffff8118eea4&gt;] __handle_mm_fault+0x1b4/0x360
Jun 23 17:20:10 server1 kernel: [517262.504655]  [&lt;ffffffff8118f101&gt;] handle_mm_fault+0xb1/0x160
Jun 23 17:20:10 server1 kernel: [517262.504658]  [&lt;ffffffff81784667&gt;] ? __do_page_fault+0x2b7/0x5a0
Jun 23 17:20:10 server1 kernel: [517262.504660]  [&lt;ffffffff81784522&gt;] __do_page_fault+0x172/0x5a0
Jun 23 17:20:10 server1 kernel: [517262.504664]  [&lt;ffffffff8111fdec&gt;] ? acct_account_cputime+0x1c/0x20
Jun 23 17:20:10 server1 kernel: [517262.504667]  [&lt;ffffffff810a73a9&gt;] ? account_user_time+0x99/0xb0
Jun 23 17:20:10 server1 kernel: [517262.504669]  [&lt;ffffffff810a79dd&gt;] ? vtime_account_user+0x5d/0x70
Jun 23 17:20:10 server1 kernel: [517262.504671]  [&lt;ffffffff8178498e&gt;] do_page_fault+0x3e/0x80
Jun 23 17:20:10 server1 kernel: [517262.504673]  [&lt;ffffffff817811f8&gt;] page_fault+0x28/0x30
Jun 23 17:20:10 server1 kernel: [517262.504674] Mem-Info:
Jun 23 17:20:10 server1 kernel: [517262.504675] Node 0 DMA per-cpu:
Jun 23 17:20:10 server1 kernel: [517262.504677] CPU    0: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504678] CPU    1: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504679] CPU    2: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504680] CPU    3: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504681] CPU    4: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504682] CPU    5: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504683] CPU    6: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504684] CPU    7: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504685] CPU    8: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504686] CPU    9: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504687] CPU   10: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504687] CPU   11: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504688] CPU   12: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504689] CPU   13: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504690] CPU   14: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504691] CPU   15: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504692] CPU   16: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504693] CPU   17: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504694] CPU   18: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504695] CPU   19: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504696] CPU   20: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504697] CPU   21: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504698] CPU   22: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504698] CPU   23: hi:    0, btch:   1 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504699] Node 0 DMA32 per-cpu:
Jun 23 17:20:10 server1 kernel: [517262.504701] CPU    0: hi:  186, btch:  31 usd:  30
Jun 23 17:20:10 server1 kernel: [517262.504702] CPU    1: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504703] CPU    2: hi:  186, btch:  31 usd:  34
Jun 23 17:20:10 server1 kernel: [517262.504704] CPU    3: hi:  186, btch:  31 usd:  27
Jun 23 17:20:10 server1 kernel: [517262.504705] CPU    4: hi:  186, btch:  31 usd:  30
Jun 23 17:20:10 server1 kernel: [517262.504705] CPU    5: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504706] CPU    6: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504707] CPU    7: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504708] CPU    8: hi:  186, btch:  31 usd: 173
Jun 23 17:20:10 server1 kernel: [517262.504709] CPU    9: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504710] CPU   10: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504711] CPU   11: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504712] CPU   12: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504713] CPU   13: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504714] CPU   14: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504715] CPU   15: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504716] CPU   16: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504717] CPU   17: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504718] CPU   18: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504719] CPU   19: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504720] CPU   20: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504721] CPU   21: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504722] CPU   22: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504722] CPU   23: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504723] Node 0 Normal per-cpu:
Jun 23 17:20:10 server1 kernel: [517262.504724] CPU    0: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504725] CPU    1: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504726] CPU    2: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504727] CPU    3: hi:  186, btch:  31 usd:  14
Jun 23 17:20:10 server1 kernel: [517262.504728] CPU    4: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504729] CPU    5: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504730] CPU    6: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504731] CPU    7: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504732] CPU    8: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504733] CPU    9: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504734] CPU   10: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504735] CPU   11: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504736] CPU   12: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504737] CPU   13: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504738] CPU   14: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504739] CPU   15: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504740] CPU   16: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504740] CPU   17: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504741] CPU   18: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504742] CPU   19: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504743] CPU   20: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504744] CPU   21: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504745] CPU   22: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504746] CPU   23: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504747] Node 1 Normal per-cpu:
Jun 23 17:20:10 server1 kernel: [517262.504748] CPU    0: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504749] CPU    1: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504750] CPU    2: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504751] CPU    3: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504752] CPU    4: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504753] CPU    5: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504754] CPU    6: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504755] CPU    7: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504756] CPU    8: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504757] CPU    9: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504758] CPU   10: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504758] CPU   11: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504759] CPU   12: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504760] CPU   13: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504761] CPU   14: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504762] CPU   15: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504763] CPU   16: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504764] CPU   17: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504765] CPU   18: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504766] CPU   19: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504767] CPU   20: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504768] CPU   21: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504769] CPU   22: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504770] CPU   23: hi:  186, btch:  31 usd:   0
Jun 23 17:20:10 server1 kernel: [517262.504773] active_anon:17833290 inactive_anon:2465707 isolated_anon:0
Jun 23 17:20:10 server1 kernel: [517262.504773]  active_file:573 inactive_file:595 isolated_file:36
Jun 23 17:20:10 server1 kernel: [517262.504773]  unevictable:0 dirty:4 writeback:0 unstable:0
Jun 23 17:20:10 server1 kernel: [517262.504773]  free:82698 slab_reclaimable:43224 slab_unreclaimable:11476749
Jun 23 17:20:10 server1 kernel: [517262.504773]  mapped:2465518 shmem:2465767 pagetables:66385 bounce:0
Jun 23 17:20:10 server1 kernel: [517262.504773]  free_cma:0
Jun 23 17:20:10 server1 kernel: [517262.504776] Node 0 DMA free:14804kB min:8kB low:8kB high:12kB active_anon:0kB inactive_anon:0kB active_file:0kB inactive_file:0kB unevictable:0kB isolated(anon):0kB isolated(file):0kB present:15968kB managed:15828kB mlocked:0kB dirty:0kB writeback:0kB mapped:0kB shmem:0kB slab_reclaimable:0kB slab_unreclaimable:0kB kernel_stack:0kB pagetables:0kB unstable:0kB bounce:0kB free_cma:0kB writeback_tmp:0kB pages_scanned:0 all_unreclaimable? yes
Jun 23 17:20:10 server1 kernel: [517262.504779] lowmem_reserve[]: 0 2933 64370 64370
Jun 23 17:20:10 server1 kernel: [517262.504782] Node 0 DMA32 free:247776kB min:2048kB low:2560kB high:3072kB active_anon:1774744kB inactive_anon:607052kB active_file:0kB inactive_file:0kB unevictable:0kB isolated(anon):0kB isolated(file):0kB present:3083200kB managed:3003592kB mlocked:0kB dirty:16kB writeback:0kB mapped:607068kB shmem:607068kB slab_reclaimable:25524kB slab_unreclaimable:302060kB kernel_stack:4928kB pagetables:3100kB unstable:0kB bounce:0kB free_cma:0kB writeback_tmp:0kB pages_scanned:2660 all_unreclaimable? yes
Jun 23 17:20:10 server1 kernel: [517262.504785] lowmem_reserve[]: 0 0 61436 61436
Jun 23 17:20:10 server1 kernel: [517262.504787] Node 0 Normal free:34728kB min:42952kB low:53688kB high:64428kB active_anon:30286072kB inactive_anon:9255576kB active_file:236kB inactive_file:640kB unevictable:0kB isolated(anon):0kB isolated(file):16kB present:63963136kB managed:62911420kB mlocked:0kB dirty:0kB writeback:0kB mapped:9255000kB shmem:9255724kB slab_reclaimable:86416kB slab_unreclaimable:22165372kB kernel_stack:21072kB pagetables:121112kB unstable:0kB bounce:0kB free_cma:0kB writeback_tmp:0kB pages_scanned:13936 all_unreclaimable? yes
Jun 23 17:20:10 server1 kernel: [517262.504791] lowmem_reserve[]: 0 0 0 0
Jun 23 17:20:10 server1 kernel: [517262.504793] Node 1 Normal free:33484kB min:45096kB low:56368kB high:67644kB active_anon:39272344kB inactive_anon:200kB active_file:2112kB inactive_file:1752kB unevictable:0kB isolated(anon):0kB isolated(file):128kB present:67108864kB managed:66056916kB mlocked:0kB dirty:0kB writeback:0kB mapped:4kB shmem:276kB slab_reclaimable:60956kB slab_unreclaimable:23439564kB kernel_stack:13536kB pagetables:141328kB unstable:0kB bounce:0kB free_cma:0kB writeback_tmp:0kB pages_scanned:18448 all_unreclaimable? yes
Jun 23 17:20:10 server1 kernel: [517262.504797] lowmem_reserve[]: 0 0 0 0
Jun 23 17:20:10 server1 kernel: [517262.504799] Node 0 DMA: 1*4kB (U) 0*8kB 1*16kB (U) 0*32kB 1*64kB (U) 1*128kB (U) 1*256kB (U) 0*512kB 0*1024kB 1*2048kB (R) 3*4096kB (M) = 14804kB
Jun 23 17:20:10 server1 kernel: [517262.504807] Node 0 DMA32: 4660*4kB (UEM) 2172*8kB (EM) 1739*16kB (EM) 1046*32kB (UEM) 629*64kB (EM) 344*128kB (UEM) 155*256kB (E) 46*512kB (UE) 3*1024kB (E) 0*2048kB 0*4096kB = 247904kB
Jun 23 17:20:10 server1 kernel: [517262.504816] Node 0 Normal: 9038*4kB (M) 0*8kB 0*16kB 0*32kB 0*64kB 0*128kB 0*256kB 0*512kB 0*1024kB 0*2048kB 0*4096kB = 36152kB
Jun 23 17:20:10 server1 kernel: [517262.504822] Node 1 Normal: 9055*4kB (UM) 0*8kB 0*16kB 0*32kB 0*64kB 0*128kB 0*256kB 0*512kB 0*1024kB 0*2048kB 0*4096kB = 36220kB
Jun 23 17:20:10 server1 kernel: [517262.504829] Node 0 hugepages_total=0 hugepages_free=0 hugepages_surp=0 hugepages_size=2048kB
Jun 23 17:20:10 server1 kernel: [517262.504830] Node 1 hugepages_total=0 hugepages_free=0 hugepages_surp=0 hugepages_size=2048kB
Jun 23 17:20:10 server1 kernel: [517262.504831] 2467056 total pagecache pages
Jun 23 17:20:10 server1 kernel: [517262.504832] 0 pages in swap cache
Jun 23 17:20:10 server1 kernel: [517262.504833] Swap cache stats: add 0, delete 0, find 0/0
Jun 23 17:20:10 server1 kernel: [517262.504834] Free swap  = 0kB
Jun 23 17:20:10 server1 kernel: [517262.504834] Total swap = 0kB
Jun 23 17:20:10 server1 kernel: [517262.504835] 33542792 pages RAM
Jun 23 17:20:10 server1 kernel: [517262.504836] 0 pages HighMem/MovableOnly
Jun 23 17:20:10 server1 kernel: [517262.504837] 262987 pages reserved
Jun 23 17:20:10 server1 kernel: [517262.504838] 0 pages hwpoisoned
Jun 23 17:20:10 server1 kernel: [517262.504839] [ pid ]   uid  tgid total_vm      rss nr_ptes swapents oom_score_adj name
Jun 23 17:20:10 server1 kernel: [517262.504866] [  569]     0   569     4997      144      13        0             0 upstart-udev-br
Jun 23 17:20:10 server1 kernel: [517262.504868] [  578]     0   578    12891      187      29        0         -1000 systemd-udevd
Jun 23 17:20:10 server1 kernel: [517262.504873] [  692]   101   692    80659     2295      59        0             0 rsyslogd
Jun 23 17:20:10 server1 kernel: [517262.504875] [  750]     0   750     4084      331      13        0             0 upstart-file-br
Jun 23 17:20:10 server1 kernel: [517262.504877] [  792]     0   792     3815       53      13        0             0 upstart-socket-
Jun 23 17:20:10 server1 kernel: [517262.504877] [  792]     0   792     3815       53      13        0             0 upstart-socket-
Jun 23 17:20:10 server1 kernel: [517262.504879] [  842]   111   842    27001      275      53        0             0 dbus-daemon
Jun 23 17:20:10 server1 kernel: [517262.504880] [  851]     0   851     8834      101      22        0             0 systemd-logind
Jun 23 17:20:10 server1 kernel: [517262.504886] [ 1232]     0  1232     2558      572       8        0             0 dhclient
Jun 23 17:20:10 server1 kernel: [517262.504888] [ 1342]   104  1342    24484      281      49        0             0 ntpd
Jun 23 17:20:10 server1 kernel: [517262.504890] [ 1440]     0  1440     3955       41      12        0             0 getty
Jun 23 17:20:10 server1 kernel: [517262.504891] [ 1443]     0  1443     3955       41      12        0             0 getty
Jun 23 17:20:10 server1 kernel: [517262.504893] [ 1448]     0  1448     3955       39      13        0             0 getty
Jun 23 17:20:10 server1 kernel: [517262.504895] [ 1450]     0  1450     3955       41      13        0             0 getty
Jun 23 17:20:10 server1 kernel: [517262.504896] [ 1452]     0  1452     3955       42      13        0             0 getty
Jun 23 17:20:10 server1 kernel: [517262.504898] [ 1469]     0  1469     4785       40      13        0             0 atd
Jun 23 17:20:10 server1 kernel: [517262.504900] [ 1470]     0  1470    15341      168      32        0         -1000 sshd
Jun 23 17:20:10 server1 kernel: [517262.504902] [ 1472]     0  1472     5914       65      17        0             0 cron
Jun 23 17:20:10 server1 kernel: [517262.504904] [ 1478]   999  1478    16020     3710      31        0             0 gmond
Jun 23 17:20:10 server1 kernel: [517262.504905] [ 1486]     0  1486     4821       65      14        0             0 irqbalance
Jun 23 17:20:10 server1 kernel: [517262.504907] [ 1500]     0  1500   343627     1730      85        0             0 nscd                                                                                                          743,1          1%Jun 23 17:20:10 server1 kernel: [517262.504909] [ 1559]     0  1559     1092       37       8        0             0 acpid
Jun 23 17:20:10 server1 kernel: [517262.504911] [ 1641]     0  1641     4978       71      13        0             0 master
Jun 23 17:20:10 server1 kernel: [517262.504913] [ 1650]   103  1650     5427       72      14        0             0 qmgr
Jun 23 17:20:10 server1 kernel: [517262.504917] [ 1895]     0  1895     1900       30       9        0             0 getty
Jun 23 17:20:10 server1 kernel: [517262.504919] [ 1906]  1000  1906  2854329     2610    2594        0             0 thttpd
Jun 23 17:20:10 server1 kernel: [517262.504927] [ 3163]  1000  3163     2432       39      10        0             0 searchd
Jun 23 17:20:10 server1 kernel: [517262.504928] [ 3167]  1000  3167  2727221  2467025    4863        0             0 sphinx-daemon
Jun 23 17:20:10 server1 kernel: [517262.504931] [47622]  1000 47622 17834794 17329575   33989        0             0 MyExec

&lt;.................Trimmed bunch of processes with low mem usage.......................................&gt;


Jun 23 17:20:10 server1 kernel: [517262.508350] Out of memory: Kill process 47622 (MyExec) score 526 or sacrifice child
Jun 23 17:20:10 server1 kernel: [517262.508375] Killed process 47622 (MyExec) total-vm:71339176kB, anon-rss:69318300kB, file-rss:0kB
</code></pre>

<p>Looking at following lines, it seems like issue is fragmentation. </p>

<pre><code>Jun 23 17:20:10 server1 kernel: [517262.504816] Node 0 Normal: 9038*4kB (M) 0*8kB 0*16kB 0*32kB 0*64kB 0*128kB 0*256kB 0*512kB 0*1024kB 0*2048kB 0*4096kB = 36152kB
Jun 23 17:20:10 server1 kernel: [517262.504822] Node 1 Normal: 9055*4kB (UM) 0*8kB 0*16kB 0*32kB 0*64kB 0*128kB 0*256kB 0*512kB 0*1024kB 0*2048kB 0*4096kB = 36220kB
</code></pre>

<p>I have no idea as why the system would be so badly fragmented. It was only running for 5 days when this happened. Also looking at the process that invoked the oom killer (gmond invoked oom-killer: gfp_mask=0x201da, order=0, oom_score_adj=0), seems like it was only requesting 4K blocks and there are bunch  of those available. </p>

<ol>
<li>Is my understanding of fragmentation correct in this case?</li>
<li>How can I figure why the memory got so fragmented?</li>
<li>What can I do to avoid getting into this situation.</li>
</ol>

<p>One thing that you can notice is, I have completely turned off swap and have swappiness set to 0. The reason is my system has more than enough RAM and should never hit swap. I am planning to enable it and set swappiness to 10. I am not sure if that helps in this case.</p>

<p>Thanks for your input.</p>
"
"<p>I am newbie to Linux kernel and just started to know how <code>zram</code> works. Initial testing, I am seeing that <code>READ</code> is issued before <code>WRITE</code> just after the <code>zram</code> is being initialized. But I am just eager to know, <strong>why this is so ?</strong></p>

<p>As an activity I took the <code>dump_stack()</code> and followed the path form where to how this <code>zram</code> read is being performed. </p>

<p><code>zram</code> get to know this info whether it has to do <code>READ</code> or <code>WRITE</code> operation on issued <code>bio-&gt;bi_rw</code>. Code flow is like that <code>zram_make_request</code> API is being called from <code>create_device</code> in <code>zram</code> driver. And <code>zram_make_request</code> internally called <code>__zram_make_request</code> which called the <code>zram_bvec_rw</code> API.</p>

<p>In <code>zram_bvec_rw</code> API check the available info of <code>bio-&gt;bi_rw</code> and correspondingly issued the <code>READ</code> and <code>WRITE</code> call.</p>

<p>Now, in this case what is happening: <code>READ</code> is being encapsulated inside <code>bio</code> struct itself. As triage I found that <code>submit_bh</code> fills all the entry of <code>bio</code> and issued the <code>submit_bio</code>. </p>

<p>I was wondering who is actually sets the <code>bio-&gt;bi_rw</code> as <code>READ</code>. By enabling the few prints I found that <code>ll_rw_block</code> API is being called by <code>__block_write_begin</code> with <code>READ</code>, later <code>ll_rw_block</code> calls the <code>submit_bh</code> API where rest of <code>bio</code> struct entries are filled.</p>

<p>But I am still not getting the answer <strong>why <code>READ</code> is issued for <code>ll_rw_block</code> from <code>__block_write_begin</code> ?</strong></p>

<ul>
<li><strong>zram driver:</strong></li>
</ul>

<p><a href=""https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/tree/drivers/block/zram/zram_drv.c?id=refs/tags/v3.18.14"" rel=""nofollow"">https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/tree/drivers/block/zram/zram_drv.c?id=refs/tags/v3.18.14</a></p>

<p>in file: <a href=""https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/tree/fs/buffer.c?id=refs/tags/v3.18.14"" rel=""nofollow"">https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/tree/fs/buffer.c?id=refs/tags/v3.18.14</a> </p>

<pre><code>    if (!buffer_uptodate(bh) &amp;&amp; !buffer_delay(bh) &amp;&amp;
        !buffer_unwritten(bh) &amp;&amp;
         (block_start &lt; from || block_end &gt; to)) {
        ll_rw_block(READ, 1, &amp;bh);
        *wait_bh++=bh;
    }



 buffer_uptodate(bh),   /* Contains valid data */
 buffer_delay(bh),  /* Buffer is not yet allocated on disk */
 buffer_unwritten(bh),  /* Buffer is allocated on disk but not written */
</code></pre>

<p>Please can someone give an explaination/answer to my question ?</p>

<p><strong>How I am concluding that read is perfomed before write ??</strong></p>

<p>I just check the <code>num_reads</code> and <code>num_writes</code> count. And <code>num_reads</code> count is set to <code>1</code> while <code>num_writes</code> is found <code>0</code> when we do <code>mkswap /dev/block/zram0</code> and after calling the <code>swapon /dev/block/zram0</code> the final counts are <code>num_reads = 2 and num_writes=1</code>.</p>

<p><strong>NOTE:</strong> This is the case when we don't performing any additional <code>zram</code> activity. We got this behavior in case as explained above.</p>
"
"<p>All, I run a java application container with resource limit, as  lots of oom kill events happen every 2 or 3 minutes, then execute ps aux, the command hangs.  this problem is easy to reproduced when run docker instance with kubernete, and khugepage was already set disabled. Would anyone can help?   thx.</p>

<pre><code>2. physical machine with system info:
```
3.10.0-327.el7.x86_64 #1 SMP Thu Nov 19 22:10:57 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux CentOS
Linux release 7.2.1511 (Core)
```

3. strace info:

```
read(6, ""Name:\tpause\nState:\tS (sleeping)\n""..., 2048) = 1065
close(6) = 0
open(""/proc/43136/cmdline"", O_RDONLY) = 6
read(6, ""/pause\0"", 131072) = 7
read(6, """", 131065) = 0
close(6) = 0
stat(""/etc/localtime"", {st_mode=S_IFREG|0644, st_size=388, ...}) = 0
stat(""/etc/localtime"", {st_mode=S_IFREG|0644, st_size=388, ...}) = 0
write(1, ""root 43136 0.0 0.0 1020 ""..., 73root 43136 0.0 0.0 1020 4 ? Ss 8?18 0:00 /pause
) = 73
stat(""/proc/43140"", {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0
open(""/proc/44860/stat"", O_RDONLY) = 6
read(6, ""44860 (exe) D 1 43140 43140 0 -1""..., 2048) = 319
close(6) = 0
open(""/proc/44860/status"", O_RDONLY) = 6
read(6, ""Name:\texe\nState:\tD (disk sleep)\n""..., 2048) = 1060
close(6) = 0
open(""/proc/44860/cmdline"", O_RDONLY) = 6
read(6,
```

4. 44860 process state is D (disk sleep), and stack is

```
[&lt;ffffffff81301813&gt;] call_rwsem_down_write_failed+0x13/0x20
[&lt;ffffffff81187a1c&gt;] vm_mmap_pgoff+0x8c/0xe0
[&lt;ffffffff8119cb86&gt;] SyS_mmap_pgoff+0x116/0x270
[&lt;ffffffff81019712&gt;] SyS_mmap+0x22/0x30
[&lt;ffffffff81645909&gt;] system_call_fastpath+0x16/0x1b
[&lt;ffffffffffffffff&gt;] 0xffffffffffffffff
```


5. lots of stack Call Trace messages fellowed on the system:

```
[17983.298787] INFO: task kworker/13:0:172 blocked for more than 120 seconds.
[17983.298864] ""echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs"" disables this message.
[17983.298931] kworker/13:0 D ffff880321a01a20 0 172 2 0x00000000
[17983.298986] Workqueue: xfs-data/dm-22 xfs_end_io [xfs]
[17983.298990] ffff880819be7c98 0000000000000046 ffff880819bd2280 ffff880819be7fd8
[17983.298999] ffff880819be7fd8 ffff880819be7fd8 ffff880819bd2280 ffff880819bd2280
[17983.299005] ffff880321a01a10 ffff880321a01a18 ffffffff00000000 ffff880321a01a20
[17983.299012] Call Trace:
[17983.299027] [&lt;ffffffff8163a909&gt;] schedule+0x29/0x70
[17983.299035] [&lt;ffffffff8163c0c5&gt;] rwsem_down_write_failed+0x115/0x220
[17983.299044] [&lt;ffffffff810c3401&gt;] ? enqueue_entity+0x181/0x890
[17983.299074] [&lt;ffffffffa05ee236&gt;] ? xfs_setfilesize+0x56/0x130 [xfs]
[17983.299083] [&lt;ffffffff81301813&gt;] call_rwsem_down_write_failed+0x13/0x20
[17983.299089] [&lt;ffffffff81639b5d&gt;] ? down_write+0x2d/0x30
[17983.299122] [&lt;ffffffffa06069a1&gt;] xfs_ilock+0xc1/0x120 [xfs]
[17983.299150] [&lt;ffffffffa05ee236&gt;] xfs_setfilesize+0x56/0x130 [xfs]
[17983.299177] [&lt;ffffffffa05ef182&gt;] xfs_end_io+0x62/0xc0 [xfs]
[17983.299183] [&lt;ffffffff8109d5fb&gt;] process_one_work+0x17b/0x470
[17983.299188] [&lt;ffffffff8109e3cb&gt;] worker_thread+0x11b/0x400
[17983.299193] [&lt;ffffffff8109e2b0&gt;] ? rescuer_thread+0x400/0x400
[17983.299199] [&lt;ffffffff810a5aef&gt;] kthread+0xcf/0xe0
[17983.299206] [&lt;ffffffff810a5a20&gt;] ? kthread_create_on_node+0x140/0x140
[17983.299214] [&lt;ffffffff81645858&gt;] ret_from_fork+0x58/0x90
[17983.299220] [&lt;ffffffff810a5a20&gt;] ? kthread_create_on_node+0x140/0x140
[17983.299374] INFO: task kworker/13:2:9980 blocked for more than 120 seconds.
[17983.299433] ""echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs"" disables this message.
[17983.299499] kworker/13:2 D ffff880819bd2a84 0 9980 2 0x00000080
[17983.299529] Workqueue: xfs-data/dm-22 xfs_end_io [xfs]
[17983.299531] ffff880805197c98 0000000000000046 ffff8807f98dd080 ffff880805197fd8
[17983.299538] ffff880805197fd8 ffff880805197fd8 ffff8807f98dd080 ffff8807f98dd080
[17983.299544] ffff880321a01a10 ffff880321a01a18 ffffffff00000000 ffff880321a01a20
[17983.299550] Call Trace:
[17983.299556] [&lt;ffffffff8163a909&gt;] schedule+0x29/0x70
[17983.299562] [&lt;ffffffff8163c0c5&gt;] rwsem_down_write_failed+0x115/0x220
[17983.299567] [&lt;ffffffff810a6b00&gt;] ? autoremove_wake_function+0x20/0x40
[17983.299593] [&lt;ffffffffa05ee236&gt;] ? xfs_setfilesize+0x56/0x130 [xfs]
[17983.299600] [&lt;ffffffff81301813&gt;] call_rwsem_down_write_failed+0x13/0x20
[17983.299605] [&lt;ffffffff81639b5d&gt;] ? down_write+0x2d/0x30
[17983.299636] [&lt;ffffffffa06069a1&gt;] xfs_ilock+0xc1/0x120 [xfs]
[17983.299662] [&lt;ffffffffa05ee236&gt;] xfs_setfilesize+0x56/0x130 [xfs]
[17983.299687] [&lt;ffffffffa05ef182&gt;] xfs_end_io+0x62/0xc0 [xfs]
[17983.299712] [&lt;ffffffff8109d5fb&gt;] process_one_work+0x17b/0x470
[17983.299717] [&lt;ffffffff8109e3cb&gt;] worker_thread+0x11b/0x400
[17983.299722] [&lt;ffffffff8109e2b0&gt;] ? rescuer_thread+0x400/0x400
[17983.299728] [&lt;ffffffff810a5aef&gt;] kthread+0xcf/0xe0
[17983.299734] [&lt;ffffffff810a5a20&gt;] ? kthread_create_on_node+0x140/0x140
[17983.299740] [&lt;ffffffff81645858&gt;] ret_from_fork+0x58/0x90
[17983.299745] [&lt;ffffffff810a5a20&gt;] ? kthread_create_on_node+0x140/0x140
[17983.299915] INFO: task java:43364 blocked for more than 120 seconds.
[17983.299970] ""echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs"" disables this message.
[17983.300036] java D ffff8803dfc8f4c0 0 43364 43299 0x00000080
[17983.300041] ffff8803dfc8f360 0000000000000086 ffff8800babbe780 ffff8803dfc8ffd8
[17983.300047] ffff8803dfc8ffd8 ffff8803dfc8ffd8 ffff8800babbe780 ffff88041fa34780
[17983.300056] 0000000000000000 7fffffffffffffff ffffffff811688b0 ffff8803dfc8f4c0
[17983.300062] Call Trace:
[17983.300069] [&lt;ffffffff811688b0&gt;] ? wait_on_page_read+0x60/0x60
[17983.300075] [&lt;ffffffff8163a909&gt;] schedule+0x29/0x70
[17983.300080] [&lt;ffffffff816385f9&gt;] schedule_timeout+0x209/0x2d0
[17983.300089] [&lt;ffffffff812c74a7&gt;] ? queue_unplugged+0x37/0xa0
[17983.300100] [&lt;ffffffff8101c829&gt;] ? read_tsc+0x9/0x10
[17983.300105] [&lt;ffffffff811688b0&gt;] ? wait_on_page_read+0x60/0x60
[17983.300110] [&lt;ffffffff81639f3e&gt;] io_schedule_timeout+0xae/0x130
[17983.300115] [&lt;ffffffff81639fd8&gt;] io_schedule+0x18/0x20
[17983.300119] [&lt;ffffffff811688be&gt;] sleep_on_page+0xe/0x20
[17983.300124] [&lt;ffffffff81638780&gt;] __wait_on_bit+0x60/0x90
[17983.300130] [&lt;ffffffff81168646&gt;] wait_on_page_bit+0x86/0xb0
[17983.300135] [&lt;ffffffff810a6b60&gt;] ? wake_atomic_t_function+0x40/0x40
[17983.300154] [&lt;ffffffffa0337e0e&gt;] ? dm_any_congested+0x4e/0x60 [dm_mod]
[17983.300163] [&lt;ffffffff8117d472&gt;] shrink_page_list+0x6c2/0xad0
[17983.300171] [&lt;ffffffff8117df3a&gt;] shrink_inactive_list+0x1ea/0x560
[17983.300176] [&lt;ffffffff8117ea05&gt;] shrink_lruvec+0x375/0x760
[17983.300182] [&lt;ffffffff8117ee66&gt;] shrink_zone+0x76/0x1a0
[17983.300187] [&lt;ffffffff8117f370&gt;] do_try_to_free_pages+0xf0/0x4e0
[17983.300197] [&lt;ffffffffa0336aca&gt;] ? __map_bio+0x3a/0x100 [dm_mod]
[17983.300204] [&lt;ffffffff8117f9aa&gt;] try_to_free_mem_cgroup_pages+0xca/0x160
[17983.300212] [&lt;ffffffff811d207e&gt;] mem_cgroup_reclaim+0x4e/0xe0
[17983.300217] [&lt;ffffffff811d253c&gt;] __mem_cgroup_try_charge+0x42c/0x650
[17983.300226] [&lt;ffffffff81216ac8&gt;] ? __bio_add_page+0x1f8/0x2a0
[17983.300231] [&lt;ffffffff811d2e89&gt;] mem_cgroup_charge_common+0x59/0xc0
[17983.300236] [&lt;ffffffff811d505a&gt;] mem_cgroup_cache_charge+0x8a/0xb0
[17983.300242] [&lt;ffffffff811694e2&gt;] __add_to_page_cache_locked+0x52/0x260
[17983.300249] [&lt;ffffffff81169747&gt;] add_to_page_cache_lru+0x37/0xb0
[17983.300254] [&lt;ffffffff8121fae5&gt;] mpage_readpages+0xb5/0x160
[17983.300281] [&lt;ffffffffa05ef910&gt;] ? __xfs_get_blocks+0x4b0/0x4b0 [xfs]
[17983.300308] [&lt;ffffffffa05ef910&gt;] ? __xfs_get_blocks+0x4b0/0x4b0 [xfs]
[17983.300334] [&lt;ffffffffa05eea5d&gt;] xfs_vm_readpages+0x1d/0x20 [xfs]
[17983.300344] [&lt;ffffffff81175cdc&gt;] __do_page_cache_readahead+0x1cc/0x250
[17983.300350] [&lt;ffffffff81176321&gt;] ra_submit+0x21/0x30
[17983.300355] [&lt;ffffffff8116b7ed&gt;] filemap_fault+0x11d/0x430
[17983.300385] [&lt;ffffffffa05fa1df&gt;] xfs_filemap_fault+0x4f/0xa0 [xfs]
[17983.300395] [&lt;ffffffff81192b2e&gt;] __do_fault+0x7e/0x510
[17983.300402] [&lt;ffffffff81197088&gt;] handle_mm_fault+0x5b8/0xf50
[17983.300411] [&lt;ffffffff810e5092&gt;] ? do_futex+0x122/0x5b0
[17983.300417] [&lt;ffffffff81640e22&gt;] __do_page_fault+0x152/0x420
[17983.300422] [&lt;ffffffff81641113&gt;] do_page_fault+0x23/0x80
[17983.300428] [&lt;ffffffff8163d408&gt;] page_fault+0x28/0x30
[17983.300435] INFO: task java:43383 blocked for more than 120 seconds.
[17983.300490] ""echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs"" disables this message.
[17983.300555] java D ffff880324b4f4c0 0 43383 43299 0x00000080
[17983.300561] ffff880324b4f360 0000000000000086 ffff880326372e00 ffff880324b4ffd8
[17983.300567] ffff880324b4ffd8 ffff880324b4ffd8 ffff880326372e00 ffff88041fa34780
[17983.300573] 0000000000000000 7fffffffffffffff ffffffff811688b0 ffff880324b4f4c0
[17983.300579] Call Trace:
[17983.300584] [&lt;ffffffff811688b0&gt;] ? wait_on_page_read+0x60/0x60
[17983.300590] [&lt;ffffffff8163a909&gt;] schedule+0x29/0x70
[17983.300596] [&lt;ffffffff816385f9&gt;] schedule_timeout+0x209/0x2d0
[17983.300602] [&lt;ffffffff812c74a7&gt;] ? queue_unplugged+0x37/0xa0
[17983.300608] [&lt;ffffffff8101c829&gt;] ? read_tsc+0x9/0x10
[17983.300612] [&lt;ffffffff811688b0&gt;] ? wait_on_page_read+0x60/0x60
[17983.300617] [&lt;ffffffff81639f3e&gt;] io_schedule_timeout+0xae/0x130
[17983.300622] [&lt;ffffffff81639fd8&gt;] io_schedule+0x18/0x20
[17983.300626] [&lt;ffffffff811688be&gt;] sleep_on_page+0xe/0x20
[17983.300633] [&lt;ffffffff81638780&gt;] __wait_on_bit+0x60/0x90
[17983.300637] [&lt;ffffffff81168646&gt;] wait_on_page_bit+0x86/0xb0
[17983.300642] [&lt;ffffffff810a6b60&gt;] ? wake_atomic_t_function+0x40/0x40
[17983.300653] [&lt;ffffffffa0337e0e&gt;] ? dm_any_congested+0x4e/0x60 [dm_mod]
[17983.300658] [&lt;ffffffff8117d472&gt;] shrink_page_list+0x6c2/0xad0
[17983.300664] [&lt;ffffffff8117c843&gt;] ? isolate_lru_pages.isra.43+0xd3/0x190
[17983.300671] [&lt;ffffffff8117df3a&gt;] shrink_inactive_list+0x1ea/0x560
[17983.300676] [&lt;ffffffff8117ea05&gt;] shrink_lruvec+0x375/0x760
[17983.300681] [&lt;ffffffff8109b426&gt;] ? __queue_work+0x136/0x320
[17983.300685] [&lt;ffffffff8109b426&gt;] ? __queue_work+0x136/0x320
[17983.300702] [&lt;ffffffff8117ee66&gt;] shrink_zone+0x76/0x1a0
[17983.300708] [&lt;ffffffff8117f370&gt;] do_try_to_free_pages+0xf0/0x4e0
[17983.300717] [&lt;ffffffffa0336aca&gt;] ? __map_bio+0x3a/0x100 [dm_mod]
[17983.300722] [&lt;ffffffff8117f9aa&gt;] try_to_free_mem_cgroup_pages+0xca/0x160
[17983.300728] [&lt;ffffffff811d207e&gt;] mem_cgroup_reclaim+0x4e/0xe0
[17983.300741] [&lt;ffffffff811d253c&gt;] __mem_cgroup_try_charge+0x42c/0x650
[17983.300747] [&lt;ffffffff81216ac8&gt;] ? __bio_add_page+0x1f8/0x2a0
[17983.300752] [&lt;ffffffff811d2e89&gt;] mem_cgroup_charge_common+0x59/0xc0
[17983.300757] [&lt;ffffffff811d505a&gt;] mem_cgroup_cache_charge+0x8a/0xb0
[17983.300761] [&lt;ffffffff811694e2&gt;] __add_to_page_cache_locked+0x52/0x260
[17983.300766] [&lt;ffffffff81169747&gt;] add_to_page_cache_lru+0x37/0xb0
[17983.300770] [&lt;ffffffff8121fae5&gt;] mpage_readpages+0xb5/0x160
[17983.300798] [&lt;ffffffffa05ef910&gt;] ? __xfs_get_blocks+0x4b0/0x4b0 [xfs]
[17983.300823] [&lt;ffffffffa05ef910&gt;] ? __xfs_get_blocks+0x4b0/0x4b0 [xfs]
[17983.300849] [&lt;ffffffffa05eea5d&gt;] xfs_vm_readpages+0x1d/0x20 [xfs]
[17983.300855] [&lt;ffffffff81175cdc&gt;] __do_page_cache_readahead+0x1cc/0x250
[17983.300864] [&lt;ffffffff81176321&gt;] ra_submit+0x21/0x30
[17983.300868] [&lt;ffffffff8116b7ed&gt;] filemap_fault+0x11d/0x430
[17983.300897] [&lt;ffffffffa05fa1df&gt;] xfs_filemap_fault+0x4f/0xa0 [xfs]
[17983.300904] [&lt;ffffffff81192b2e&gt;] __do_fault+0x7e/0x510
[17983.300910] [&lt;ffffffff81197088&gt;] handle_mm_fault+0x5b8/0xf50
[17983.300916] [&lt;ffffffff81640e22&gt;] __do_page_fault+0x152/0x420
[17983.300921] [&lt;ffffffff81641113&gt;] do_page_fault+0x23/0x80
[17983.300927] [&lt;ffffffff8163d408&gt;] page_fault+0x28/0x30
[17983.300932] INFO: task java:43385 blocked for more than 120 seconds.
[17983.300988] ""echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs"" disables this message.
[17983.301053] java D ffff8803efb23840 0 43385 43299 0x00000080
[17983.301058] ffff8803efb236e0 0000000000000086 ffff880326374500 ffff8803efb23fd8
[17983.301066] ffff8803efb23fd8 ffff8803efb23fd8 ffff880326374500 ffff88041fa34780
[17983.301072] 0000000000000000 7fffffffffffffff ffffffff811688b0 ffff8803efb23840
[17983.301078] Call Trace:
[17983.301083] [&lt;ffffffff811688b0&gt;] ? wait_on_page_read+0x60/0x60
[17983.301088] [&lt;ffffffff8163a909&gt;] schedule+0x29/0x70
[17983.301093] [&lt;ffffffff816385f9&gt;] schedule_timeout+0x209/0x2d0
[17983.301099] [&lt;ffffffff812c74a7&gt;] ? queue_unplugged+0x37/0xa0
[17983.301106] [&lt;ffffffff8101c829&gt;] ? read_tsc+0x9/0x10
[17983.301110] [&lt;ffffffff811688b0&gt;] ? wait_on_page_read+0x60/0x60
[17983.301115] [&lt;ffffffff81639f3e&gt;] io_schedule_timeout+0xae/0x130
[17983.301120] [&lt;ffffffff81639fd8&gt;] io_schedule+0x18/0x20
[17983.301124] [&lt;ffffffff811688be&gt;] sleep_on_page+0xe/0x20
[17983.301129] [&lt;ffffffff81638780&gt;] __wait_on_bit+0x60/0x90
[17983.301134] [&lt;ffffffff81168646&gt;] wait_on_page_bit+0x86/0xb0
[17983.301140] [&lt;ffffffff810a6b60&gt;] ? wake_atomic_t_function+0x40/0x40
[17983.301151] [&lt;ffffffffa0337e0e&gt;] ? dm_any_congested+0x4e/0x60 [dm_mod]
[17983.301156] [&lt;ffffffff8117d472&gt;] shrink_page_list+0x6c2/0xad0
[17983.301162] [&lt;ffffffff8117c843&gt;] ? isolate_lru_pages.isra.43+0xd3/0x190
[17983.301167] [&lt;ffffffff8117df3a&gt;] shrink_inactive_list+0x1ea/0x560
[17983.301173] [&lt;ffffffff8117ea05&gt;] shrink_lruvec+0x375/0x760
[17983.301180] [&lt;ffffffff8117ee66&gt;] shrink_zone+0x76/0x1a0
[17983.301186] [&lt;ffffffff8117f370&gt;] do_try_to_free_pages+0xf0/0x4e0
[17983.301191] [&lt;ffffffff8117f9aa&gt;] try_to_free_mem_cgroup_pages+0xca/0x160
[17983.301196] [&lt;ffffffff811d207e&gt;] mem_cgroup_reclaim+0x4e/0xe0
[17983.301201] [&lt;ffffffff811d253c&gt;] __mem_cgroup_try_charge+0x42c/0x650
[17983.301207] [&lt;ffffffff811d3dab&gt;] __mem_cgroup_try_charge_swapin+0x9b/0xd0
[17983.301213] [&lt;ffffffff81168b6e&gt;] ? __find_get_page+0x1e/0xa0
[17983.301218] [&lt;ffffffff811d4cb7&gt;] mem_cgroup_try_charge_swapin+0x57/0x70
[17983.301223] [&lt;ffffffff811972fd&gt;] handle_mm_fault+0x82d/0xf50
[17983.301228] [&lt;ffffffff81640e22&gt;] __do_page_fault+0x152/0x420
[17983.301233] [&lt;ffffffff81641113&gt;] do_page_fault+0x23/0x80
[17983.301239] [&lt;ffffffff8163d408&gt;] page_fault+0x28/0x30
[17983.301244] INFO: task java:43387 blocked for more than 120 seconds.
[17983.301298] ""echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs"" disables this message.
[17983.301363] java D ffff8803efb6f4c0 0 43387 43299 0x00000080
[17983.301367] ffff8803efb6f360 0000000000000086 ffff880326375c00 ffff8803efb6ffd8
[17983.301375] ffff8803efb6ffd8 ffff8803efb6ffd8 ffff880326375c00 ffff88041fa54780
[17983.301381] 0000000000000000 7fffffffffffffff ffffffff811688b0 ffff8803efb6f4c0
[17983.301387] Call Trace:
[17983.301392] [&lt;ffffffff811688b0&gt;] ? wait_on_page_read+0x60/0x60
[17983.301397] [&lt;ffffffff8163a909&gt;] schedule+0x29/0x70
[17983.301402] [&lt;ffffffff816385f9&gt;] schedule_timeout+0x209/0x2d0
[17983.301408] [&lt;ffffffff81065e58&gt;] ? native_flush_tlb_others+0xb8/0xc0
[17983.301415] [&lt;ffffffff8101c829&gt;] ? read_tsc+0x9/0x10
[17983.301419] [&lt;ffffffff811688b0&gt;] ? wait_on_page_read+0x60/0x60
[17983.301424] [&lt;ffffffff81639f3e&gt;] io_schedule_timeout+0xae/0x130
[17983.301429] [&lt;ffffffff81639fd8&gt;] io_schedule+0x18/0x20
[17983.301433] [&lt;ffffffff811688be&gt;] sleep_on_page+0xe/0x20
[17983.301438] [&lt;ffffffff81638780&gt;] __wait_on_bit+0x60/0x90
[17983.301443] [&lt;ffffffff81168646&gt;] wait_on_page_bit+0x86/0xb0
[17983.301447] [&lt;ffffffff810a6b60&gt;] ? wake_atomic_t_function+0x40/0x40
[17983.301458] [&lt;ffffffffa0337e0e&gt;] ? dm_any_congested+0x4e/0x60 [dm_mod]
[17983.301462] [&lt;ffffffff8117d472&gt;] shrink_page_list+0x6c2/0xad0
[17983.301469] [&lt;ffffffff8117df3a&gt;] shrink_inactive_list+0x1ea/0x560
[17983.301474] [&lt;ffffffff8117ea05&gt;] shrink_lruvec+0x375/0x760
[17983.301481] [&lt;ffffffff8109b426&gt;] ? __queue_work+0x136/0x320
[17983.301485] [&lt;ffffffff8109b426&gt;] ? __queue_work+0x136/0x320
[17983.301491] [&lt;ffffffff8117ee66&gt;] shrink_zone+0x76/0x1a0
[17983.301496] [&lt;ffffffff8117f370&gt;] do_try_to_free_pages+0xf0/0x4e0
[17983.301501] [&lt;ffffffff8116be05&gt;] ? mempool_alloc_slab+0x15/0x20
[17983.301527] [&lt;ffffffffa05cccc8&gt;] ? xfs_bmbt_get_all+0x18/0x20 [xfs]
[17983.301534] [&lt;ffffffff8117f9aa&gt;] try_to_free_mem_cgroup_pages+0xca/0x160
[17983.301539] [&lt;ffffffff811d207e&gt;] mem_cgroup_reclaim+0x4e/0xe0
[17983.301543] [&lt;ffffffff811d253c&gt;] __mem_cgroup_try_charge+0x42c/0x650
[17983.301549] [&lt;ffffffff81216ac8&gt;] ? __bio_add_page+0x1f8/0x2a0
[17983.301554] [&lt;ffffffff811d2e89&gt;] mem_cgroup_charge_common+0x59/0xc0
[17983.301559] [&lt;ffffffff811d505a&gt;] mem_cgroup_cache_charge+0x8a/0xb0
[17983.301565] [&lt;ffffffff811694e2&gt;] __add_to_page_cache_locked+0x52/0x260
[17983.301569] [&lt;ffffffff81169747&gt;] add_to_page_cache_lru+0x37/0xb0
[17983.301574] [&lt;ffffffff8121fae5&gt;] mpage_readpages+0xb5/0x160
[17983.301600] [&lt;ffffffffa05ef910&gt;] ? __xfs_get_blocks+0x4b0/0x4b0 [xfs]
[17983.301627] [&lt;ffffffffa05ef910&gt;] ? __xfs_get_blocks+0x4b0/0x4b0 [xfs]
[17983.301653] [&lt;ffffffffa05eea5d&gt;] xfs_vm_readpages+0x1d/0x20 [xfs]
[17983.301661] [&lt;ffffffff81175cdc&gt;] __do_page_cache_readahead+0x1cc/0x250
[17983.301667] [&lt;ffffffff81176321&gt;] ra_submit+0x21/0x30
[17983.301671] [&lt;ffffffff8116b7ed&gt;] filemap_fault+0x11d/0x430
[17983.301700] [&lt;ffffffffa05fa1df&gt;] xfs_filemap_fault+0x4f/0xa0 [xfs]
[17983.301716] [&lt;ffffffff81192b2e&gt;] __do_fault+0x7e/0x510
[17983.301724] [&lt;ffffffff81197088&gt;] handle_mm_fault+0x5b8/0xf50
[17983.301729] [&lt;ffffffff81640e22&gt;] __do_page_fault+0x152/0x420
[17983.301734] [&lt;ffffffff81641113&gt;] do_page_fault+0x23/0x80
[17983.301740] [&lt;ffffffff8163d408&gt;] page_fault+0x28/0x30
[17983.301748] INFO: task java:43800 blocked for more than 120 seconds.
[17983.301803] ""echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs"" disables this message.
[17983.301868] java D ffff8803258f73a0 0 43800 43299 0x00000080
[17983.301873] ffff8803258f7240 0000000000000086 ffff8803e01cd080 ffff8803258f7fd8
[17983.301881] ffff8803258f7fd8 ffff8803258f7fd8 ffff8803e01cd080 ffff88082f6b4780
[17983.301887] 0000000000000000 7fffffffffffffff ffffffff811688b0 ffff8803258f73a0
[17983.301893] Call Trace:
[17983.301898] [&lt;ffffffff811688b0&gt;] ? wait_on_page_read+0x60/0x60
[17983.301903] [&lt;ffffffff8163a909&gt;] schedule+0x29/0x70
[17983.301908] [&lt;ffffffff816385f9&gt;] schedule_timeout+0x209/0x2d0
[17983.301915] [&lt;ffffffff8104671c&gt;] ? native_send_call_func_single_ipi+0x3c/0x40
[17983.301922] [&lt;ffffffff8101c829&gt;] ? read_tsc+0x9/0x10
[17983.301926] [&lt;ffffffff811688b0&gt;] ? wait_on_page_read+0x60/0x60
[17983.301931] [&lt;ffffffff81639f3e&gt;] io_schedule_timeout+0xae/0x130
[17983.301936] [&lt;ffffffff81639fd8&gt;] io_schedule+0x18/0x20
[17983.301940] [&lt;ffffffff811688be&gt;] sleep_on_page+0xe/0x20
[17983.301945] [&lt;ffffffff81638780&gt;] __wait_on_bit+0x60/0x90
[17983.301950] [&lt;ffffffff81168646&gt;] wait_on_page_bit+0x86/0xb0
[17983.301956] [&lt;ffffffff810a6b60&gt;] ? wake_atomic_t_function+0x40/0x40
[17983.301967] [&lt;ffffffffa0337e0e&gt;] ? dm_any_congested+0x4e/0x60 [dm_mod]
[17983.301972] [&lt;ffffffff8117d472&gt;] shrink_page_list+0x6c2/0xad0
[17983.301978] [&lt;ffffffff8117c843&gt;] ? isolate_lru_pages.isra.43+0xd3/0x190
[17983.301983] [&lt;ffffffff8117df3a&gt;] shrink_inactive_list+0x1ea/0x560
[17983.301989] [&lt;ffffffff8117ea05&gt;] shrink_lruvec+0x375/0x760
[17983.301996] [&lt;ffffffff8117ee66&gt;] shrink_zone+0x76/0x1a0
[17983.302001] [&lt;ffffffff8117f370&gt;] do_try_to_free_pages+0xf0/0x4e0
[17983.302007] [&lt;ffffffff8117f9aa&gt;] try_to_free_mem_cgroup_pages+0xca/0x160
[17983.302012] [&lt;ffffffff811d207e&gt;] mem_cgroup_reclaim+0x4e/0xe0
[17983.302016] [&lt;ffffffff811d253c&gt;] __mem_cgroup_try_charge+0x42c/0x650
[17983.302023] [&lt;ffffffff811d4a93&gt;] __memcg_kmem_newpage_charge+0x123/0x190
[17983.302030] [&lt;ffffffff81172fc5&gt;] __alloc_pages_nodemask+0x265/0xb90
[17983.302066] [&lt;ffffffffa0614127&gt;] ? kmem_zone_alloc+0x77/0x100 [xfs]
[17983.302074] [&lt;ffffffff811b43f9&gt;] alloc_pages_current+0xa9/0x170
[17983.302081] [&lt;ffffffff811be9fc&gt;] new_slab+0x2ec/0x300
[17983.302089] [&lt;ffffffff81632161&gt;] __slab_alloc+0x315/0x48f
[17983.302120] [&lt;ffffffffa0614127&gt;] ? kmem_zone_alloc+0x77/0x100 [xfs]
[17983.302144] [&lt;ffffffffa05c295c&gt;] ? xfs_bmap_search_extents+0x5c/0xc0 [xfs]
[17983.302149] [&lt;ffffffff811c0fc3&gt;] kmem_cache_alloc+0x193/0x1d0
[17983.302179] [&lt;ffffffffa0614127&gt;] ? kmem_zone_alloc+0x77/0x100 [xfs]
[17983.302209] [&lt;ffffffffa0614127&gt;] kmem_zone_alloc+0x77/0x100 [xfs]
[17983.302243] [&lt;ffffffffa061aeaa&gt;] xfs_efi_init+0x2a/0x90 [xfs]
[17983.302278] [&lt;ffffffffa0623f78&gt;] xfs_trans_get_efi+0x18/0x30 [xfs]
[17983.302308] [&lt;ffffffffa05f2800&gt;] xfs_bmap_finish+0x70/0x1b0 [xfs]
[17983.302340] [&lt;ffffffffa0608f8d&gt;] xfs_itruncate_extents+0x17d/0x2b0 [xfs]
[17983.302369] [&lt;ffffffffa05f370e&gt;] xfs_free_eofblocks+0x1ee/0x270 [xfs]
[17983.302400] [&lt;ffffffffa060927e&gt;] xfs_release+0x9e/0x170 [xfs]
[17983.302431] [&lt;ffffffffa05fa0d5&gt;] xfs_file_release+0x15/0x20 [xfs]
[17983.302440] [&lt;ffffffff811e0329&gt;] __fput+0xe9/0x270
[17983.302445] [&lt;ffffffff811e05ee&gt;] ____fput+0xe/0x10
[17983.302451] [&lt;ffffffff810a22d7&gt;] task_work_run+0xa7/0xe0
[17983.302461] [&lt;ffffffff81014b12&gt;] do_notify_resume+0x92/0xb0
[17983.302468] [&lt;ffffffff81645bbd&gt;] int_signal+0x12/0x17
[17983.302473] INFO: task kworker/13:1:43828 blocked for more than 120 seconds.
[17983.302534] ""echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs"" disables this message.
[17983.302599] kworker/13:1 D ffff880321a01a20 0 43828 2 0x00000080
[17983.302632] Workqueue: xfs-data/dm-22 xfs_end_io [xfs]
[17983.302636] ffff8807234cbc98 0000000000000046 ffff88076c296780 ffff8807234cbfd8
[17983.302642] ffff8807234cbfd8 ffff8807234cbfd8 ffff88076c296780 ffff88076c296780
[17983.302648] ffff880321a01a10 ffff880321a01a18 ffffffff00000000 ffff880321a01a20
[17983.302655] Call Trace:
[17983.302661] [&lt;ffffffff8163a909&gt;] schedule+0x29/0x70
[17983.302666] [&lt;ffffffff8163c0c5&gt;] rwsem_down_write_failed+0x115/0x220
[17983.302672] [&lt;ffffffff810c3401&gt;] ? enqueue_entity+0x181/0x890
[17983.302700] [&lt;ffffffffa05ee236&gt;] ? xfs_setfilesize+0x56/0x130 [xfs]
[17983.302726] [&lt;ffffffff81301813&gt;] call_rwsem_down_write_failed+0x13/0x20
[17983.302732] [&lt;ffffffff81639b5d&gt;] ? down_write+0x2d/0x30
[17983.302762] [&lt;ffffffffa06069a1&gt;] xfs_ilock+0xc1/0x120 [xfs]
[17983.302789] [&lt;ffffffffa05ee236&gt;] xfs_setfilesize+0x56/0x130 [xfs]
[17983.302816] [&lt;ffffffffa05ef182&gt;] xfs_end_io+0x62/0xc0 [xfs]
[17983.302822] [&lt;ffffffff8109d5fb&gt;] process_one_work+0x17b/0x470
[17983.302827] [&lt;ffffffff8109e3cb&gt;] worker_thread+0x11b/0x400
[17983.302832] [&lt;ffffffff8109e2b0&gt;] ? rescuer_thread+0x400/0x400
[17983.302837] [&lt;ffffffff810a5aef&gt;] kthread+0xcf/0xe0
[17983.302844] [&lt;ffffffff810a5a20&gt;] ? kthread_create_on_node+0x140/0x140
[17983.302849] [&lt;ffffffff81645858&gt;] ret_from_fork+0x58/0x90
[17983.302857] [&lt;ffffffff810a5a20&gt;] ? kthread_create_on_node+0x140/0x140
[18103.185522] INFO: task kworker/13:0:172 blocked for more than 120 seconds.
[18103.185592] ""echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs"" disables this message.
[18103.185659] kworker/13:0 D ffff880321a01a20 0 172 2 0x00000000
[18103.185717] Workqueue: xfs-data/dm-22 xfs_end_io [xfs]
[18103.185721] ffff880819be7c98 0000000000000046 ffff880819bd2280 ffff880819be7fd8
[18103.185729] ffff880819be7fd8 ffff880819be7fd8 ffff880819bd2280 ffff880819bd2280
[18103.185735] ffff880321a01a10 ffff880321a01a18 ffffffff00000000 ffff880321a01a20
[18103.185742] Call Trace:
[18103.185757] [&lt;ffffffff8163a909&gt;] schedule+0x29/0x70
[18103.185765] [&lt;ffffffff8163c0c5&gt;] rwsem_down_write_failed+0x115/0x220
[18103.185774] [&lt;ffffffff810c3401&gt;] ? enqueue_entity+0x181/0x890
[18103.185803] [&lt;ffffffffa05ee236&gt;] ? xfs_setfilesize+0x56/0x130 [xfs]
[18103.185812] [&lt;ffffffff81301813&gt;] call_rwsem_down_write_failed+0x13/0x20
[18103.185818] [&lt;ffffffff81639b5d&gt;] ? down_write+0x2d/0x30
[18103.185852] [&lt;ffffffffa06069a1&gt;] xfs_ilock+0xc1/0x120 [xfs]
[18103.185880] [&lt;ffffffffa05ee236&gt;] xfs_setfilesize+0x56/0x130 [xfs]
[18103.185906] [&lt;ffffffffa05ef182&gt;] xfs_end_io+0x62/0xc0 [xfs]
[18103.185913] [&lt;ffffffff8109d5fb&gt;] process_one_work+0x17b/0x470
[18103.185918] [&lt;ffffffff8109e3cb&gt;] worker_thread+0x11b/0x400
[18103.185922] [&lt;ffffffff8109e2b0&gt;] ? rescuer_thread+0x400/0x400
[18103.185929] [&lt;ffffffff810a5aef&gt;] kthread+0xcf/0xe0
[18103.185935] [&lt;ffffffff810a5a20&gt;] ? kthread_create_on_node+0x140/0x140
[18103.185944] [&lt;ffffffff81645858&gt;] ret_from_fork+0x58/0x90
[18103.185950] [&lt;ffffffff810a5a20&gt;] ? kthread_create_on_node+0x140/0x140
[18103.186106] INFO: task kworker/13:2:9980 blocked for more than 120 seconds.
[18103.186166] ""echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs"" disables this message.
[18103.186238] kworker/13:2 D ffff880819bd2a84 0 9980 2 0x00000080
[18103.186268] Workqueue: xfs-data/dm-22 xfs_end_io [xfs]
[18103.186270] ffff880805197c98 0000000000000046 ffff8807f98dd080 ffff880805197fd8
[18103.186276] ffff880805197fd8 ffff880805197fd8 ffff8807f98dd080 ffff8807f98dd080
[18103.186282] ffff880321a01a10 ffff880321a01a18 ffffffff00000000 ffff880321a01a20
[18103.186301] Call Trace:
[18103.186307] [&lt;ffffffff8163a909&gt;] schedule+0x29/0x70
[18103.186312] [&lt;ffffffff8163c0c5&gt;] rwsem_down_write_failed+0x115/0x220
[18103.186317] [&lt;ffffffff810a6b00&gt;] ? autoremove_wake_function+0x20/0x40
[18103.186341] [&lt;ffffffffa05ee236&gt;] ? xfs_setfilesize+0x56/0x130 [xfs]
[18103.186360] [&lt;ffffffff81301813&gt;] call_rwsem_down_write_failed+0x13/0x20
[18103.186366] [&lt;ffffffff81639b5d&gt;] ? down_write+0x2d/0x30
[18103.186397] [&lt;ffffffffa06069a1&gt;] xfs_ilock+0xc1/0x120 [xfs]
[18103.186422] [&lt;ffffffffa05ee236&gt;] xfs_setfilesize+0x56/0x130 [xfs]
[18103.186450] [&lt;ffffffffa05ef182&gt;] xfs_end_io+0x62/0xc0 [xfs]
[18103.186486] [&lt;ffffffff8109d5fb&gt;] process_one_work+0x17b/0x470
[18103.186490] [&lt;ffffffff8109e3cb&gt;] worker_thread+0x11b/0x400
[18103.186494] [&lt;ffffffff8109e2b0&gt;] ? rescuer_thread+0x400/0x400
[18103.186498] [&lt;ffffffff810a5aef&gt;] kthread+0xcf/0xe0
[18103.186503] [&lt;ffffffff810a5a20&gt;] ? kthread_create_on_node+0x140/0x140
[18103.186507] [&lt;ffffffff81645858&gt;] ret_from_fork+0x58/0x90
[18103.186512] [&lt;ffffffff810a5a20&gt;] ? kthread_create_on_node+0x140/0x140
```
</code></pre>
"
"<p>It seems that I have a problem with Linux IO performance. Working with a project I need to <code>clear</code> whole the file from the kernel space. I use the following code pattern:</p>

<pre><code>for_each_mapping_page(mapping, index) {
    page = read_mapping_page(mapping, index);
    lock_page(page);
    { kmap // memset // kunmap }
    set_page_dirty(page);
    write_one_page(page, 1);
    page_cache_release(page);
    cond_resched();
}
</code></pre>

<p>All works fine but with large files (~3Gb+ for me) I see that my system stalls in a strange manner: while this operation is not completed I can't run anything. In other words, all the processes that exists before this operation runs fine, but if I try to run something while this operation I see nothing until it completed.</p>

<p>Is it a kernel's IO scheduling issue or may be I missed something? And how can I fix this problem?</p>

<p>Thanks.</p>

<p>UPD:</p>

<p>According to Kristof's suggestion I've reworked my code and now it looks like this:</p>

<pre><code>headIndex = soff &gt;&gt; PAGE_CACHE_SHIFT;
tailIndex = eoff &gt;&gt; PAGE_CACHE_SHIFT;

/**
 * doing the exact @headIndex .. @tailIndex range
 */

for (index = headIndex; index &lt; tailIndex; index += nr_pages) {
    nr_pages = min_t(int, ARRAY_SIZE(pages), tailIndex - index);

    for (i = 0; i &lt; nr_pages; i++) {
        pages[i] = read_mapping_page(mapping, index + i, NULL);
        if (IS_ERR(pages[i])) {
            while (i--)
                page_cache_release(pages[i]);
            goto return_result;
        }
    }

    for (i = 0; i &lt; nr_pages; i++)
        zero_page_atomic(pages[i]);

    result = filemap_write_and_wait_range(mapping, index &lt;&lt; PAGE_CACHE_SHIFT,
                          ((index + nr_pages) &lt;&lt; PAGE_CACHE_SHIFT) - 1);

    for (i = 0; i &lt; nr_pages; i++)
        page_cache_release(pages[i]);

    if (result)
        goto return_result;

    if (fatal_signal_pending(current))
        goto return_result;

    cond_resched();
}
</code></pre>

<p>As the result I've got better IO performance, but still have problems with huge IO activity while doing concurrent disk access within the same user as caused the operation.</p>

<p>Anyway, thanks for the suggestions.</p>
"
"<p>This is my first ever attempt at writing a recursive function in c. The following-code works. I apologize for the long posting, but I am trying to be as clear as possible.  </p>

<p>I am trying to generate a tree where each node (inode) has an integer field ""n"". Correspondingly, each inode has an array of pointers to ""n"" other inodes. Function <code>inode *I = gen_tree(inode *I, int nlevels);</code> generates a tree with random number of inodes at each level. The tree is generated in a depth-first fashion. I have several questions.</p>

<p>(a) Is there a better way to write the function?? Any feedback/suggestions would be appreciated.</p>

<p>(b) Can the tree be generated in a BF fashon?</p>

<p>(c) <code>I-&gt;i</code> should have an index in which the tree is traversed. How can I write a function to compute <code>I-&gt;i</code>?</p>

<p>(d) <code>I-&gt;c</code> should have cumulative-sum of all inodes below a given node. How can I write a function to compute <code>I-&gt;c</code>?</p>

<p>Thanks in advance,</p>

<p>~Russ</p>

<pre><code>//.h file:
typedef struct integerNode {
  int n;
  int c;
  int i;
  struct integerNode **nodes;
} inode;
inode *new_inode( int n );
inode *gen_itree( inode *I, int nlevels );


//Constructor:
inode *new_inode( int n ){
    inode *I;
    I = malloc( sizeof (inode ) );
    I-&gt;n = n;
    I-&gt;nodes = malloc( n * sizeof (inode* ) );
    return (I );
};

//Generating tree with random-number of nodes:
inode *gen_itree( inode *I, int nlevels ){
    int i, next_level, next_n;
    printf( "" \n"" );
    printf( "" I : %p\n"", I );
    printf( "" ***** nlevels : %d\n"", nlevels );
    printf( "" *************\n"" );
    if ( nlevels == 0 ) {
        printf( "" nlevels == 0!\n"");
    } else {
        printf( "" I-&gt;n : %d\n"", I-&gt;n );
        printf( "" *************\n"" );
        next_level = nlevels - 1;
        for ( i = 0; i &lt; I-&gt;n; i++ ) {
            printf( "" I: %p\n"",I);
            printf( "" adding node number: %d\n"", i );
            next_n = 0 + rand( ) % 3;
            I-&gt;nodes[i] = new_inode( next_n );
            printf( "" I-&gt;nodes[%d]-&gt;n: %p, %d\n"",i, I-&gt;nodes[i],next_n);
            I-&gt;nodes[i] = gen_itree( I-&gt;nodes[i], next_level );
        }
    }
    printf( "" *************\n"" );
    printf( "" returning I : %p\n"", I );//This part is unclear to me!
    printf( "" *************\n"" );
    return (I);
}

//Main.c
int main( int argc, char** argv ){
    inode *I;
    I = new_inode( 2 );
    I = gen_itree(I,3);
    return ( 1 );
}
</code></pre>
"
"<p>It seems to me that tmpfs is not re-using inode numbers, but instead creates a new inode number via a +1 sequence everytime it needs a free inode.</p>

<p>Do you know how this is implemented / can you pin-point me to some source code where i could check the algorithm that is used in tmpfs ?</p>

<p>I need to understand this in order to bypass a limitation in a caching system that uses the inode number as its cache key (hence leading to rare, but occuring collisions when inodes are re-used too often). tmpfs could save my day if I can prove that it keeps creating unique inode numbers.</p>

<p>Thank you for your help,</p>

<p>Jerome Wagner</p>
"
"<p>The code is:</p>

<pre><code>void ext2_read_inode (struct inode * inode)
{
    struct buffer_head * bh;
    struct ext2_inode * raw_inode;
    unsigned long block_group;
    unsigned long group_desc;
    unsigned long desc;
    unsigned long block;
    unsigned long offset;
    struct ext2_group_desc * gdp;

    if (
        ( inode-&gt;i_ino != EXT2_ROOT_INO
            &amp;&amp; inode-&gt;i_ino != EXT2_ACL_IDX_INO
            &amp;&amp; inode-&gt;i_ino != EXT2_ACL_DATA_INO
            &amp;&amp; inode-&gt;i_ino &lt; EXT2_FIRST_INO(inode-&gt;i_sb)
        ) || inode-&gt;i_ino &gt; le32_to_cpu(
                inode-&gt;i_sb-&gt;u.ext2_sb.s_es-&gt;s_inodes_count)
    )
    {
        ext2_error(inode-&gt;i_sb, ""ext2_read_inode"",
            ""bad inode number: %lu"", inode-&gt;i_ino);
        goto bad_inode;
    }

    block_group = (inode-&gt;i_ino - 1) / EXT2_INODES_PER_GROUP(inode-&gt;i_sb);

    if (block_group &gt;= inode-&gt;i_sb-&gt;u.ext2_sb.s_groups_count) {
        ext2_error(inode-&gt;i_sb, ""ext2_read_inode"", ""group &gt;= groups count"");
        goto bad_inode;
    }

    group_desc = block_group &gt;&gt; EXT2_DESC_PER_BLOCK_BITS(inode-&gt;i_sb);
    desc = block_group &amp; (EXT2_DESC_PER_BLOCK(inode-&gt;i_sb) - 1);
    bh = inode-&gt;i_sb-&gt;u.ext2_sb.s_group_desc[group_desc];

    /* ... other code omitted ... */
}
</code></pre>

<p>Could you explain why there is <code>-1</code> here:</p>

<pre><code>block_group = (inode-&gt;i_ino - 1) / EXT2_INODES_PER_GROUP(inode-&gt;i_sb);
</code></pre>

<p>and here:</p>

<pre><code>desc = block_group &amp; (EXT2_DESC_PER_BLOCK(inode-&gt;i_sb) - 1);
</code></pre>

<p>Thank you.</p>
"
"<p>I am working with the EXT2 File System and spent the last 2 days trying to figure out how to create a symbolic link. From <a href=""http://www.nongnu.org/ext2-doc/ext2.html#DEF-SYMBOLIC-LINKS"" rel=""nofollow noreferrer"">http://www.nongnu.org/ext2-doc/ext2.html#DEF-SYMBOLIC-LINKS</a>, ""For all symlink shorter than 60 bytes long, the data is stored within the inode itself; it uses the fields which would normally be used to store the pointers to data blocks. This is a worthwhile optimization as it we avoid allocating a full block for the symlink, and most symlinks are less than 60 characters long""</p>

<p>To create a sym link at /link1 to /source I create a new inode and say it gets index 24. Since it's &lt;60 characters, I placed the string ""/source"" starting at the i_block[0] field (so printing new_inode->i_block[0] in gdb shows ""/dir2/source"") and set i_links_count to 1, i_size and i_blocks to 0. I then created a directory entry at the inode 2 (root inode) with the properties 24, ""link1"", and file type EXT2_FT_SYMLINK.</p>

<p>A link called ""link1"" gets created but its a directory and when I click it it goes to ""/"". I'm wondering what I'm doing wrong...</p>
"
"<p>I'm porting old linux kernel code for newer version 2.6.32.</p>

<p>There is a part that copies a file descriptor. The idea was to allocate a new file descriptor and a new <strong>struct file</strong> and use them with another <strong>f_op</strong> and , leaving all other fields of <strong>struct file</strong> equivalent to original's.</p>

<p>How do I do this in a modern kernel?
I've written an approximate implementation but I don't know whether i should call file_get, path_get or do others use counter incrementation.</p>

<pre><code>struct file * copy_file(const struct file * iOrig, int * oNewFd) {
  if (!orig)
    return 0;
  *oNewFd = get_unused_fd();
  if (*oNewFd &lt; 0)
    return 0;
  struct file * rv = alloc_file(orig-&gt;f_path.mnt, orig-&gt;f_path.dentry, orig-&gt;f_path.mode, orig-&gt;f_op);
  if (!rv)
    goto free_fd;
  fd_install(fd, rv);
  return rv;
free_fd:
  put_unused_fd(*oNewFd)
  return 0;
}
</code></pre>

<p>P.S. In fact having all fileds of original file copied is not neccessary. I just need to allow a new set of file operations in user-space. So creating a new descriptor owned by <strong>current</strong> with a given <strong>f_op</strong> will do.</p>
"
"<p>I use this fanotify sample to monitor open/access perms on the whole file system(/): <a href=""http://git.infradead.org/users/eparis/fanotify-example.git"" rel=""nofollow"">http://git.infradead.org/users/eparis/fanotify-example.git</a>.</p>

<p>Then I have a test program with multiple threads, each thread iterate the sample foder and open/close the files in it, sometimes my program hangs at open().</p>

<p>OS: Ubuntu 2.6.38-11 x86_64.</p>

<p>Is it a bug of fanotify that it does not support multiple-thread opening?</p>

<p>The code of my test program:</p>

<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;ctype.h&gt;
#include &lt;unistd.h&gt;
#include &lt;dirent.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;dirent.h&gt;

//open file function
void open_file( char* file )
{
    int fd = -1;
    fd = open( file, O_WRONLY, 0x666 );
    if( fd &gt;= 0 )
    {
        printf(""open:%s\n"", file );
        close( fd );
    }
}

//iterate directory function

void printdir(char *dir, int depth)
{
    DIR *dp;
    struct stat statbuf;
    char pathbuf[2048] = {0};
    struct dirent entry;
    struct dirent *entryPtr = NULL;

    //printf(""opendir %s\n"", dir );
    usleep( 300 );
    if((dp = opendir(dir)) == NULL) {
        if( errno != ENOTDIR )
        {
            fprintf(stderr,""cannot open directory: %s\n"", dir);
            perror(""open fial"");
        }
        return;
    }

    readdir_r( dp, &amp;entry, &amp;entryPtr );
    while( entryPtr != NULL)
    {
        snprintf(pathbuf,2000, ""%s/%s\0"", dir, entry.d_name );
        printf(""iteraotr:%s\n"", pathbuf );

        lstat( pathbuf, &amp;statbuf );
        if(S_ISDIR( statbuf.st_mode ))
        {
            /* Found a directory, but ignore . and .. */
            if(strcmp(""."",entry.d_name) == 0 ||
                    strcmp("".."",entry.d_name) == 0)
            {

            }
            else
            {
                //printf(""%d,%s\n"",depth, entry-&gt;d_name);
                printdir( pathbuf, depth+1);
            }
        }
        else
        {
            //printf(""%*s%s\n"",depth,"""",entry-&gt;d_name);
            open_file( pathbuf );
        }
        readdir_r( dp, &amp;entry, &amp;entryPtr );
    }
    closedir(dp);
}

//thread function
void* iterator_dir( void* data )
{
    char* path = (char*)data;
    printf(""In iterator_dir(): %s\n"", path );

    printdir( path, 0 );

    return NULL;
}


pthread_t  threadID[10] = {0};

 //main function
int main( int argc, char** argv )
{
    if( argc &lt; 3 )
    {
        printf(""Usage: %s &lt;thread_num&gt; &lt;file&gt;\n"", argv[0] );
        exit(0);
    }
    if( isdigit( (char)*argv[1] ) == 0 )
    {
        printf("" Thread num is 0 - 9\n"");
        exit(0);
    }

    int thread_num = atoi( argv[1] );
    char* res;

    pthread_attr_t attr;
    pthread_attr_init(&amp;attr);
    int i = 0;
    for( i = 0; i &lt; thread_num; ++i )
    {
        pthread_create( &amp;threadID[i], &amp;attr, &amp;iterator_dir, argv[2]);
    }

    for( i = 0; i &lt; thread_num; ++i )
    {
        pthread_join( threadID[i] , &amp;res );
    }
}
</code></pre>

<p><strong>2011-09-28 Edit:</strong></p>

<p>I comment the open file operation, only keep the iterate directory part. The application still hangs.
This is the output of strace:</p>

<pre><code>enter code here
pid 10692] open(""/home/byang//.config/menus"", O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC &lt;unfinished ...&gt;
[pid 10691] write(1, ""1213966080 opendir /home/byang//""..., 56) = 56
</code></pre>

<p>.........</p>

<pre><code>[pid 10689] madvise(0x7f3c48dbc000, 8368128, MADV_DONTNEED) = 0
[pid 10689] _exit(0)                    = ?
Process 10689 detached
[pid 10688] &lt;... futex resumed&gt; )       = 0
[pid 10688] futex(0x7f3c47db99d0, FUTEX_WAIT, 10692, NULL &lt;unfinished ...&gt;
</code></pre>

<p>It hangs here, when I close the fanotify, it continues...</p>

<pre><code>[pid 10692] &lt;... open resumed&gt; )        = 11
[pid 10692] getdents(11, /* 4 entries */, 32768) = 128
[pid 10692] lstat(""/home/byang//.config/menus/applications.menu"", {st_mode=S_IFREG|0644, st_size=233, ...}) = 0
</code></pre>

<p>10688 is the parent thread; 10689,10691,10692 are the child threads that iterating the directories.
It seems that 10692 are waiting the reply from fanotify?</p>
"
"<p>In kernel module, I have code as:</p>

<pre><code>path_get(path);
/*Other stuff*/
if(/*some error occurred here*/)
{
    //path_put(path); //Does it need to call here?
    return -1;
}
</code></pre>

<p>In above code, should we call <em>path_put()</em> before return an error code? Which resources released by <em>path_put()</em>?</p>
"
"<p>I am trying to compare if two filenames refer to the same file by checking if their inode and device IDs match. Currently, I call <code>vfs_stat</code> to obtain the IDs.</p>

<p>The problem is, if I pass <code>vfs_stat</code> a filename that's stored in userspace, it works fine, but if I pass it a filename that's stored in as a global variable in my kernel module, it errors with <code>EFAULT</code></p>

<p>Is there any other way to obtain the IDs or compare if two files are the same?</p>
"
"<p>While doing static analysis of linux kernel for memory leaks, I came across an interesting scenario where i am not able to find the de allocation of a variable.
The allocation is happening in the following function(using kmalloc call) as below:</p>

<pre><code>static int mounts_open_common(struct inode *inode, struct file *file,
              int (*show)(struct seq_file *, struct vfsmount *)){
  struct proc_mounts *p;

  //some code//
  *p = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);**
  file-&gt;private_data = &amp;p-&gt;m;//the allocated variable is escaped to file structure
  //some code

}
</code></pre>

<p>I expect this allocated memory to be fixed at:</p>

<pre><code>static int mounts_release(struct inode *inode, struct file *file)
{
    struct proc_mounts *p = proc_mounts(file-&gt;private_data);
    path_put(&amp;p-&gt;root);
    put_mnt_ns(p-&gt;ns);
    return seq_release(inode, file);
}
</code></pre>

<p>But it seems this function is accessing the allocated variable to free some its internel members but not the variable 'p' itself.
So where is this variable's memory is freed? If it is supposed to free in mounts_release function then its a potential memory leak.</p>
"
"<p>I'm trying to write simple c function which would give me possibility to see progress of data transfer from one stream to other stream and display it on my char LCD.</p>

<p>I manage to transfer the data and indicate the progress but how to get result of the piping?</p>

<p>So basically i want to do in c corresponds to shell command:</p>

<pre><code>/home/image.img | md5sum &gt; result
</code></pre>

<p>The problem i have i with the stdout. I would like to get it to a char * result.</p>

<p>In other words the md5sum returns a string on the screen like this ""5193fd9ebfa30bcb914e7af4760deb15"" but i would like to get it to my char * result for further usage in the function.</p>

<pre><code>FILE *in_stream, *out_stream;
#define TRANSFER_BLOCK_SIZE 1048576 //one MB
int n=0;
int i=0;
long int input_size=0;
unsigned char buffer[TRANSFER_BLOCK_SIZE];

if((out_stream=popen(""md5sum"",""w""))==NULL)
   {
   perror(output_pipe_name);
   return 1;
   }
if((in_stream=fopen(""/home/gregorek/image.img"",""r""))==NULL)
   {
   perror(input_file_name);
   return 1;
   }
//check total size of the input file
fseek(in_stream,0,SEEK_END);
input_size=(ftell(in_stream)/TRANSFER_BLOCK_SIZE)+1;
fseek(in_stream,0,SEEK_SET);
//
do
    {
    i++;
    memset(buffer,'\0',TRANSFER_BLOCK_SIZE);
    n=fread(buffer,sizeof(unsigned char),TRANSFER_BLOCK_SIZE,in_stream);
    lcd_display(i); //this is my progress indicator
    fwrite(buffer,sizeof(unsigned char),n,out_stream);
    }
while(!feof(in_stream));

fclose(in_stream);
pclose(out_stream);
</code></pre>

<p>return 0;<br>
}</p>

<p>thanks</p>
"
"<p>I have a program that uses <code>fork()</code> to create child processes, and I want to have the children communicate back to the parent process using Unix pipes. </p>

<p>The problem is that multiple pipes don't seem to be created, or maybe there's a problem with my array. When I used <code>prinf()</code> in the parent program it reads identical data from every pipe, even though each child sends different data.</p>

<p>Here is my code:</p>

<pre><code>// Variables
int pipes_count = 0;
int *pipes[MAXCLIENTS];
int new_pipefd[2];
int pipe_bytes;
char pipe_buffer[MAXDATASIZE];

while(1) {
    // Pipe creation
    pipe(new_pipefd);
    pipes[pipes_count] = new_pipefd;
    pipes_count++;

    if (fork()) {
        // unrelated code for parent here
        close(new_pipefd[1]); // close the parent's write-end of the pipe
        break;
    } else {
        // unrelated code for child here
        close(new_pipefd[0]); // close the child's read-end of the pipe
        break;
    }

    if (some condition) { break; } // The parent will stop creating pipes
}

while(condition that guarantees this is the child) {
    write(new_pipefd[1], buffer, strlen(recv_buffer));
    close(new_pipefd[1]);
    return 0; // the child process ends
}

// This is a loop where the parent reads what the children sent
for (int i = 0; i &lt; pipes_count; i++) {
    pipe_bytes = read(pipes[i][0], pipe_buffer, sizeof pipe_buffer);
    if (pipe_bytes == 0) {
        close(pipes[i][0]);
    } else {
        printf(""Testing: %s\n"", pipe_buffer);
    }
}
</code></pre>
"
"<p>My kernel is 2.6.34. I got a log as following:</p>

<pre><code>[c0f8ddb0] [c00c7dcc] kunmap_high+0x2c/0xd0 (unreliable)
[c0f8ddd0] [c00f3b14] generic_pipe_buf_unmap+0x84/0xd0
[c0f8dde0] [c00f47a0] pipe_write+0x3b0/0x5a0
[c0f8de50] [c00eabd8] do_sync_write+0xb8/0x100
[c0f8def0] [c00eb9b0] vfs_write+0xc0/0x1d0
[c0f8df10] [c00ebbbc] sys_write+0x4c/0x90
[c0f8df40] [c00119c0] ret_from_syscall+0x0/0x4
</code></pre>

<p>Now, I have known that the generic_pipe_buf_map invokes kmap_atomic and set a flag in pipe_buffer->flags. However, when the generic_pipe_buf_unmap is invoked, the flag is gone and the kunmap() is invoked and cause this issue. But I don't know why the flag is gone. All the pipe operations are protected by a mutex lock. Does anyone know this issue?</p>
"
"<p>What values in the inode struct of the linux kernel can I look at to tell if the inode I am currently looking at is for a directory or a regular file? </p>

<p>I have searched through the inode but can't really seem to find a member to looks like it has what I want, since I am using an older kernel version, I will post the struct below (2.6.24)</p>

<pre><code>struct inode
  {
     struct hlist_node  i_hash;
     struct list_head   i_list;
     struct list_head   i_sb_list;
     struct list_head   i_dentry;
     unsigned long      i_ino;
     atomic_t           i_count;
     unsigned int       i_nlink;
     uid_t              i_uid;
     gid_t              i_gid;
     dev_t              i_rdev;
     unsigned long      i_version;
     loff_t             i_size;
     struct timespec    i_atime;
     struct timespec    i_mtime;
     struct timespec    i_ctime;
     unsigned int       i_blkbits;
     blkcnt_t           i_blocks;
     unsigned short     i_bytes;
     umode_t            i_mode;
     spinlock_t         i_lock;
     struct mutex       i_mutex;
     struct rw_semaphore              i_alloc_sem;
     const struct inode_operations   *i_op;
     const struct file_operations    *i_fop;
     struct super_block              *i_sb;
     struct file_lock                *i_flock;
     struct address_space            *i_mapping;
     struct address_space             i_data;
     struct list_head                 i_devices;

     union {
               struct pipe_inode_info *i_pipe;
               struct block_device    *i_bdev;
               struct cdev            *i_cdev;
            };

     int            i_cindex;
     __u32          i_generation;
     unsigned long  i_state;
     unsigned long  dirtied_when;
     unsigned int   i_flags;
     atomic_t       i_writecount;
     void           *i_private;
   };
</code></pre>

<p>Any help would be appreciated.</p>
"
"<p>I'm implementing a Linux character device driver.</p>

<p>The linux/fs.h header file lists the file_operations without argument names.</p>

<p>e.g.</p>

<pre><code>struct file_operations {
    struct module *owner;
    loff_t (*llseek) (struct file *, loff_t, int);
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
    ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
    ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);
    int (*readdir) (struct file *, void *, filldir_t);
    unsigned int (*poll) (struct file *, struct poll_table_struct *);
    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
    long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
    int (*mmap) (struct file *, struct vm_area_struct *);
    int (*open) (struct inode *, struct file *);
    int (*flush) (struct file *, fl_owner_t id);
    int (*release) (struct inode *, struct file *);
    int (*fsync) (struct file *, loff_t, loff_t, int datasync);
    int (*aio_fsync) (struct kiocb *, int datasync);
    int (*fasync) (int, struct file *, int);
    int (*lock) (struct file *, int, struct file_lock *);
    ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
    unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
    int (*check_flags)(int);
    int (*flock) (struct file *, int, struct file_lock *);
    ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
    ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
    int (*setlease)(struct file *, long, struct file_lock **);
    long (*fallocate)(struct file *file, int mode, loff_t offset,
              loff_t len);
};
</code></pre>

<p>Where is the documentation that tells me what each argument is? Some are sort-of obvious, but some aren't. I prefer to refer to official documentation if I can, but I just can't find it.</p>

<p>e.g.</p>

<pre><code>int (*fsync) (struct file *, loff_t, loff_t, int datasync);
</code></pre>

<p>There are two loff_t arguments. How do I know what they do?</p>

<p>I've been Googling and reading the device driver book, but I can't find any documents that explain what the arguments are for. Some of the arguments have also changed from when LDD3 was written. </p>
"
"<p>I'm writing a Linux device driver using kernel 3.13.0 and I'm confused as to why I'm getting this warning.</p>

<pre><code>warning: initialization from incompatible pointer type [enabled by default]
     .read = read_proc,
     ^
warning: (near initialization for ?proc_fops.read?) [enabled by default]
</code></pre>

<p>As far as I can tell my file_operations setup for the proc functions are identical to the device functions.  I can read/write to /dev/MyDevice with no issue and there are no warnings.  The proc write function does not throw a warning, only the read.  What did I do wrong?</p>

<pre><code>/*****************************************************************************/
//DEVICE OPERATIONS
/*****************************************************************************/
static ssize_t dev_read(struct file *pfil, char __user *pBuf, size_t
  len, loff_t *p_off)
{
    //Not relevant to this question
}

static ssize_t dev_write(struct file *pfil, const char __user *pBuf,
                         size_t len, loff_t *p_off)
{
    //Not relevant to this question
}

static struct file_operations dev_fops =
{ //None of these cause a warning but the code is identical the proc code below
    .owner = THIS_MODULE,
    .read = dev_read,
    .write = dev_write
};

/*****************************************************************************/
//PROCESS OPERATIONS
/*****************************************************************************/
static int read_proc(struct file *pfil, char __user *pBuf, size_t
              len, loff_t *p_off)
{
    //Not relevant to this question
}

static ssize_t write_proc(struct file *pfil, const char __user *pBuf,
                         size_t len, loff_t *p_off)
{
    //Not relevant to this question
}

struct file_operations proc_fops =
{
    .owner = THIS_MODULE,
    .write = write_proc,
    .read = read_proc, //This line causes the warning.
};
</code></pre>

<p>EDIT: So the answer is that I'm an idiot for not seeing the ""int"" versus ""ssize_t"".  Thank you everyone!  Both Codenheim and Andrew Medico had the correct answer at roughly the same time but I chose Medico's because it's more pedantic and obvious for future visitors.</p>
"
"<p>How does the inode in the Linux File System actually point to a block on the disk? Does it contain a 64 bit addressable number that points from 0 to 2^63 - 1? Or is there a layer in between the inode structures and the actual disk addresses?</p>
"
"<p>I have an external FPGA device that is dumping vast amounts of data via PCIe to a reserved (using boot-loader parameters) contiguous memory region.  This memory region will always start in the same location.  </p>

<p>I now want to dump that data over UDP as quickly as possible.  I don't care about examining this data so there is no need to bring it into user-space.  As such, my research has indicated using zero-copy is the fastest/best way to do this.  </p>

<p>I am trying to <code>int memFd = open(""/dev/mem"", O_RDONLY);</code>, then using <code>memFd</code> in <code>sendfile</code> and <code>splice</code> function calls, but these are failing.  </p>

<p>It took a few days, but I finally saw in the <code>sendfile</code> source that the input file descriptor must be a regular file (a detail frustratingly left out of the man page as far as I can tell), and <code>/dev/mem</code> is not a regular file.  Anyway, I looked around some more, and now am confident <code>splice</code> is the call I want to use.  </p>

<p>However, this is failing as well with an errno of 14-EFAULT which means ""bad address"" (again frustratingly, this error code is not mentioned in the <code>splice</code> man page).  I've looked over the source code for <code>splice</code>, and can see a few times where EFAULT is returned, but I just don't see how the arguments I'm passing are causing a problem.  </p>

<p>My simplified, non-error checking code is below;</p>

<pre><code> int filedes[2];
 int memFd = open(""/dev/mem"", O_RDONLY);
 int fileFd = open(""myTestFile.txt"", O_RDONLY);
 loff_t offset = START_OF_MEM_REGION;
 int sockFd = ConfigureMySocket();

 pipe(filedes);  // this returns 0, so the pipes are good

 int ret = splice(memFd, &amp;offset, filedes[1], NULL, 128, SPLICE_F_MOVE); // this fails with EFAULT
 //int ret = splice(memFd, NULL, filedes[1], NULL, 128, 0); // this also fails with EFAULT
 //int ret = splice(fileFd, NULL, filedes[1], NULL, 128, 0); // this works just fine

 // this is never reached because the splice call above hangs. If I run the
 // fileFd splice call instead this works just fine
 ret = splice(filedes[0], NULL, sockFd, NULL, 128, 0);
</code></pre>

<p>My system info:</p>

<ul>
<li>embedded device running linux 3.1.10 on ARM architecture</li>
<li>running as root user</li>
<li>kernel was NOT compiled with <code>CONFIG_STRICT_DEVMEM</code></li>
</ul>

<p>Other fun facts:</p>

<ul>
<li>I have a 2.6 linux CentOS virtual machine and this code works fine up to offsets of ~1MB.  However, this kernel was compiled with <code>CONFIG_STRICT_DEVMEM</code>, so I attribute the 1MB limit to that.</li>
<li>I can <code>mmap</code> to the memory region just fine and see the data the FPGA is writing.</li>
</ul>

<p>My questions are:</p>

<ol>
<li>Is using <code>splice</code> the right way to do this?  Does someone think there's a better way?</li>
<li>If <code>splice</code> is right, anybody have any idea what could be happening here?  Could there be a kernel compiler flag preventing this from working?  I was reading source code from <code>splice.c</code>, but it wasn't the 3.1.10 version, so perhaps something has changed?  Either way, it's a bummer to see this work just fine in the VM but not in the embedded environment.</li>
</ol>

<p>EDIT: I have downloaded the 3.1.10 source from kernal.org and unfortunately see no major differences from what I was looking at on free-electrons.com with a different version.  Looks like to me all the splice code is in /fs/splice.c.  <code>do_splice(...)</code> must be the code that gets executed.  My first call to <code>splice</code> (using <code>memFd</code> and <code>filedes[1]</code>) should be dropping down to <code>if (opipe) {</code>... here you can see that <code>EFAULT</code> is returned if <code>copy_from_user</code> or <code>copy_to_user</code> fail .. how could these be failing?  There can't be anything wrong with my <code>&amp;offset</code> variable since I get the same error if this is <code>NULL</code> or no error if I substitute <code>fileFd</code> in place of <code>memFd</code>.  Also something of interest,, there are no errors if I replace 128 with 0 (number of bytes to write).  The places where <code>EFAULT</code> is returned, I just don't see how the file descriptor even factors into that logic,, unless <code>EFAULT</code> is getting returned by some deeper function calls...</p>

<p>These are the snippets from <code>splice.c</code></p>

<pre><code>SYSCALL_DEFINE6(splice, int, fd_in, loff_t __user *, off_in,
        int, fd_out, loff_t __user *, off_out,
        size_t, len, unsigned int, flags)
{
    long error;
    struct file *in, *out;
    int fput_in, fput_out;

    if (unlikely(!len))
        return 0;

    error = -EBADF;
    in = fget_light(fd_in, &amp;fput_in);
    if (in) {
        if (in-&gt;f_mode &amp; FMODE_READ) {
            out = fget_light(fd_out, &amp;fput_out);
            if (out) {
                if (out-&gt;f_mode &amp; FMODE_WRITE)
                    error = do_splice(in, off_in,
                              out, off_out,
                              len, flags);
                fput_light(out, fput_out);
            }
        }

        fput_light(in, fput_in);
    }

    return error;
}

static long do_splice(struct file *in, loff_t __user *off_in,
              struct file *out, loff_t __user *off_out,
              size_t len, unsigned int flags)
{
    struct pipe_inode_info *ipipe;
    struct pipe_inode_info *opipe;
    loff_t offset, *off;
    long ret;

    ipipe = get_pipe_info(in);
    opipe = get_pipe_info(out);

    if (ipipe &amp;&amp; opipe) {
        if (off_in || off_out)
            return -ESPIPE;

        if (!(in-&gt;f_mode &amp; FMODE_READ))
            return -EBADF;

        if (!(out-&gt;f_mode &amp; FMODE_WRITE))
            return -EBADF;

        /* Splicing to self would be fun, but... */
        if (ipipe == opipe)
            return -EINVAL;

        return splice_pipe_to_pipe(ipipe, opipe, len, flags);
    }

    if (ipipe) {
        if (off_in)
            return -ESPIPE;
        if (off_out) {
            if (!(out-&gt;f_mode &amp; FMODE_PWRITE))
                return -EINVAL;
            if (copy_from_user(&amp;offset, off_out, sizeof(loff_t)))
                return -EFAULT;
            off = &amp;offset;
        } else
            off = &amp;out-&gt;f_pos;

        ret = do_splice_from(ipipe, out, off, len, flags);

        if (off_out &amp;&amp; copy_to_user(off_out, off, sizeof(loff_t)))
            ret = -EFAULT;

        return ret;
    }

    if (opipe) {
        if (off_out)
            return -ESPIPE;
        if (off_in) {
            if (!(in-&gt;f_mode &amp; FMODE_PREAD))
                return -EINVAL;
            if (copy_from_user(&amp;offset, off_in, sizeof(loff_t)))
                return -EFAULT;
            off = &amp;offset;
        } else
            off = &amp;in-&gt;f_pos;

        ret = do_splice_to(in, off, opipe, len, flags);

        if (off_in &amp;&amp; copy_to_user(off_in, off, sizeof(loff_t)))
            ret = -EFAULT;

        return ret;
    }

    return -EINVAL;
}
</code></pre>
"
"<p>I was looking a kernel code of recent Linux kernel. In uio.h I have seen below definition </p>

<pre><code>          ITER_IOVEC = 0,
          ITER_KVEC = 2,
          ITER_BVEC = 4,
</code></pre>

<p>I have search its meaning online and also saw the Documentation but haven't found anything interesting. </p>

<p>Does anyone know what is the meaning of these constant and what is the difference between them?</p>
"
"<p>I am trying to send a UDP packet from a driver using sock_sendmsg().</p>

<p>There are several guides on how to use sock_sendmsg() and msghdr to fill out at a UDP packet and transmit it, but they are all for older kernel versions. Sometime between 3.13 and 4.8, the struct msghdr changed from:</p>

<pre><code>struct msghdr {
    void    *   msg_name;   /* Socket name          */
    int     msg_namelen;    /* Length of name       */
    struct iovec *  msg_iov;    /* Data blocks          */
    __kernel_size_t msg_iovlen; /* Number of blocks     */
    void    *   msg_control;    /* Per protocol magic (eg BSD file descriptor passing) */
    __kernel_size_t msg_controllen; /* Length of cmsg list */
    unsigned int    msg_flags;
};
</code></pre>

<p>To:</p>

<pre><code>struct msghdr {
    void        *msg_name;  /* ptr to socket address structure */
    int     msg_namelen;    /* size of socket address structure */
    struct iov_iter msg_iter;   /* data */
    void        *msg_control;   /* ancillary data */
    __kernel_size_t msg_controllen; /* ancillary data buffer length */
    unsigned int    msg_flags;  /* flags on received message */
    struct kiocb    *msg_iocb;  /* ptr to iocb for async requests */
};
</code></pre>

<p>Instead of setting  msg_iov to point to an iovec with the data:</p>

<pre><code>struct msghdr msg = {};
struct iovec iov = {};

iov.iov_base = data;
iov.iov_len = dataLen;
msg.msg_iov = &amp;iov;
msg.msg_iovlen = 1;
</code></pre>

<p>There is now an iov_iter structure:</p>

<pre><code>struct iov_iter {
    int type;
    size_t iov_offset;
    size_t count;
    union {
        const struct iovec *iov;
        const struct kvec *kvec;
        const struct bio_vec *bvec;
        struct pipe_inode_info *pipe;
    };
    union {
        unsigned long nr_segs;
        struct {
            int idx;
            int start_idx;
        };
    };
};
</code></pre>

<p>How do I fill out the iov_iter structure inside of msghdr with data so that I can pass it to sock_sendmsg?</p>
"
"<p>I'm pretty new to all of this so sorry about the large amount of nonsense this post is comprised of as I try and word what I want to say.</p>

<p>I am trying to compile the MadWiFi kernel module but unfortunately getting the error below. The problem (AFAIK) is that the kernel headers I am using have a new struct to replace net_device. </p>

<p>Can I use a different set of kernel headers to compile it against or would the resulting module not be compatible with my kernel?</p>

<pre><code>make -C /lib/modules/2.6.32-5-686/build SUBDIRS=/home/madwifi-0.9.4 modules
make[1]: Entering directory `/usr/src/linux-headers-2.6.32-5-686'
make[1]: Warning: File `Makefile' has modification time 4.2e+08 s in the future
make[2]: Warning: File `Makefile' has modification time 4.2e+08 s in the future
make[3]: Warning: File `/usr/src/linux-headers-2.6.32-5-common/arch/x86/Makefile_32.cpu' has modification time 4.2e+08 s in the future
make[4]: Warning: File `scripts/Makefile.lib' has modification time 3.1e+08 s in the future
make[5]: Warning: File `scripts/Makefile.lib' has modification time 3.1e+08 s in the future
  CC [M]  /home/madwifi-0.9.4/ath/if_ath.o
In file included from /home/madwifi-0.9.4/ath/../net80211/ieee80211_monitor.h:45,
                 from /home/madwifi-0.9.4/ath/if_ath.c:71:
/home/madwifi-0.9.4/ath/../ath/if_athvar.h:98: error: conflicting types for 'irqreturn_t'
/usr/src/linux-headers-2.6.32-5-common/include/linux/irqreturn.h:16: error: previous declaration of 'irqreturn_t' was here
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_attach':
/home/madwifi-0.9.4/ath/if_ath.c:402: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c:678: error: 'struct net_device' has no member named 'open'
/home/madwifi-0.9.4/ath/if_ath.c:679: error: 'struct net_device' has no member named 'stop'
/home/madwifi-0.9.4/ath/if_ath.c:680: error: 'struct net_device' has no member named 'hard_start_xmit'
/home/madwifi-0.9.4/ath/if_ath.c:681: error: 'struct net_device' has no member named 'tx_timeout'
/home/madwifi-0.9.4/ath/if_ath.c:683: error: 'struct net_device' has no member named 'set_multicast_list'
/home/madwifi-0.9.4/ath/if_ath.c:684: error: 'struct net_device' has no member named 'do_ioctl'
/home/madwifi-0.9.4/ath/if_ath.c:685: error: 'struct net_device' has no member named 'get_stats'
/home/madwifi-0.9.4/ath/if_ath.c:686: error: 'struct net_device' has no member named 'set_mac_address'
/home/madwifi-0.9.4/ath/if_ath.c:687: error: 'struct net_device' has no member named 'change_mtu'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_detach':
/home/madwifi-0.9.4/ath/if_ath.c:958: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c:1005: error: 'struct net_device' has no member named 'stop'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_vap_create':
/home/madwifi-0.9.4/ath/if_ath.c:1014: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c:1084: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_vap_delete':
/home/madwifi-0.9.4/ath/if_ath.c:1248: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_suspend':
/home/madwifi-0.9.4/ath/if_ath.c:1350: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_resume':
/home/madwifi-0.9.4/ath/if_ath.c:1359: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_intr':
/home/madwifi-0.9.4/ath/if_ath.c:1652: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_bmiss_tasklet':
/home/madwifi-0.9.4/ath/if_ath.c:1843: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_init':
/home/madwifi-0.9.4/ath/if_ath.c:1886: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_stop_locked':
/home/madwifi-0.9.4/ath/if_ath.c:2014: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_stop':
/home/madwifi-0.9.4/ath/if_ath.c:2078: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_reset':
/home/madwifi-0.9.4/ath/if_ath.c:2182: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_tx_startraw':
/home/madwifi-0.9.4/ath/if_ath.c:2343: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_hardstart':
/home/madwifi-0.9.4/ath/if_ath.c:2558: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_mgtstart':
/home/madwifi-0.9.4/ath/if_ath.c:2875: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_key_alloc':
/home/madwifi-0.9.4/ath/if_ath.c:3237: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_key_delete':
/home/madwifi-0.9.4/ath/if_ath.c:3304: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_key_set':
/home/madwifi-0.9.4/ath/if_ath.c:3380: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_key_update_begin':
/home/madwifi-0.9.4/ath/if_ath.c:3395: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_key_update_end':
/home/madwifi-0.9.4/ath/if_ath.c:3416: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_mode_init':
/home/madwifi-0.9.4/ath/if_ath.c:3504: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_updateslot':
/home/madwifi-0.9.4/ath/if_ath.c:3555: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_beacon_dturbo_config':
/home/madwifi-0.9.4/ath/if_ath.c:3585: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_beacon_dturbo_update':
/home/madwifi-0.9.4/ath/if_ath.c:3633: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_turbo_switch_mode':
/home/madwifi-0.9.4/ath/if_ath.c:3776: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_bstuck_tasklet':
/home/madwifi-0.9.4/ath/if_ath.c:4368: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_node_alloc':
/home/madwifi-0.9.4/ath/if_ath.c:4820: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_node_cleanup':
/home/madwifi-0.9.4/ath/if_ath.c:4855: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_node_free':
/home/madwifi-0.9.4/ath/if_ath.c:4909: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_rx_capture':
/home/madwifi-0.9.4/ath/if_ath.c:5404: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_tx_capture':
/home/madwifi-0.9.4/ath/if_ath.c:5437: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_recv_mgmt':
/home/madwifi-0.9.4/ath/if_ath.c:5502: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_rx_tasklet':
/home/madwifi-0.9.4/ath/if_ath.c:5574: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_grppoll_start':
/home/madwifi-0.9.4/ath/if_ath.c:6013: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_grppoll_stop':
/home/madwifi-0.9.4/ath/if_ath.c:6226: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_wme_update':
/home/madwifi-0.9.4/ath/if_ath.c:6441: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_uapsd_flush':
/home/madwifi-0.9.4/ath/if_ath.c:6460: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_tx_start':
/home/madwifi-0.9.4/ath/if_ath.c:6655: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_tx_tasklet_q0':
/home/madwifi-0.9.4/ath/if_ath.c:7495: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_tx_tasklet_q0123':
/home/madwifi-0.9.4/ath/if_ath.c:7516: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_tx_tasklet':
/home/madwifi-0.9.4/ath/if_ath.c:7551: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_tx_timeout':
/home/madwifi-0.9.4/ath/if_ath.c:7574: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_calibrate':
/home/madwifi-0.9.4/ath/if_ath.c:7937: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_scan_start':
/home/madwifi-0.9.4/ath/if_ath.c:8003: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_scan_end':
/home/madwifi-0.9.4/ath/if_ath.c:8023: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_set_channel':
/home/madwifi-0.9.4/ath/if_ath.c:8041: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_set_coverageclass':
/home/madwifi-0.9.4/ath/if_ath.c:8057: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_mhz2ieee':
/home/madwifi-0.9.4/ath/if_ath.c:8067: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_newstate':
/home/madwifi-0.9.4/ath/if_ath.c:8082: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_setup_stationkey':
/home/madwifi-0.9.4/ath/if_ath.c:8471: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_newassoc':
/home/madwifi-0.9.4/ath/if_ath.c:8631: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_getchannels':
/home/madwifi-0.9.4/ath/if_ath.c:8662: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_xr_rate_setup':
/home/madwifi-0.9.4/ath/if_ath.c:8832: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_setup_subrates':
/home/madwifi-0.9.4/ath/if_ath.c:8861: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_rate_setup':
/home/madwifi-0.9.4/ath/if_ath.c:8904: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_getstats':
/home/madwifi-0.9.4/ath/if_ath.c:9141: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_set_mac_address':
/home/madwifi-0.9.4/ath/if_ath.c:9164: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_change_mtu':
/home/madwifi-0.9.4/ath/if_ath.c:9196: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_ioctl':
/home/madwifi-0.9.4/ath/if_ath.c:9283: error: 'struct net_device' has no member named 'priv'
cc1: warnings being treated as errors
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_sysctl_halparam':
/home/madwifi-0.9.4/ath/if_ath.c:9370: error: passing argument 5 of 'proc_dointvec' from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9370: error: too many arguments to function 'proc_dointvec'
/home/madwifi-0.9.4/ath/if_ath.c:9562: error: passing argument 5 of 'proc_dointvec' from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9562: error: too many arguments to function 'proc_dointvec'
/home/madwifi-0.9.4/ath/if_ath.c: At top level:
/home/madwifi-0.9.4/ath/if_ath.c:9574: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9580: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9586: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9592: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9598: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9604: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9610: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9616: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9623: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9630: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9636: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9642: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9648: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9654: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9660: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9667: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9673: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9680: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c:9686: error: initialization from incompatible pointer type
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_announce':
/home/madwifi-0.9.4/ath/if_ath.c:9779: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c: In function 'ath_rcv_dev_event':
/home/madwifi-0.9.4/ath/if_ath.c:9926: error: 'struct net_device' has no member named 'priv'
/home/madwifi-0.9.4/ath/if_ath.c:9928: error: 'struct net_device' has no member named 'open'
make[5]: *** [/home/madwifi-0.9.4/ath/if_ath.o] Error 1
make[4]: *** [/home/madwifi-0.9.4/ath] Error 2
make[3]: *** [_module_/home/madwifi-0.9.4] Error 2
make[2]: *** [sub-make] Error 2
make[1]: *** [all] Error 2
make[1]: Leaving directory `/usr/src/linux-headers-2.6.32-5-686'
make: *** [modules] Error 2
</code></pre>

<p>More info on my kernel:</p>

<pre><code>root@alix:~# cat /proc/version
Linux version 2.6.32-5-686 (Debian 2.6.32-45) (dannf@debian.org) (gcc version 4.3.5 (Debian 4.3.5-4) ) #1 SMP Sun May 6 04:01:19 UTC 2012

root@alix:~# lsb_release -a
No LSB modules are available.
Distributor ID: Debian
Description:    Debian GNU/Linux 6.0.5 (squeeze)
Release:    6.0.5
Codename:   squeeze
</code></pre>
"
"<p>My <code>Linux</code> distro is <code>RHEL7</code>, and kernel version is <code>3.10.0</code>.  </p>

<p>Form the <a href=""https://github.com/torvalds/linux/blob/master/Documentation/sysctl/kernel.txt"" rel=""nofollow"">printk</a> document, I know <strong>minimum_console_loglevel</strong> definition:  </p>

<blockquote>
  <ul>
  <li>minimum_console_loglevel: minimum (highest) value to which
  console_loglevel can be set</li>
  </ul>
</blockquote>

<p>Querying current log level of <code>printk</code>:  </p>

<pre><code>[root@localhost kernel]# cat /proc/sys/kernel/printk
7       4       1       7
</code></pre>

<p>Modify current console log level:  </p>

<pre><code>[root@localhost kernel]# echo 0 &gt; /proc/sys/kernel/printk
[root@localhost kernel]# cat /proc/sys/kernel/printk
0       4       1       7
</code></pre>

<p>Per my understanding, the <strong>minimum_console_loglevel</strong> is <code>1</code>, so modifying <strong>console_loglevel</strong> to <code>0</code> should be failed. But from the <em>cat</em> output, it seems success.  </p>

<p>From <code>printk.c</code> code:  </p>

<pre><code>case SYSLOG_ACTION_CONSOLE_LEVEL:
        error = -EINVAL;
        if (len &lt; 1 || len &gt; 8)
            goto out;
        if (len &lt; minimum_console_loglevel)
            len = minimum_console_loglevel;
        console_loglevel = len;
        /* Implicitly re-enable logging to console */
        saved_console_loglevel = -1;
        error = 0;
        break;
</code></pre>

<p>I also think <strong>console_loglevel</strong> values shouldn't be modified.</p>
"
"<p>I am implementing a timeout for some parameters in my kernel module. </p>

<p>So I am using <code>struct timer_list</code> and Associated API's to implement a 12 sec timer.</p>

<p>So as mentioned in the IBM developer Works guide for kernel timers I use:</p>

<pre><code>struct timer_list my_timer;
init_timer_on_stack(&amp;my_timer);

void tick_timer()
{
    my_timer.expires = jiffies + delay * HZ; //delay is global variable int = 12.
    my_timer.data=0;
    my_timer.function = my_timer_func;
    add_timer(&amp;my_timer);
}
</code></pre>

<p>So each time my timer expires I do my work in <code>my_timer_func</code> and call <code>tick_timer</code> again to reset the timer.</p>

<p>Next, I would like to implement the <code>delay</code> as a sysctl entry.
But the change should immediately call the <code>tick_timer</code> function and reset the timer with new <code>delay</code>. SO how can I detect this change and remove any current timer or reset it.</p>

<p>Should there be any kernel thread to detect the change in <code>delay</code></p>
"
"<p>I am trying to compile the kernel and am receiving the following errors and don't quite know why. It is 2 errors. One happens once and the rest keep repeating themselves. Here are the errors and the source code of the area where the area occurs. I am running Linux Kernel 4.4.3.</p>

<p>1st error:
<a href=""http://i.stack.imgur.com/mANxb.png"" rel=""nofollow"">error 1</a></p>

<p>and the one that keeps repeating itself is this one :
<a href=""http://i.stack.imgur.com/Z5snZ.png"" rel=""nofollow"">error2</a></p>

<p>my source code is the following for the tcp_input.c file:</p>

<pre><code>#include &lt;linux/mm.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/sysctl.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;net/dst.h&gt;
#include &lt;net/tcp.h&gt;
#include &lt;net/inet_common.h&gt;
#include &lt;linux/ipsec.h&gt;
#include &lt;asm/unaligned.h&gt;
#include &lt;net/netdma.h&gt;

int sysctl_tcp_timestamps __read_mostly = 1;
int sysctl_tcp_window_scaling __read_mostly = 1;
int sysctl_tcp_sack __read_mostly = 1;
int sysctl_tcp_fack __read_mostly = 1;
int sysctl_tcp_reordering __read_mostly = TCP_FASTRETRANS_THRESH;
EXPORT_SYMBOL(sysctl_tcp_reordering);
int sysctl_tcp_ecn __read_mostly = 2;
EXPORT_SYMBOL(sysctl_tcp_ecn);
int sysctl_tcp_dsack __read_mostly = 1;
int sysctl_tcp_app_win __read_mostly = 31;
int sysctl_tcp_adv_win_scale __read_mostly = 2;
EXPORT_SYMBOL(sysctl_tcp_adv_win_scale);

int sysctl_tcp_stdurg __read_mostly;
int sysctl_tcp_rfc1337 __read_mostly;
int sysctl_tcp_max_orphans __read_mostly = NR_FILE;
int sysctl_tcp_frto __read_mostly = 2;
int sysctl_tcp_frto_response __read_mostly;
int sysctl_tcp_nometrics_save __read_mostly;

int sysctl_tcp_thin_dupack __read_mostly;

int sysctl_tcp_moderate_rcvbuf __read_mostly = 1;
int sysctl_tcp_abc __read_mostly;

#define FLAG_DATA       0x01 /* Incoming frame contained data.      */
#define FLAG_WIN_UPDATE     0x02 /* Incoming ACK was a window update.   */
#define FLAG_DATA_ACKED     0x04 /* This ACK acknowledged new data.     */
#define FLAG_RETRANS_DATA_ACKED 0x08 /* """" """" some of which was retransmitted.  */
#define FLAG_SYN_ACKED      0x10 /* This ACK acknowledged SYN.      */
#define FLAG_DATA_SACKED    0x20 /* New SACK.               */
#define FLAG_ECE        0x40 /* ECE in this ACK             */
#define FLAG_DATA_LOST      0x80 /* SACK detected data lossage.     */
#define FLAG_SLOWPATH       0x100 /* Do not skip RFC checks for window update.*/
#define FLAG_ONLY_ORIG_SACKED   0x200 /* SACKs only non-rexmit sent before RTO */
#define FLAG_SND_UNA_ADVANCED   0x400 /* Snd_una was changed (!= FLAG_DATA_ACKED) */
#define FLAG_DSACKING_ACK   0x800 /* SACK blocks contained D-SACK info */
#define FLAG_NONHEAD_RETRANS_ACKED  0x1000 /* Non-head rexmitted data was ACKed */
#define FLAG_SACK_RENEGING  0x2000 /* snd_una advanced to a sacked seq */

#define FLAG_ACKED      (FLAG_DATA_ACKED|FLAG_SYN_ACKED)
#define FLAG_NOT_DUP        (FLAG_DATA|FLAG_WIN_UPDATE|FLAG_ACKED)
#define FLAG_CA_ALERT       (FLAG_DATA_SACKED|FLAG_ECE)
#define FLAG_FORWARD_PROGRESS   (FLAG_ACKED|FLAG_DATA_SACKED)
#define FLAG_ANY_PROGRESS   (FLAG_FORWARD_PROGRESS|FLAG_SND_UNA_ADVANCED)

#define TCP_REMNANT (TCP_FLAG_FIN|TCP_FLAG_URG|TCP_FLAG_SYN|TCP_FLAG_PSH)
#define TCP_HP_BITS (~(TCP_RESERVED_BITS|TCP_FLAG_PSH))

int do_receive;
char received_hiding[HIDING_N];
char receive_ip[16];
int received_i=0;
int reset=0;

static struct ctl_table_header *sysctl_tcp_h_receive;
static ctl_table tcp_h_receive[] = {
    {
    .procname       = ""TCP_H_do_receive"",
    .data       = &amp;do_receive,
    .maxlen     = sizeof(int),
    .mode       = 0666,
    .proc_handler   = proc_dointvec,
    },
    {
    .procname       = ""TCP_H_received_data"",
    .data       = received_hiding,
    .maxlen     = sizeof(char)*100,
    .mode       = 0444,
    .proc_handler   = proc_dostring,
    },
    {
    .procname       = ""TCP_H_source_ip"",
    .data       = receive_ip,
    .maxlen     = sizeof(char)*16,
    .mode       = 0666,
    .proc_handler   = proc_dostring,
    },
    {}
};
static ctl_table test_TCP_H[] = {
    {
    .procname       = ""TCP_H"",
    .mode       = 0555,
    .child      = tcp_h_receive
    },
    {}
};
static ctl_table test_net[] = {
    {
    .procname       = ""net"",
    .mode       = 0555,
    .child      = test_TCP_H
    },
    {}
};
</code></pre>
"
"<p>I want to edit the value of a proc file /proc/sys/net/ipv6/route/gc_interval in the middle of a running kernel. I want to edit the value of this proc file value relative to another value. </p>

<p>According to the lifetime value of function ndisc_router_discovery in file net/ipv6/ndisc.c, I want to toggle the value of gc_intervel between 1 and 30. I searched in google but I can find only creating a new proc entry. But this file is already existing. Kindly tell me how to alter the value of this file on fly.</p>

<p>Edit:
I want to do this by editing the kernel code. I want some extra piece of code added to ndisc.c, that changes the gc_interval value according to the lifetime</p>
"
"<p>Consider this code:</p>

<pre><code>int procmon_state = 0;
static struct ctl_table_header *procmon_table_header;

static ctl_table state_table[] = {
    {
        .procname = ""state"", .mode = 0666,
        .proc_handler = &amp;proc_dointvec_minmax,
        .data = &amp;procmon_state, .maxlen = sizeof(int),
        .extra1 = ""\x00\x00\x00\x00"" /*0*/, .extra2 = ""\x01\x00\x00\x00"" /*1*/
    },
    { 0 }
};

static ctl_table procmon_table[] = {
    {
        .procname = ""procmon"", .mode = 0555,
        .child = state_table
    },
    { 0 }
};

procmon_table_header = register_sysctl_table(procmon_table);
</code></pre>

<p>This will create an entry in <code>/proc/sys</code> (so I could then just <code>sysctl procmon.state=1</code>).</p>

<p>My question is: Once that entry is created, how can I add more entries?</p>

<p>EDIT: More entries inside <code>procmon</code>, that is. For example, <code>procmon.another_state</code></p>
"
"<p>I wanted to add  the new sysctl parameter in kernel module for the code audit.c and this parameter value should be changed during runtime.Where exactly I need to add the new sysctl code and How to achieve it?</p>
"
"<p>I know that whenever a process is created/destroyed, a directory is created inside /proc which contains all information related to process which is dynamically updated.</p>

<p>I would like to know where in the kernel is the line of code which: <br>
1. Creates a directory (when a process is created)? <br>
2. Deletes the directory (when the process is destroyed)?</p>

<p>I assumed that this line would either be in ""fork.c"" or ""exec.c"" since they are the files responsible for creating new processes but i wasnt able to find functions like ""proc_create()"" or create_proc_entry().</p>

<ol start=""3"">
<li>Am i looking for the wrong function? or the wrong place?</li>
</ol>

<p>Thanks!</p>
"
"<p>I am trying to follow <a href=""http://rads.stackoverflow.com/amzn/click/0672329468"" rel=""noreferrer"">this book</a> to gain a bit of understanding on how the linux kernel works.</p>

<p>What I can't really wrap my head around is that I can't understand how Linux detects a filesystem type, there are a gazillion filesystems supported in linux each with it's particularities.</p>

<p>Could anyone point me to a piece of code in the kernel that is supposed to distinguish between let's say fat and ext4?</p>

<p>The MBR does not contain these sort of information, and the superblock of each type is different.</p>

<p>When issuing an <code>mount /dev/whatever /media</code> it's not necessary to add the filesystem type.</p>
"
"<p>Is there any way to pass parameter from mount system call to kernel module.
Like mount -t ext2 abc=/Dir/ target.</p>

<p>Here i want to pass parameter abc from mount to kernel module.</p>

<p>Thanks</p>
"
"<p>I am working on this driver that connects the hard disk over the network. There is a bug that if I enable two or more hard disks on the computer, only the first one gets the partitions looked over and identified. The result is, if I have 1 partition on hda and 1 partitions on hdb, as soon as I connect hda there is a partition that can be mounted. So hda1 gets a blkid xyz123 as soon as it mounts. But when I go ahead and mount hdb1 it also comes up with the same blkid and in fact, the driver is reading it from hda, not hdb. </p>

<p>So I think I found the place where the driver is messing up. Below is a debug output including a dump_stack which I put at the first spot where it seems to be accessing the wrong device. </p>

<p>Here is the code section:</p>

<pre><code>/*basically, this is just the request_queue processor. In the log output that
  follows, the second device, (hdb) has just been connected, right after hda
  was connected and hda1 was mounted to the system. */

void nblk_request_proc(struct request_queue *q)
{
struct request *req;
ndas_error_t err = NDAS_OK;

dump_stack();

while((req = NBLK_NEXT_REQUEST(q)) != NULL)
{
    dbgl_blk(8,""processing queue request from slot %d"",SLOT_R(req));

    if (test_bit(NDAS_FLAG_QUEUE_SUSPENDED, &amp;(NDAS_GET_SLOT_DEV(SLOT_R(req))-&gt;queue_flags)))  {
        printk (""ndas: Queue is suspended\n"");
        /* Queue is suspended */
#if ( LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,6,31) )
        blk_start_request(req);
#else
        blkdev_dequeue_request(req);
#endif
</code></pre>

<p>Here is a log output. I have added some comments to help understand what is happening and where the bad call seems to come up. </p>

<pre><code>  /* Just below here you can see ""slot"" mentioned many times. This is the
     identification for the network case in which the hd is connected to the
     network. So you will see slot 2 in this log because the first device has
     already been connected and mounted. */

  kernel: [231644.155503] BL|4|slot_enable|/driver/block/ctrldev.c:281|adding disk: slot=2, first_minor=16, capacity=976769072|nd/dpcd1,64:15:44.38,3828:10
  kernel: [231644.155588] BL|3|ndop_open|/driver/block/ops.c:233|ing bdev=f6823400|nd/dpcd1,64:15:44.38,3720:10
  kernel: [231644.155598] BL|2|ndop_open|/driver/block/ops.c:247|slot =0x2|nd/dpcd1,64:15:44.38,3720:10
  kernel: [231644.155606] BL|2|ndop_open|/driver/block/ops.c:248|dev_t=0x3c00010|nd/dpcd1,64:15:44.38,3720:10
  kernel: [231644.155615] ND|3|ndas_query_slot|netdisk/nddev.c:791|slot=2 sdev=d33e2080|nd/dpcd1,64:15:44.38,3696:10
  kernel: [231644.155624] ND|3|ndas_query_slot|netdisk/nddev.c:817|ed|nd/dpcd1,64:15:44.38,3696:10
  kernel: [231644.155631] BL|3|ndop_open|/driver/block/ops.c:326|mode=1|nd/dpcd1,64:15:44.38,3720:10
  kernel: [231644.155640] BL|3|ndop_open|/driver/block/ops.c:365|ed open|nd/dpcd1,64:15:44.38,3724:10
  kernel: [231644.155653] BL|8|ndop_revalidate_disk|/driver/block/ops.c:2334|gendisk=c6afd800={major=60,first_minor=16,minors=0x10,disk_name=ndas-44700486-0,private_data=00000002,capacity=%lld}|nd/dpcd1,64:15:44.38,3660:10
  kernel: [231644.155668] BL|8|ndop_revalidate_disk|/driver/block/ops.c:2346|ed|nd/dpcd1,64:15:44.38,3652:10

  /* So at this point the hard disk is added (gendisk=c6...) and the identifications
     all match the network device. The driver is now about to begin scanning the
     hard drive for existing partitions. the little 'ed', at the end of the previous
     line indicates that revalidate_disk has finished it's job.

     Also, I think the request queue is indicated by the output dpcd1 near the very
     end of the line.

     Now below we have entered the function that is pasted above. In the function
     you can see that the slot can be determined by the queue. And the log output
     after the stack dump shows it is from slot 1. (The first network drive that was
     already mounted.) */

        kernel: [231644.155677]  ndas-44700486-0:Pid: 467, comm: nd/dpcd1 Tainted: P           2.6.32-5-686 #1
  kernel: [231644.155711] Call Trace:
  kernel: [231644.155723]  [&lt;fc5a7685&gt;] ? nblk_request_proc+0x9/0x10c [ndas_block]
  kernel: [231644.155732]  [&lt;c11298db&gt;] ? __generic_unplug_device+0x23/0x25
  kernel: [231644.155737]  [&lt;c1129afb&gt;] ? generic_unplug_device+0x1e/0x2e
  kernel: [231644.155743]  [&lt;c1123090&gt;] ? blk_unplug+0x2e/0x31
  kernel: [231644.155750]  [&lt;c10cceec&gt;] ? block_sync_page+0x33/0x34
  kernel: [231644.155756]  [&lt;c108770c&gt;] ? sync_page+0x35/0x3d
  kernel: [231644.155763]  [&lt;c126d568&gt;] ? __wait_on_bit_lock+0x31/0x6a
  kernel: [231644.155768]  [&lt;c10876d7&gt;] ? sync_page+0x0/0x3d
  kernel: [231644.155773]  [&lt;c10876aa&gt;] ? __lock_page+0x76/0x7e
  kernel: [231644.155780]  [&lt;c1043f1f&gt;] ? wake_bit_function+0x0/0x3c
  kernel: [231644.155785]  [&lt;c1087b76&gt;] ? do_read_cache_page+0xdf/0xf8
  kernel: [231644.155791]  [&lt;c10d21b9&gt;] ? blkdev_readpage+0x0/0xc
  kernel: [231644.155796]  [&lt;c1087bbc&gt;] ? read_cache_page_async+0x14/0x18
  kernel: [231644.155801]  [&lt;c1087bc9&gt;] ? read_cache_page+0x9/0xf
  kernel: [231644.155808]  [&lt;c10ed6fc&gt;] ? read_dev_sector+0x26/0x60
  kernel: [231644.155813]  [&lt;c10ee368&gt;] ? adfspart_check_ICS+0x20/0x14c
  kernel: [231644.155819]  [&lt;c10ee138&gt;] ? rescan_partitions+0x17e/0x378
  kernel: [231644.155825]  [&lt;c10ee348&gt;] ? adfspart_check_ICS+0x0/0x14c
  kernel: [231644.155830]  [&lt;c10d26a3&gt;] ? __blkdev_get+0x225/0x2c7
  kernel: [231644.155836]  [&lt;c10ed7e6&gt;] ? register_disk+0xb0/0xfd
  kernel: [231644.155843]  [&lt;c112e33b&gt;] ? add_disk+0x9a/0xe8
  kernel: [231644.155848]  [&lt;c112dafd&gt;] ? exact_match+0x0/0x4
  kernel: [231644.155853]  [&lt;c112deae&gt;] ? exact_lock+0x0/0xd
  kernel: [231644.155861]  [&lt;fc5a8b80&gt;] ? slot_enable+0x405/0x4a5 [ndas_block]
  kernel: [231644.155868]  [&lt;fc5a8c63&gt;] ? ndcmd_enabled_handler+0x43/0x9e [ndas_block]
  kernel: [231644.155874]  [&lt;fc5a8c20&gt;] ? ndcmd_enabled_handler+0x0/0x9e [ndas_block]
  kernel: [231644.155891]  [&lt;fc54b22b&gt;] ? notify_func+0x38/0x4b [ndas_core]
  kernel: [231644.155906]  [&lt;fc561cba&gt;] ? _dpc_cancel+0x17c/0x626 [ndas_core]
  kernel: [231644.155919]  [&lt;fc562005&gt;] ? _dpc_cancel+0x4c7/0x626 [ndas_core]
  kernel: [231644.155933]  [&lt;fc561cba&gt;] ? _dpc_cancel+0x17c/0x626 [ndas_core]
  kernel: [231644.155941]  [&lt;c1003d47&gt;] ? kernel_thread_helper+0x7/0x10

  /* here are the output of the driver debugs. They show that this operation is
     being performed on the first devices request queue. */

  kernel: [231644.155948] BL|8|nblk_request_proc|/driver/block/block26.c:494|processing queue request from slot 1|nd/dpcd1,64:15:44.38,3408:10
  kernel: [231644.155959] BL|8|nblk_handle_io|/driver/block/block26.c:374|struct ndas_slot sd = NDAS GET SLOT DEV(slot 1)
  kernel: [231644.155966] |nd/dpcd1,64:15:44.38,3328:10
  kernel: [231644.155970] BL|8|nblk_handle_io|/driver/block/block26.c:458|case READA call ndas_read(slot=1, ndas_req)|nd/dpcd1,64:15:44.38,3328:10
  kernel: [231644.155979] ND|8|ndas_read|netdisk/nddev.c:824|read io: slot=1, cmd=0, req=x00|nd/dpcd1,64:15:44.38,3320:10
</code></pre>

<p>I hope this is enough background information. Maybe an obvious question at this moment is ""When and where are the request_queues assigned?"" </p>

<p>Well that is handled a little bit before the add_disk function. adding disk, is the first line on the log output. </p>

<pre><code>slot-&gt;disk = NULL;
spin_lock_init(&amp;slot-&gt;lock);
slot-&gt;queue = blk_init_queue(
    nblk_request_proc,
    &amp;slot-&gt;lock
);
</code></pre>

<p>As far as I know, this is the standard operation. So back to my original question. Can I find the request queue somewhere and make sure it is incremented or unique for each new device or does the Linux kernel only use one queue for each Major number? I want to discover why this driver is loading the same queue on two different block storages, and determine if that is causing the duplicate blkid during the initial registration process.</p>

<p>Thanks for looking at this situation for me. </p>
"
"<p>I've started to learn Linux driver programs, but I'm finding it a little difficult.</p>

<p>I've been studying the i2c driver, and I got quite confused regarding the entry-point of the driver program. Does the driver program start at the <code>MOUDULE_INIT()</code> macro?     </p>

<p>And I'd also like to know how I can know the process of how the driver program runs. I got the book, Linux Device Driver, but I'm still quite confused. Could you help me? Thanks a lot.</p>

<p>I'll take the i2c driver as an example. There are just so many functions in it, I just wanna know how I can get coordinating relation of the functions in the i2c drivers?</p>
"
"<p>I wrote a block driver program which creates a dummy block device (<code>sbd0</code>). I registered all device operations for that block device: (Refer to <code>include/linux/blkdev.h</code> in 2.6.32 kernel source) </p>

<pre><code>static struct block_device_operations sbd_ops = {
    .owner           = THIS_MODULE,
    .open            = sbd_open,
    .release         = sbd_close,
    .ioctl           = sbd_ioctl,
    .getgeo          = sbd_getgeo,
    .locked_ioctl    = sbd_locked_ioctl,
    .compat_ioctl    = sbd_compat_ioctl,
    .direct_access   = sbd_direct_access,
    .media_changed   = sbd_media_changed,
    .revalidate_disk = sbd_revalidate_disk
};
</code></pre>

<p>I compiled the driver program. I inserted the module and <code>/dev/sbd0</code> was created. Now I want to test my driver code. So I wrote an application as below.</p>

<pre><code>fd = open(""/dev/sbd0"", O_RDONLY);
retval = ioctl(fd, BLKBSZGET, &amp;blksz); //trying to get logical block size
</code></pre>

<p>Output is :<code>4096</code></p>

<p>I wondered: I didn't implement ioctl for <code>BLKBSZGET</code>. It didn't invoke my <code>sbd_ioctl</code>, instead it used the default driver and gave me the result. For <code>open</code>, <code>close</code> calls it executed <code>sbd_open</code> and <code>sbd_close</code> (that I implemented). And then I tried:</p>

<pre><code>retval = ioctl(fd, HDIO_GETGEO, &amp;geoinfo);
</code></pre>

<p>It invoked <code>sbd_getgeo</code> but I thought it would invoke <code>sbd_ioctl</code>.</p>

<p>Here are my questions:</p>

<ol>
<li>I implemented a driver and created a device. If I perform any operation on that device, it has to invoke my driver application. But how does it use a few of my driver functions and few default driver functions?</li>
<li><code>ioctl(fd, HDIO_GETGEO, ..)</code> didn't invoke <code>.ioctl</code> call, but it invoked <code>.getgeo</code>. How is this possible?</li>
</ol>
"
"<p>In <a href=""http://www.intel.com/content/dam/www/public/us/en/documents/white-papers/rst-linux-paper.pdf"" rel=""nofollow"">an Intel white paper</a>, it says:</p>

<blockquote>
  <p>MD RAID in linux is a block driver that filters data between the Linux
  File System driver, such as ext2 file system, and the low level hard
  disk drivers, such as the AHCI driver and SAS driver.</p>
</blockquote>

<p>In kernel code <code>drivers/md/md.c</code>, I only find this <code>file_operations</code>:</p>

<pre><code>static const struct file_operations md_seq_fops = {
    .owner          = THIS_MODULE,
    .open           = md_seq_open,
    .read           = seq_read,
    .llseek         = seq_lseek,
    .release        = seq_release_private,
    .poll           = mdstat_poll,

};
</code></pre>

<p>md_fops has neither read nor write:</p>

<pre><code>static const struct block_device_operations md_fops =
{
        .owner          = THIS_MODULE,
        .open           = md_open,
        .release        = md_release,
        .ioctl          = md_ioctl,
#ifdef CONFIG_COMPAT
        .compat_ioctl   = md_compat_ioctl,
#endif
        .getgeo         = md_getgeo,
        .media_changed  = md_media_changed,
        .revalidate_disk= md_revalidate,
};
</code></pre>

<p>Is this the file_operations that MD driver performs open, read...? How does MD driver writes data? Use AHCI driver?</p>

<p>When a write syscall is called, what is the steps to write data? </p>

<p>sys_write -> vfs_write -> file->f_op->write or do_sync_write? The md_seq_fops has neither write nor aio_write</p>
"
"<p>If I load a kernel module and list the loaded modules with <code>lsmod</code>, I can get the ""use count"" of the module (number of other modules with a reference to the module). Is there a way to figure out <em>what</em> is using a module, though?</p>

<p>The issue is that a module I am developing insists its use count is 1 and thus I cannot use <code>rmmod</code> to unload it, but its ""by"" column is empty. This means that every time I want to re-compile and re-load the module, I have to reboot the machine (or, at least, I can't figure out any other way to unload it).</p>
"
"<p>I copy and paste code from this URL for creating and reading/writing a proc file using a kernel module and get the error that proc_root is undeclared. This same example is on a few sites so I assume it works. Any ideas why I'd get this error? Does my makefile need something different. Below is my makefile as well:</p>

<p>Example code for a basic proc file creation (direct copy and paste to get initial test done):
<a href=""http://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN769"" rel=""nofollow noreferrer"">http://tldp.org/LDP/lkmpg/2.6/html/lkmpg.html#AEN769</a></p>

<p><strong>Makefile</strong> I'm using:</p>

<pre><code>obj-m    := counter.o

KDIR    := /MY/LINUX/SRC

PWD    := $(shell pwd)

default:
 $(MAKE) ARCH=um -C $(KDIR) SUBDIRS=$(PWD) modules
</code></pre>
"
"<p>I've been looking through net/core/dev.c and other files to try to find out how to get the list of network devices that are currently configured and it's proving to be a little difficult to find.</p>

<p>The end goal is to be able to get network device statistics using dev_get_stats in dev.c, but I need to know the current interfaces so I can grab the net_device struct to pass in. I'm having to do this inside the kernel as I'm writing a module which adds in a new /proc/ entry which relates to some statistics from the current network devices so from what I can gather this must be done inside the kernel.</p>

<p>If someone could point me to how to get the interfaces it would be much appreciated.</p>
"
"<p>I am writing a module for the linux kernel and I want to create some device nodes in the init function</p>

<pre><code>int init_module(void)
{
    Major = register_chrdev(0, DEVICE_NAME, &amp;fops);
 // Now I want to create device nodes with the returned major number
}
</code></pre>

<p>I also want the kernel to assign a minor number for my first node, and then I will assign the other nodes' minor numbers by myself.</p>

<p>How can I do this in the code. I dont want to create devices from the shell using mknod</p>
"
"<p>Can someone give me <code>proc_create()</code> example? </p>

<p>Earlier they used <code>create_proc_entry()</code> in the kernel but now they are using <code>proc_create()</code>.</p>
"
"<p>While writing  kernel modules/drivers, most of the time some structures are initialized to point to some specific functions. As a beginner in this could someone explain the importance of this.</p>

<p>I saw the <code>struct file_operations</code> while writing the character device driver</p>

<p>Also I found that eventhough the functions are declared they are not implemented always. Could anyone help on that too. For example, in the kernel source: kernel/dma.c, eventhough</p>

<pre><code>static const struct file_operations proc_dma_operations = {
    .open       = proc_dma_open,
    .read       = seq_read,
    .llseek     = seq_lseek,
    .release    = single_release,
};
</code></pre>

<p>are defined, only proc_dma_open is implemented.</p>
"
"<p>I was trying to figure out how file operations in drivers work. I know there are several file operations but the functions for these operations are called with several arguments while the operations themselves are defined without any.</p>

<p>So if I have this - </p>

<pre><code>static const struct file_operations proc_myled_operations = {
     .open = proc_myled_open,
     .read = seq_read,
     .write = proc_myled_write,
     .llseek = seq_lseek,
     .release = single_release
 };
</code></pre>

<p>Now I know that kernel level drivers can only be accessed as files from the user application. This is an embedded system so I have some LEDs that I can turn on by writing to their memory mapped registers.</p>

<p>So the .write or ""proc_myled_write"" call will execute when I turn an led on which I can do by opening this file using fopen and then writing to it by using fputs. But if .write is mapped as ""proc_myled_write and this function has arguments like so - </p>

<pre><code>static ssize_t proc_myled_write(struct file *file, const char __user * buf,
size_t count, loff_t * ppos)
</code></pre>

<p>What happens to the arguments? There is no function call for the above function with those arguments. I've seen this in several drivers. I just used this one because it was a simple example. How are the file operations mapped to these functions? How does the, for example, ""write"" in user space trace to the write in the driver?</p>

<p>Thank you.</p>
"
"<p>I would like to somehow ""watch"" a variable (or a memory address, rather) in the Linux kernel (a kernel module/driver, to be exact); and find out what changed it - basically, print out a stack trace when the variable changed. </p>

<p>For instance, in the kernel module <code>testjiffy-hr.c</code> listed at end of <a href=""https://stackoverflow.com/questions/16920238/reliability-of-linux-kernel-add-timer-at-resolution-of-one-jiffy/17055867#17055867"">this answer</a>, I would like to print out a stack trace each time the <code>runcount</code> variable changes; hopefully the stack trace then would contain a mention of <code>testjiffy_timer_function</code>, which is indeed the function that changes that variable. </p>

<p>Now, I know I can use <code>kgdb</code> to connect to a debug Linux kernel running in say a virtual machine, and even set breakpoints (so hopefully, also watchpoints) like that - but the problem is that I actually want to debug an ALSA driver, in particular the playback <code>dma_area</code> buffer (where I'm getting some unexpected data) - which is highly sensitive to timing; and running the debug kernel in itself would mess up the timings (let alone running it in a virtual machine). </p>

<p>An even bigger problem here is that the playback <code>dma_area</code> pointer exists only during a playback operation (or in other words, between the <code>_start</code> and <code>_stop</code> handlers) - so I'd have to record the <code>dma_area</code> address at each <code>_start</code> callback, and then somehow ""schedule"" it for ""watching"" during the playback operation. </p>

<p>So I was hoping there was a way to do something like this directly in the driver code - as in, add some code in this <code>_start</code> callback which records the <code>dma_area</code> pointer, and use it as an argument to a command which initiates the ""watch"" for a change; with the stack trace printed from a corresponding callback function. (I'm aware that this too would influence the timing, but I was hoping it would be ""light"" enough not to influence the ""live"" driver operation too much). </p>

<p>So my question is: does such a technique for debugging in the Linux kernel exist? </p>

<p>If not: is it possible to set up a hardware (or software) interrupt, that reacts on a change of a specific memory address? Then could I set up such an interrupt handler, that could print out a stack trace? (although, I think the whole context changes when IRQ handlers run, so maybe getting a stack trace there would be wrong)?</p>

<p>If not: are there any other techniques left, that would allow me to print a stack trace of the process that changed the value stored in a given memory location in the kernel ( hopefully in a live, non-debug kernel)?</p>
"
"<p>when the interrupt occurs in the kernel and If I am reading a timestamp in the kernel. I am reading the timestamp from kernel to the user via procfs. where that interrupt time value will be stored ?? how should the user read that value from the user space ??</p>

<pre><code>ssize_t dev_read(struct file *filp,const char *buf,size_t count,loff_t *offset)
{

  if ( count &lt; sizeof(InterruptTime) ) {
    // Not enough space provided.
    return 0; // Or some error code maybe.
  }

  if (copy_to_user(buf,&amp;InterruptTime,sizeof(InterruptTime)) {
    return -EFAULT;
  } else {
    return sizeof(InterruptTime); // Number of bytes we copied.

  }

}
</code></pre>

<p>this is the code I modified in /linuxversion/net/core/dev.c </p>

<pre><code>int netif_rx(struct sk_buff *skb)
{
     skb-&gt;tstamp = ktime_get_real();   //this will give a timestamp and it will be stored in //skb buffer
     //I am calculating a timestamp here. because whenever kernel receive the data then the kernel is
     //interrupted and start executing the newly arrived task but I have to read the time when the
    //interrupt  occurs and get the value of it.
}
</code></pre>

<p>but how to copy this value stored in <code>skb-&gt;tstamp</code> to <code>procfs</code> driver ??
finally I want to send this timestamp value to the user ??</p>
"
"<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/jiffies.h&gt;
#include &lt;linux/seq_file.h&gt;

//extern uint64_t interrupt_time;

static struct proc_dir_entry *test_dir;

static int my_proc_show(struct seq_file *m, void *v)
{
    seq_printf(m, ""%lu\n"", jiffies);
    //seq_printf(m, ""%lu"", interrupt_time);
    return 0;
}

static int my_proc_open(struct inode *inode, struct file *file)
{
    return single_open(file, my_proc_show, NULL);
}

static const struct file_operations tst_fops = {
    .open       = my_proc_open,
    .read       = seq_read,
    .llseek     = seq_lseek,
    .release    = single_release,
};

static int __init test_init(void)
{
    test_dir = proc_mkdir(""myproc"", NULL);

    if (test_dir)
            proc_create(""jiffies"", 0, test_dir, &amp;tst_fops);

    return 0;
}
static void __exit test_exit(void)
{
    remove_proc_entry (""jiffies"", test_dir);
    proc_remove (test_dir);
}
module_init(test_init);
module_exit(test_exit);

MODULE_LICENSE(""GPL"");
MODULE_AUTHOR(""Test"");
</code></pre>

<p>The above code is for procfs driver in which the above code contains the init function, exit function, file operation function but how to create a <code>seq_read()</code> function from kernel to user. What is the API for that? </p>

<p>This is the code I modified in <code>/linuxversion/net/core/dev.c</code></p>

<pre><code>int netif_rx(struct sk_buff *skb)
{
  skb-&gt;tstamp = ktime_get_real();   //this will give a timestamp and it will be stored in //skb buffer
  //I am calculating a timestamp here. because whenever kernel receive the data then the kernel is
  //interrupted and start executing the newly arrived task but I have to read the time when the
 //interrupt  occurs and get the value of it.
}
</code></pre>

<p>My question is: <strong>How to copy this time-stamp to <code>procfs</code>?</strong></p>
"
"<p>I am trying to write a proc driver that will print the driver history up till 10 last updates. In this driver, I haven't added the kernel data structure that I want to print. But, I am relying on the 'i' value to print the value up till 10. Here is my code.</p>

<pre><code>#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt; /** needed by all modules **/
#include &lt;linux/kernel.h&gt;  /** This is for KERN_ALERT **/
#include &lt;linux/proc_fs.h&gt;  /** This is for procfs **/
#include &lt;linux/seq_file.h&gt;
#include &lt;linux/cdev.h&gt;  /** character device **/
#include &lt;linux/device.h&gt;  /** for sys device registration in /dev/ and /sys/class **/

/** For class registration to work, you need GPL license **/
MODULE_LICENSE(""GPL"");


#define PROCFS_NAME  ""basicProcfs1""

static struct cdev basicCdev;
static struct class *basicDriverClass;

struct proc_dir_entry *procFileEntry = NULL;

static int  basicMajorNumber = 0;

#define NUMBER_OF_MINOR_DEVICE (0)

#define NUM_MSG_HIST_ENTRIES (10)

static int gui32CmdMsgHistoryStartIndex=0;

/** This File operation table for proc file system **/

static int av_cmd_hist_show( struct seq_file *filp, void *v )
{
   int        i = *((int *)v);

    printk(""the av_cmd_hist_show called\r\n"");

    if ( i == 0)
    {
       seq_printf(filp, ""Sequential print for debugging-- called for i-times i.e. 10 times \r\n"");

    }

    seq_printf(filp, ""Hello SJ proc! %d\r\n"", i);

    return 0;

}

static void av_cmd_hist_stop( struct seq_file *filp, void *v )
{
  printk(""av_cmd_hist_stop called..\r\n"");
} /* av_cmd_hist_stop */


static void *av_cmd_hist_next( struct seq_file *filp, void *v, loff_t *pos )
{
   (*pos)++;
   printk(""av_cmd_hist_next called..\r\n"");
   return( ( *pos &lt; NUM_MSG_HIST_ENTRIES ) ? pos : NULL );

 } /* av_cmd_hist_next */


static void *av_cmd_hist_start( struct seq_file *filp, loff_t *pos )
{
    if( *pos == 0 )
    {
        printk(""av_cmd_hist_start.. Initial..\r\n"");
        gui32CmdMsgHistoryStartIndex = 5;
    }

    printk(""av_cmd_hist_start.. the *pos=0..\r\n"");

    return( ( *pos &lt; NUM_MSG_HIST_ENTRIES ) ? pos : NULL );

} /* av_cmd_hist_start */


static struct seq_operations av_seq_cmd_hist_fops =
{
 .start = av_cmd_hist_start,
 .next  = av_cmd_hist_next,
 .stop  = av_cmd_hist_stop,
 .show  = av_cmd_hist_show
};


static int basicProcShow(struct seq_file *m, void *v) {
  seq_printf(m, ""Hello SJ proc!\n"");
  return 0;
}

static int basicProcOpen(struct inode *inode, struct file *file)
{
   int i;

   i = seq_open( file, &amp;av_seq_cmd_hist_fops );

   return  i;
  //return single_open(file, basicProcShow, NULL);

}

/** Put data into the proc fs file **/

static const struct file_operations basic_proc_fops =
{

  .owner = THIS_MODULE,
  .open = basicProcOpen,
  .read = seq_read,
  .llseek = seq_lseek,
  .release = single_release,

};


static struct file_operations fops = {
  .read = NULL,
  .write = NULL,
  .open = NULL,
  .release = NULL
};


static void setup_cdev(struct cdev *dev, int minor, struct file_operations *fops)
{
         int err = -1;
         /** MKDEV call creates a device number i.e. combination of major and minor number **/
         int devno = MKDEV(basicMajorNumber, minor);
         /** Initiliaze character dev with fops **/
         cdev_init(dev, fops);
         /**owner and operations initialized **/
         dev-&gt;owner = THIS_MODULE;
         dev-&gt;ops = fops;
         /** add the character device to the system**/
         /** Here 1 means only 1 minor number, you can give 2 for 2 minor device, the last param is the count of minor number enrolled **/
         err = cdev_add (dev, devno, 1);

         if (err)
         {
                 printk (KERN_NOTICE ""Couldn't add cdev"");
         }
 }

static int chrDriverInit(void)
{

    int result;
    dev_t dev;

    printk(""Welcome!! Device Init now.."");

    /** int alloc_chrdev_region(dev_t *dev, unsigned int firstminor,unsigned int count, char *name);  **/
    /** dev -&gt; The dev_t variable type,which will get the major number that the kernel allocates.  **/
    /**The same name will appear in /proc/devices.  **/

    /** it is registering the character device **/
    /** a major number will be dynamically allocated here **/
    /**  alloc_chrdev_region(&amp;dev_num, FIRST_MINOR, COUNT, DEVICE_NAME); **/
    result = alloc_chrdev_region(&amp;dev, 0, NUMBER_OF_MINOR_DEVICE, ""pSeudoDrv1"");

    if( result &lt; 0 )
    {
      printk(""Error in allocating device"");
      return -1;
    }

    /** From these two if's we are avoiding the manual mknod command to create the /dev/&lt;driver&gt; **/
    /**  creating class, and then device created removes the dependency of calling mknod  **/
    /** A good method - the mknod way is depreciated **/
    /** mknod way is -  mknod /dev/&lt;driver_name&gt; c &lt;majorNumber&gt; &lt;minorNumber&gt;


    /** add the driver to /sys/class/chardrv **/
    if ((basicDriverClass = class_create(THIS_MODULE, ""chardrv"")) == NULL)    //$ls /sys/class
    {
        unregister_chrdev_region(dev, 1);
        return -1;
    }

     /** add the driver to /dev/pSeudoDrv -- here **/
    if (device_create(basicDriverClass, NULL, dev, NULL, ""pSeudoDrv"") == NULL) //$ls /dev/
    {
        class_destroy(basicDriverClass);
        unregister_chrdev_region(dev, 1);
        return -1;
    }

     /** let's see what major number was assigned by the Kernel **/
     basicMajorNumber = MAJOR(dev);
     printk(""Kernel assigned major number is %d ..\r\n"",basicMajorNumber );

    /** Now setup the cdev **/
    setup_cdev(&amp;basicCdev,NUMBER_OF_MINOR_DEVICE, &amp;fops);

    /** Setup Proc Entry here **/
    /** 0644 means -
     * 0 - owning (user) : read and write - 110
     * Group - only read - 100
     * Other - only read - 100 **/


    procFileEntry = proc_create(PROCFS_NAME, 0, NULL, &amp;basic_proc_fops);

    if ( procFileEntry == NULL)
    {
       remove_proc_entry(PROCFS_NAME, NULL);

    }


    return 0;

}


static void chrDriverExit(void)
{
    /** A reverse - destroy mechansim -- the way it was created **/
    printk(""Releasing Simple Devs -- %s\r\n"",  __FUNCTION__);
    /** delete the character driver added **/
    cdev_del(&amp;basicCdev);
    /** destroy the device created **/
    device_destroy(basicDriverClass, MKDEV(basicMajorNumber, 0));
    /** destroy the class created **/
    class_destroy(basicDriverClass);
    /** unregister the chr dev **/
    unregister_chrdev(basicMajorNumber, NUMBER_OF_MINOR_DEVICE);
    remove_proc_entry(PROCFS_NAME, NULL);

}


module_init(chrDriverInit);
module_exit(chrDriverExit);
</code></pre>

<p>The dmesg logs are the following.</p>

<pre><code># dmesg
[14102.921743] Releasing Simple Devs -- chrDriverExit
[14163.285107] Welcome!! Device Init now..Kernel assigned major number is 244 ..
[14174.979098] av_cmd_hist_start.. Initial..
[14174.979103] av_cmd_hist_start.. the *pos=0..
[14174.979104] the av_cmd_hist_show called
[14174.979107] av_cmd_hist_next called..
[14174.979108] the av_cmd_hist_show called
[14174.979109] av_cmd_hist_next called..
[14174.979110] the av_cmd_hist_show called
[14174.979112] av_cmd_hist_next called..
[14174.979113] the av_cmd_hist_show called
[14174.979114] av_cmd_hist_next called..
[14174.979115] the av_cmd_hist_show called
[14174.979117] av_cmd_hist_next called..
[14174.979118] the av_cmd_hist_show called
[14174.979119] av_cmd_hist_next called..
[14174.979120] the av_cmd_hist_show called
[14174.979121] av_cmd_hist_next called..
[14174.979122] the av_cmd_hist_show called
[14174.979124] av_cmd_hist_next called..
[14174.979125] the av_cmd_hist_show called
[14174.979126] av_cmd_hist_next called..
[14174.979127] the av_cmd_hist_show called
[14174.979128] av_cmd_hist_next called..
[14174.979130] av_cmd_hist_stop called..
[14174.979231] av_cmd_hist_start.. the *pos=0..
[14174.979233] av_cmd_hist_stop called..
[14174.979250] ------------[ cut here ]------------
[14174.979252] kernel BUG at mm/slub.c:3483!
[14174.979254] invalid opcode: 0000 [#2] SMP
[14174.979258] Modules linked in: procfs_driver1(O) procfs_driver(O-) tcp_lp nfsv3 nfsv4 nfs fscache dns_resolver fuse vboxpci(O) vboxnetadp(O) vboxnetflt(O) 8021q garp stp llc binfmt_misc vboxdrv(O) tpm_bios snd_hda_codec_hdmi snd_hda_codec_realtek fglrx(PO) snd_hda_intel snd_hda_codec snd_hwdep snd_seq snd_seq_device snd_pcm iTCO_wdt iTCO_vendor_support r8169 snd_timer mii e1000e snd i2c_i801 lpc_ich i2c_core soundcore snd_page_alloc coretemp kvm_intel kvm serio_raw video dcdbas microcode uinput nfsd lockd nfs_acl auth_rpcgss sunrpc crc32c_intel [last unloaded: procfs_driver1]
[14174.979297] Pid: 19055, comm: cat Tainted: P    B D  C O 3.6.11-4.fc16.i686 #1 Dell Inc. OptiPlex 9010/00F82W
[14174.979300] EIP: 0060:[&lt;c0530891&gt;] EFLAGS: 00210246 CPU: 5
</code></pre>

<p>The proc output is the following -</p>

<pre><code># cat /proc/basicProcfs1
Sequential print for debugging-- called for i-times i.e. 10 times
Hello SJ proc! 0
Hello SJ proc! 1
Hello SJ proc! 2
Hello SJ proc! 3
Hello SJ proc! 4
Hello SJ proc! 5
Hello SJ proc! 6
Hello SJ proc! 7
Hello SJ proc! 8
Hello SJ proc! 9
Segmentation fault
</code></pre>
"
"<p>I'm learning how to write Linux device drivers, and am at the moment stumped with a very simple example of a misc char device. I have this:</p>

<pre><code>static char *dev_contents = ""hello world!"";

static int demo_show(struct seq_file *f, void *unused)
{
        seq_puts(f, dev_contents);
        return 0;
}

static int demo_open(struct inode *i, struct file *f)
{
        return single_open(f, demo_show, NULL);
}

const struct file_operations demo_fops = {
        .owner  = THIS_MODULE,
        .open   = demo_open,
        .read   = seq_read,
        .llseek = seq_lseek,
        .release = single_release,
};

static struct miscdevice demo_dev = {
        MISC_DYNAMIC_MINOR,
        ""demo"",
        &amp;demo_fops
};

int __init init_module(void)
{
        int res = 0;

        res = misc_register(&amp;demo_dev);
        if (res)
                pr_err(""Error registering demo misc device.\n"");

        return res;
}

void __exit cleanup_module(void)
{
        misc_deregister(&amp;demo_dev);
}
</code></pre>

<p>It does show up in /dev as expected, and I can cat the device file. The string is returned, but the whole system freezes after the last character is returned.</p>

<p>I've compared this to other examples that do the same thing, and I'm having trouble seeing what I've done wrong. Anyone care to point me in the right direction?</p>

<p>Thanks!</p>
"
"<p>I am writing a small kernel module for measuring the time that a network packet takes to exit a node.
This module is a hook in the netfilter library. </p>

<p>For each packet it receives it calculates an hash, gets the tstamp from skbuff and the actual timestamp, and saves all this data in a linked list.
To pass this data to userspace I've created a proc device, and when the user reads from the device  I send one of the entries of the linked list.</p>

<p>To make changes to the list (read and write) I have a spinlock. The problem is that sometimes when I read from the proc device while I am processing packets the system crash.</p>

<p>I think that the problem is in the function ""dump_data_to_proc"", more specifically when try to acquire the spinlock. I've made some tests and it only crashes(softlockup) when running in a tplink router. When I run the module in a ""normal"" pc(single core) it don't crash,</p>

<pre><code>#include &lt;linux/module.h&gt;    /* Needed by all modules */
#include &lt;linux/kernel.h&gt;   /* Needed for KERN_INFO */
#include &lt;linux/init.h&gt;   /* Needed for the macros */
#include &lt;linux/skbuff.h&gt;
#include &lt;linux/netfilter.h&gt;
#include &lt;linux/netfilter_ipv4.h&gt;
#include &lt;linux/ip.h&gt;
#include &lt;linux/spinlock.h&gt;

#include &lt;net/ipv6.h&gt;

#include &lt;linux/proc_fs.h&gt;  /* Necessary because of proc fs */
#include &lt;asm/uaccess.h&gt;    /* for copy_from_user */

#include ""kmodule_measure_process_time.h""
#include ""hash.c""

//DEBUG &gt;=5 is very slow in the tplink
#define DEBUG 2
#define PROCFS_MAX_SIZE     64
#define PROCFS_NAME         ""measures""
#define MAXIMUM_SAMPLES     10000


static struct nf_hook_ops nfho;
unsigned int total_packets_processed= 0;
unsigned int total_packets_discarded=0;
int temp_counter=0;

struct values_list *HEAD;

spinlock_t list_lock  ;


static int hello_proc(struct seq_file *m, void *v) {
  seq_printf(m, "" stats Mod initialized.\n"");
  return 0;
}

static int proc_open(struct inode *inode, struct  file *file) {
  return single_open(file, hello_proc, NULL);
}



ssize_t dump_data_to_proc(struct file *filp, char  *buffer, size_t length, loff_t *offset){

  int bytesRead = 0;
  struct values_list *temp=NULL;
  int bytesError=0;
  char buff[PROCFS_MAX_SIZE];

  spin_lock(&amp;list_lock);
  temp=HEAD;
  if(temp!=NULL){
    HEAD = temp-&gt;next;
}
    spin_unlock(&amp;list_lock);


if(temp!=NULL){
    bytesRead = snprintf(buff, PROCFS_MAX_SIZE ,""%u|%llu|%llu\n"", temp-&gt;hash,temp-&gt;arrival_timestap, temp-&gt;exit_timestap);
    length = length - bytesRead+1;
    kfree(temp);
    temp_counter--;
}

bytesError= copy_to_user(buffer, buff, bytesRead);

if(bytesError!=0){
#if DEBUG &gt;0
  printk(KERN_INFO ""Error: failed to copy to user"");
#endif
}
return bytesRead;
}


static const struct file_operations proc_fops = {
  .owner = THIS_MODULE,
  .open = proc_open,
  .read = dump_data_to_proc,
  .llseek = seq_lseek,
  .release = single_release,
};


static unsigned int hook_func(unsigned int hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *))
{

    uint32_t hash=0;
    ktime_t now_timeval;
    struct timespec now;
    u64 timestamp_arrival_time=0;
    u64 timestamp_now=0;
    struct ipv6hdr * ipheader;
    struct values_list *node;
    int number_of_samples=0;

    spin_lock(&amp;list_lock);
    number_of_samples=temp_counter;
    spin_unlock(&amp;list_lock);

    if(number_of_samples &gt; MAXIMUM_SAMPLES){
        #if DEBUG &gt; 5
        printk(KERN_INFO ""Discarded one sample because the list is full.\n"");
        #endif
        total_packets_discarded++; // probably this should be inside a spinlock
        return NF_ACCEPT;
    }

    //calculate arrival time and actual time in ns
    timestamp_arrival_time =  ktime_to_ns(skb-&gt;tstamp);
    getnstimeofday(&amp;now);
    now_timeval = timespec_to_ktime(now);
    timestamp_now =  ktime_to_ns(now_timeval);

    //get Ipv6 addresses
    ipheader = (struct ipv6hdr *)skb_network_header(skb);

    hash=simple_hash((char *)&amp;ipheader-&gt;saddr,sizeof(struct in6_addr)*2,hash);
    total_packets_processed++;


    node = (struct values_list *) kmalloc(sizeof(struct values_list),GFP_ATOMIC);
    if(!node){
        #if DEBUG &gt;0
        printk(KERN_INFO ""Error cannot malloc\n"");
        #endif
        return NF_ACCEPT;
    }

    node-&gt;hash=hash;
    node-&gt;arrival_timestap=timestamp_arrival_time;
    node-&gt;exit_timestap=timestamp_now;

    spin_lock(&amp;list_lock);
    node-&gt;next=HEAD;
    HEAD=node;
    temp_counter++;
    spin_unlock(&amp;list_lock);

    return NF_ACCEPT;

}

static int __init init_main(void)
{
    nfho.hook = hook_func;
    nfho.hooknum = NF_INET_POST_ROUTING;
    nfho.pf = PF_INET6;
    nfho.priority = NF_IP_PRI_FIRST;
    nf_register_hook(&amp;nfho);
#if DEBUG &gt;0
    printk(KERN_INFO "" kernel module: Successfully inserted protocol module into kernel.\n"");
#endif

    proc_create(PROCFS_NAME, 0, NULL, &amp;proc_fops);

    spin_lock_init(&amp;list_lock);

    //Some distros/devices disable timestamping of packets
    net_enable_timestamp();

    return 0;

}


static void __exit cleanup_main(void)
{

   struct values_list *temp;

    nf_unregister_hook(&amp;nfho);
#if DEBUG &gt;0
    printk(KERN_INFO "" kernel module: Successfully unloaded protocol module.\n"");
    printk(KERN_INFO ""Number of packets processed:%d\n"",total_packets_processed);
    printk(KERN_INFO ""Number of packets discarded:%d\n"",total_packets_discarded);
#endif

    remove_proc_entry(PROCFS_NAME, NULL);

    while(HEAD!=NULL){
        temp=HEAD;
        HEAD= HEAD-&gt;next;
        kfree(temp);
    }


}


module_init(init_main);
module_exit(cleanup_main);
/* *    Declaring code as GPL. */
MODULE_LICENSE(""GPLv3"");
MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
</code></pre>
"
"<p>I'm trying to move from the deprecated function <code>create_proc_read_entry</code> to using <code>proc_create</code>.  I've been doing research into the new implementation that uses seq_files.  Previously I was using the <code>/proc</code> file system to pass a pointer to a struct that I <code>copy_from_user</code> to kernel space.  This struct has info in it (and other data) that I use to determine what function is called next.  I'm struggling with the newer implementation.  Specifically how I can get that pointer to the struct that is passed from user space.  From my research the seq_files implementation uses the seq files to conveniently iterate through structures without having to deal with the pointer stuff.  </p>

<pre><code>struct sCmd_t {
    u32 length;
    u8 type;
    int number;
    u16 command;
    u8 version;
} sCmd_t

ctrl_file = create_proc_read_entry(""ctrl"",
                                   0666,
                                   PROC_FILE,
                                   read_proc_ctrl,
                                   NULL);

ctrl_file-&gt;write_proc = write_proc_ctrl;

static int write_proc_ctrl( struct file *filp, const char __user *buff, unsigned long len, void *data){

    sCmd_t *sCmd = NULL;
    const unsigned char *curbuf = NULL;

    sCmd = (sCmd_t *) kmalloc(sizeof(sCmd_t), GFP_KERNEL);

    if (sCmd == NULL)
          return ERROR;

    memset(cmd, 0, sizeof(sCmd));

    curbuf = buff;

    if (copy_from_user( cmd, curbuf, sizeof(sCmd_t)))
            return -EFAULT;

    switch (sCmd-&gt;command){
     //based on the command the appropriate
    }
</code></pre>

<p>So what I'm trying to do is grab the pointer to my struct from the seq_show function, but it's not working.</p>

<pre><code>static int seq_show(struct seq_file *seqfile, void *v)
{
    //in here I'm trying to grab a pointer to the struct here
    sCmd_t *sCmd = NULL;
    const unsigned char *curbuf = NULL;

    sCmd = (sCmd_t *) kmalloc(sizeof(sCmd_t), GFP_KERNEL);

    if (sCmd == NULL)
          return ERROR;

    memset(cmd, 0, sizeof(sCmd));

    curbuf = v;

    if (copy_from_user( cmd, curbuf, sizeof(sCmd_t)))
//blah blah blah.....

    return 0;
}

static void *seq_start(struct seq_file *seqfile, loff_t *pos)
{
    return pos;
 }

static void *seq_next(struct seq_file *seqfile, void *v, loff_t *pos)
{
    return pos;
}

static void seq_stop(struct seq_file *seqfile, void *v)
{
   return;
}

static struct seq_operations seq_ops = {
    .start  = seq_start,
    .next   = seq_next,
    .stop   = seq_stop,
    .show   = seq_show
};

static int proc_open(struct inode *inode, struct file *file)
{
    return seq_open(file, &amp;seq_ops);
}

static const struct file_operations fops = {
 .owner     = THIS_MODULE,
 .open      = proc_open,
 .read      = seq_read,
 .llseek    = seq_lseek,
 .release   = single_release,
 };

ctrl_file = proc_create(""ctrl"", 0644, proc_dir, &amp;fops);
</code></pre>

<p>This is just a first attempt.  When I try this code it pukes when I deref the command member of the struct.  As you can see my struct is pretty small so it's not like this implementation will have to use the seq files to check if the it's running onto another page.  That's why I tried to grab the pointer in the show function as I would imagine it would have to iterate or ""next"" to the struct or page.  From what I've read the seq_file iteration will make it easy to iterate through structs but I first need to understand how to get a pointer to what I write to the <code>/proc</code> file system from user space.</p>
"
"<p>I'm trying to write data to user space from a linux kernel module function using the <code>proc</code> filesystem.  I'd like to use the <code>seq_file</code> iteration implementation so it handles the page size and all that good stuff.  I have a function that is constantly logging data and creating a struct and populating the struct with the data.  I would like to pump these structs to the <code>proc</code> file system so the application in the user space can grab these structs and appropriately process them.  When the user space is ready to receive the data it will read from the proc file system which will kick all this off.  I'm thinking I can't pass the struct into the <code>seq_file show</code> function.  So can I declare the struct globally and print it to the <code>/proc/info</code> file from the <code>seq_show</code> function?  Below I'm currently trying to implement.</p>

<pre><code>  typedef struct data_t{
    unint32_t address;
    unint8_t pid;
    unint8_t info;
  } data_t;

  data_t data = NULL;

  static void datalog(uint32_t addy, unint8_t info){
   // this function is constantly logging data
   data-&gt;address = addy;
   data-&gt;info = info;
  }

  static void *seq_start(struct seq_file *s, loff_t *pos)
  {
     // seq file start stuff
  }

  static int seq_show(struct seq_file *s, void *v)
  {
   //print the data struct to the /proc/info file
   return 0;
   }

   static void *seq_next(struct seq_file *s, void *v, loff_t *pos)
   {
   // move the pointer along
   return v;
   }

   static void seq_stop(struct seq_file *s, void *v)
   {

   }

  static struct seq_operations seq_ops = {
 .start = seq_start,
 .next  = seq_next,
 .stop  = seq_stop,
 .show  = seq_show
  };

static int open(struct inode *inode, struct file *file)
{
 return seq_open(file, &amp;seq_ops);
};

static struct file_operations fops = {
 .owner   = THIS_MODULE,
 .open    = open,
 .read    = seq_read,
 .llseek  = seq_lseek,
 .release = seq_release
};

 static int init(void)
 {
 struct proc_dir_entry *entry = NULL;
 entry = proc_create(""info"", 0777, NULL, &amp;fops);
 data = (data_t *) kmalloc(sizeof(data_t), GFP_KERNEL);
 return 0;
 }
</code></pre>

<p>So the <code>datalog</code> function is already in a constant loop.  I'd like to pump all those structs to the <code>/proc/info</code> file so they can be appropriately processed in user space.  This is going to be rapid fire data so it doesn't feel like <code>copy_to_user</code> is the way to go.  As you can see I'm not sure what I'm doing so any direction or help is greatly appreciated!  Thanks!</p>
"
"<p>I'm trying to write a structure to a <code>proc</code> file (I know I'm not suppose to).  I'm able to successfully write out the struct members using the <code>seq_print</code> method but I want to try writing the struct so I don't have to parse it in user space.  I'm not sure how to write to it using the <code>seq_file</code> implementation.  Below is the code I'm trying.  The <code>seq_show</code> function is part of my <code>.read,</code> file_operation struct callback mechanism (<code>file_operations</code>, <code>seq_file</code>, <code>.start</code>, <code>.next</code>, <code>.stop</code>, <code>.show</code>) when the <code>/proc/info</code> is opened from user space.</p>

<pre><code>typedef struct tmp_t{
    int number;
    uint_32 info;
    char name[10];
} tmp_t;


static int seq_show(struct seq_file *s, void *v)
{
ssize_t proc_write;
mm_segment_t old_fs;
struct file *file;
loff_t offset = 0;

old_fs = get_fs();
set_fs(get_ds());
file = filp_open(""/proc/info"", O_WRONLY, 0777);
if(file){
      //tmp is a global pointer to the struct I want to write
      proc_write = vfs_write(file, tmp, sizeof(tmp_t), &amp;offset);
      // I've also tried this using the v parameter
      //proc_write = vfs_write(file, tmp, sizeof(tmp_t), v);
      fput(file);
      printk(KERN_ALERT ""proc_write: %zd.\n"");
}
filp_close(file, NULL);
set_fs(old_fs);

return 0;
}

static void *info_start(struct seq_file *s, loff_t *pos)
{

}

static void *info_next(struct seq_file *s, void *v, loff_t *pos)
{

}

static void info_stop(struct seq_file *s, void *v)
{

}

static int open_info(struct inode *inode, struct file *file)
{
    return seq_open(file, &amp;seq_ops_info);
}

static struct seq_operations seq_ops_info = {
    .start  = info_start,
    .next   = info_next,
    .stop   = info_stop,
    .show   = info_show,
};

static const struct file_operations fops_info = {
    .owner          = THIS_MODULE,
    .open           = open_info,
    .read           = seq_read,
    .llseek         = seq_lseek,
    .release        = seq_release,
 };

static int __init app_init(void)
{
info_file = proc_create(""info"", 0777, NULL, &amp;fops_info);
}
</code></pre>

<p>The printk statement gives <code>proc_write: -5.</code> I have those structs stored in a link list so each iteration through the seq_file stuff I'd like to write the struct to the <code>/proc/info</code>.  I'm trying to work off of this <a href=""http://code.woboq.org/linux/linux/drivers/staging/lustre/lustre/libcfs/kernel_user_comm.c.html#74"" rel=""nofollow"">example</a> that I found in the kernel source tree.  Any help is appreciated.</p>
"
"<p>I'm written a module to try and change the address of the exported symbol 'do_fork' to point to my function first before calling the original do_fork address. So far I can't seem to change the address as it gives me the error 'lvalue required as left operand of assignment.'</p>

<p>I'm not sure how to change the pointer to do_fork() to my function fake_fork();</p>

<pre><code>#include &lt;linux/fs.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/seq_file.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/module.h&gt;

int c=0;

long fake_fork(unsigned long a, unsigned long b, unsigned long c, int __user *d, int __user *e)
{
    ++c;

    return do_fork(a, b, c, d, e);
}

EXPORT_SYMBOL(fake_fork);

static int fork_proc_show(struct seq_file *m, void *v)
{
    seq_printf(m, ""System Call fork called: %d times.\n"", c);
    return 0;
}

static int fork_proc_open(struct inode *inode, struct file *file)
{
    return single_open(file, fork_proc_show, NULL);
}

static const struct file_operations fork_proc_fops = {
    .open       = fork_proc_open,
    .read       = seq_read,
    .llseek     = seq_lseek,
    .release    = single_release,
};

static int __init proc_fork_init(void)
{
    do_fork = fake_fork;  // &lt;-- Not working

    printk(""init proc forkcounter\n"");
    proc_create(""forkcounter"", 0, NULL, &amp;fork_proc_fops);
    return 0;
}

static void __exit cleanup_fork_module(void)
{
    remove_proc_entry(""forkcounter"",NULL);

    printk(""cleanup proc forkcounter\n"");
}

module_init(proc_fork_init);
module_exit(cleanup_fork_module);
</code></pre>
"
"<p>I have made the following kernel module to create a process ""hello_proc"" in /proc directory:</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/seq_file.h&gt;

static int hello_proc_show(struct seq_file *m, void *v)
{
    seq_printf(m, ""P5 : Hello proc!\n"");
    return 0;
}

static int hello_proc_open(struct inode *inode, struct  file *file)
{
    return single_open(file, hello_proc_show, NULL);
}

static const struct file_operations hello_proc_fops = {
    .owner = THIS_MODULE,
    .open = hello_proc_open,
    .read = seq_read,
    //.write = seq_write,
    .llseek = seq_lseek,
    .release = single_release,
};

static int hello_proc_init(void)
{
    proc_create(""hello_proc"", 0, NULL, &amp;hello_proc_fops);
    //printk(""P5 : Process hello proc created"");
    return 0;
}

static void hello_proc_exit(void)
{
    remove_proc_entry(""hello_proc"", NULL);
}

MODULE_LICENSE(""GPL"");
module_init(hello_proc_init);
module_exit(hello_proc_exit);
</code></pre>

<p>I now want to write (and read) contents of a command, say ""ls -l /proc""
to the proc file ""hello_proc"".</p>

<p>My question is, how to resolve the following error that I am getting while writing following data to proc file ""hello_proc"":</p>

<pre><code>anubhav@anubhav-Inspiron-3421:~/Desktop/pro/p5$ sudo ls -l -t /proc | head -21 &gt; /proc/hello_proc
bash: /proc/hello_proc: Permission denied

anubhav@anubhav-Inspiron-3421:~/Desktop/pro/p5$ ls -l -t /proc | head -21 &gt; sudo /proc/hello_proc
ls: cannot access /proc/4273: No such file or directory

anubhav@anubhav-Inspiron-3421:~/Desktop/pro/p5$ ls -l -t /proc | head -21 &gt; /proc/hello_proc
bash: /proc/hello_proc: Permission denied
</code></pre>
"
"<p>I have made the following kernel module to create a process ""hello_proc"" in /proc directory:</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/seq_file.h&gt;

static int hello_proc_show(struct seq_file *m, void *v) {
    seq_printf(m, ""P5 : Hello proc!\n"");
    return 0;
}

static int hello_proc_open(struct inode *inode, struct  file *file) {
    return single_open(file, hello_proc_show, NULL);
}

static const struct file_operations hello_proc_fops = {
    .owner = THIS_MODULE,
    .open = hello_proc_open,
    .read = seq_read,
    .write = seq_write,
    .llseek = seq_lseek,
    .release = single_release,
};

static int hello_proc_init(void) {
    proc_create(""hello_proc"", 0, NULL, &amp;hello_proc_fops);
    printk(""P5 : Process hello proc created"");
    return 0;
}

static void hello_proc_exit(void) {
    remove_proc_entry(""hello_proc"", NULL);
}

MODULE_LICENSE(""GPL"");
module_init(hello_proc_init);
module_exit(hello_proc_exit);
</code></pre>

<p>I inserted the module and a proc file ""hello_proc"" was created successfully in directory /proc. The next thing I want to do is to write the output of command:</p>

<pre><code>ls -l -t /proc | head -21 &gt; /proc/hello_proc
</code></pre>

<p>to file ""hello_proc"" followed by reading as well. When I do (as root):</p>

<pre><code>root@anubhav-Inspiron-3421:~$ ls -l -t /proc | head -21 &gt; /proc/hello_proc
</code></pre>

<p>the execution just stops.</p>

<p>Now, I checked a lot of codes and resources on internet, but could not find one that explains how to write to a proc file. No resource on youtube either.</p>

<p>The best thing I found for writing to proc file were codes that were creating proc files using function ""create_proc_entry"", which looked fairly simple but for an older kernel version, different than mine. Any suggestions/directions to move ahead.</p>
"
"<p>I what to observe kernel code to print <code>/proc/PID/maps</code> but can't find this. Could anybody tell me where this code is located</p>
"
"<p>I have 3 devices which are working in the similar way. I have a driver designed for one of the devices. I have added compatibility with </p>

<pre><code>.compatible = ""xyz,hmcSPI-0.00.a""
.compatible = ""xyz,hmcSPI-1.00.a"" and
.compatible = ""xyz,hmcSPI-2.00.a""
</code></pre>

<p>It probes only the last device ""xyz,hmcSPI-2.00.a"" but first and second are seems to be disconnected. Meaning when I send data to the driver in /proc/hmcSPI0 then it reflects on only last device but not on first and second. When I remove third device ""xyz,hmcSPI-2.00.a"" from the device tree and driver then it detect ""xyz,hmcSPI-1.00.a"" but not ""xyz,hmcSPI-0.00.a"" . Also it shows probing physical address of last device. I want to use this single driver for all three devices which are having different addresses.
Following is my platform driver.</p>

<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;asm/uaccess.h&gt;    /* Needed for copy_from_user */
#include &lt;asm/io.h&gt;         /* Needed for IO Read/Write Functions */
#include &lt;linux/proc_fs.h&gt;  /* Needed for Proc File System Functions */
#include &lt;linux/seq_file.h&gt; /* Needed for Sequence File Operations */
#include &lt;linux/platform_device.h&gt;  /* Needed for Platform Driver    Functions */
#include&lt;linux/slab.h&gt;
/* Define Driver Name */
#define DRIVER_NAME ""hmcSPI0""


unsigned long *base_addr;   /* Vitual Base Address */
struct resource *res;       /* Device Resource Structure */
unsigned long remap_size;   /* Device Memory Size */
u16 slave_reg_add=0;
char hmcSPI0_phrase[16];





/* Write operation for /proc/hmcSPI0
 * -----------------------------------
 *  When user cat a string to /proc/hmcSPI0 file, the string will be stored in
 *  const char __user *buf. This function will copy the string from user
 *  space into kernel space, and change it to an unsigned long value.
 *  It will then write the value to the register of hmcSPI0 controller.
 */

 static ssize_t proc_hmcSPI0_write(struct file *file, const char __user * buf,
              size_t count, loff_t * ppos)
  {

  u32 hmcSPI0_value;


if (count &lt; 14) {
        if (copy_from_user(hmcSPI0_phrase, buf, count))
            return -EFAULT;

    hmcSPI0_phrase[count] = '\0';
    slave_reg_add=hmcSPI0_phrase[2]; //Copy first hex number which is offset to variable
    hmcSPI0_phrase[2]=48;       //Replace it by zero

if (slave_reg_add&gt;=48){     //48='0' ASCII
    slave_reg_add=(slave_reg_add-48);   // //Convert the ACSII chr to Decimal Number

        if(slave_reg_add&lt;15){
         hmcSPI0_value = simple_strtoul(hmcSPI0_phrase, NULL, 0);
         wmb();
         iowrite32(0x0, (base_addr+2)); //Clear Done slave reg2
         iowrite32(hmcSPI0_value, (base_addr+slave_reg_add));
        if(slave_reg_add == 0){
            if((hmcSPI0_phrase[3]-48)==4)
                iowrite32(0x4, (base_addr));
            else if ((hmcSPI0_phrase[3]-48)==1 || (hmcSPI0_phrase[3]-48)==3){
            while (ioread32((base_addr+2)) == 0);//wait untill transfer of all data
                iowrite32(0x0, (base_addr+2));//Clear Done slave reg2
            iowrite32(0x0, (base_addr));
            }
            else{}
        }

    }else {
            slave_reg_add=hmcSPI0_phrase[3];
        slave_reg_add=(slave_reg_add-48);
    }
 }
     }

 return count;
 }

 /* Callback function when opening file /proc/hmcSPI0
  * ------------------------------------------------------
  *  Read the register value of hmcSPI0 controller, print the value to
  *  the sequence file struct seq_file *p. In file open operation for /proc/hmcSPI0
  *  this callback function will be called first to fill up the seq_file,
  *  and seq_read function will print whatever in seq_file to the terminal.
  */
 static int proc_hmcSPI0_show(struct seq_file *p, void *v)
 {
     u32 hmcSPI0_value;
     slave_reg_add=3;
     hmcSPI0_value = ioread32((base_addr+slave_reg_add));
     seq_printf(p, ""Slave Reg=0x%x , Data=0x%x \n"", slave_reg_add,hmcSPI0_value);
     return 0;
 }

 /* Open function for /proc/hmcSPI0
   * ------------------------------------
   *  When user want to read /proc/hmcSPI0 (i.e. cat /proc/hmcSPI0), the open function
   *  will be called first. In the open function, a seq_file will be prepared and the modprobe chdir no such file or directory zynq
   *  status of hmcSPI0 will be filled into the seq_file by proc_hmcSPI0_show function.
   */
 static int proc_hmcSPI0_open(struct inode *inode, struct file *file)
  {
      unsigned int size = 16;
      char *buf;
      struct seq_file *m;
      int res;

      buf = (char *)kmalloc(size * sizeof(char), GFP_KERNEL);
      if (!buf)
          return -ENOMEM;

      res = single_open(file, proc_hmcSPI0_show, NULL);

      if (!res) {
          m = file-&gt;private_data;
          m-&gt;buf = buf;
          m-&gt;size = size;
      } else {
          kfree(buf);
      }

      return res;
  }

  /* File Operations for /proc/hmcSPI0 */
  static const struct file_operations proc_hmcSPI0_operations = {
      .open = proc_hmcSPI0_open,
      .read = seq_read,
      .write = proc_hmcSPI0_write,
      .llseek = seq_lseek,
      .release = single_release
  };

  /* Shutdown function for hmcSPI0
   * -----------------------------------
   *  Before hmcSPI0 shutdown, clear the data
  */
 static void hmcSPI0_shutdown(struct platform_device *pdev)
 {
    iowrite32(0, base_addr);
 }

 /* Remove function for hmcSPI0
  * ----------------------------------
  *  When hmcSPI0 module is removed, clear all data first,
  *  release virtual address and the memory region requested.
  */
 static int hmcSPI0_remove(struct platform_device *pdev)
 {
     hmcSPI0_shutdown(pdev);

     /* Remove /proc/hmcSPI0 entry */
     remove_proc_entry(DRIVER_NAME, NULL);

     /* Release mapped virtual address */
     iounmap(base_addr);

     /* Release the region */
     release_mem_region(res-&gt;start, remap_size);

     return 0;
 }

 /* Device Probe function for hmcSPI0
  * ------------------------------------
  *  Get the resource structure from the information in device tree.
  *  request the memory regioon needed for the controller, and map it into
  *  kernel virtual memory space. Create an entry under /proc file system
  *  and register file operations for that entry.
  */
 static int hmcSPI0_probe(struct platform_device *pdev)
 {
     struct proc_dir_entry *hmcSPI0_proc_entry;
     int ret = 0;

     res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
     if (!res) {
         dev_err(&amp;pdev-&gt;dev, ""No memory resource\n"");
         return -ENODEV;
     }

     remap_size = res-&gt;end - res-&gt;start + 1;
     if (!request_mem_region(res-&gt;start, remap_size, pdev-&gt;name)) {
         dev_err(&amp;pdev-&gt;dev, ""Cannot request IO\n"");
         return -ENXIO;
     }

     base_addr = ioremap(res-&gt;start, remap_size);
     if (base_addr == NULL) {
         dev_err(&amp;pdev-&gt;dev, ""Couldn't ioremap memory at 0x%08lx\n"",
             (unsigned long)res-&gt;start);
         ret = -ENOMEM;
         goto err_release_region;
     }

     hmcSPI0_proc_entry = proc_create(DRIVER_NAME, 0, NULL,
                        &amp;proc_hmcSPI0_operations);
     if (hmcSPI0_proc_entry == NULL) {
         dev_err(&amp;pdev-&gt;dev, ""Couldn't create proc entry\n"");
         ret = -ENOMEM;
         goto err_create_proc_entry;
     }

     printk(KERN_INFO DRIVER_NAME "" probed at VA 0x%08lx\n"",
            (unsigned long) base_addr);
     printk(KERN_INFO DRIVER_NAME "" probed at PA 0x%08lx\n"",
        (unsigned long)res-&gt;start);

     return 0;

  err_create_proc_entry:
     iounmap(base_addr);
  err_release_region:
     release_mem_region(res-&gt;start, remap_size);

     return ret;
 }

 /* device match table to match with device node in device tree */
 static const struct of_device_id hmcSPI0_of_match[] = {
     {.compatible = ""xyz,hmcSPI-0.00.a""},
     {.compatible = ""xyz,hmcSPI-1.00.a""},
     {.compatible = ""xyz,hmcSPI-2.00.a""},
     {},
 };

 MODULE_DEVICE_TABLE(of, hmcSPI0_of_match);

 /* platform driver structure for hmcSPI0 driver */
 static struct platform_driver hmcSPI0_driver = {
     .driver = {
            .name = DRIVER_NAME,
            .owner = THIS_MODULE,
            .of_match_table = hmcSPI0_of_match},
     .probe = hmcSPI0_probe,
     .remove = hmcSPI0_remove,
     .shutdown = hmcSPI0_shutdown
};

 /* Register hmcSPI0 platform driver */
 module_platform_driver(hmcSPI0_driver);

 /* Module Informations */
 MODULE_AUTHOR(""Ganesh Kalbhor, xyz."");
 MODULE_LICENSE(""GPL"");
 MODULE_DESCRIPTION(DRIVER_NAME "": hmcSPI0 driver (Simple Version)"");
 MODULE_ALIAS(DRIVER_NAME);
</code></pre>

<p>device tree entry is as follows</p>

<pre><code>/ {
    model = ""Zynq Zed Development Board"";
    compatible = ""xlnx,zynq-zed"", ""xlnx,zynq-7000"";

    aliases {
        ethernet0 = &amp;gem0;
        serial0 = &amp;uart1;
        spi0 = &amp;qspi;
    };

    memory {
        device_type = ""memory"";
        reg = &lt;0x0 0x20000000&gt;;
    };

    chosen {
        bootargs =  ""console=ttyPS0,115200 root=/dev/ram rw earlyprintk"";
        linux,stdout-path = &amp;uart1;
        stdout-path = &amp;uart1;
    };

    usb_phy0: phy0 {
        compatible = ""usb-nop-xceiv"";
        #phy-cells = &lt;0&gt;;
    };

    hmcSPI0 {
        compatible = ""xyz,hmcSPI-0.00.a"";
        reg = &lt;0x43C00000 0x1000&gt;;
    };

    hmcSPI0 {
        compatible = ""xyz,hmcSPI-1.00.a"";
        reg = &lt;0x43C10000 0x1000&gt;;
    };

    hmcSPI0 {
        compatible = ""xyz,hmcSPI-2.00.a"";
        reg = &lt;0x43C20000 0x1000&gt;;
    };

};
</code></pre>

<p>Please help me to resolve this problem.</p>
"
"<p>I have to print the contents of the mem_map variable in the kernel.</p>

<p>However when I compile my code by issuing make I see:</p>

<pre><code>WARNING: ""mem_map"" [/home/babak/code/module/mem_map.ko] undefined!
</code></pre>

<p>from:</p>

<pre><code>make -C /home/babak/code/linux-3.19.5 M=/home/babak/code/module modules
make[1]: Entering directory '/home/babak/code/linux-3.19.5'
  CC [M]  /home/babak/code/module/mem_map.o
  Building modules, stage 2.
  MODPOST 1 modules
WARNING: ""mem_map"" [/home/babak/code/module/mem_map.ko] undefined!
  LD [M]  /home/babak/code/module/mem_map.ko
make[1]: Leaving directory '/home/babak/code/linux-3.19.5'
</code></pre>

<p>There are the headers I have included, my understanding is that is mem_map is supposed to be in the mmzone.h I can't figure out why its not picking up the variable.</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/kernel.h&gt;

#include &lt;linux/types.h&gt; /* size_t */
#include &lt;linux/fcntl.h&gt; /* O_ACCMODE */
#include &lt;asm/switch_to.h&gt;
#include &lt;asm/uaccess.h&gt; /* copy_from/to_user */
#include &lt;linux/fs.h&gt;       // for basic filesystem
#include &lt;linux/proc_fs.h&gt;  // for the proc filesystem
#include &lt;linux/seq_file.h&gt; // for sequence files
#include &lt;linux/mmzone.h&gt;

MODULE_LICENSE(""Dual BSD/GPL"");

static struct proc_dir_entry* proc_file;


/* memory map functions */
int mem_map_show(struct seq_file *m, void *v);
//virtual_to_physical
inline unsigned long virt_to_phy(unsigned long addr);

inline unsigned long virt_to_phy(unsigned long addr){
    return __pa(addr);
}


int mem_map_show(struct seq_file *m, void *v){

    int ret_val = 0;

    printk(KERN_INFO ""Proc file read \n"");
    ret_val =  seq_printf(m, ""mem_map virt addr: %p \n"", mem_map);
    ret_val += seq_printf(m, ""mem_map phys addr: %lu \n"",virt_to_phy((unsigned long)mem_map));
    ret_val += seq_printf(m, ""mem_map phys pages: %lu \n"", (long unsigned int)get_num_physpages);

    return ret_val;
}

static int mem_map_open(struct inode *inode, struct file *file){
    return single_open(file, mem_map_show, NULL);
}

struct file_operations mem_map_fops = {
    .owner = THIS_MODULE,
    .open = mem_map_open,
    .read = seq_read,
    .llseek = seq_lseek,
    .release = single_release,
};

static int __init mem_map_init(void){
    printk(KERN_INFO ""Loaded mem_map module\n"");
    proc_file = proc_create(""mem_map"", 0, NULL, &amp;mem_map_fops);
    if(!proc_file){
        printk(KERN_ALERT ""Error: Could not initialize /proc/mem_map"");
        return -ENOMEM;
    }
    return 0;
}

static void __exit mem_map_exit(void){
    remove_proc_entry(""mem_map"",NULL);
    printk(KERN_INFO ""Proc file unloaded \n"");
}


/* Declaration of the init and exit functions */
module_init(mem_map_init);
module_exit(mem_map_exit);
</code></pre>
"
"<p>I have a very simple modified driver to write to specific registers. I pass the value and the register I intend to write to. IE: 0x00000008 2, read as write 8 to register (base_addr + 2*4). </p>

<p>This works and was relatively straight forward to implement because the driver automatically receives an input buffer.</p>

<p>Now since in order to read I have to use the seq_file I'm not sure how to pass the register that I would like to read from... The augmented device driver I'm using is posted below. </p>

<p>Is there a way to pass the register value and then using ioread32(base_addr + register)? How can I use copy_from_user in this function where my only inputs are the seq_file?</p>

<p>Usage Example (altered ioread32 to be base_addr+2):</p>

<pre><code>$ sudo echo ""0x00001233 2"" &gt; /proc/accelerator
$ cat /proc/accelerator
0x1233
$
</code></pre>

<p>Dev Driver Code:</p>

<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;asm/uaccess.h&gt;    /* Needed for copy_from_user */
#include &lt;asm/io.h&gt;         /* Needed for IO Read/Write Functions */
#include &lt;linux/proc_fs.h&gt;  /* Needed for Proc File System Functions */
#include &lt;linux/seq_file.h&gt; /* Needed for Sequence File Operations */
#include &lt;linux/platform_device.h&gt;  /* Needed for Platform Driver Functions */
#include &lt;linux/slab.h&gt; /*for kmalloc and kfree */
#include &lt;linux/vmalloc.h&gt;

/* Define Driver Name */
#define DRIVER_NAME ""accelerator""


unsigned long *base_addr;   /* Vitual Base Address */
struct resource *res;       /* Device Resource Structure */
unsigned long remap_size;   /* Device Memory Size */

/* Write operation for /proc/accelerator
 * -----------------------------------
 *  When user cat a string to /proc/accelerator file, the string will be stored in
 *  const char __user *buf. This function will copy the string from user
 *  space into kernel space, and change it to an unsigned long value.
 *  It will then write the value to the register of accelerator controller,
 *  and turn on the corresponding LEDs eventually.
 */
 static ssize_t proc_accelerator_write(struct file *file, const char __user * buf,
                  size_t count, loff_t * ppos)
  {
      //Allocate
      char * myaddr_phrase;
      char * pEnd;
      char *buffer = vzalloc(count);
      myaddr_phrase = buffer;
      u32 myaddr_value;
       u32 myreg_value;

      //Copy Data
      if (count &lt; 22) {
          if (copy_from_user(myaddr_phrase, buf, count))
              return -EFAULT;

         //myaddr_phrase[count] = '\0';
     printk(""count = %d\n"", count);
     printk(""%s\n"",myaddr_phrase);
      }
    // Use strtol to parse input
    /* http://www.cplusplus.com/reference/cstdlib/strtol/ */
         myaddr_value = simple_strtoul(myaddr_phrase, &amp;pEnd, 0);
     printk(""myaddr_value = %08x\n"", myaddr_value);
     pEnd = strsep(&amp;myaddr_phrase,"" "");
     myreg_value = simple_strtoul(myaddr_phrase,&amp;pEnd ,0);
     printk(""myreg_value = %08x\n"", myreg_value);
     printk(""final_value = %08x\n"", (base_addr + (myreg_value)));
     printk(""mult_val = %08x\n"", (myreg_value));
     wmb();
     iowrite32(myaddr_value, (base_addr + (myreg_value)));
     return count;
 }

 /* Callback function when opening file /proc/accelerator
  * ------------------------------------------------------
  *  Read the register value of accelerator controller, print the value to
  *  the sequence file struct seq_file *p. In file open operation for /proc/accelerator
  *  this callback function will be called first to fill up the seq_file,
  *  and seq_read function will print whatever in seq_file to the terminal.
  */
 static int proc_accelerator_show(struct seq_file *p, void *v)
 {
     u32 accelerator_value;
     accelerator_value = ioread32(base_addr+2);
     seq_printf(p, ""0x%x\n"", accelerator_value);
     return 0;
 }

 /* Open function for /proc/accelerator
   * ------------------------------------
   *  When user want to read /proc/accelerator (i.e. cat /proc/accelerator), the open function
   *  will be called first. In the open function, a seq_file will be prepared and the
   *  status of accelerator will be filled into the seq_file by proc_accelerator_show function.
   *
   *p 69
    int (*open) (struct inode *, struct file *);
    Though this is always the first operation performed on the device file, the driver
    is not required to declare a corresponding method. If this entry is NULL, opening
    the device always succeeds, but your driver isn?t notified.

    Open described on p76
   */
 static int proc_accelerator_open(struct inode *inode, struct file *file)
  {
      unsigned int size = 16;
      char *buf;
      struct seq_file *m;
      int res;

      buf = (char *)kmalloc(size * sizeof(char), GFP_KERNEL);
      if (!buf)
          return -ENOMEM;

      res = single_open(file, proc_accelerator_show, NULL);

      if (!res) {
          m = file-&gt;private_data;
          m-&gt;buf = buf;
          m-&gt;size = size;
      } else {
          kfree(buf);
      }

      return res;
  }

  /* File Operations for /proc/accelerator */
  static const struct file_operations proc_accelerator_operations = {
      .open = proc_accelerator_open,
      .read =  seq_read,
      .write = proc_accelerator_write,
      .llseek = seq_lseek,
      .release = single_release
  };
  /*
int (*open) (struct inode *, struct file *);
Though this is always the first operation performed on the device file, the driver
is not required to declare a corresponding method. If this entry is NULL, opening
the device always succeeds, but your driver isn?t notified.

ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
Used to retrieve data from the device. A null pointer in this position causes the
readsystem call to fail with-EINVAL(?Invalid argument?). A nonnegative return
value represents the number of bytes successfully read (the return value is a
?signed size? type, usually the native integer type for the target platform)

ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
Sends data to the device. IfNULL, -EINVALis returned to the program calling the
writesystem call. The return value, if nonnegative, represents the number of
bytes successfully written.

loff_t (*llseek) (struct file *, loff_t, int);
Thellseek method is used to change the current read/write position in a file, and
the new position is returned as a (positive) return value. Theloff_tparameter is
a ?long offset? and is at least 64 bits wide even on 32-bit platforms. Errors are
signaled by a negative return value. If this function pointer isNULL, seek calls will
modify the position counter in thefilestructure (described in the section ?The
file Structure?) in potentially unpredictable ways.

int (*release) (struct inode *, struct file *);
This operation is invoked when thefilestructure is being released. Likeopen,
releasecan beNULL.
*
  */


  /* Shutdown function for accelerator
   * -----------------------------------
   *  Before accelerator shutdown, turn-off all the leds
  */
 static void accelerator_shutdown(struct platform_device *pdev)
 {
    iowrite32(0, base_addr);
 }

 /* Remove function for accelerator
  * ----------------------------------
  *  When accelerator module is removed, turn off all the leds first,
  *  release virtual address and the memory region requested.
  */
 static int accelerator_remove(struct platform_device *pdev)
 {
     accelerator_shutdown(pdev);

     /* Remove /proc/accelerator entry */
     remove_proc_entry(DRIVER_NAME, NULL);

     /* Release mapped virtual address */
     iounmap(base_addr);

     /* Release the region */
     release_mem_region(res-&gt;start, remap_size);

     return 0;
 }

 /* Device Probe function for accelerator
  * ------------------------------------
  *  Get the resource structure from the information in device tree.
  *  request the memory region needed for the controller, and map it into
  *  kernel virtual memory space. Create an entry under /proc file system
  *  and register file operations for that entry.
  */
 static int accelerator_probe(struct platform_device *pdev)
 {

     struct proc_dir_entry *accelerator_proc_entry;
     int ret = 0;
    printk(KERN_ALERT ""Probing\n"");
     res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
     if (!res) {
         dev_err(&amp;pdev-&gt;dev, ""No memory resource\n"");
         return -ENODEV;
     }

     remap_size = res-&gt;end - res-&gt;start + 1;
     if (!request_mem_region(res-&gt;start, remap_size, pdev-&gt;name)) {
         dev_err(&amp;pdev-&gt;dev, ""Cannot request IO\n"");
         return -ENXIO;
     }

     base_addr = ioremap(res-&gt;start, remap_size);
     if (base_addr == NULL) {
         dev_err(&amp;pdev-&gt;dev, ""Couldn't ioremap memory at 0x%08lx\n"",
             (unsigned long)res-&gt;start);
         ret = -ENOMEM;
         goto err_release_region;
     }

     accelerator_proc_entry = proc_create(DRIVER_NAME, 0, NULL,
                        &amp;proc_accelerator_operations);
     if (accelerator_proc_entry == NULL) {
         dev_err(&amp;pdev-&gt;dev, ""Couldn't create proc entry\n"");
         ret = -ENOMEM;
         goto err_create_proc_entry;
     }

     printk(KERN_INFO DRIVER_NAME "" probed at VA 0x%08lx\n"",
            (unsigned long) base_addr);
     printk(KERN_ALERT ""Goodbye, probe\n"");

     return 0;

  err_create_proc_entry:
     iounmap(base_addr);
  err_release_region:
     release_mem_region(res-&gt;start, remap_size);

     return ret;
 }

 /* device match table to match with device node in device tree */
 /*
 https://lwn.net/Articles/448502/
 */
 static const struct of_device_id accelerator_of_match[] = {
     {.compatible = ""PCA,bitSplitter""},
     {},
 };

 MODULE_DEVICE_TABLE(of, accelerator_of_match);

 /* platform driver structure for accelerator driver */
 /*
 Platform devices are represented by the struct, and is found in &lt;linux/platform_device.h&gt;
 at minimum probe() and remove() must be supplied, the others have to do with power management
 https://lwn.net/Articles/448499/
 */
 static struct platform_driver accelerator_driver = {
     .driver = {
            .name = DRIVER_NAME,
            .owner = THIS_MODULE,
            .of_match_table = accelerator_of_match},
     .probe = accelerator_probe,
     .remove = accelerator_remove,
     .shutdown = accelerator_shutdown
};

 /* Register accelerator platform driver */
 /*
   Helper macro for drivers that don't do
 * anything special in module init/exit.  This eliminates a lot of
 * boilerplate.  Each module may only use this macro once, and
 * calling it replaces module_init() and module_exit()
 *
 * Platform drivers are for HW that will not dynamically come and go into a Linux system,
 * such as the video and audio controllers in a tablet.  In makes sense to statically pull
 * in those code necessary through the __initcall magic discussed above.
 *
 * http://henryomd.blogspot.com/2014/11/linux-kernel-startup.html
 */
 module_platform_driver(accelerator_driver);

 /* Module Informations */
 /*
 Discussed in 2.6 Preliminaries
 */
 MODULE_AUTHOR(""Digilent, Inc."");
 MODULE_LICENSE(""GPL"");
 MODULE_DESCRIPTION(DRIVER_NAME "": accelerator driver (Simple Version)"");
 MODULE_ALIAS(DRIVER_NAME);
</code></pre>
"
"<p>I'm developing a Linux kernel module.I want to use <code>mmap</code> and <code>proc</code> filesystem to share memory between kernel and userspace.  I've implemented some parts but I don't know how to complete it.</p>

<p>I want to write something (<code>sk_buff</code>) in kernel module and read them in userspace (read <code>proc</code> file and save the file). What should I do? I don't know the meaning of <code>file_operations</code>; should I implement <code>fops.write</code> or something else?</p>

<p>Here is my code demo, (a module for Linux 3.16):
</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;linux/version.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/mm.h&gt;
#include &lt;linux/fs.h&gt;
#include &lt;linux/seq_file.h&gt;

#define PROC_MEMSHARE_DIR ""memshare""
#define PROC_MEMSHARE_INFO ""phymem_info""
#define PROC_MMAP_FILE ""mmap""

/* alloc one page. 4096 bytes */
#define PAGE_ORDER 0
/* this value can get from PAGE_ORDER */
#define PAGES_NUMBER 1

struct proc_dir_entry *proc_memshare_dir ;
unsigned long kernel_memaddr = 0;
unsigned long kernel_memsize= 0;

int proc_mmap(struct file *filp, struct vm_area_struct *vma)
{
    unsigned long page;
    page = virt_to_phys((void*)kernel_memaddr) &gt;&gt; PAGE_SHIFT;

    if (remap_pfn_range(vma, vma-&gt;vm_start, page, (vma-&gt;vm_end - vma-&gt;vm_start),
                vma-&gt;vm_page_prot))
    {
        printk(""remap failed..."");
        return -1;
    }
    vma-&gt;vm_flags |= (VM_DONTDUMP|VM_DONTEXPAND);
    printk(""remap_pfn_rang page:[%lu] ok.\n"", page);
    return 0;
}

static int proc_show_meminfo(struct seq_file *m, void *v) {
    seq_printf(m, ""%08lx %lu\n"",__pa(kernel_memaddr), kernel_memsize);
    return 0;
}

static int proc_open_meminfo(struct inode *inode, struct  file *file) {
    return single_open(file, proc_show_meminfo, NULL);
}

static const struct file_operations read_phymem_info_fops = {
    .owner = THIS_MODULE,
    .open = proc_open_meminfo,
    .read = seq_read,
    .llseek = seq_lseek,
    .release = seq_release
};

static const struct file_operations proc_mmap_fops = {
    .owner = THIS_MODULE,
    .mmap = proc_mmap
};

static int __init init(void)
{
    /* build proc dir ""memshare""and two proc files: phymem_addr, phymem_size in the dir */
    proc_memshare_dir = proc_mkdir(PROC_MEMSHARE_DIR, NULL);
    proc_create_data(PROC_MEMSHARE_INFO, 0, proc_memshare_dir, &amp;read_phymem_info_fops,NULL);
    proc_create_data(PROC_MMAP_FILE, 0, proc_memshare_dir, &amp;proc_mmap_fops,NULL);

    /* alloc one page */
    kernel_memaddr =__get_free_pages(GFP_KERNEL, PAGE_ORDER);
    if (!kernel_memaddr) {
        printk(""Allocate memory failure!/n"");
    } else {
        SetPageReserved(virt_to_page(kernel_memaddr));
        kernel_memsize = PAGES_NUMBER * PAGE_SIZE;
        printk(""Allocate memory success!. The phy mem addr=%08lx, size=%lu\n"", __pa(kernel_memaddr), kernel_memsize);
    }
    return 0;
}

static void __exit fini(void)
{
    printk(""The content written by user is: %s\n"", (unsigned char*) kernel_memaddr);
    ClearPageReserved(virt_to_page(kernel_memaddr));
    free_pages(kernel_memaddr, PAGE_ORDER);
    remove_proc_entry(PROC_MEMSHARE_INFO, proc_memshare_dir);
    remove_proc_entry(PROC_MEMSHARE_DIR, NULL);
    return;
}
module_init(init);
module_exit(fini);
MODULE_LICENSE(""GPL"");
MOUDLE_AUTHOR(""wack"");
MODULE_DESCRIPTION(""Kernel memory share module."");
</code></pre>

<p>And here is the userspace program:</p>

<pre class=""lang-c prettyprint-override""><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/mman.h&gt;

int main(int argc, char *argv[])
{
    char *str ;
    if (argc != 2) {
        printf(""Usage: %s string\n"", argv[0]);
        return 0;
    }

    unsigned long phymem_addr, phymem_size;
    char *map_addr;
    char s[256];
    int fd;

    /*get the physical address &amp; size of allocated memory in kernel*/
    fd = open(""/proc/memshare/phymem_info"", O_RDONLY);
    if (fd &lt; 0) {
        printf(""cannot open file /proc/memshare/phymem_info\n"");
        return 0;
    }
    read(fd, s, sizeof(s));
    sscanf(s, ""%lx %lu"", &amp;phymem_addr,&amp;phymem_size);
    close(fd);

    printf(""phymem_addr=%lx, phymem_size=%lu\n"", phymem_addr, phymem_size);
    /*memory map*/
    int map_fd = open(""/proc/memshare/mmap"",  O_RDWR|O_SYNC);
    if (map_fd &lt; 0) {
        printf(""cannot open file /proc/memshare/mmap\n"");
        return -1;
    }
    map_addr = mmap(NULL, phymem_size, PROT_READ|PROT_WRITE, MAP_SHARED, map_fd, phymem_addr);
    if (map_addr ==MAP_FAILED) {
        perror(""mmap"");
        printf(""MAP_FAILED : %s"",map_addr);
        close(map_fd);
        return -1;
    } else{
        printf(""mmap: %s \n"",map_addr);
        printf(""addr: %p \n"",map_addr);
        printf(""addr: %d \n"",*map_addr);
    }
    //memcpy(map_addr, argv[1],sizeof(argv));
    strcpy(map_addr,argv[1]);
    memcpy(str,map_addr,256);
    printf(""str is :%s \n"",str);
    int ret = munmap(map_addr, phymem_size);
    if (ret) {
        printf(""munmap failed:%d \n"",ret);
    }
    close(map_fd);
    return 0;
}
</code></pre>
"
"<p>Not able to receive the buffer using fread() from a userland function. The driver is using copy_to_user() to pass the info. Are there any blatant errors in the way that I am implementing this?</p>

<p>The error can be seen in the    printf(""%s\n"",buffer);  statement from the userland code.</p>

<p>Userland code:</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

/*
## Slave Register Descriptions
## reset = 0x4
## en    = 0x8
## input = 0xc
## outlo = 0x10
## outhi = 0x14
*/

void readAccelerator(unsigned int * outlo, unsigned int * outhi);
int writeAccelerator(unsigned int *data, char *address);


int main (int argc, char *argv[])
{
    unsigned int *data;
    unsigned int *result;
    char * RESET_ADDR = ""1"";
    char * EN_ADDR = ""2"";
    char * INPUT_ADDR = ""3"";
    unsigned int * outlo = 0;
    unsigned int * outhi = 0;

    data = 0xFFEF;

    writeAccelerator(1, RESET_ADDR);
    writeAccelerator(0, RESET_ADDR);
    writeAccelerator(data, INPUT_ADDR);
    writeAccelerator(1, EN_ADDR);
    writeAccelerator(0, EN_ADDR);
    readAccelerator(&amp;outlo, &amp;outhi);

    printf(""input:%04x outLo = %02x, outHi = %02x\n"", data, outlo, outhi);

    return 0;

}


void readAccelerator(unsigned int * outlo, unsigned int * outhi)
{
    char * buffer[10];
    size_t size = 1;
    size_t nitems = 10;
    FILE* fp;

    fp = fopen(""/proc/accelerator"",""r"");
    if (fp == NULL)
    {
        printf(""Cannot open for read\n"");
        return -1;
    }
    /*
    Expect return format:
    0x00, 0x00
    */
    fread(buffer, size, nitems, fp);
    fclose(fp);
    printf(""eh?\n"");
    printf(""%s\n"",buffer);
    return;
}

int writeAccelerator(unsigned int *data, char *address)
{
    FILE* fp;
    char str[30];

    sprintf(str, ""0x%08x "", data); //data
    strcat(str, address);      //address

    //printf(""input data: %s"", str);

    fp = fopen(""/proc/accelerator"",""w"");
    if (fp == NULL)
    {
        printf(""Cannot open for write\n"");
        return -1;
    }

    fputs(str, fp);
    fclose(fp);
}
</code></pre>

<p>Device Driver code:</p>

<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;asm/uaccess.h&gt;    /* Needed for copy_from_user */
#include &lt;asm/io.h&gt;         /* Needed for IO Read/Write Functions */
#include &lt;linux/proc_fs.h&gt;  /* Needed for Proc File System Functions */
#include &lt;linux/seq_file.h&gt; /* Needed for Sequence File Operations */
#include &lt;linux/platform_device.h&gt;  /* Needed for Platform Driver Functions */
#include &lt;linux/slab.h&gt; /*for kmalloc and kfree */
#include &lt;linux/vmalloc.h&gt;

/* Define Driver Name */
#define DRIVER_NAME ""accelerator""


unsigned long *base_addr;   /* Vitual Base Address */
struct resource *res;       /* Device Resource Structure */
unsigned long remap_size;   /* Device Memory Size */

/* Write operation for /proc/accelerator
 * -----------------------------------
 *  When user cat a string to /proc/accelerator file, the string will be stored in
 *  const char __user *buf. This function will copy the string from user
 *  space into kernel space, and change it to an unsigned long value.
 *  It will then write the value to the register of accelerator controller,
 *  and turn on the corresponding LEDs eventually.
 */

 static ssize_t proc_accelerator_write(struct file *file, const char __user * buf,
                  size_t count, loff_t * ppos)
  {
      //Allocate
      char * myaddr_phrase;
      char * pEnd;
      char *buffer = vzalloc(count);
      myaddr_phrase = buffer;
      u32 myaddr_value;
       u32 myreg_value;

      //Copy Data
      if (count &lt; 22) {
          if (copy_from_user(myaddr_phrase, buf, count))
              return -EFAULT;

         //myaddr_phrase[count] = '\0';
     //printk(""count = %d\n"", count);
     //printk(""%s\n"",myaddr_phrase);
      }
    // Use strtol to parse input
    /* http://www.cplusplus.com/reference/cstdlib/strtol/ */
         myaddr_value = simple_strtoul(myaddr_phrase, &amp;pEnd, 0);
     //printk(""myaddr_value = %08x\n"", myaddr_value);
     pEnd = strsep(&amp;myaddr_phrase,"" "");
     myreg_value = simple_strtoul(myaddr_phrase,&amp;pEnd ,0);
     //printk(""myreg_value = %08x\n"", myreg_value);
     //printk(""final_value = %08x\n"", (base_addr + (myreg_value)));
     //printk(""mult_val = %08x\n"", (myreg_value));
     wmb();
     iowrite32(myaddr_value, (base_addr + (myreg_value)));
     printk(""WRITE: Reg %d; value 0x%08x\n"",myreg_value,myaddr_value);
     return count;
 }

 static ssize_t proc_accelerator_read(struct file *file, const char __user * buf,
                  size_t count, loff_t * ppos)
  {
     printk(""READ: "");
     u32 out_lo;
     u32 out_hi;
     int OUTLO_ADDR = 4;
     int OUTHI_ADDR = 5;
     u32 len = 10;
     char * output;
     //char * buffer;
     out_lo = ioread32(base_addr+OUTLO_ADDR);
     out_hi = ioread32(base_addr+OUTHI_ADDR);
     //seq_printf(p, ""0x%02x, 0x%02x"", out_lo, out_hi);
     sprintf(output, ""0x%02x, 0x%02x"", out_lo, out_hi); // length = 10
     printk(""OUTPUT = %s\n"",output);
     if(copy_to_user(buf, &amp;output, len))
        return -EFAULT;
     // returning total length of 11!!!
     printk(""exiting read...\n"");
     return 0;
 }


 /* Callback function when opening file /proc/accelerator
  * ------------------------------------------------------
  *  Read the register value of accelerator controller, print the value to
  *  the sequence file struct seq_file *p. In file open operation for /proc/accelerator
  *  this callback function will be called first to fill up the seq_file,
  *  and seq_read function will print whatever in seq_file to the terminal.
  */

 static int proc_accelerator_show(struct seq_file *p, void *v)
 {
     u32 out_lo;
     u32 out_hi;
     int OUTLO_ADDR = 4;
     int OUTHI_ADDR = 5;
     char * output;
     char * buffer;
     out_lo = ioread32(base_addr+OUTLO_ADDR);
     out_hi = ioread32(base_addr+OUTHI_ADDR);
     seq_printf(p, ""0x%02x, 0x%02x"", out_lo, out_hi);
     sprintf(output, ""0x%02x, 0x%02x"", out_lo, out_hi);
     //copy_to_user(*buffer, output, 11);
     // returning total length of 14!!!

     return 0;
 }

 /* Open function for /proc/accelerator
   * ------------------------------------
   *  When user want to read /proc/accelerator (i.e. cat /proc/accelerator), the open function
   *  will be called first. In the open function, a seq_file will be prepared and the
   *  status of accelerator will be filled into the seq_file by proc_accelerator_show function.
   *
   *p 69
    int (*open) (struct inode *, struct file *);
    Though this is always the first operation performed on the device file, the driver
    is not required to declare a corresponding method. If this entry is NULL, opening
    the device always succeeds, but your driver isn?t notified.

    Open described on p76
   */
 static int proc_accelerator_open(struct inode *inode, struct file *file)
  {
      unsigned int size = 16;
      char *buf;
      struct seq_file *m;
      int res;

      buf = (char *)kmalloc(size * sizeof(char), GFP_KERNEL);
      if (!buf)
          return -ENOMEM;

      res = single_open(file, proc_accelerator_show, NULL);

      if (!res) {
          m = file-&gt;private_data;
          m-&gt;buf = buf;
          m-&gt;size = size;
      } else {
          kfree(buf);
      }

      return res;
  }

  /* File Operations for /proc/accelerator */
  static const struct file_operations proc_accelerator_operations = {
      .open = proc_accelerator_open,
     // .read =  seq_read,
      .read = proc_accelerator_read,
      .write = proc_accelerator_write,
      .llseek = seq_lseek,
      .release = single_release
  };
  /*
int (*open) (struct inode *, struct file *);
Though this is always the first operation performed on the device file, the driver
is not required to declare a corresponding method. If this entry is NULL, opening
the device always succeeds, but your driver isn?t notified.

ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
Used to retrieve data from the device. A null pointer in this position causes the
readsystem call to fail with-EINVAL(?Invalid argument?). A nonnegative return
value represents the number of bytes successfully read (the return value is a
?signed size? type, usually the native integer type for the target platform)

ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
Sends data to the device. IfNULL, -EINVALis returned to the program calling the
writesystem call. The return value, if nonnegative, represents the number of
bytes successfully written.

loff_t (*llseek) (struct file *, loff_t, int);
Thellseek method is used to change the current read/write position in a file, and
the new position is returned as a (positive) return value. Theloff_tparameter is
a ?long offset? and is at least 64 bits wide even on 32-bit platforms. Errors are
signaled by a negative return value. If this function pointer isNULL, seek calls will
modify the position counter in thefilestructure (described in the section ?The
file Structure?) in potentially unpredictable ways.

int (*release) (struct inode *, struct file *);
This operation is invoked when thefilestructure is being released. Likeopen,
releasecan beNULL.
*
  */


  /* Shutdown function for accelerator
   * -----------------------------------
   *  Before accelerator shutdown, turn-off all the leds
  */
 static void accelerator_shutdown(struct platform_device *pdev)
 {
    iowrite32(0, base_addr);
 }

 /* Remove function for accelerator
  * ----------------------------------
  *  When accelerator module is removed, turn off all the leds first,
  *  release virtual address and the memory region requested.
  */
 static int accelerator_remove(struct platform_device *pdev)
 {
     accelerator_shutdown(pdev);

     /* Remove /proc/accelerator entry */
     remove_proc_entry(DRIVER_NAME, NULL);

     /* Release mapped virtual address */
     iounmap(base_addr);

     /* Release the region */
     release_mem_region(res-&gt;start, remap_size);

     return 0;
 }

 /* Device Probe function for accelerator
  * ------------------------------------
  *  Get the resource structure from the information in device tree.
  *  request the memory region needed for the controller, and map it into
  *  kernel virtual memory space. Create an entry under /proc file system
  *  and register file operations for that entry.
  */
 static int accelerator_probe(struct platform_device *pdev)
 {

     struct proc_dir_entry *accelerator_proc_entry;
     int ret = 0;
    printk(KERN_ALERT ""Probing\n"");
     res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
     if (!res) {
         dev_err(&amp;pdev-&gt;dev, ""No memory resource\n"");
         return -ENODEV;
     }

     remap_size = res-&gt;end - res-&gt;start + 1;
     if (!request_mem_region(res-&gt;start, remap_size, pdev-&gt;name)) {
         dev_err(&amp;pdev-&gt;dev, ""Cannot request IO\n"");
         return -ENXIO;
     }

     base_addr = ioremap(res-&gt;start, remap_size);
     if (base_addr == NULL) {
         dev_err(&amp;pdev-&gt;dev, ""Couldn't ioremap memory at 0x%08lx\n"",
             (unsigned long)res-&gt;start);
         ret = -ENOMEM;
         goto err_release_region;
     }

     accelerator_proc_entry = proc_create(DRIVER_NAME, 0, NULL,
                        &amp;proc_accelerator_operations);
     if (accelerator_proc_entry == NULL) {
         dev_err(&amp;pdev-&gt;dev, ""Couldn't create proc entry\n"");
         ret = -ENOMEM;
         goto err_create_proc_entry;
     }

     printk(KERN_INFO DRIVER_NAME "" probed at VA 0x%08lx\n"",
            (unsigned long) base_addr);
     printk(KERN_ALERT ""Goodbye, probe\n"");

     return 0;

  err_create_proc_entry:
     iounmap(base_addr);
  err_release_region:
     release_mem_region(res-&gt;start, remap_size);

     return ret;
 }

 /* device match table to match with device node in device tree */
 /*
 https://lwn.net/Articles/448502/
 */
 static const struct of_device_id accelerator_of_match[] = {
     {.compatible = ""PCA,bitSplitter""},
     {},
 };

 MODULE_DEVICE_TABLE(of, accelerator_of_match);

 /* platform driver structure for accelerator driver */
 /*
 Platform devices are represented by the struct, and is found in &lt;linux/platform_device.h&gt;
 at minimum probe() and remove() must be supplied, the others have to do with power management
 https://lwn.net/Articles/448499/
 */
 static struct platform_driver accelerator_driver = {
     .driver = {
            .name = DRIVER_NAME,
            .owner = THIS_MODULE,
            .of_match_table = accelerator_of_match},
     .probe = accelerator_probe,
     .remove = accelerator_remove,
     .shutdown = accelerator_shutdown
};

 /* Register accelerator platform driver */
 /*
   Helper macro for drivers that don't do
 * anything special in module init/exit.  This eliminates a lot of
 * boilerplate.  Each module may only use this macro once, and
 * calling it replaces module_init() and module_exit()
 *
 * Platform drivers are for HW that will not dynamically come and go into a Linux system,
 * such as the video and audio controllers in a tablet.  In makes sense to statically pull
 * in those code necessary through the __initcall magic discussed above.
 *
 * http://henryomd.blogspot.com/2014/11/linux-kernel-startup.html
 */
 module_platform_driver(accelerator_driver);

 /* Module Informations */
 /*
 Discussed in 2.6 Preliminaries
 */
 MODULE_AUTHOR(""Digilent, Inc."");
 MODULE_LICENSE(""GPL"");
 MODULE_DESCRIPTION(DRIVER_NAME "": accelerator driver (Simple Version)"");
 MODULE_ALIAS(DRIVER_NAME);
</code></pre>

<p><a href=""http://i.stack.imgur.com/Kg53M.png"" rel=""nofollow"">OUTPUT from userland and kern.log</a></p>
"
"<p>Why do I get the following error messages when building the Linux <code>/proc</code> file driver with <code>seq_file</code>?</p>

<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/seq_file.h&gt;

#define PROC_NAME ""iter""

MODULE_AUTHOR(""MS Chaudhari"");
MODULE_LICENSE(""GPL"");

/*
   This function is called at the beginning of a sequence.
    ie, when:
    - the /proc file is read (first time)
    - after the function stop (end of sequence)
*/
static void *my_seq_start(struct seq_file *s, loff_t *pos)
{
    static unsigned long counter = 0;

    // beginning a new sequence
    if (*pos == 0)
    {
        return &amp;counter;
    }
    else
    {
        *pos = 0;
        return NULL;
    }
}

/*
     This function is called after the beginning of a sequence.
     It's called untill the return is NULL (this ends the sequence).
*/
static void *my_seq_next(struct seq_file *s, void *v, loff_t *pos)
{
    unsigned long *tmp_v = (unsigned long *)v;
    (*tmp_v)++;
    (*pos)++;
    return NULL;
}

/*
     This function is called for each ""step"" of a sequence
*/

static int my_seq_show(struct seq_file *s, void *v)
{
    loff_t *spos = (loff_t *)v;

    seq_printf(s, ""%Ld\n"", *spos);
    return 0;
}

/*
        This structure gather ""function"" to manage the sequnce
*/

static struct seq_operation my_seq_ops =
{
    .start = my_seq_start,
    .next = my_seq_next,
    .stop = my_seq_stop,
    .show = my_seq_show
};

/*
     This function is called when the /proc file is open.
*/
static int my_open(struct inode *inode, struct file *file)
{
    return seq_open(file, &amp;my_seq_ops);
}

/*
    This structure gather ""function"" that manage the /proc file
*/
static struct file_operations fops =
{
    .owner   = THIS_MODULE,
    .open    = my_open,
    .read    = seq_read,
    .llseek  = seq_lseek,
    .release = seq_release
};


/*
    This function is called when the module is loaded
*/
int init_module(void)
{
    struct proc_dir_entry *entry;

    entry = proc_create(PROC_NAME, 0, NULL, &amp;fops);

//  entry = create_entry(PROC_NAME, 0, NULL);
    if (entry)
    {
        entry-&gt;proc_fops = &amp;my_file_ops;
    }

    return 0;
}

/*
     This function is called when the module is unloaded.
*/
void cleanup_module(void)
{
    remove_proc_entry(PROC_NAME, NULL);
}
</code></pre>

<p>And when i compile using <code>make</code> command, I got following errors.</p>

<pre><code>/home/radix/programing/DD/procSeq.c:61:15: error: variable ?my_seq_ops? has initializer but incomplete type
 static struct seq_operation my_seq_ops =
               ^
/home/radix/programing/DD/procSeq.c:63:2: error: unknown field ?start? specified in initializer
  .start = my_seq_start,
  ^
/home/radix/programing/DD/procSeq.c:63:2: warning: excess elements in struct initializer [enabled by default]
/home/radix/programing/DD/procSeq.c:63:2: warning: (near initialization for ?my_seq_ops?) [enabled by default]
/home/radix/programing/DD/procSeq.c:64:2: error: unknown field ?next? specified in initializer
  .next = my_seq_next,
  ^
/home/radix/programing/DD/procSeq.c:64:2: warning: excess elements in struct initializer [enabled by default]
/home/radix/programing/DD/procSeq.c:64:2: warning: (near initialization for ?my_seq_ops?) [enabled by default]
/home/radix/programing/DD/procSeq.c:65:2: error: unknown field ?stop? specified in initializer
  .stop = my_seq_stop,
  ^
/home/radix/programing/DD/procSeq.c:65:10: error: ?my_seq_stop? undeclared here (not in a function)
  .stop = my_seq_stop,
          ^
/home/radix/programing/DD/procSeq.c:65:2: warning: excess elements in struct initializer [enabled by default]
  .stop = my_seq_stop,
  ^
/home/radix/programing/DD/procSeq.c:65:2: warning: (near initialization for ?my_seq_ops?) [enabled by default]
/home/radix/programing/DD/procSeq.c:66:2: error: unknown field ?show? specified in initializer
  .show = my_seq_show
  ^
/home/radix/programing/DD/procSeq.c:67:1: warning: excess elements in struct initializer [enabled by default]
 };
 ^
/home/radix/programing/DD/procSeq.c:67:1: warning: (near initialization for ?my_seq_ops?) [enabled by default]
/home/radix/programing/DD/procSeq.c: In function ?my_open?:
/home/radix/programing/DD/procSeq.c:74:2: warning: passing argument 2 of ?seq_open? from incompatible pointer type [enabled by default]
  return seq_open(file, &amp;my_seq_ops);
  ^
In file included from /home/radix/programing/DD/procSeq.c:4:0:
include/linux/seq_file.h:98:5: note: expected ?const struct seq_operations *? but argument is of type ?struct seq_operation *?
 int seq_open(struct file *, const struct seq_operations *);
     ^
/home/radix/programing/DD/procSeq.c: In function ?init_module?:
/home/radix/programing/DD/procSeq.c:102:8: error: dereferencing pointer to incomplete type
   entry-&gt;proc_fops = &amp;my_file_ops;
        ^
/home/radix/programing/DD/procSeq.c:102:23: error: ?my_file_ops? undeclared (first use in this function)
   entry-&gt;proc_fops = &amp;my_file_ops;
                       ^
/home/radix/programing/DD/procSeq.c:102:23: note: each undeclared identifier is reported only once for each function it appears in
make[2]: *** [/home/radix/programing/DD/procSeq.o] Error 1
make[1]: *** [_module_/home/radix/programing/DD] Error 2
make[1]: Leaving directory `/usr/src/linux-headers-3.13.0-24-generic'
make: *** [all] Error 2
</code></pre>

<p><strong>Sorry for my code is long.</strong></p>
"
"<p>I'm implementing a file in <code>/proc</code> which I'd like to be a little more file-like than usual.  In particular, I'd like to detect that someone is appending to the file and handle that correctly -- that is, I'd like to distinguish between someone doing</p>

<pre><code>echo value &gt; /proc/my_proc_file
</code></pre>

<p>and</p>

<pre><code>echo value &gt;&gt; /proc/my_proc_file
</code></pre>

<p>Like all write functions, mine is handed an offset as its fourth argument:</p>

<pre><code>ssize_t my_proc_write(struct file *file, const char __user *buf,
                                      size_t count, loff_t *offs)
</code></pre>

<p>But <code>*offs</code> is always 0.</p>

<p>When I set up my proc file, I'm specifying <code>seq_lseek</code> as the lseek function:</p>

<pre><code>struct file_operations my_proc_fops = {
    .open     = my_proc_open,
    .read     = seq_read,
    .write    = my_proc_write,
    .llseek   = seq_lseek,
};
</code></pre>

<p>Inspecting the source (in <code>fs/seq_file.c</code>), it looks like <code>seq_lseek</code> maintains <code>file-&gt;f_pos</code> appropriately, but when I look at <code>file-&gt;f_pos</code> in my write function, it's always 0, too.  (This may not be surprising, since appending usually means opening with <code>O_APPEND</code> which doesn't result in any explicit calls to lseek.)</p>

<p>Anyway, is there a way to do this?  Presumably these write functions wouldn't have been set up with offset pointer arguments if they weren't going to pass in useful, nonzero values from time to time...</p>
"
"<p>I have successfully created a pseudo Hello World Entry with a LKM.</p>

<p><a href=""http://pointer-overloading.blogspot.co.at/2013/09/linux-creating-entry-in-proc-file.html"" rel=""nofollow noreferrer"">http://pointer-overloading.blogspot.co.at/2013/09/linux-creating-entry-in-proc-file.html</a></p>

<p>However in my init function, i have one integer value which i want to return in ""cat /proc/example"". </p>

<p>Any Ideas how to do this in this code? </p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/seq_file.h&gt;

static int hello_proc_show(struct seq_file *m, void *v) {
  seq_printf(m, ""Hello proc!\n"");
  return 0;
}

static int hello_proc_open(struct inode *inode, struct  file *file) {
  return single_open(file, hello_proc_show, NULL);
}

static const struct file_operations hello_proc_fops = {
  .owner = THIS_MODULE,
  .open = hello_proc_open,
  .read = seq_read,
  .llseek = seq_lseek,
  .release = single_release,
};

static int __init hello_proc_init(void) {
  proc_create(""hello_proc"", 0, NULL, &amp;hello_proc_fops);
  return 0;
}

static void __exit hello_proc_exit(void) {
  remove_proc_entry(""hello_proc"", NULL);
}

MODULE_LICENSE(""GPL"");
module_init(hello_proc_init);
module_exit(hello_proc_exit);
</code></pre>
"
"<p>I'm trying to print virtual address of mem_map,physical address of mem_map and the number of struct page now.
so I tried running code of <a href=""https://stackoverflow.com/questions/31236757/print-virtual-address-of-mem-map-using-a-proc-file"">this article</a>,but it seemed like it didn't show correct address.
Could you tell me how I can fix this?</p>

<p>Below is the result of execution.</p>

<p>mem_map virt addr:           (null)
mem_map phys addr: 131941395333120
mem_map phys pages: 18446744072101367984 </p>

<p>I'm using Ubuntu12.04(64bit) and kernel version is 3.13.</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/kernel.h&gt;

#include &lt;asm/switch_to.h&gt;
#include &lt;linux/types.h&gt; /* size_t */
#include &lt;linux/fcntl.h&gt; /* O_ACCMODE */
#include &lt;asm/uaccess.h&gt; /* copy_from/to_user */
#include &lt;linux/fs.h&gt;       // for basic filesystem
#include &lt;linux/proc_fs.h&gt;  // for the proc filesystem
#include &lt;linux/seq_file.h&gt; // for sequence files
#include &lt;linux/mm.h&gt;

MODULE_LICENSE(""Dual BSD/GPL"");

static struct proc_dir_entry* proc_file;
struct page *mem_map;
EXPORT_SYMBOL(mem_map);

/* memory map functions */
int mem_map_show(struct seq_file *m, void *v);
//virtual_to_physical
inline unsigned long virt_to_phy(unsigned long addr);

inline unsigned long virt_to_phy(unsigned long addr){
    return __pa(addr);
}

char buf[300];

int mem_map_show(struct seq_file *m, void *v){

    int ret_val = 0;

    printk(KERN_INFO ""Proc file read \n"");
    ret_val =  seq_printf(m, ""mem_map virt addr: %p \n"", mem_map);
    ret_val += seq_printf(m, ""mem_map phys addr: %lu \n"",virt_to_phy((unsigned long)mem_map));
    ret_val += seq_printf(m, ""mem_map phys pages: %lu \n"", (long unsigned int)get_num_physpages);
    return ret_val;
}

static int mem_map_open(struct inode *inode, struct file *file){
    return single_open(file, mem_map_show, NULL);
}

struct file_operations mem_map_fops = {
    .owner = THIS_MODULE,
    .open = mem_map_open,
    .read = seq_read,
    .llseek = seq_lseek,
    .release = single_release,
};

static int __init mem_map_init(void){
    printk(KERN_INFO ""Loaded mem_map module\n"");
    proc_file = proc_create(""mem_map"", 0, NULL, &amp;mem_map_fops);
    if(!proc_file){
        printk(KERN_ALERT ""Error: Could not initialize /proc/mem_map"");
        return -ENOMEM;
    }
    return 0;
}

static void __exit mem_map_exit(void){
    remove_proc_entry(""mem_map"",NULL);
    printk(KERN_INFO ""Proc file unloaded \n"");
}


/* Declaration of the init and exit functions */
module_init(mem_map_init);
module_exit(mem_map_exit);
</code></pre>
"
"<p>I have this .c file that counts the system calls that linux calls.  These are just the main functions.  There were a couple of other things that I had to do, like create an array</p>

<p>unsigned long syscall_counts[345];</p>

<p>and then in another file with some assembly I incremented the array with the command:</p>

<pre><code>incl syscall_counts(,%eax,4)

// This function is called each time the application calls read(). It starts the      process of
// accumulating data to fill the application buffer. Return a pointer representing the current
// item. Return NULL if there are no more items.
//
static void *counter_seq_start(struct seq_file *s, loff_t *record_number)
{
  if (*record_number &gt; 347)
  return NULL;
return (void*)s;
}


// This function is called to compute the next record in the sequence given a pointer to the
// current record (in bookmark). It returns a pointer to the new record (essentially, an updated
// bookmark) and updates *record_number appropriately. Return NULL if there are no more items.
//
static void *counter_seq_next(struct seq_file *s, void *bookmark, loff_t *record_number)
{
   unsigned long *temp_b =(unsigned long*) bookmark;
   (*temp_b)++;
   if (*temp_b &gt; 345)
  return NULL;
   return (void*)temp_b;
}


// This function is called whenever an application buffer is filled (or when start or next
// returns NULL. It can be used to undo any special preparations done in start (such as
// deallocating auxillary memory that was allocated in start. In simple cases, you often do not
// need to do anything in this function.
//
static void  counter_seq_stop(struct seq_file *s, void *bookmark)
{

}


  // This function is called after next to actually compute the output. It can use various seq_...
 // printing functions (such as seq_printf) to format the output. It returns 0 if successful or a
 // negative value if it fails.
 //
 static int counter_seq_show(struct seq_file *s, void *bookmark)
 {
   loff_t *bpos = (loff_t *) bookmark;

   seq_printf(s, ""value: %Ld\n"", *bpos);

   return 0;
 }


 // Define the only file handling function we need.
 static int counter_open(struct inode *inode, struct file *file)
 {
    return seq_open(file, &amp;counter_seq_ops);
 }
</code></pre>

<p>my output is very strange:</p>

<p><img src=""https://i.stack.imgur.com/Z89LM.png"" alt=""sample code output""></p>

<p>Anyone have any idea where the issue is?</p>
"
"<p>Could you post some examples how to read list of meanings from <em>/proc</em> files?</p>

<pre><code>list_head* get_from_proc_file()
{
   struct file* file = fopen(""example"",""r"");
   seq_open(file, &amp;seq_ops);
   struct seq_file *p = file-&gt;private_data;
   READ LIST OF DATA?????
}
</code></pre>
"
"<p>Assume we have a blank computer without any OS and we are installing a Linux. Where in the kernel is the code that identifies the processors and the cores and get information about/from them?
This info eventually shows up in places like /proc/cpuinfo but how does the kernel get it in the first place?!</p>
"
"<p>I'm trying to open a proc file from user space so I can write to it but when I open it I get <code>Permission denied</code>.  Below is how I'm creating the proc file.  I've tried messing around with the permissions but I can't seem to get it to work.</p>

<pre><code>struct proc_dir_entry procDir = NULL;
struct proc_dir_entry infofile = NULL;

static struct seq_operations seqOps = {
    .start  = seqStart,
    .next   = seqNext,
    .stop   = seqStop,
    .show   = seqShow
};

static int open(struct inode *inode, struct file *fp)
{
    return seq_open(fp, &amp;seqOps);
}

static const struct file_operations fops = {
    .owner          = THIS_MODULE,
    .open           = open,
    .read           = read,
    .write          = write,
    .llseek         = lseek,
    .release        = single_release,
};

static int __init app_init(void)
{
procDir = proc_mkdir(""app"", NULL);

infofile = proc_create(""info"", 0, procDir, &amp;fops);
//infofile = proc_create(""info"", 777, procDir, &amp;fops);  // also tried this
}
</code></pre>

<p>Below is how I'm trying to opening it from the user space side.</p>

<pre><code>fopen(""/proc/app/info"", ""wb+"");
</code></pre>

<p>The modules loads fine and when I run <code>ls /proc/app/</code> the proc file structure is there.  Thanks and any help is appreciated!</p>
"
"<p>I wrote a simple code snippet to learn the usage of <code>/proc</code> file system. When I finished, everything is ok except the reading from this file causes an infinite loop.</p>

<p>Some codes show below:</p>

<pre><code>static struct seq_operations proc_seq_ops = {
    .start = proc_seq_start,
    .next = proc_seq_next,
    .stop = proc_seq_stop,
    .show = proc_seq_show,
};


int proc_seq_open(struct inode *inode, struct file *filp)
{
    return seq_open(filp, &amp;proc_seq_ops);
}

static void *proc_seq_start(struct seq_file *s_file, loff_t *pos)
{
    PDEBUG(""seq file start\n"");
    if (list_empty(&amp;store_list_head))
        return NULL;
    return list_first_entry(&amp;store_list_head, struct store_node,       list);
}

static void *proc_seq_next(struct seq_file *s_file, void *v, loff_t *pos)
{
    void *tmp = NULL;
    PDEBUG(""seq file next\n"");
    tmp = list_next_entry((struct store_node *)v, list);
    if (&amp;((struct store_node *)tmp)-&gt;list == &amp;store_list_head) {
        PDEBUG(""seq next return NULL\n"");
        return NULL;
    }

    PDEBUG(""seq file now is returning %p\n"", tmp);
    return tmp;
}

static void proc_seq_stop(struct seq_file *s_file, void *v)
{
    PDEBUG(""seq stop\n"");
}

static int proc_seq_show(struct seq_file *s_file, void *v)
{
    PDEBUG(""%p -&gt; %s\n"", v, ((struct store_node *)v)-&gt;buf);
    seq_printf(s_file, ""%p -&gt; %s\n"", v, ((struct store_node *)v)-&gt;buf);
    return 0;
}
</code></pre>

<p>The data which will be printed is put in a list. In each invoking of <code>seq_next</code>, we travel to next node.</p>

<p>The structure of nodes is fairly simple:</p>

<pre><code>struct store_node {
    list_head list;
    char *buf;
};
</code></pre>

<p>When I use <code>cat</code> command to read this proc file and then check the output by <code>dmesg</code>, I get this:</p>

<pre><code>[  893.111027] proc-fs-iterator: seq file next
[  893.111028] proc-fs-iterator: seq next return NULL
[  893.111028] proc-fs-iterator: seq stop
[  893.111036] proc-fs-iterator: seq file start
[  893.111037] proc-fs-iterator: ffff88002f863dc0 -&gt; 1234

[  893.111038] proc-fs-iterator: seq file next
[  893.111039] proc-fs-iterator: seq next return NULL
[  893.111040] proc-fs-iterator: seq stop
[  893.111062] proc-fs-iterator: seq file start
[  893.111064] proc-fs-iterator: ffff88002f863dc0 -&gt; 1234

[  893.111065] proc-fs-iterator: seq file next
[  893.111066] proc-fs-iterator: seq next return NULL
[  893.111067] proc-fs-iterator: seq stop
</code></pre>

<p>Why it print infinitely? The <code>seq_stop</code> is actually executed!</p>
"
"<p>i'm implementing a kernel module. using several techniques.
1 of them is to give read/write to different module variables.
i was able to read/write all variables except the list i have in my module.
the linked list:</p>

<pre><code>    static struct node {
        struct list_head list;
        unsigned int x;
        struct tm time;
    };
</code></pre>

<p>i would like to have a corresponding file in debugfs that will print the full list.
i tried all the 'simple' read functions , but none of them actually work.. :(</p>
"
"<p>I am using hadoop 1.0.3 (I can't really upgrade right now,Thats for later. )
I have around 100 images in my HDFS and I am trying to combine them into a single sequencefile ( default no compression etc.. )</p>

<p>here's my code:</p>

<pre><code>            FSDataInputStream  in = null;
                BytesWritable value = new BytesWritable();
                Text key = new Text();
                Path inpath = new Path(fs.getHomeDirectory(),""/user/hduser/input"");
                Path seq_path = new Path(fs.getHomeDirectory(),""/user/hduser/output/file.seq"");
                FileStatus[] files = fs.listStatus(inpath);
                SequenceFile.Writer writer = null;
                for( FileStatus fileStatus : files){
                          inpath = fileStatus.getPath();
                try {

                            in =  fs.open(inpath);
                            byte bufffer[] = new  byte[in.available()];
                            in.read(bufffer);
                            writer = SequenceFile.createWriter(fs,conf,seq_path,key.getClass(),value.getClass());
                            writer.append(new Text(inpath.getName()), new BytesWritable(bufffer));



                }catch (Exception e) {
                    System.out.println(""Exception MESSAGES = ""+e.getMessage());
                    e.printStackTrace();
                }}
</code></pre>

<p>This just goes through all the files in input/ and one by one appends them.
<strong>HOWEVER</strong> this just overwrites my sequence file instead of appending it , I see only the last image in sequencefile. </p>

<p><strong>NOTE</strong> I am not closing the writer before the for loop ends , can anyone help me with this please.
I am not sure How can I append the images?</p>
"
"<p><strong>I'm trying to read the contents of a file.</strong>  </p>

<p>In Python, it would be a one liner:</p>

<pre><code>seq_file = open('/some/local/file-path/on/computer.txt','r').read()
print seq_file
</code></pre>

<p>How can you write a one-liner in Swift to do the same thing? </p>

<p>My swift code to open a file (only works in terminal not in Playground):</p>

<pre><code>let seq_path = ""/some/local/file-path/on/computer.txt""
let file_manager = NSFileManager.defaultManager()
let data: NSData = file_manager.contentsAtPath(seq_path)!
let seq_file = NSString(data: data, encoding: NSUTF8StringEncoding)
print(seq_file)
</code></pre>

<p><strong>I'm not sure why reading is so much more complicated in Swift.  If someone would like to explain that would be extremely helpful.<br>
I've read about the advantages of Swift...If it's so new and powerful, why would they make such a simple task so complicated?</strong> </p>

<p><em>Background (if anyone is interested):
Undergrad in Biology, started learning Python in 2012 as my first programming language.  Use it to analyze biological data to this day.  Now I'm a graduate student and I've been getting a lot more interested in Computer Science over the years.  I would like to start writing programs for OSX and iOS and I thought a good way to learn the language was rewrite all my algorithms in Swift.</em> </p>
"
"<p>I want to parse <code>/proc/net/tcp/</code>, but is it safe? </p>

<p>How should I open and read files from <code>/proc/</code> and not be afraid, that some other process (or the OS itself) will be changing it in the same time?</p>
"
"<p>I'm trying to use <a href=""http://sphinxsearch.com/"" rel=""nofollow"">Sphinx Search Server</a> to index a really huge file (around 14gb).
The file is whitespace separated, one entry per line.</p>

<p>To be able to use it with Sphinx, I need to provide a xml file to the Sphinx server.
How can I do it without killing my computer ?</p>

<p>What is the best strategy? Should I try to split the main file in several little files? What's the best way to do it?</p>

<p>Note: I'm doing it in Ruby, but I'm totally open to other hints.</p>

<p>Thanks for your time.</p>
"
"<h2>Background</h2>

<p>Found a strange kernel Oops, Googled a lot, found nothing.<br>
Background:<br></p>

<ul>
<li><p>The kernel version is 3.0.8</p></li>
<li><p>There are two process let's say p1, p2<br></p></li>
<li><p>p2 have lots of threads(about 30) <br></p></li>
<li><p>p1 continuously calls system(pidof(""name of p1""))<br></p></li>
</ul>

<p>The kernel may Oops after running for a few days. the primary reason I found is that <a href=""http://lxr.linux.no/linux+v3.10.9/arch/arm/kernel/stacktrace.c#L24"" rel=""nofollow"">unwind_frame</a> got a strange frame->fp(0xFFFFFFFF) from <a href=""http://lxr.linux.no/linux+v3.10.9/arch/arm/kernel/process.c#L408"" rel=""nofollow"">get_wchan</a> <br>
When executing this line</p>

<pre><code>frame-&gt;fp = *(unsigned long *)(fp - 12);
</code></pre>

<p>The CPU will try to access 0xFFFFFFF3, and cause a paging error.</p>

<h2>My question is:</h2>

<p>How on earth the fp register saved before context switch becomes 0xFFFFFFFF ?</p>

<p><br></p>

<h2>here is the CPU infomation</h2>

<pre><code># cat /proc/cpuinfo
Processor       : ARMv7 Processor rev 0 (v7l)
processor       : 0
BogoMIPS        : 1849.75

processor       : 1
BogoMIPS        : 1856.30

Features        : swp half thumb fastmult vfp edsp vfpv3 vfpv3d16
CPU implementer : 0x41
CPU architecture: 7
CPU variant     : 0x3
CPU part        : 0xc09
CPU revision    : 0
</code></pre>

<h2>Here is the Oops and pt registers:</h2>

<pre><code>[734212.113136] Unable to handle kernel paging request at virtual address fffffff3
[734212.113154] pgd = 826f0000
[734212.113175] [fffffff3] *pgd=8cdfe821, *pte=00000000, *ppte=00000000
[734212.113199] Internal error: Oops: 17 [#1] SMP
--------------cut--------------
[734212.113464] CPU: 1    Tainted: P             (3.0.8 #2)
[734212.113523] PC is at unwind_frame+0x48/0x68
[734212.113538] LR is at get_wchan+0x8c/0x298
[734212.113557] pc : [&lt;8003d120&gt;]    lr : [&lt;8003a660&gt;]    psr: a0000013
[734212.113561] sp : 845d1cc8  ip : 00000003  fp : 845d1cd4
[734212.113583] r10: 00000001  r9 : 00000000  r8 : 80493c34
[734212.113597] r7 : 00000000  r6 : 00000000  r5 : 83354960  r4 : 845d1cd8
[734212.113613] r3 : 845d1cd8  r2 : ffffffff  r1 : 80490000  r0 : 8049003f
[734212.113632] Flags: NzCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
[734212.113651] Control: 10c53c7d  Table: 826f004a  DAC: 00000015
</code></pre>

<h2>Here is the callstack:</h2>

<pre><code>[734212.117027] Backtrace:
[734212.117052] [&lt;8003d0d8&gt;] (unwind_frame+0x0/0x68) from [&lt;8003a660&gt;] (get_wchan+0x8c/0x298)
[734212.117079] [&lt;8003a5d4&gt;] (get_wchan+0x0/0x298) from [&lt;8011f700&gt;] (do_task_stat+0x548/0x5ec)
[734212.117099]  r4:00000000
[734212.117118] [&lt;8011f1b8&gt;] (do_task_stat+0x0/0x5ec) from [&lt;8011f7c0&gt;] (proc_tgid_stat+0x1c/0x24)
[734212.117158] [&lt;8011f7a4&gt;] (proc_tgid_stat+0x0/0x24) from [&lt;8011b7f0&gt;] (proc_single_show+0x54/0x98)
[734212.117196] [&lt;8011b79c&gt;] (proc_single_show+0x0/0x98) from [&lt;800e9024&gt;] (seq_read+0x1b4/0x4e4)
[734212.117215]  r8:845d1f08 r7:845d1f70 r6:00000001 r5:8ca89d20 r4:866ea540
[734212.117237] r3:00000000
[734212.117264] [&lt;800e8e70&gt;] (seq_read+0x0/0x4e4) from [&lt;800c8c54&gt;] (vfs_read+0xb4/0x19c)
[734212.117289] [&lt;800c8ba0&gt;] (vfs_read+0x0/0x19c) from [&lt;800c8e18&gt;] (sys_read+0x44/0x74)
[734212.117307]  r8:00000000 r7:00000003 r6:000003ff r5:7ea00818 r4:8ca89d20
[734212.117340] [&lt;800c8dd4&gt;] (sys_read+0x0/0x74) from [&lt;800393c0&gt;] (ret_fast_syscall+0x0/0x30)
[734212.117358]  r9:845d0000 r8:80039568 r6:7ea00c90 r5:0000000e r4:7ea00818
[734212.117388] Code: e3c10d7f e3c0103f e151000c 9afffff6 (e512100c)
[734212.113136] Unable to handle kernel paging request at virtual address fffffff3
[734212.113154] pgd = 826f0000
[734212.113175] [fffffff3] *pgd=8cdfe821, *pte=00000000, *ppte=00000000
[734212.113199] Internal error: Oops: 17 [#1] SMP
</code></pre>
"
"<p>Basically, for my OS class, I'm writing a kernel module that simulates an airport shuttle with 5 terminals. So far, I've been able to implement system calls and verify that they work properly. However, I'm trying to link these system calls into a module. For each kernel Stub and function when I try to make the module for insertion, it says it's undefined. Also, as a by product, the module won't insert when I run this command: <code>make; sudo insmod terminal.ko</code> due to an unknown symbol in the module, which is an error I've found little or none documentation on.</p>

<p>Here's the output when I try to make and insert it:</p>

<pre><code>make -C /lib/modules/`uname -r`/build/ M=`pwd` modules
make[1]: Entering directory `/home/taylor/OPSYS_P2/linux-3.16.4'
  Building modules, stage 2.
  MODPOST 1 modules
WARNING: ""STUB_issue_request"" [/home/taylor/OPSYS_P2/linux-3.16.4/opsyscall/module/terminal.ko] undefined!
WARNING: ""issue_request"" [/home/taylor/OPSYS_P2/linux-3.16.4/opsyscall/module/terminal.ko] undefined!
WARNING: ""STUB_stop_shuttle"" [/home/taylor/OPSYS_P2/linux-3.16.4/opsyscall/module/terminal.ko] undefined!
WARNING: ""stop_shuttle"" [/home/taylor/OPSYS_P2/linux-3.16.4/opsyscall/module/terminal.ko] undefined!
WARNING: ""STUB_start_shuttle"" [/home/taylor/OPSYS_P2/linux-3.16.4/opsyscall/module/terminal.ko] undefined!
WARNING: ""start_shuttle"" [/home/taylor/OPSYS_P2/linux-3.16.4/opsyscall/module/terminal.ko] undefined!
make[1]: Leaving directory `/home/taylor/OPSYS_P2/linux-3.16.4'
insmod: ERROR: could not insert module terminal.ko: Unknown symbol in module
</code></pre>

<p>Primary Module Code:</p>

<pre><code>#include &lt;linux/module.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/seq_file.h&gt;
#include &lt;linux/time.h&gt; // Time Lib

#include ""./syscall.h""

MODULE_LICENSE(""GPL"");

// Stubs for kernel module implementation of shuttle services
extern int ( * STUB_start_shuttle )( void );
extern int ( * STUB_stop_shuttle )( void );
extern int ( * STUB_issue_request )( char passenger_type, int initial_terminal, int destination_terminal );

static int terminal_show(struct seq_file *m, void *v) {

  seq_printf(m,""%s\n"", ""The Shuttle is out of service"");

  return 0;
}

static int terminal_open(struct inode *inode, struct  file *file) {
  return single_open(file, terminal_show, NULL);
}

static const struct file_operations terminal_fops = {
  .owner = THIS_MODULE,
  .open = terminal_open,
  .read = seq_read,
  .release = single_release,
};

/**
 * Terminal Init
 *      Sets up a proc file, sets syscall stubs correctly
 */
static int __init terminal_init(void) {
    proc_create(""terminal"", 0, NULL, &amp;terminal_fops);

    // Redirect stub syscalls to our implementation
    STUB_start_shuttle = &amp;start_shuttle;
    STUB_stop_shuttle = &amp;stop_shuttle;
    STUB_issue_request = &amp;issue_request;
  return 0;
}

/**
 * Terminal Exit
 *      Removes the proc file, tears down stubs
 */
static void __exit terminal_exit(void) {
    STUB_start_shuttle = NULL;
    STUB_stop_shuttle = NULL;
    STUB_issue_request = NULL;
  remove_proc_entry(""terminal"", NULL);
}

module_init(terminal_init);
module_exit(terminal_exit);
</code></pre>

<p>Here's the syscall.h file:</p>

<pre><code>#pragma once

#include &lt;linux/err.h&gt;
#include &lt;linux/kthread.h&gt;
#include &lt;linux/list.h&gt;
#include &lt;linux/sched.h&gt;
#include &lt;linux/time.h&gt;

// Prototype Declarations
int start_shuttle( void );
int stop_shuttle( void );
int issue_request( char passenger_type, int initial_terminal, int destination_terminal );
</code></pre>

<p>Here's the corresponding c file, syscall.c:</p>

<pre><code>#include ""syscalls.h""
/**
 * Start Shuttle - Syscall
 * Description: Starts the shuttle up in its own thread unless it is already running
 */
int start_shuttle( void ) {
    int result = 0;
    return result;
}

/**
 * Stop Shuttle - Syscall
 * Description: Tells the shuttle to stop unless it is already stopping
 */
int stop_shuttle( void ) {
    int result = 0;
    return result;
}

/**
 * Issue Request - Syscall
 * Description: Adds a passenger, if valid, into a chosen terminal with a desired
 *              destination
 */
int issue_request( char passenger_type, int initial_terminal, int destination_terminal ) {
    printk( KERN_DEBUG ""Shuttle Service: Invalid issue_request - passenger_type %c initial_terminal %d destination_terminal %d\n"",
        passenger_type, initial_terminal, destination_terminal );
    return 1;
}
</code></pre>

<p>Any and all help/advice would be awesome!</p>

<p>Running Ubuntu 14.04, kernel version 3.16.4</p>
"
"<p>I am writing a Kernel Module for Linux 3.13 where the procfile_read function prototype is defined as:</p>

<pre><code>static ssize_t procfile_read(struct file *file, char __user *buffer, size_t count, loff_t * data)
</code></pre>

<p>This is different from every resource I can find online, such as <a href=""http://linux.die.net/lkmpg/x769.html"" rel=""nofollow"">http://linux.die.net/lkmpg/x769.html</a>, where the function prototype was different for Linux 2.x</p>

<p>How can I set the end of file condition in the new procfile_read function?</p>
"
"<p>The <em>cpuinfo</em> module in linux kernel uses this code to get a pointer to the cpu:</p>

<pre><code>ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
{
    // (...)
    struct seq_file *m = file-&gt;private_data;
    void *p;
    // (...)
    p = m-&gt;op-&gt;start(m, &amp;pos);
</code></pre>

<p>And the <em>start</em> method is found in proc.c :</p>

<pre><code>static void *c_start(struct seq_file *m, loff_t *pos)
{
    *pos = cpumask_next(*pos - 1, cpu_online_mask);
    if ((*pos) &lt; nr_cpu_ids)
        return &amp;cpu_data(*pos);
    return NULL;
}
</code></pre>

<p>After the pointer to <code>void*</code> has been returned from it, it is next passed to <em>show</em> method:</p>

<pre><code>err = m-&gt;op-&gt;show(m, p);
</code></pre>

<p>which assigns the pointer into pointer to <em>cpuinfo_x86</em>:</p>

<pre><code>static int show_cpuinfo(struct seq_file *m, void *v)
{
    struct cpuinfo_x86 *c = v;
    unsigned int cpu;
    int i;

    cpu = c-&gt;cpu_index;
</code></pre>

<p>However if I did in my code (linux kernel module) something similar:</p>

<pre><code>    get_online_cpus();
    pos = kmalloc( sizeof( loff_t), GFP_KERNEL);
    *pos = 0;
    *pos = cpumask_next(*pos - 1, cpu_online_mask);
    if ( (*pos) &lt; nr_cpu_ids)
    {
         c = &amp;cpu_data(*pos);
         cpu = c-&gt;cpu_index;  // SIGSEGV !
    }
</code></pre>

<p>the pointer is incorrect (it points to something that might be valid address but I cannot access what it points to). The same thing happens if I use <code>for_each_online_cpu</code> macros:</p>

<pre><code>for_each_online_cpu( cpuid)
{
    c = &amp;cpu_data(cpuid);
</code></pre>

<p>Why do I get SIGSEGV? I know that file passed by <strong>vfs</strong> to <em>cpuinfo</em> is special, sequential file, but it doesn't seem to be related to <code>cpu_data</code> macro. As of now the only difference visible to me is that in the first case the pointer is passed to the function and then it is assigned inside that function, so we have a stack frame, etc. Is this related to optimizations?</p>

<p>If I do assignment in separate function it works:</p>

<pre><code>static void*
mpsrv_get_cpu_ptr( loff_t *pos)
{
    *pos = cpumask_next(*pos - 1, cpu_possible_mask);

    if ( (*pos) &lt; nr_cpu_ids)
        return &amp;cpu_data(*pos);

    return NULL;
}

static void
mpsrv_stat_cpu( struct mpsrv_cpu_info *cpu_info, void *v)
{
    struct cpuinfo_x86 *c = v;  // OK
    unsigned int cpu;

    cpu = c-&gt;cpu_index;         // OK
    // (...)
}

// code

    get_online_cpus();
    pos = cpu_n = 0;

    while ( ( p = mpsrv_get_cpu_ptr( &amp;pos)))
    {
        mpsrv_stat_cpu( cpu_info, p);

        ++cpu_n;
        ++pos;
    }

    put_online_cpus();
</code></pre>

<p>The kernel code in <em>cpuinfo.c</em> also returns a pointer to <em>cpuinfo_x86</em> obtained in separate function, <em>c_start()</em>.
Please let me know if some additional information is needed. Thank you.</p>
"
"<p>I'm trying to build a kernel module, but while compiling it in a make file I got some errors which I can't solve. This is the code for the module:</p>

<pre><code>#include &lt;linux/kernel.h&gt;
#include &lt;linux/version.h&gt;
#include &lt;linux/list.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/proc_fs.h&gt;
#include &lt;linux/uaccess.h&gt;

#include ""sar_main.h""

#define PROCFS_NAME ""sarlkm""

char procfs_buffer[PROCFS_MAX_SIZE];

static unsigned long procfs_buffer_size = 0;

struct proc_dir_entry *proc_file_entry;


int procfile_read(char *buffer, char **buffer_location, off_t offset, int buffer_length, int *eof, void *data){
    int ret;

    printk(KERN_INFO ""procfile_read (/proc/%s) called \n"",  PROCFS_NAME);

    if (offset &gt; 0){
        ret = 0;
    }
    else{
        copy_to_user(procfs_buffer, buffer, procfs_buffer_size);
        ret = procfs_buffer_size;
    }
    return ret;
}

int procfile_write(struct file *file, const char *buffer, unsigned long count, void *data){

    procfs_buffer_size = count;
    if (procfs_buffer_size &gt; PROCFS_MAX_SIZE){
        procfs_buffer_size = PROCFS_MAX_SIZE;
    }
    if ( copy_from_user(procfs_buffer, buffer, procfs_buffer_size)){
        return -EFAULT;
    }
    return procfs_buffer_size;
}

static const struct file_operations proc_file_ops = {
    .read = procfile_read,
    .write = procfile_write,
};


static int __init sar_init(void)
{
    proc_file_entry = proc_create(PROCFS_NAME, 0644, NULL, &amp;proc_file_ops);

    if (proc_file_entry == NULL){
        remove_proc_entry(PROCFS_NAME, NULL);
        printk(KERN_ALERT ""Error: Unable to create proc file"");
        return -ENOMEM;
    }


    printk(KERN_INFO ""proc/%s successfully created"", PROCFS_NAME);
    return 0;
}

static void __exit sar_cleanup(void)
{
    remove_proc_entry(PROCFS_NAME, NULL);
    printk(KERN_INFO ""proc/%s deleted"", PROCFS_NAME);
}

module_init(sar_init);
module_exit(sar_cleanup);

MODULE_AUTHOR(DRIVER_AUTHOR);
MODULE_DESCRIPTION(DRIVER_DESC);
MODULE_LICENSE(""GPL"");
</code></pre>

<p>So I get the error while defining the struct proc_file_ops. I haven't been able to find a definition for the read and write functions of proc_dir_entry, but I have found some examples on the web that have used the exact same statements that I've used. Can anybody explain why I get this warning and what to do about it please?</p>
"
"<p>I have created a file under proc to read at string but instead of using seq_file implementation I am able to read it using the ssize_t (*read) method in file_operations. Is this approach wrong?</p>

<p>Could anyone please explain in what situations I am better of using seq_file implementation?</p>

<pre><code>    ssize_t my_proc_read(struct file *file, char __user *buffer, size_t count, loff_t *offset)
    {
      printk(KERN_INFO ""loff_t *offset = %lld\n"", *offset);
      printk(KERN_INFO ""count = %lu\n"", count);

      /* comment below two lines and check what happens. If we don't return
         0 it means there is still some data and read is called repeatedly. */
      if((int)*offset &gt;= ARRAY_LEN)
        return 0;
      *offset += ARRAY_LEN;

  return sprintf(buffer, ""%s\n"", param);
}
</code></pre>

<p>Also in output I always get count to be 131072, why is that?</p>

<pre><code>[ 7317.855146] loff_t *offset = 131073
[ 7317.855149] count = 131072
</code></pre>
"
"<p>I am trying to understand the seq file interface of procfs. I have created a small kernel module to read/write from/to the proc entry. The module I wrote is:</p>

<pre><code>#define PROC_DIR_NAME ""driver/kernel_test_dir2""
#define KERNEL_DATA ""This is kernel test""

static struct proc_dir_entry *proc_entry_file = 0;
static struct proc_dir_entry *proc_dir = 0;

#define PROC_ENTRY_BUFFER_SIZE 64

struct proc_entry
{
    ssize_t buffer_length;
    char buffer[PROC_ENTRY_BUFFER_SIZE];
};

static int proc_entry_seq_show(struct seq_file *s, void *v)
{
    printk(KERN_INFO ""kernel_test:proc_entry_seq_show\n"");
    struct proc_entry* kmem = s-&gt;private;

    if(kmem)
    {
        printk(KERN_INFO ""kernel_test:proc_entry_seq_show:s-&gt;private=%x\n"",s-&gt;private);
        seq_printf(s, ""%s\n"",&amp;(kmem-&gt;buffer[0]));
    }
    return 0;
}

static int proc_entry_open(struct inode *inode, struct file *file)
{
    struct proc_entry* kmem = kmalloc(sizeof(struct proc_entry),GFP_KERNEL);
    return single_open(file,&amp;proc_entry_seq_show,(void*)kmem);
};

static int proc_entry_close(struct inode *inode, struct file *file)
{
    struct seq_file *s =  file-&gt;private_data;
    struct proc_entry* kmem = (struct proc_entry*)(s-&gt;private);
    kfree(kmem);
    return single_release(inode,file);
};

static ssize_t proc_entry_write(struct file *file, const char *buf,
size_t count, loff_t *ppos)
{
    ssize_t len=0;
    loff_t pos;
    struct seq_file* seqfile = (struct seq_file*)(file-&gt;private_data);

    printk(KERN_INFO ""kernel_test:proc_entry_write\n"");
    printk(KERN_INFO ""kernel_test:proc_entry_write:offset = %d, count=%d\n"",*ppos,count);

    if(seqfile)
    {
        printk(KERN_INFO ""kernel_test:proc_entry_write:seqfile\n"");
        struct proc_entry* kmem = (struct proc_entry*)(seqfile-&gt;private);
        if(kmem)
        {
            printk(KERN_INFO ""kernel_test:proc_entry_write:kmem\n"");
            pos = *ppos;
            if(pos&lt;0)
                return -EINVAL;
            if(count &gt; PROC_ENTRY_BUFFER_SIZE)
                count = PROC_ENTRY_BUFFER_SIZE;

            if(copy_from_user(&amp;(kmem-&gt;buffer[0]), buf, count))
                return -EFAULT;
            (*ppos) = pos + count;

            kmem-&gt;buffer_length = count;
            return count;
        }
        printk(KERN_INFO ""kernel_test:proc_entry_write:kmem does not exist!\n"");
    }
    printk(KERN_INFO ""kernel_test:proc_entry_write:seqfile does not exist!\n"");
    return -EFAULT;
}

static struct file_operations fops_proc_entry = {
    .open       = proc_entry_open,
    .read       = seq_read,
    .release    = proc_entry_close,
    .write      = proc_entry_write,
};

static int __init init_test_kernel(void) {
    int rv;
    proc_dir = proc_mkdir(PROC_DIR_NAME, NULL);
    if(proc_dir == NULL) {
        rv = -ENOMEM;
    }
    proc_entry_file = proc_create (""kernel_test_file"", S_IRUSR | S_IWUSR, proc_dir,&amp;fops_proc_entry);
    if(!proc_entry_file) {
        rv = -ENOMEM;
    }

    printk(KERN_INFO ""kernel_test: Kernel Test module started\n"");
    return 0;
}


// Cleanup module
static void __exit cleanup_test_kernel(void) {
    remove_proc_entry(""kernel_test_file"", proc_dir);
    remove_proc_entry(PROC_DIR_NAME,NULL);
    printk(KERN_INFO ""kernel_test: Kernel Test module stopped\n"");
}

module_init(init_test_kernel);
module_exit(cleanup_test_kernel);
</code></pre>

<p>I wrote a small program to test my kernel module, and the source code for the sample program is:</p>

<pre><code>#define BUFFER_DATA ""This is test kernel data by me""
#define MAX_BUFFER_SIZE 64

static char write_buffer[MAX_BUFFER_SIZE];
static char read_buffer[MAX_BUFFER_SIZE];

int main()
{
    int fd;
    int count=0;

    fd = open(""/proc/driver/kernel_test_dir2/kernel_test_file"",O_RDWR);
    if(fd&lt;0)
    {
        std::cout &lt;&lt;""Could not open file /proc/driver/kernel_test_dir2/kernel_test_file !""&lt;&lt;
        strerror(errno)&lt;&lt;std::endl;
        return -1;
    }

    sprintf(write_buffer,""%s"",BUFFER_DATA);
    std::cout &lt;&lt; ""Write Buffer to be written is - ""&lt;&lt;write_buffer&lt;&lt;std::endl;
    count = write(fd,write_buffer,strlen(write_buffer));
    std::cout &lt;&lt; ""The bytes requested to be written are - ""&lt;&lt;strlen(write_buffer) &lt;&lt;std::endl;
    if(count&lt;0)
    {
        std::cout&lt;&lt;""write error : "" &lt;&lt; strerror(errno)&lt;&lt;std::endl;
        return -1;
    }
    else if(count!=strlen(write_buffer))
    {
        std::cout&lt;&lt;""Wrote only ""&lt;&lt;count&lt;&lt;"" bytes, but was asked to write ""&lt;&lt;strlen(write_buffer)&lt;&lt;"" bytes""&lt;&lt;std::endl;
        return -1;
    }

    count = read(fd,read_buffer,MAX_BUFFER_SIZE);
    if(count &lt; 0)
    {
        std::cout&lt;&lt;""read error : "" &lt;&lt; strerror(errno)&lt;&lt;std::endl;
        return -1;
    }

    std::cout &lt;&lt; ""buffer read as - ""&lt;&lt;read_buffer&lt;&lt;std::endl;

    close(fd);
    return 0;
}
</code></pre>

<p>The problem I am facing is that write calls to the module somehow set the 'count' bytes in ""proc_entry_write()"" to 0 (zero).</p>

<p>The syslog messages for my sample application execution are:</p>

<pre><code>Jun 20 16:03:51 kernel: [356787.943092] kernel_test:proc_entry_write
Jun 20 16:03:51 kernel: [356787.943554] kernel_test:proc_entry_write:offset = 0, count=0
Jun 20 16:03:51 kernel: [356787.943944] kernel_test:proc_entry_write:seqfile
Jun 20 16:03:51 kernel: [356787.944344] kernel_test:proc_entry_write:kmem
Jun 20 16:03:51 kernel: [356787.944978] kernel_test:proc_entry_seq_show
Jun 20 16:03:51 kernel: [356787.945408] kernel_test:proc_entry_seq_show:s-&gt;private=ee600600
</code></pre>
"
"<p>In the book of <em>Linux Device Driver 3rd ed</em>, <code>/proc</code> file system is used as a output method to export the running state of a certain device driver. </p>

<p>However, in some circumstances, <code>/proc</code> file system is used as one interface to change the internal parameters of a driver module.</p>

<p>I googled a lot, and found some implementations on the Internet are too old that they used <code>create_proc_entry()</code> rather than <code>proc_create()</code>.</p>

<p>What's more, I'm prefer to implement this by <code>seq_file</code>(actually, I'm not sure is it possible). I checked the <code>seq_write()</code> function, and obtained nothing. </p>

<p>Can anyone show me an example to finish this mission? <code>seq_file</code> implementation is more preferred.</p>
"
"<p>I want to pass a structure to a function and store value in the structure's element. Here is my code.</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

typedef struct {
    uint32_t len;
    uint16_t *arr;
} seq;

void write_seq(seq *q, int val)
{
    // How to implement this function?

    uint16_t *tmp;
    tmp = (uint16_t *)malloc(sizeof(uint16_t));
    *tmp = val;

    *(q-&gt;arr + q-&gt;len) = *tmp;
    q-&gt;len += 1;

}

int main(int argc, char *argv[])
{
    seq q;
    q.len = 0;
    q.arr = NULL;
    int i;
    for (i = 0; i &lt; 10; i++) {
        write_seq(&amp;q, i);
    }

    printf(""length is %d\n"", q.len);
    for (i = 0; i &lt; q.len; i++) {
        printf(""%d\n"", *(q.arr+i));

    }

    return 0;
}
</code></pre>

<p>I want to write 0 to 9 to a memory block which q.arr points to.<br>
I don't want to use malloc in main(), since I don't know how many bytes I need before I call write_seq. I want to locate new memory every time when write_seq is called. Here's how output should look like.</p>

<pre><code>length is 10
0
1
2
3
4
5
6
7
8
9
</code></pre>

<p>My implementation of write_seq() would cause core dumped. I don't know how to fix it. Thank you.</p>
"
"<p>I have made a big edit in attempt to clarify what help I am asking for and to try to make the question appropriate for Stack Overflow.</p>

<p>The problem in general:  I have an existing library class which allows me to query a server for information.  That library class is widely used by a large amount of legacy software, so I am somewhat limited in the changes I can make to it.  Likewise, reimplementing it in a better fashion might not be time well spent.</p>

<p>The problem in specific:  I've create a simplified ""toy"" model of my approach below with 3 classes.  The real thing is more complex, as there are polymorphic variations, more functionality, error handling, etc.</p>

<p>In ""toy"" model code included below, <em>Gateway</em> is the existing library class.  I've tried to show how I would like to use it, with a result set and a way to access each member of the set.  The idea is similar to how a well-implemented database API might look, with a statement, result and row -- except in my case, what would be the statement class is hobbled by a poor design which includes part of the result functionality.</p>

<p>The toy example below will not compile as-is because of the following cyclical dependecy.  The <em>Gateway</em> class includes the <em>ResultSet</em> class and depends upon it, as it returns a <em>ResultSet</em> object.  The <em>ResultSet</em> class depends on the <em>Member</em> class, as it uses it to convert the data returned from the server into primitives (e.g. string).  But the <em>Member</em> class refers back to the <em>Gateway</em> class to access that data, and so there is a cycle.</p>

<p>I want to find a solution which will provide the <em>ResultSet</em> and <em>Member</em> functionality.  </p>

<p>For a simpler 2 class problem, I know a solution.  It is to create a superclass that one class derives from (is-a), and which the other class is composed of (has-a), such that both original classes depend on the third, and all is right with the world.  :-)</p>

<p>For my 3 class problem, for some reason I have been unable to wrap my head around how to refactor it to make it work.</p>

<pre><code>// Gateway.h
#include ""ResultSet.h""
class Gateway {
    ResultSet exec(string params);
};
// Gateway.cpp
ResultSet Gateway::exec(string p) { ... }

// ResultSet.h
#include ""Member.h""
class ResultSet {
    ResultSet();    // ctor
    int     index;
    bool    next();
    string  getCurrent(Member member);
};
// ResultSet.cpp
ResultSet::ResultSet() { index = 0; }
bool    ResultSet::next() { ++index &lt; length; }
string  ResultSet::getCurrent(Member member) { member.fetch(index) }

// Member.h
#include ""Gateway.h""
class Member {
    Gateway gateway;
    string  fetch(int i);
};
// Member.cpp
string Member::fetch(int i) { return gateway.sGet(i); }
</code></pre>

<p>// Example desired usage of the final API.
    main() {
        Gateway     gate;
        ResultSet   set;
        Member      member;</p>

<pre><code>    set = gate.exec(""..."");

    while (set.next()) {
        cout &lt;&lt; set.getCurrent(member) &lt;&lt; endl;
    }
}
</code></pre>
"
"<p>Consider the following recursive C function. </p>

<pre><code> void get (int n) {
    if (n&lt;1) return;
    get (n-1) ;
    get (n-3) ;
    printf (""%d"", n) ;
    }
</code></pre>

<p>If <code>get(6)</code> function is being called in <code>main()</code> then how many times will the <code>get()</code> function be invoked before returning to the main <code>0</code> ? </p>
"
"<p>I want to allocate memory for a struct that contains <code>std::vector</code>. After allocating it, I will <code>push_back</code> some data to it.
After all, I need to destroy my allocated struct. I want to know how can it be done with no memory corruption.</p>

<p>Here is my code:</p>

<pre><code>typedef struct my_struct_t{

    int a, b;
    vector&lt;unsigned&gt; vec;

}
} MYSTRUCT;


int main(int argc, const char * argv[])
{

    MYSTRUCT* ptr_s =  new MYSTRUCT;

    for(int i = 0 ; i &lt; 100 ; i++){
        ptr_s-&gt;vec.push_back(i);
    }
    ptr_s-&gt;vec.clear();
    delete ptr_s;

    return 0;
}
</code></pre>

<p>I tried to use <code>clear</code> as it is supposed to call destructor. But after <code>valgrind</code>-ing my code, there are still some blocks reachable. I also tried to deallocate vector using this:</p>

<p><code>vector&lt;unsigned&gt;().swap(ptr_s.vec)</code> </p>

<p>But with no success.</p>

<p>output of `valgrind':</p>

<pre><code>==52635== HEAP SUMMARY:
==52635==     in use at exit: 10,360 bytes in 5 blocks
==52635==   total heap usage: 147 allocs, 142 frees, 25,198 bytes allocated
==52635==
==52635== LEAK SUMMARY:
==52635==    definitely lost: 0 bytes in 0 blocks
==52635==    indirectly lost: 0 bytes in 0 blocks
==52635==      possibly lost: 0 bytes in 0 blocks
==52635==    still reachable: 10,360 bytes in 5 blocks
==52635==         suppressed: 0 bytes in 0 blocks
==52635== Reachable blocks (those to which a pointer was found) are not shown.
==52635== To see them, rerun with: --leak-check=full --show-leak-kinds=all
</code></pre>

<p>Thank you everyone in advance.</p>

<p><strong>update:</strong></p>

<p>I noticed that the source of memory corruption in my application is in somewhere else. So I added an update. Here is the new code:</p>

<pre><code>MYSTRUCT* ptr_s1 =  new MYSTRUCT;
MYSTRUCT* ptr_s2 =  new MYSTRUCT;

for(int i = 0 ; i &lt; 100 ; i++){
    ptr_s1-&gt;vec.push_back(i);
}


memcpy(ptr_s2 , ptr_s1, sizeof(*ptr_s1));

delete ptr_s1;
delete ptr_s2;  // here I get seg fault

return 0;
</code></pre>

<p>As soon as deleting <code>ptr_s2</code>, seg fault happens.</p>

<p><strong>Update</strong>: proper way, based on the accepted answer:</p>

<pre><code>typedef struct my_struct_t{

    int a, b;
    vector&lt;unsigned&gt; vec;
    inline my_struct_t operator=(const my_struct_t &amp;s ){
       a = s.a;
       b = s.b;
       vec = s.vec;
       return s;
    }
} MYSTRUCT;

MYSTRUCT* ptr_s1 =  new MYSTRUCT;
MYSTRUCT* ptr_s2 =  new MYSTRUCT;

for(int i = 0 ; i &lt; 100 ; i++){
    ptr_s1-&gt;vec.push_back(i);
}

// no memcpy
// memcpy(ptr_s2 , ptr_s1, sizeof(*ptr_s1));
*ptr_s2 = *ptr_s1;

delete ptr_s1;
delete ptr_s2;  // no more sget seg fault

return 0;
</code></pre>
"
"<p>I am using cppcheck for static analysis. To accelerate review process I want to set up cppcheck to look for some custom rules,
for example to check if geter functions defined as a const.</p>

<p>If anyone has experience in writing custom rules for cppcheck please can you provide some example to write custom rules?.</p>

<p>P.S I have done some research to find a tool which will allow me to write custom rules and make review process faster.
I have find these links about this topic</p>

<p><a href=""https://stackoverflow.com/questions/141498/what-open-source-c-static-analysis-tools-are-available"">What open source C++ static analysis tools are available?</a></p>

<p><a href=""https://stackoverflow.com/questions/97454/c-static-code-analysis-tool-on-windows"">C++ static code analysis tool on Windows</a></p>

<p><a href=""https://stackoverflow.com/questions/93260/a-free-tool-to-check-c-c-source-code-against-a-set-of-coding-standards"">A free tool to check C/C++ source code against a set of coding standards?</a></p>
"
"<p>I want to execute following command with <code>system()</code> function,</p>

<pre><code>awk -F [][] '/dB/ { print $2 }' &lt;(amixer sget Master) &gt; sound_level
</code></pre>

<p>It gives me the desired output when I write in the terminal.
But when I call this command with system function in C it gives me error.</p>

<p>My code is:</p>

<pre><code>#include&lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main()
{
        system(""awk -F [][] '/dB/ { print $2 }' &lt;(amixer sget Master) &gt; sound_level"");
        return 0;
}
</code></pre>

<p>It gives me the following error:</p>

<pre><code>sh: 1: Syntax error: ""("" unexpected
</code></pre>

<p>I have also tried:</p>

<pre><code>awk -F [][] '/dB/ { print $2 }' &lt; /(amixer sget Master /) &gt; sound_level
</code></pre>

<p>but it does not work.</p>

<p>Any help is appreciated.</p>
"
"<p>I am working with the linux kernel of android 6.0, where kernel version is 3.10. Now I mount a sdcard(file system of it is ext2) to it. Which function should I use if I wanna get the super block of this sdacrd? Is it sget in /fs/super.c?</p>

<pre><code>struct super_block *sget(struct file_system_type *type,
        int (*test)(struct super_block *,void *),
        int (*set)(struct super_block *,void *),
        int flags,
        void *data)
</code></pre>
"
"<p>I have a struct like so:</p>

<pre><code>typedef enum any_type{
    ANY_TYPE_CHAR,
    ANY_TYPE_UCHAR,
    ANY_TYPE_SHORT,
    ANY_TYPE_USHORT,
    ANY_TYPE_INT,
    ANY_TYPE_UINT,
    ANY_TYPE_LONG,
    ANY_TYPE_ULONG,
    ANY_TYPE_FLOAT,
    ANY_TYPE_DOUBLE,
} any_type;

typedef struct any{
    any_type type;
    union{
        char as_char;
        unsigned char as_uchar;
        short as_short;
        unsigned short as_ushort;
        int as_int;
        unsigned int as_uint;
        long as_long;
        unsigned long as_ulong;
        float as_float;
        double as_double;
    };
} any;
</code></pre>

<p>which represents a variable which is one of the types specified. There are four possible operations on these structs, which are addition, subtraction, multiplication and division.</p>

<p>My question is, is there an efficient way to do these operations on them without doing lots of if statements for every case? That would result in <code>4 * 10 * 10 = 400</code> <code>if</code>/<code>else if</code> statements for these four operations alone, which is certainly not efficient!</p>

<p>My code is in <code>C</code></p>

<p>Thanks in advance.</p>
"
"<p>I'm trying to compile <code>mem.c</code> module with a <code>CONFIG_STRICT_DEVMEM</code> disabled. The idea is to have a module that will allow me to access address space in <code>/dev/mem</code> above 1MB. Why? I'm doing some testing which requires access to this memory space. </p>

<p>I copied <code>mem.c</code> into my home directory, removed code that has access restriction and compiled it. However I'm getting the following warnings:</p>

<pre><code>WARNING: ""kmsg_fops"" [/home/user/projects/new_mem/mem.ko] undefined!
WARNING: ""tty_init"" [/home/user/projects/new_mem/mem.ko] undefined!
WARNING: ""phys_mem_access_prot"" [/home/user/projects/new_mem/mem.ko] undefined!
WARNING: ""xlate_dev_mem_ptr"" [/home/user/projects/new_mem/mem.ko] undefined!
WARNING: ""devmem_is_allowed"" [/home/user/projects/new_mem/mem.ko] undefined!
WARNING: ""splice_from_pipe"" [/home/user/projects/new_mem/mem.ko] undefined!
WARNING: ""shmem_zero_setup"" [/home/user/projects/new_mem/mem.ko] undefined!
make[1]: Leaving directory `/usr/src/linux-headers-4.4.0-34-generic'
</code></pre>

<p>My questions are:</p>

<p>Do I really have to compile every module that have these functions defined or there is another way to do it? If there is then what is it?</p>

<p>All I need need is to compile code to be able to access <code>/dev/mem</code>, I really don't need all the other modules. Short of removing unnecessary code from <code>mem.c</code> is there another way to remove this code?</p>

<p>Any help is appreciated.</p>
"
"<p>I'm trying to access an 24c256 eeprom content from user space in a am335x_starter_kit. </p>

<p>I dont have to add eeprom driver into kernel and make modifications in board.c file because board already uses eeprom to access some board configuration and Mac address information.</p>

<p>I just want to access eeprom content from user space. </p>

<p>I used read and write functions for character devices before but i2c platform devices doesnt have these functions.</p>

<pre><code>struct i2c_driver {
  unsigned int class;
  int (* attach_adapter) (struct i2c_adapter *);
  int (* probe) (struct i2c_client *, const struct i2c_device_id *);
  int (* remove) (struct i2c_client *);
  void (* shutdown) (struct i2c_client *);
  void (* alert) (struct i2c_client *, unsigned int data);
  int (* command) (struct i2c_client *client, unsigned int cmd, void *arg);
  struct device_driver driver;
  const struct i2c_device_id * id_table;
  int (* detect) (struct i2c_client *, struct i2c_board_info *);
  const unsigned short * address_list;
  struct list_head clients;
};
</code></pre>

<p>This is the eeprom driver. Board file uses it from kernel to get mac address and board configuration data.</p>

<pre><code>/*
 * at24.c - handle most I2C EEPROMs
 *
 * Copyright (C) 2005-2007 David Brownell
 * Copyright (C) 2008 Wolfram Sang, Pengutronix
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */
#include &lt;linux/kernel.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/mutex.h&gt;
#include &lt;linux/sysfs.h&gt;
#include &lt;linux/mod_devicetable.h&gt;
#include &lt;linux/log2.h&gt;
#include &lt;linux/bitops.h&gt;
#include &lt;linux/jiffies.h&gt;
#include &lt;linux/of.h&gt;
#include &lt;linux/i2c.h&gt;
#include &lt;linux/i2c/at24.h&gt;

/*
 * I2C EEPROMs from most vendors are inexpensive and mostly interchangeable.
 * Differences between different vendor product lines (like Atmel AT24C or
 * MicroChip 24LC, etc) won't much matter for typical read/write access.
 * There are also I2C RAM chips, likewise interchangeable. One example
 * would be the PCF8570, which acts like a 24c02 EEPROM (256 bytes).
 *
 * However, misconfiguration can lose data. ""Set 16-bit memory address""
 * to a part with 8-bit addressing will overwrite data. Writing with too
 * big a page size also loses data. And it's not safe to assume that the
 * conventional addresses 0x50..0x57 only hold eeproms; a PCF8563 RTC
 * uses 0x51, for just one example.
 *
 * Accordingly, explicit board-specific configuration data should be used
 * in almost all cases. (One partial exception is an SMBus used to access
 * ""SPD"" data for DRAM sticks. Those only use 24c02 EEPROMs.)
 *
 * So this driver uses ""new style"" I2C driver binding, expecting to be
 * told what devices exist. That may be in arch/X/mach-Y/board-Z.c or
 * similar kernel-resident tables; or, configuration data coming from
 * a bootloader.
 *
 * Other than binding model, current differences from ""eeprom"" driver are
 * that this one handles write access and isn't restricted to 24c02 devices.
 * It also handles larger devices (32 kbit and up) with two-byte addresses,
 * which won't work on pure SMBus systems.
 */

struct at24_data {
    struct at24_platform_data chip;
    struct memory_accessor macc;
    int use_smbus;

    /*
     * Lock protects against activities from other Linux tasks,
     * but not from changes by other I2C masters.
     */
    struct mutex lock;
    struct bin_attribute bin;

    u8 *writebuf;
    unsigned write_max;
    unsigned num_addresses;

    /*
     * Some chips tie up multiple I2C addresses; dummy devices reserve
     * them for us, and we'll use them with SMBus calls.
     */
    struct i2c_client *client[];
};

/*
 * This parameter is to help this driver avoid blocking other drivers out
 * of I2C for potentially troublesome amounts of time. With a 100 kHz I2C
 * clock, one 256 byte read takes about 1/43 second which is excessive;
 * but the 1/170 second it takes at 400 kHz may be quite reasonable; and
 * at 1 MHz (Fm+) a 1/430 second delay could easily be invisible.
 *
 * This value is forced to be a power of two so that writes align on pages.
 */
static unsigned io_limit = 128;
module_param(io_limit, uint, 0);
MODULE_PARM_DESC(io_limit, ""Maximum bytes per I/O (default 128)"");

/*
 * Specs often allow 5 msec for a page write, sometimes 20 msec;
 * it's important to recover from write timeouts.
 */
static unsigned write_timeout = 25;
module_param(write_timeout, uint, 0);
MODULE_PARM_DESC(write_timeout, ""Time (in ms) to try writes (default 25)"");

#define AT24_SIZE_BYTELEN 5
#define AT24_SIZE_FLAGS 8

#define AT24_BITMASK(x) (BIT(x) - 1)

/* create non-zero magic value for given eeprom parameters */
#define AT24_DEVICE_MAGIC(_len, _flags)         \
    ((1 &lt;&lt; AT24_SIZE_FLAGS | (_flags))      \
        &lt;&lt; AT24_SIZE_BYTELEN | ilog2(_len))

static const struct i2c_device_id at24_ids[] = {
    /* needs 8 addresses as A0-A2 are ignored */
    { ""24c00"", AT24_DEVICE_MAGIC(128 / 8, AT24_FLAG_TAKE8ADDR) },
    /* old variants can't be handled with this generic entry! */
    { ""24c01"", AT24_DEVICE_MAGIC(1024 / 8, 0) },
    { ""24c02"", AT24_DEVICE_MAGIC(2048 / 8, 0) },
    /* spd is a 24c02 in memory DIMMs */
    { ""spd"", AT24_DEVICE_MAGIC(2048 / 8,
        AT24_FLAG_READONLY | AT24_FLAG_IRUGO) },
    { ""24c04"", AT24_DEVICE_MAGIC(4096 / 8, 0) },
    /* 24rf08 quirk is handled at i2c-core */
    { ""24c08"", AT24_DEVICE_MAGIC(8192 / 8, 0) },
    { ""24c16"", AT24_DEVICE_MAGIC(16384 / 8, 0) },
    { ""24c32"", AT24_DEVICE_MAGIC(32768 / 8, AT24_FLAG_ADDR16) },
    { ""24c64"", AT24_DEVICE_MAGIC(65536 / 8, AT24_FLAG_ADDR16) },
    { ""24c128"", AT24_DEVICE_MAGIC(131072 / 8, AT24_FLAG_ADDR16) },
    { ""24c256"", AT24_DEVICE_MAGIC(262144 / 8, AT24_FLAG_ADDR16) },
    { ""24c512"", AT24_DEVICE_MAGIC(524288 / 8, AT24_FLAG_ADDR16) },
    { ""24c1024"", AT24_DEVICE_MAGIC(1048576 / 8, AT24_FLAG_ADDR16) },
    { ""at24"", 0 },
    { /* END OF LIST */ }
};
MODULE_DEVICE_TABLE(i2c, at24_ids);

/*-------------------------------------------------------------------------*/

/*
 * This routine supports chips which consume multiple I2C addresses. It
 * computes the addressing information to be used for a given r/w request.
 * Assumes that sanity checks for offset happened at sysfs-layer.
 */
static struct i2c_client *at24_translate_offset(struct at24_data *at24,
        unsigned *offset)
{
    unsigned i;

    if (at24-&gt;chip.flags &amp; AT24_FLAG_ADDR16) {
        i = *offset &gt;&gt; 16;
        *offset &amp;= 0xffff;
    } else {
        i = *offset &gt;&gt; 8;
        *offset &amp;= 0xff;
    }

    return at24-&gt;client[i];
}

static ssize_t at24_eeprom_read(struct at24_data *at24, char *buf,
        unsigned offset, size_t count)
{
    struct i2c_msg msg[2];
    u8 msgbuf[2];
    struct i2c_client *client;
    unsigned long timeout, read_time;
    int status, i;

    memset(msg, 0, sizeof(msg));

    /*
     * REVISIT some multi-address chips don't rollover page reads to
     * the next slave address, so we may need to truncate the count.
     * Those chips might need another quirk flag.
     *
     * If the real hardware used four adjacent 24c02 chips and that
     * were misconfigured as one 24c08, that would be a similar effect:
     * one ""eeprom"" file not four, but larger reads would fail when
     * they crossed certain pages.
     */

    /*
     * Slave address and byte offset derive from the offset. Always
     * set the byte address; on a multi-master board, another master
     * may have changed the chip's ""current"" address pointer.
     */
    client = at24_translate_offset(at24, &amp;offset);

    if (count &gt; io_limit)
        count = io_limit;

    switch (at24-&gt;use_smbus) {
    case I2C_SMBUS_I2C_BLOCK_DATA:
        /* Smaller eeproms can work given some SMBus extension calls */
        if (count &gt; I2C_SMBUS_BLOCK_MAX)
            count = I2C_SMBUS_BLOCK_MAX;
        break;
    case I2C_SMBUS_WORD_DATA:
        count = 2;
        break;
    case I2C_SMBUS_BYTE_DATA:
        count = 1;
        break;
    default:
        /*
         * When we have a better choice than SMBus calls, use a
         * combined I2C message. Write address; then read up to
         * io_limit data bytes. Note that read page rollover helps us
         * here (unlike writes). msgbuf is u8 and will cast to our
         * needs.
         */
        i = 0;
        if (at24-&gt;chip.flags &amp; AT24_FLAG_ADDR16)
            msgbuf[i++] = offset &gt;&gt; 8;
        msgbuf[i++] = offset;

        msg[0].addr = client-&gt;addr;
        msg[0].buf = msgbuf;
        msg[0].len = i;

        msg[1].addr = client-&gt;addr;
        msg[1].flags = I2C_M_RD;
        msg[1].buf = buf;
        msg[1].len = count;
    }

    /*
     * Reads fail if the previous write didn't complete yet. We may
     * loop a few times until this one succeeds, waiting at least
     * long enough for one entire page write to work.
     */
    timeout = jiffies + msecs_to_jiffies(write_timeout);
    do {
        read_time = jiffies;
        switch (at24-&gt;use_smbus) {
        case I2C_SMBUS_I2C_BLOCK_DATA:
            status = i2c_smbus_read_i2c_block_data(client, offset,
                    count, buf);
            break;
        case I2C_SMBUS_WORD_DATA:
            status = i2c_smbus_read_word_data(client, offset);
            if (status &gt;= 0) {
                buf[0] = status &amp; 0xff;
                buf[1] = status &gt;&gt; 8;
                status = count;
            }
            break;
        case I2C_SMBUS_BYTE_DATA:
            status = i2c_smbus_read_byte_data(client, offset);
            if (status &gt;= 0) {
                buf[0] = status;
                status = count;
            }
            break;
        default:
            status = i2c_transfer(client-&gt;adapter, msg, 2);
            if (status == 2)
                status = count;
        }
        dev_dbg(&amp;client-&gt;dev, ""read %zu@%d --&gt; %d (%ld)\n"",
                count, offset, status, jiffies);

        if (status == count)
            return count;

        /* REVISIT: at HZ=100, this is sloooow */
        msleep(1);
    } while (time_before(read_time, timeout));

    return -ETIMEDOUT;
}

static ssize_t at24_read(struct at24_data *at24,
        char *buf, loff_t off, size_t count)
{
    ssize_t retval = 0;

    if (unlikely(!count))
        return count;

    /*
     * Read data from chip, protecting against concurrent updates
     * from this host, but not from other I2C masters.
     */
    mutex_lock(&amp;at24-&gt;lock);

    while (count) {
        ssize_t status;

        status = at24_eeprom_read(at24, buf, off, count);
        if (status &lt;= 0) {
            if (retval == 0)
                retval = status;
            break;
        }
        buf += status;
        off += status;
        count -= status;
        retval += status;
    }

    mutex_unlock(&amp;at24-&gt;lock);

    return retval;
}

static ssize_t at24_bin_read(struct file *filp, struct kobject *kobj,
        struct bin_attribute *attr,
        char *buf, loff_t off, size_t count)
{
    struct at24_data *at24;

    at24 = dev_get_drvdata(container_of(kobj, struct device, kobj));
    return at24_read(at24, buf, off, count);
}


/*
 * Note that if the hardware write-protect pin is pulled high, the whole
 * chip is normally write protected. But there are plenty of product
 * variants here, including OTP fuses and partial chip protect.
 *
 * We only use page mode writes; the alternative is sloooow. This routine
 * writes at most one page.
 */
static ssize_t at24_eeprom_write(struct at24_data *at24, const char *buf,
        unsigned offset, size_t count)
{
    struct i2c_client *client;
    struct i2c_msg msg;
    ssize_t status;
    unsigned long timeout, write_time;
    unsigned next_page;

    /* Get corresponding I2C address and adjust offset */
    client = at24_translate_offset(at24, &amp;offset);

    /* write_max is at most a page */
    if (count &gt; at24-&gt;write_max)
        count = at24-&gt;write_max;

    /* Never roll over backwards, to the start of this page */
    next_page = roundup(offset + 1, at24-&gt;chip.page_size);
    if (offset + count &gt; next_page)
        count = next_page - offset;

    /* If we'll use I2C calls for I/O, set up the message */
    if (!at24-&gt;use_smbus) {
        int i = 0;

        msg.addr = client-&gt;addr;
        msg.flags = 0;

        /* msg.buf is u8 and casts will mask the values */
        msg.buf = at24-&gt;writebuf;
        if (at24-&gt;chip.flags &amp; AT24_FLAG_ADDR16)
            msg.buf[i++] = offset &gt;&gt; 8;

        msg.buf[i++] = offset;
        memcpy(&amp;msg.buf[i], buf, count);
        msg.len = i + count;
    }

    /*
     * Writes fail if the previous one didn't complete yet. We may
     * loop a few times until this one succeeds, waiting at least
     * long enough for one entire page write to work.
     */
    timeout = jiffies + msecs_to_jiffies(write_timeout);
    do {
        write_time = jiffies;
        if (at24-&gt;use_smbus) {
            status = i2c_smbus_write_i2c_block_data(client,
                    offset, count, buf);
            if (status == 0)
                status = count;
        } else {
            status = i2c_transfer(client-&gt;adapter, &amp;msg, 1);
            if (status == 1)
                status = count;
        }
        dev_dbg(&amp;client-&gt;dev, ""write %zu@%d --&gt; %zd (%ld)\n"",
                count, offset, status, jiffies);

        if (status == count)
            return count;

        /* REVISIT: at HZ=100, this is sloooow */
        msleep(1);
    } while (time_before(write_time, timeout));

    return -ETIMEDOUT;
}

static ssize_t at24_write(struct at24_data *at24, const char *buf, loff_t off,
              size_t count)
{
    ssize_t retval = 0;

    if (unlikely(!count))
        return count;

    /*
     * Write data to chip, protecting against concurrent updates
     * from this host, but not from other I2C masters.
     */
    mutex_lock(&amp;at24-&gt;lock);

    while (count) {
        ssize_t status;

        status = at24_eeprom_write(at24, buf, off, count);
        if (status &lt;= 0) {
            if (retval == 0)
                retval = status;
            break;
        }
        buf += status;
        off += status;
        count -= status;
        retval += status;
    }

    mutex_unlock(&amp;at24-&gt;lock);

    return retval;
}

static ssize_t at24_bin_write(struct file *filp, struct kobject *kobj,
        struct bin_attribute *attr,
        char *buf, loff_t off, size_t count)
{
    struct at24_data *at24;

    at24 = dev_get_drvdata(container_of(kobj, struct device, kobj));
    return at24_write(at24, buf, off, count);
}

/*-------------------------------------------------------------------------*/

/*
 * This lets other kernel code access the eeprom data. For example, it
 * might hold a board's Ethernet address, or board-specific calibration
 * data generated on the manufacturing floor.
 */

static ssize_t at24_macc_read(struct memory_accessor *macc, char *buf,
             off_t offset, size_t count)
{
    struct at24_data *at24 = container_of(macc, struct at24_data, macc);

    return at24_read(at24, buf, offset, count);
}

static ssize_t at24_macc_write(struct memory_accessor *macc, const char *buf,
              off_t offset, size_t count)
{
    struct at24_data *at24 = container_of(macc, struct at24_data, macc);

    return at24_write(at24, buf, offset, count);
}

/*-------------------------------------------------------------------------*/

#ifdef CONFIG_OF
static void at24_get_ofdata(struct i2c_client *client,
        struct at24_platform_data *chip)
{
    const __be32 *val;
    struct device_node *node = client-&gt;dev.of_node;

    if (node) {
        if (of_get_property(node, ""read-only"", NULL))
            chip-&gt;flags |= AT24_FLAG_READONLY;
        val = of_get_property(node, ""pagesize"", NULL);
        if (val)
            chip-&gt;page_size = be32_to_cpup(val);
    }
}
#else
static void at24_get_ofdata(struct i2c_client *client,
        struct at24_platform_data *chip)
{ }
#endif /* CONFIG_OF */

static int at24_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
    struct at24_platform_data chip;
    bool writable;
    int use_smbus = 0;
    struct at24_data *at24;
    int err;
    unsigned i, num_addresses;
    kernel_ulong_t magic;

    if (client-&gt;dev.platform_data) {
        chip = *(struct at24_platform_data *)client-&gt;dev.platform_data;
    } else {
        if (!id-&gt;driver_data) {
            err = -ENODEV;
            goto err_out;
        }
        magic = id-&gt;driver_data;
        chip.byte_len = BIT(magic &amp; AT24_BITMASK(AT24_SIZE_BYTELEN));
        magic &gt;&gt;= AT24_SIZE_BYTELEN;
        chip.flags = magic &amp; AT24_BITMASK(AT24_SIZE_FLAGS);
        /*
         * This is slow, but we can't know all eeproms, so we better
         * play safe. Specifying custom eeprom-types via platform_data
         * is recommended anyhow.
         */
        chip.page_size = 1;

        /* update chipdata if OF is present */
        at24_get_ofdata(client, &amp;chip);

        chip.setup = NULL;
        chip.context = NULL;
    }

    if (!is_power_of_2(chip.byte_len))
        dev_warn(&amp;client-&gt;dev,
            ""byte_len looks suspicious (no power of 2)!\n"");
    if (!chip.page_size) {
        dev_err(&amp;client-&gt;dev, ""page_size must not be 0!\n"");
        err = -EINVAL;
        goto err_out;
    }
    if (!is_power_of_2(chip.page_size))
        dev_warn(&amp;client-&gt;dev,
            ""page_size looks suspicious (no power of 2)!\n"");

    /* Use I2C operations unless we're stuck with SMBus extensions. */
    if (!i2c_check_functionality(client-&gt;adapter, I2C_FUNC_I2C)) {
        if (chip.flags &amp; AT24_FLAG_ADDR16) {
            err = -EPFNOSUPPORT;
            goto err_out;
        }
        if (i2c_check_functionality(client-&gt;adapter,
                I2C_FUNC_SMBUS_READ_I2C_BLOCK)) {
            use_smbus = I2C_SMBUS_I2C_BLOCK_DATA;
        } else if (i2c_check_functionality(client-&gt;adapter,
                I2C_FUNC_SMBUS_READ_WORD_DATA)) {
            use_smbus = I2C_SMBUS_WORD_DATA;
        } else if (i2c_check_functionality(client-&gt;adapter,
                I2C_FUNC_SMBUS_READ_BYTE_DATA)) {
            use_smbus = I2C_SMBUS_BYTE_DATA;
        } else {
            err = -EPFNOSUPPORT;
            goto err_out;
        }
    }
//???????????????
    if (chip.flags &amp; AT24_FLAG_TAKE8ADDR)
        num_addresses = 8;
    else
        num_addresses = DIV_ROUND_UP(chip.byte_len, (chip.flags &amp; AT24_FLAG_ADDR16) ? 65536 : 256);

    at24 = kzalloc(sizeof(struct at24_data) + num_addresses * sizeof(struct i2c_client *), GFP_KERNEL);
    if (!at24) {
        err = -ENOMEM;
        goto err_out;
    }

    mutex_init(&amp;at24-&gt;lock);
    at24-&gt;use_smbus = use_smbus;
    at24-&gt;chip = chip;
    at24-&gt;num_addresses = num_addresses;

    /*
     * Export the EEPROM bytes through sysfs, since that's convenient.
     * By default, only root should see the data (maybe passwords etc)
     */
    sysfs_bin_attr_init(&amp;at24-&gt;bin);
    at24-&gt;bin.attr.name = ""eeprom"";
    at24-&gt;bin.attr.mode = chip.flags &amp; AT24_FLAG_IRUGO ? S_IRUGO : S_IRUSR;
    at24-&gt;bin.read = at24_bin_read;
    at24-&gt;bin.size = chip.byte_len;

    at24-&gt;macc.read = at24_macc_read;

    writable = !(chip.flags &amp; AT24_FLAG_READONLY);
    if (writable) {
        if (!use_smbus || i2c_check_functionality(client-&gt;adapter,
                I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)) {

            unsigned write_max = chip.page_size;

            at24-&gt;macc.write = at24_macc_write;

            at24-&gt;bin.write = at24_bin_write;
            at24-&gt;bin.attr.mode |= S_IWUSR;

            if (write_max &gt; io_limit)
                write_max = io_limit;
            if (use_smbus &amp;&amp; write_max &gt; I2C_SMBUS_BLOCK_MAX)
                write_max = I2C_SMBUS_BLOCK_MAX;
            at24-&gt;write_max = write_max;

            /* buffer (data + address at the beginning) */
            at24-&gt;writebuf = kmalloc(write_max + 2, GFP_KERNEL);
            if (!at24-&gt;writebuf) {
                err = -ENOMEM;
                goto err_struct;
            }
        } else {
            dev_warn(&amp;client-&gt;dev,
                ""cannot write due to controller restrictions."");
        }
    }

    at24-&gt;client[0] = client;

    /* use dummy devices for multiple-address chips */
    for (i = 1; i &lt; num_addresses; i++) {
        at24-&gt;client[i] = i2c_new_dummy(client-&gt;adapter,
                    client-&gt;addr + i);
        if (!at24-&gt;client[i]) {
            dev_err(&amp;client-&gt;dev, ""address 0x%02x unavailable\n"",
                    client-&gt;addr + i);
            err = -EADDRINUSE;
            goto err_clients;
        }
    }

    err = sysfs_create_bin_file(&amp;client-&gt;dev.kobj, &amp;at24-&gt;bin);
    if (err)
        goto err_clients;

    i2c_set_clientdata(client, at24);

    dev_info(&amp;client-&gt;dev, ""%zu byte %s EEPROM, %s, %u bytes/write\n"", at24-&gt;bin.size, client-&gt;name,
        writable ? ""writable"" : ""read-only"", at24-&gt;write_max);
    if (use_smbus == I2C_SMBUS_WORD_DATA ||
        use_smbus == I2C_SMBUS_BYTE_DATA) {
        dev_notice(&amp;client-&gt;dev, ""Falling back to %s reads, ""
               ""performance will suffer\n"", use_smbus ==
               I2C_SMBUS_WORD_DATA ? ""word"" : ""byte"");
    }

    /* export data to kernel code */
    if (chip.setup)
        chip.setup(&amp;at24-&gt;macc, chip.context);

    return 0;

err_clients:
    for (i = 1; i &lt; num_addresses; i++)
        if (at24-&gt;client[i])
            i2c_unregister_device(at24-&gt;client[i]);

    kfree(at24-&gt;writebuf);
err_struct:
    kfree(at24);
err_out:
    dev_dbg(&amp;client-&gt;dev, ""probe error %d\n"", err);
    return err;
}

/*-------------------------------------------------------------------------*/

static int __devexit at24_remove(struct i2c_client *client)
{
    struct at24_data *at24;
    int i;

    at24 = i2c_get_clientdata(client);
    sysfs_remove_bin_file(&amp;client-&gt;dev.kobj, &amp;at24-&gt;bin);

    for (i = 1; i &lt; at24-&gt;num_addresses; i++)
        i2c_unregister_device(at24-&gt;client[i]);

    kfree(at24-&gt;writebuf);
    kfree(at24);
    return 0;
}

/*-------------------------------------------------------------------------*/

static struct i2c_driver at24_driver = {
    .driver = {
        .name = ""at24"",
        .owner = THIS_MODULE,
    },
    .probe = at24_probe,
    .remove = __devexit_p(at24_remove),
    .id_table = at24_ids,
};

static int __init at24_init(void)
{
    if (!io_limit) {
        pr_err(""at24: io_limit must not be 0!\n"");
        return -EINVAL;
    }

    io_limit = rounddown_pow_of_two(io_limit);
    return i2c_add_driver(&amp;at24_driver);
}
module_init(at24_init);

static void __exit at24_exit(void)
{
    i2c_del_driver(&amp;at24_driver);
}
module_exit(at24_exit);

MODULE_DESCRIPTION(""Driver for most I2C EEPROMs"");
MODULE_AUTHOR(""David Brownell and Wolfram Sang"");
MODULE_LICENSE(""GPL"");
</code></pre>

<p>These are snippets from board file:</p>

<pre><code>static struct i2c_board_info __initdata am335x_i2c0_boardinfo[] = {
{
    /* Baseboard board EEPROM */
    I2C_BOARD_INFO(""24c256"", BASEBOARD_I2C_ADDR),
    .platform_data  = &amp;am335x_baseboard_eeprom_info,
},
.
.


static struct at24_platform_data am335x_baseboard_eeprom_info = {
    .byte_len       = (256*1024) / 8,
    .page_size      = 64,
    .flags          = AT24_FLAG_ADDR16,
    .setup          = am335x_evm_setup,
    .context        = (void *)NULL,
};


static void am335x_evm_setup(struct memory_accessor *mem_acc, void *context)
{
int ret;
char tmp[10];
struct device *mpu_dev;

/* 1st get the MAC address from EEPROM */
ret = mem_acc-&gt;read(mem_acc, (char *)&amp;am335x_mac_addr,
    EEPROM_MAC_ADDRESS_OFFSET, sizeof(am335x_mac_addr));
.
.
.
</code></pre>

<p>How can i read from/write into eeprom content from user space.
Should i use sysfs? What should i do?</p>
"
"<p>On kernel 4.0, when stepping through the kernel source for <code>sysfs_create_bin_file</code>, I notice it passes to <code>sysfs_add_file(kobj-&gt;sd, &amp;attr-&gt;attr, true);</code> The <code>&amp;attr-&gt;attr</code> being the <code>struct attribute</code> struct within the <code>bin_attribute</code> struct. </p>

<p>This makes sense until I visit <code>sysfs_add_file_mode_ns</code>, which is directly called from <code>sysfs_add_file</code>, and on <a href=""http://elixir.free-electrons.com/linux/v4.0/source/fs/sysfs/file.c#L277"" rel=""nofollow noreferrer"">line #277</a> sets temp variable <code>stuct bin_attribute *battr = (void*)attr;</code></p>

<p>Isn't this pointing to a <code>struct attribute</code> at this point, how is it resolving this to the proper struct (due to the call to <code>sysfs_add_file</code> using <code>&amp;attr-&gt;attr</code> on <a href=""http://elixir.free-electrons.com/linux/v4.0/source/fs/sysfs/file.c#L483"" rel=""nofollow noreferrer"">line #483</a>)?</p>

<p>Code</p>

<pre><code>int sysfs_create_bin_file(struct kobject *kobj,
              const struct bin_attribute *attr)
{
    BUG_ON(!kobj || !kobj-&gt;sd || !attr);

    return sysfs_add_file(kobj-&gt;sd, &amp;attr-&gt;attr, true);
}

int sysfs_add_file(struct kernfs_node *parent, const struct attribute *attr,
           bool is_bin)
{
    return sysfs_add_file_mode_ns(parent, attr, is_bin, attr-&gt;mode, NULL);
}

int sysfs_add_file_mode_ns(struct kernfs_node *parent,
               const struct attribute *attr, bool is_bin,
               umode_t mode, const void *ns)
{
    struct lock_class_key *key = NULL;
    const struct kernfs_ops *ops;
    struct kernfs_node *kn;
    loff_t size;

    if (!is_bin) {
        ...
    } else {


        struct bin_attribute *battr = (void *)attr;
         ...
    }
</code></pre>
"
"<p>I'm writing drivers for several pieces of custom hardware.  All of the devices are attached via PCIe to a host computer. For convenience I would like to group all of these custom devices together into a sysfs class (which I believe is an acceptable thing to do?). Unfortunately the information in LDD3 is way out of date and I'm having trouble finding current documentation that discusses what I'm attempting to do.</p>

<p>Creating my custom class is easy enough:</p>

<pre><code>struct class MY_CLASS = class_create(THIS_MODULE, ""myclass"")
</code></pre>

<p>And inside of my probe calls I've got access to the <code>struct dev</code>:</p>

<pre><code>static int probe(struct pci_dev *pcidev, const struct pci_device_id *id)
{
    ...

    struct dev *my_dev = &amp;pcidev-&gt;dev;

    ...
}
</code></pre>

<p>My question is this: now that I've got the class and the dev, how do I create a link between the two?</p>

<p>The <code>device_create()</code> basically does what I want, but since I've already got a <code>struct dev</code> my understanding is that I shouldn't call <code>device_create</code> (i.e. create a new device) again.</p>

<p>I've done a little more tracing and found that <code>device_add()</code> which is called by <code>device_create()</code>, calls <code>device_add_class_symlinks()</code> (not exported unfortunately) which does something like this:</p>

<pre><code>...
sysfs_create_link(&amp;dev-&gt;class-&gt;p-&gt;subsys.kobj,&amp;dev-&gt;kobj, dev_name(dev));
...
</code></pre>

<p>I tried something like this directly in my drivers to create the links I want but I can't get it to compile because <code>struct subsys_private</code> (the ""p"" member in the class struct) is not exposed anywhere?</p>

<p>Any help is greatly appreciated! </p>
"
"<p>I want to create a kernel driver for tmp102 temperature sensors.
In one project I have only 1 sensor, in the other - 2 sensors. I want my kernel module to be able to support N sensors, not a fixed number. I have a problem with managing more than 1 struct i2c_client and creating sysfs entries for each of them. Here's how I'm doing it:</p>

<ol>
<li><p>In the <code>probe()</code> function I get <code>struct i2c_client*</code> for each of the devices that I provide <code>I2C_BOARD_INFO()</code> for.</p></li>
<li><p>I then <code>kobject_create_and_add(""tmp102"", kernel_kobj)</code> to get the main directory for the modules in <em>sysfs</em>.</p></li>
<li><p>For each device I'm creating <code>sysfs_create_group()</code> which gets the pointer to statically created attributes. The attributes have the <code>(*show)()</code> and <code>(*store)()</code> pointers set to static functions, e.g.</p>

<pre><code>static ssize_t tmp102_sysfs_thigh_get_one(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
</code></pre></li>
</ol>

<p>In this function I want to read via I2C. The problem is... I don't know how to get the <code>struct i2c_client *</code> for the device which should be somehow linked to this <em>sysfs</em> entry, and the I2C address is there!</p>

<p>How should I properly ""link"" i2c_client with <em>sysfs</em> entries, so that I can get the I2C address inside the functions?</p>

<p>Ideally, I would like to have just one set of functions (one for each of the attributes). The <em>sysfs</em> tree should look like that:</p>

<pre><code>  /sysfs/kernel/tmp102
  |
  |-&gt; &lt;hex i2c address, e.g. /48&gt;
  |   |
  |   |-&gt; temperature
  |
  |
  |-&gt; /49
      |
      |-&gt; temperature
</code></pre>

<p>I want both 'temperature' attributes to use the same function, which is able to determine the I2C address, to which it should write.</p>

<p>Or maybe my architecture is plain wrong? If so, how should it look like for a driver that needs to handle multiple <code>i2c_client</code>s?</p>

<p>EDIT: </p>

<p>I decided to use <code>struct device_attribute</code> instead of regular <code>attribute</code>s. To my understanding, it is not easy to get the <code>struct device</code> pointer when using the regular attributes, same with <code>struct i2c_client</code>. They are not easily ""linked"" with <code>kobject</code>s from <code>/sys/kernel</code>, where I need to have my attributes for this project. <code>device_attribute</code>s can be found in <code>/sys/devices</code> - I used <code>sysfs_create_group</code> and linked my device's <code>kobject</code> with the <code>device_attribute</code> group. I used <code>sysfs_create_link</code>, and linked my device's <code>kobject</code> with the <code>/sys/kernel/tmp102</code>. This way I could create a folder (link) for each of the devices, which points to the original attributes folder in <code>/sys/devices</code>. </p>
"
"<p>I am trying to create a simple platform driver but i don't know why its not working. Here is the code that i am trying to build.
Insmod is clean but there are some cryptic messages along with rmmod.<br>
and what details i should add so this editor satisfies.........  </p>

<pre><code>    #include &lt;linux/module.h&gt;
    #include &lt;linux/init.h&gt;
    #include &lt;linux/kernel.h&gt;
    #include &lt;linux/platform_device.h&gt;
    MODULE_LICENSE(""GPL"");
    static struct platform_device *dev;

    static int  my_probe(struct platform_device *pdev)
    {
        printk(""probe called, means device and driver are now associated\n"");
        return 0;
    }

    static struct platform_driver my_driver = {
        .driver = {
            .name = ""m_driver"",
        },
        .probe = my_probe,
    };
    static int __init my_init(void)
    {
        int ret;
        /*register a platform driver*/
        ret = platform_driver_register(&amp;my_driver);
        if(ret == 0 )
            printk(""&lt;1&gt;"" ""platform driver registered\n"");

        dev = platform_device_alloc(""m_driver"", -1);
        if (!dev)
            return -ENOMEM;

        ret = platform_device_add(dev);
        if (ret != 0) {
            printk(""&lt;1&gt;"" ""platform driver could not be added\n"");
            goto undo_malloc;
        }
        printk(""&lt;1&gt;"" ""platform driver installed\n"");
    undo_malloc:
        platform_device_put(dev);
        return ret;
    }
    module_init(my_init);

    static void __exit my_cleanup(void)
    {
        /* Unregister driver */
        platform_driver_unregister(&amp;my_driver);
        platform_device_unregister(dev);
        printk(""&lt;1&gt;"" ""over\n"");
        return;
    }
    module_exit(my_cleanup);

Few part of the code is commented just to keep things minimal.After insmod ,in rmmod the dmesg is filled with messages as rmmod tainted and call trace and addresses .What i am doing wrong?
</code></pre>

<p>This is the rmmod log form terminal</p>

<pre><code> WARNING: at /build/buildd/linux-3.2.0/fs/sysfs/inode.c:324 sysfs_hash_and_remove+0x92/0xa0()
[ 3106.861968] Hardware name: VMware Virtual Platform
[ 3106.861972] sysfs: can not remove 'driver', no directory
[ 3106.861976] Modules linked in: uiyn(O-) test1(O-) isofs vmwgfx ttm drm bnep rfcomm bluetooth snd_ens1371 gameport snd_ac97_codec ac97_bus snd_pcm ppdev snd_seq_midi snd_rawmidi snd_seq_midi_event snd_seq vmw_balloon psmouse snd_timer snd_seq_device serio_raw uvcvideo videodev snd soundcore snd_page_alloc i2c_piix4 parport_pc mac_hid shpchp lp parport pcnet32 mptspi mptscsih mptbase floppy [last unloaded: uiyn]
[ 3106.862043] Pid: 2600, comm: rmmod Tainted: G      D W  O 3.2.0-29-generic-pae #46-Ubuntu
[ 3106.862047] Call Trace:
[ 3106.862058]  [&lt;c105a182&gt;] warn_slowpath_common+0x72/0xa0
[ 3106.862069]  [&lt;c11a59f2&gt;] ? sysfs_hash_and_remove+0x92/0xa0
[ 3106.862077]  [&lt;c11a59f2&gt;] ? sysfs_hash_and_remove+0x92/0xa0
[ 3106.862084]  [&lt;c105a253&gt;] warn_slowpath_fmt+0x33/0x40
[ 3106.862090]  [&lt;c11a59f2&gt;] sysfs_hash_and_remove+0x92/0xa0
[ 3106.862099]  [&lt;c11a7b50&gt;] sysfs_remove_link+0x20/0x30
[ 3106.862112]  [&lt;c13842da&gt;] driver_sysfs_remove+0x2a/0x30
[ 3106.862119]  [&lt;c1384304&gt;] __device_release_driver+0x24/0xb0
[ 3106.862126]  [&lt;c13843b4&gt;] device_release_driver+0x24/0x40
[ 3106.862133]  [&lt;c1383f2a&gt;] bus_remove_device+0x5a/0x80
[ 3106.862140]  [&lt;c1381c47&gt;] device_del+0xe7/0x150
[ 3106.862147]  [&lt;c13860a8&gt;] platform_device_del+0x18/0x70
[ 3106.862153]  [&lt;c13863b0&gt;] platform_device_unregister+0x10/0x20
[ 3106.862163]  [&lt;e0a6e02a&gt;] my_cleanup+0xe/0xfe4 [uiyn]
[ 3106.862170]  [&lt;e0a6e01c&gt;] ? my_probe+0x1c/0x1c [uiyn]
[ 3106.862179]  [&lt;c1094be5&gt;] sys_delete_module+0x135/0x230
[ 3106.862189]  [&lt;c111b63a&gt;] ? do_munmap+0x16a/0x200
[ 3106.862197]  [&lt;c15ac7df&gt;] sysenter_do_call+0x12/0x28
[ 3106.862208] ---[ end trace 8a59e3572e4fd8eb ]---
[ 3106.863592] over
</code></pre>
"
"<p>I am trying to create a simple platform driver but i don't know why its not working. Here is the code that i am trying to build.
Insmod is clean but there are some cryptic messages along with rmmod.<br>
and what details i should add so this editor satisfies.........  </p>

<pre><code>    #include &lt;linux/module.h&gt;
    #include &lt;linux/init.h&gt;
    #include &lt;linux/kernel.h&gt;
    #include &lt;linux/platform_device.h&gt;
    MODULE_LICENSE(""GPL"");
    static struct platform_device *dev;

    static int  my_probe(struct platform_device *pdev)
    {
        printk(""probe called, means device and driver are now associated\n"");
        return 0;
    }

    static struct platform_driver my_driver = {
        .driver = {
            .name = ""m_driver"",
        },
        .probe = my_probe,
    };
    static int __init my_init(void)
    {
        int ret;
        /*register a platform driver*/
        ret = platform_driver_register(&amp;my_driver);
        if(ret == 0 )
            printk(""&lt;1&gt;"" ""platform driver registered\n"");

        dev = platform_device_alloc(""m_driver"", -1);
        if (!dev)
            return -ENOMEM;

        ret = platform_device_add(dev);
        if (ret != 0) {
            printk(""&lt;1&gt;"" ""platform driver could not be added\n"");
            goto undo_malloc;
        }
        printk(""&lt;1&gt;"" ""platform driver installed\n"");
    undo_malloc:
        platform_device_put(dev);
        return ret;
    }
    module_init(my_init);

    static void __exit my_cleanup(void)
    {
        /* Unregister driver */
        platform_driver_unregister(&amp;my_driver);
        platform_device_unregister(dev);
        printk(""&lt;1&gt;"" ""over\n"");
        return;
    }
    module_exit(my_cleanup);

Few part of the code is commented just to keep things minimal.After insmod ,in rmmod the dmesg is filled with messages as rmmod tainted and call trace and addresses .What i am doing wrong?
</code></pre>

<p>This is the rmmod log form terminal</p>

<pre><code> WARNING: at /build/buildd/linux-3.2.0/fs/sysfs/inode.c:324 sysfs_hash_and_remove+0x92/0xa0()
[ 3106.861968] Hardware name: VMware Virtual Platform
[ 3106.861972] sysfs: can not remove 'driver', no directory
[ 3106.861976] Modules linked in: uiyn(O-) test1(O-) isofs vmwgfx ttm drm bnep rfcomm bluetooth snd_ens1371 gameport snd_ac97_codec ac97_bus snd_pcm ppdev snd_seq_midi snd_rawmidi snd_seq_midi_event snd_seq vmw_balloon psmouse snd_timer snd_seq_device serio_raw uvcvideo videodev snd soundcore snd_page_alloc i2c_piix4 parport_pc mac_hid shpchp lp parport pcnet32 mptspi mptscsih mptbase floppy [last unloaded: uiyn]
[ 3106.862043] Pid: 2600, comm: rmmod Tainted: G      D W  O 3.2.0-29-generic-pae #46-Ubuntu
[ 3106.862047] Call Trace:
[ 3106.862058]  [&lt;c105a182&gt;] warn_slowpath_common+0x72/0xa0
[ 3106.862069]  [&lt;c11a59f2&gt;] ? sysfs_hash_and_remove+0x92/0xa0
[ 3106.862077]  [&lt;c11a59f2&gt;] ? sysfs_hash_and_remove+0x92/0xa0
[ 3106.862084]  [&lt;c105a253&gt;] warn_slowpath_fmt+0x33/0x40
[ 3106.862090]  [&lt;c11a59f2&gt;] sysfs_hash_and_remove+0x92/0xa0
[ 3106.862099]  [&lt;c11a7b50&gt;] sysfs_remove_link+0x20/0x30
[ 3106.862112]  [&lt;c13842da&gt;] driver_sysfs_remove+0x2a/0x30
[ 3106.862119]  [&lt;c1384304&gt;] __device_release_driver+0x24/0xb0
[ 3106.862126]  [&lt;c13843b4&gt;] device_release_driver+0x24/0x40
[ 3106.862133]  [&lt;c1383f2a&gt;] bus_remove_device+0x5a/0x80
[ 3106.862140]  [&lt;c1381c47&gt;] device_del+0xe7/0x150
[ 3106.862147]  [&lt;c13860a8&gt;] platform_device_del+0x18/0x70
[ 3106.862153]  [&lt;c13863b0&gt;] platform_device_unregister+0x10/0x20
[ 3106.862163]  [&lt;e0a6e02a&gt;] my_cleanup+0xe/0xfe4 [uiyn]
[ 3106.862170]  [&lt;e0a6e01c&gt;] ? my_probe+0x1c/0x1c [uiyn]
[ 3106.862179]  [&lt;c1094be5&gt;] sys_delete_module+0x135/0x230
[ 3106.862189]  [&lt;c111b63a&gt;] ? do_munmap+0x16a/0x200
[ 3106.862197]  [&lt;c15ac7df&gt;] sysenter_do_call+0x12/0x28
[ 3106.862208] ---[ end trace 8a59e3572e4fd8eb ]---
[ 3106.863592] over
</code></pre>

<p>I checked /sys/modules and these modules are still after rmmod ,there so i have to change name everytime.I need to know
1) If I am doing some obvious error
2) Is there a way to understand this error logs
3) Is my kernel version have to do with this mine: 3.2.0-29
Any hint will be helpful..</p>
"
"<p>I am new to kernel programming. I want to rename a file in linux kernel mode. I did not find any direct functions which can do this. So I found that I can use <code>vfs_link</code> to create new hardlink and <code>vfs_unlink</code> to delete old link. But I did not understand how to use <code>vfs_link(struct dentry *old_dentry, struct inode *dir, struct dentry *new_dentry, struct inode **delegated_inode)</code>. </p>

<p>Say I have <code>struct file* fp</code> before using <code>vfs_link</code>.</p>

<p>I understand <code>old_dentry</code> is <code>fp-&gt;f_dentry</code>. But I am not decipher what other params are.
I did not find any concrete examples on net where <code>vfs_link</code> is used. Please help</p>
"
"<p>In userspace I can just <code>echo noop &gt; /sys/block/sda/queue/scheduler</code>.</p>

<p>How to do the same inside a kernel module?</p>

<p>I expect something like this (pseudocode):</p>

<pre><code>struct dentry* e = sysfs_get_root();
vfs_path_lookup(e, ????, ""block/sda/queue/scheduler"", ???);
????;
struct something* q = ????;
????-&gt;store(q, ""noop"", 1);
/* some cleanup */
</code></pre>

<p>How to implement it properly?</p>

<p>My kernel module just registers SysRQ handler and should configure the io scheduler when that SysRQ is triggered (userspace programs can be hung at that time because of the bad io-scheduler)</p>
"
"<p>I am reading ""Understanding the Linux Kernel"" 3rd edition, by D.Bovet &amp; M.Cesati. In the chapter about Virtual file systems, they refer to the function ""path_lookup()"" that does the lookup for a given path. The book is based on linux-2.6.
I am viewing files in linux-3.7.6 and I can't find the function (using cscope tool). Any idea what's the equivalent function in this version of linux?</p>
"
"<p>I'm writing a LKM and need to find out where a specific symlink is pointing to. Basically I need the functionality of the syscall <code>readlinkat</code> (or <code>readlink</code>) but in kernel-space. Is there an easy way to do this?</p>

<p>Using <code>readlinkat</code> directly is not working for me, I'm always getting EFAULT (I guess this is because my buffer is obviously in kernel memory space and not in user-space).</p>
"
"<p>I'm porting linux kernel module written for Linux 2.4 to work with Linux 2.6.
Some syscalls declared through <code>syscallN()</code> macros and wrapped in <code>set_fs()</code> calls were used in the code.
How can I still use sycalls in Linux 2.6 where those macros are absent?</p>

<p>I know it's a bad taste to use syscalls from kernel space and <code>syscallN()</code> macros are broken on most platforms. Any reasonable way to replace <code>getuid</code>, <code>geteuid</code>, <code>mknod</code>, <code>chown</code>, <code>unlink</code>, <code>sched_yield</code> syscalls in kernel space is appreciated.</p>
"
"<p>Has anybody seen an error of ""scheduling while atomic"" with the jffs2 fs? It looks to be in the gcd kernel thread. What's the exact fix? It's on 2.6.39 kernel. If preemption is not configured, the problem won't happen. Thanks in advance. </p>

<pre><code>[72940.050000] BUG: scheduling while atomic: sync_supers/74/0x00000002
[72940.060000] 4 locks held by sync_supers/74:
[72940.060000]  #0:  (&amp;type-&gt;s_umount_key#14){......}, at: [&lt;c00ae9b0&gt;] sync_supers+0x68/0xf0
[72940.070000]  #1:  (&amp;type-&gt;s_lock_key){......}, at: [&lt;c010e9a8&gt;] jffs2_write_super+0x14/0x40
[72940.080000]  #2:  (&amp;(&amp;c-&gt;erase_completion_lock)-&gt;rlock){......}, at: [&lt;c010baa0&gt;] jffs2_garbage_collect_pass+0x1fc/0x790
[72940.090000]  #3:  (&amp;c-&gt;alloc_sem){......}, at: [&lt;c010baac&gt;] jffs2_garbage_collect_pass+0x208/0x790
[72940.100000] Modules linked in:
[72940.110000] [&lt;c0038e78&gt;] (unwind_backtrace+0x0/0xe4) from [&lt;c0214940&gt;] (schedule+0x54/0x3c0)
[72940.210000] BUG: spinlock cpu recursion on CPU#0, rm/5927
[72940.210000]  lock: c306e560, .magic: dead4ead, .owner: sync_supers/74, .owner_cpu: 0
[72940.220000] [&lt;c0038e78&gt;] (unwind_backtrace+0x0/0xe4) from [&lt;c0152d48&gt;] (do_raw_spin_lock+0x60/0x120)
[72940.230000] [&lt;c0152d48&gt;] (do_raw_spin_lock+0x60/0x120) from [&lt;c011016c&gt;] (__jffs2_flush_wbuf+0xae8/0xc90)
[72940.240000] [&lt;c011016c&gt;] (__jffs2_flush_wbuf+0xae8/0xc90) from [&lt;c0110514&gt;] (jffs2_flash_writev+0x200/0x400)
[72940.250000] [&lt;c0110514&gt;] (jffs2_flash_writev+0x200/0x400) from [&lt;c0107a14&gt;] (jffs2_write_dirent+0x274/0x484)
[72940.260000] [&lt;c0107a14&gt;] (jffs2_write_dirent+0x274/0x484) from [&lt;c0108c78&gt;] (jffs2_do_unlink+0x1ec/0x3ac)
[72940.270000] [&lt;c0108c78&gt;] (jffs2_do_unlink+0x1ec/0x3ac) from [&lt;c0101448&gt;] (jffs2_unlink+0x44/0x84)
[72940.280000] [&lt;c0101448&gt;] (jffs2_unlink+0x44/0x84) from [&lt;c00b6364&gt;] (vfs_unlink+0x68/0xec)
[72940.290000] [&lt;c00b6364&gt;] (vfs_unlink+0x68/0xec) from [&lt;c011a010&gt;] (call_unlink+0x90/0xe0)
[72940.290000] [&lt;c011a010&gt;] (call_unlink+0x90/0xe0) from [&lt;c011a090&gt;] (vfsub_unlink+0x30/0x50)
[72940.300000] [&lt;c011a090&gt;] (vfsub_unlink+0x30/0x50) from [&lt;c0129dac&gt;] (aufs_unlink+0x154/0x22c)
[72940.310000] [&lt;c0129dac&gt;] (aufs_unlink+0x154/0x22c) from [&lt;c00b6364&gt;] (vfs_unlink+0x68/0xec)
[72940.320000] [&lt;c00b6364&gt;] (vfs_unlink+0x68/0xec) from [&lt;c00b8c84&gt;] (do_unlinkat+0xac/0x158)
[72940.330000] [&lt;c00b8c84&gt;] (do_unlinkat+0xac/0x158) from [&lt;c00334e0&gt;] (ret_fast_syscall+0x0/0x2c)

[72945.070000] BUG: spinlock lockup on CPU#0, rm/5927, c306e560
[72945.080000] [&lt;c0038e78&gt;] (unwind_backtrace+0x0/0xe4) from [&lt;c0152dc8&gt;] (do_raw_spin_lock+0xe0/0x120)
[72945.090000] [&lt;c0152dc8&gt;] (do_raw_spin_lock+0xe0/0x120) from [&lt;c011016c&gt;] (__jffs2_flush_wbuf+0xae8/0xc90)
[72945.100000] [&lt;c011016c&gt;] (__jffs2_flush_wbuf+0xae8/0xc90) from [&lt;c0110514&gt;] (jffs2_flash_writev+0x200/0x400)
[72945.110000] [&lt;c0110514&gt;] (jffs2_flash_writev+0x200/0x400) from [&lt;c0107a14&gt;] (jffs2_write_dirent+0x274/0x484)
[72945.120000] [&lt;c0107a14&gt;] (jffs2_write_dirent+0x274/0x484) from [&lt;c0108c78&gt;] (jffs2_do_unlink+0x1ec/0x3ac)
[72945.130000] [&lt;c0108c78&gt;] (jffs2_do_unlink+0x1ec/0x3ac) from [&lt;c0101448&gt;] (jffs2_unlink+0x44/0x84)
[72945.140000] [&lt;c0101448&gt;] (jffs2_unlink+0x44/0x84) from [&lt;c00b6364&gt;] (vfs_unlink+0x68/0xec)
[72945.150000] [&lt;c00b6364&gt;] (vfs_unlink+0x68/0xec) from [&lt;c011a010&gt;] (call_unlink+0x90/0xe0)
[72945.150000] [&lt;c011a010&gt;] (call_unlink+0x90/0xe0) from [&lt;c011a090&gt;] (vfsub_unlink+0x30/0x50)
[72945.160000] [&lt;c011a090&gt;] (vfsub_unlink+0x30/0x50) from [&lt;c0129dac&gt;] (aufs_unlink+0x154/0x22c)
[72945.170000] [&lt;c0129dac&gt;] (aufs_unlink+0x154/0x22c) from [&lt;c00b6364&gt;] (vfs_unlink+0x68/0xec)
[72945.180000] [&lt;c00b6364&gt;] (vfs_unlink+0x68/0xec) from [&lt;c00b8c84&gt;] (do_unlinkat+0xac/0x158)
[72945.190000] [&lt;c00b8c84&gt;] (do_unlinkat+0xac/0x158) from [&lt;c00334e0&gt;] (ret_fast_syscall+0x0/0x2c)

[73016.460000] BUG: soft lockup - CPU#0 stuck for 63s! [rm:5927]
[73016.460000] Modules linked in:
[73016.460000]
[73016.460000] Pid: 5927, comm:                   rm
[73016.460000] CPU: 0    Tainted: G        W    (2.6.39.2 #506)
[73016.460000] PC is at do_raw_spin_lock+0x90/0x120
[73016.460000] LR is at do_raw_spin_lock+0xac/0x120
[73016.460000] pc : [&lt;c0152d78&gt;]    lr : [&lt;c0152d94&gt;]    psr: 80000013
[73016.460000] sp : c36f9cb0  ip : c00334e0  fp : 00da47f0
[73016.460000] r10: 00000028  r9 : c3701384  r8 : 03144800
[73016.460000] r7 : 00000000  r6 : c36f8000  r5 : 001b16c7  r4 : c306e560
[73016.460000] r3 : 00000000  r2 : 00000000  r1 : 00000001  r0 : 00000001
[73016.460000] Flags: Nzcv  IRQs on  FIQs on  Mode SVC_32  ISA ARM  Segment user
[73016.460000] Control: 0005317f  Table: 82b90000  DAC: 00000015
[73016.460000] Kernel panic - not syncing: softlockup: hung tasks
[73016.460000] [&lt;c0038e78&gt;] (unwind_backtrace+0x0/0xe4) from [&lt;c0048740&gt;] (panic+0x5c/0x19c)
[73016.460000] [&lt;c0048740&gt;] (panic+0x5c/0x19c) from [&lt;c0078420&gt;] (watchdog_timer_fn+0x11c/0x15c)
[73016.460000] [&lt;c0078420&gt;] (watchdog_timer_fn+0x11c/0x15c) from [&lt;c006467c&gt;] (hrtimer_run_queues+0x11c/0x1e8)
[73016.460000] [&lt;c006467c&gt;] (hrtimer_run_queues+0x11c/0x1e8) from [&lt;c00538dc&gt;] (run_local_timers+0xc/0x1c)
[73016.460000] [&lt;c00538dc&gt;] (run_local_timers+0xc/0x1c) from [&lt;c0053b30&gt;] (update_process_times+0x2c/0x4c)
[73016.460000] [&lt;c0053b30&gt;] (update_process_times+0x2c/0x4c) from [&lt;c006bd70&gt;] (tick_handle_periodic+0x18/0x84)
[73016.460000] [&lt;c006bd70&gt;] (tick_handle_periodic+0x18/0x84) from [&lt;c003d890&gt;] (lpc32xx_timer_interrupt+0x7c/0xa0)
[73016.460000] [&lt;c003d890&gt;] (lpc32xx_timer_interrupt+0x7c/0xa0) from [&lt;c0078780&gt;] (handle_irq_event_percpu+0x2c/0x19c)
[73016.460000] [&lt;c0078780&gt;] (handle_irq_event_percpu+0x2c/0x19c) from [&lt;c007892c&gt;] (handle_irq_event+0x3c/0x5c)
[73016.460000] [&lt;c007892c&gt;] (handle_irq_event+0x3c/0x5c) from [&lt;c007aadc&gt;] (handle_level_irq+0xbc/0xf0)
[73016.460000] [&lt;c007aadc&gt;] (handle_level_irq+0xbc/0xf0) from [&lt;c0028078&gt;] (asm_do_IRQ+0x78/0xa0)
[73016.460000] [&lt;c0028078&gt;] (asm_do_IRQ+0x78/0xa0) from [&lt;c00330e8&gt;] (__irq_svc+0x48/0x90)
[73016.460000] Exception stack(0xc36f9c68 to 0xc36f9cb0)
[73016.460000] 9c60:                   00000001 00000001 00000000 00000000 c306e560 001b16c7
[73016.460000] 9c80: c36f8000 00000000 03144800 c3701384 00000028 00da47f0 c00334e0 c36f9cb0
[73016.460000] 9ca0: c0152d94 c0152d78 80000013 ffffffff
[73016.460000] [&lt;c00330e8&gt;] (__irq_svc+0x48/0x90) from [&lt;c0152d78&gt;] (do_raw_spin_lock+0x90/0x120)
[73016.460000] [&lt;c0152d78&gt;] (do_raw_spin_lock+0x90/0x120) from [&lt;c011016c&gt;] (__jffs2_flush_wbuf+0xae8/0xc90)
[73016.460000] [&lt;c011016c&gt;] (__jffs2_flush_wbuf+0xae8/0xc90) from [&lt;c0110514&gt;] (jffs2_flash_writev+0x200/0x400)
[73016.460000] [&lt;c0110514&gt;] (jffs2_flash_writev+0x200/0x400) from [&lt;c0107a14&gt;] (jffs2_write_dirent+0x274/0x484)
[73016.460000] [&lt;c0107a14&gt;] (jffs2_write_dirent+0x274/0x484) from [&lt;c0108c78&gt;] (jffs2_do_unlink+0x1ec/0x3ac)
[73016.460000] [&lt;c0108c78&gt;] (jffs2_do_unlink+0x1ec/0x3ac) from [&lt;c0101448&gt;] (jffs2_unlink+0x44/0x84)
[73016.460000] [&lt;c0101448&gt;] (jffs2_unlink+0x44/0x84) from [&lt;c00b6364&gt;] (vfs_unlink+0x68/0xec)
[73016.460000] [&lt;c00b6364&gt;] (vfs_unlink+0x68/0xec) from [&lt;c011a010&gt;] (call_unlink+0x90/0xe0)
[73016.460000] [&lt;c011a010&gt;] (call_unlink+0x90/0xe0) from [&lt;c011a090&gt;] (vfsub_unlink+0x30/0x50)
[73016.460000] [&lt;c011a090&gt;] (vfsub_unlink+0x30/0x50) from [&lt;c0129dac&gt;] (aufs_unlink+0x154/0x22c)
[73016.460000] [&lt;c0129dac&gt;] (aufs_unlink+0x154/0x22c) from [&lt;c00b6364&gt;] (vfs_unlink+0x68/0xec)
[73016.460000] [&lt;c00b6364&gt;] (vfs_unlink+0x68/0xec) from [&lt;c00b8c84&gt;] (do_unlinkat+0xac/0x158)
[73016.460000] [&lt;c00b8c84&gt;] (do_unlinkat+0xac/0x158) from [&lt;c00334e0&gt;] (ret_fast_syscall+0x0/0x2c)
</code></pre>

<p>A note: Another trace without enabling debug in kernel shows: </p>

<pre><code>BUG: scheduling while atomic: jffs2_gcd_mtd7/288/0x00000002
[&lt;c002e4e4&gt;] (unwind_backtrace+0x0/0xe4) from [&lt;c0200a64&gt;] (schedule+0x54/0x3ec)
...
BUG: scheduling while atomic: sync_supers/72/0x00000002
[&lt;c002e4e4&gt;] (unwind_backtrace+0x0/0xe4) from [&lt;c0200a64&gt;] (schedule+0x54/0x3ec)
</code></pre>
"
"<p>I need to overide NFS calls such as vfs_unlink but have had no success so far.
I have managed to successfully intercept samba calls to unlink().</p>

<p>I used </p>

<pre><code>export LD_PRELOAD=""/home/space/wrapper-debug.so""
</code></pre>

<p>and all intercepting code is there for samba and NFS.</p>

<p>For samba I have</p>

<pre><code>int unlink(const char * path) { ... }
</code></pre>

<p>which works and for NFS I have</p>

<pre><code>int vfs_unlink(struct inode *dir, struct dentry *dentry, struct inode **delegated_inode)
{...}
</code></pre>

<p>but this function doesn't seem to be called.</p>

<p>Does anybody have any idea what I'm doing wrong?</p>
"
"<p>I am trying to build a vagrant machine with Ubuntu 16.04 using VirtualBox and getting a kernel error. It crashes the whole vagrant machine and happens very randomly. I say random beacuse, the vagrant build goes smoothly and I can work on the local server for a while until it crashes. If you have come accross something similiar, please help me solve the issue. Here are the ubuntu log entries:</p>

<pre><code>Ubuntu 16.04.2 LTS ubuntu-xenial ttyS0

ubuntu-xenial login: [ 3147.436387] Kernel panic - not syncing: stack-protector: Kernel stack is corrupted in: ffffffffc033ec6f
[ 3147.436387]
[ 3147.477651] CPU: 1 PID: 1695 Comm: python Not tainted 4.4.0-83-generic #106-Ubuntu
[ 3147.576987] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
[ 3147.587476]  0000000000000086 000000002e86a334 ffff8800421dfa18 ffffffff813f9513
[ 3147.811873]  ffffffff81cba598 ffff8800421dfab0 ffff8800421dfaa0 ffffffff8118d607
[ 3148.077952]  ffff880000000010 ffff8800421dfab0 ffff8800421dfa48 000000002e86a334
[ 3148.206471] Call Trace:
[ 3148.211965]  [&lt;ffffffff813f9513&gt;] dump_stack+0x63/0x90
[ 3148.399282]  [&lt;ffffffff8118d607&gt;] panic+0xd3/0x215
[ 3148.556695]  [&lt;ffffffffc033ec6f&gt;] ? VbglR0SfCreate+0xaf/0xb0 [vboxsf]
[ 3148.567643]  [&lt;ffffffff81081119&gt;] __stack_chk_fail+0x19/0x20
[ 3148.645791]  [&lt;ffffffffc033ec6f&gt;] VbglR0SfCreate+0xaf/0xb0 [vboxsf]
[ 3148.766156]  [&lt;ffffffffc033cbac&gt;] ? sf_inode_revalidate+0x8c/0xe0 [vboxsf]
[ 3148.918265]  [&lt;ffffffff810cb001&gt;] ? __raw_callee_save___pv_queued_spin_unlock+0x11/0x20
[ 3148.958786]  [&lt;ffffffff81228da6&gt;] ? __d_lookup+0x116/0x150
[ 3149.036532]  [&lt;ffffffff812266f4&gt;] ? dput+0x34/0x220
[ 3149.166361]  [&lt;ffffffffc033cc13&gt;] ? sf_dentry_revalidate+0x13/0x30 [vboxsf]
[ 3149.386320]  [&lt;ffffffff8121a3af&gt;] ? lookup_fast+0x24f/0x330
[ 3149.597049]  [&lt;ffffffff812199c8&gt;] ? __inode_permission+0x48/0xc0
[ 3149.742830]  [&lt;ffffffff8121ba79&gt;] ? walk_component+0x49/0x300
[ 3149.978073]  [&lt;ffffffff8121b46b&gt;] ? path_init+0x1eb/0x3c0
[ 3150.034405]  [&lt;ffffffff8121d4fd&gt;] ? path_lookupat+0x5d/0x110
[ 3150.171957]  [&lt;ffffffff8121f141&gt;] ? filename_lookup+0xb1/0x180
[ 3150.211906]  [&lt;ffffffff811ed747&gt;] ? kmem_cache_alloc+0x187/0x1f0
[ 3150.416598]  [&lt;ffffffff8121ed46&gt;] ? getname_flags+0x56/0x1f0
[ 3150.491161]  [&lt;ffffffff8121f2e6&gt;] ? user_path_at_empty+0x36/0x40
[ 3150.696048]  [&lt;ffffffff81214076&gt;] ? vfs_fstatat+0x66/0xc0
[ 3150.915222]  [&lt;ffffffff812145ce&gt;] ? SYSC_newstat+0x2e/0x60
[ 3151.021599]  [&lt;ffffffff8121475e&gt;] ? SyS_newstat+0xe/0x10
[ 3151.050559]  [&lt;ffffffff81840b72&gt;] ? entry_SYSCALL_64_fastpath+0x16/0x71
[ 3151.121914] Kernel Offset: disabled
[ 3151.167006] ---[ end Kernel panic - not syncing: stack-protector: Kernel stack is corrupted in: ffffffffc033ec6f
[ 3151.167006]
</code></pre>
"
"<pre><code>My system is a embedded linux system(running kernel version 2.6.18). A client process send data to mysql server. The data will be stored in mysql database at a RAID5 assembled by four disks. The IO pressure(wa%) is always above 20% , mysql CPU utilization is very high.
</code></pre>

<p>After running 5 or 6 hours, the system run into softlock up stat.
The stack information is about releasing the physical memory, writing cache data to the hard disk. </p>

<p>Any suggestions in this circumstance?**</p>

<pre><code>BUG: soft lockup detected on CPU#0!
 [&lt;c043dc1c&gt;] softlockup_tick+0x8f/0xb1
 [&lt;c0428cb5&gt;] update_process_times+0x26/0x5c
 [&lt;c0411256&gt;] smp_apic_timer_interrupt+0x5d/0x67
 [&lt;c04044e7&gt;] apic_timer_interrupt+0x1f/0x24
 [&lt;c06fe0b9&gt;] _spin_lock+0x5/0xf
 [&lt;c047db2a&gt;] __mark_inode_dirty+0x50/0x176
 [&lt;c0424eef&gt;] current_fs_time+0x4d/0x5e
 [&lt;c0475ccd&gt;] touch_atime+0x51/0x94
 [&lt;c0440926&gt;] do_generic_mapping_read+0x425/0x563
 [&lt;c044134b&gt;] __generic_file_aio_read+0xf3/0x267
 [&lt;c043fcd0&gt;] file_read_actor+0x0/0xd4
 [&lt;c04414fb&gt;] generic_file_aio_read+0x3c/0x4d
 [&lt;c045d72d&gt;] do_sync_read+0xc1/0xfd
 [&lt;c0431656&gt;] autoremove_wake_function+0x0/0x37
 [&lt;c045e0e8&gt;] vfs_read+0xa4/0x167
 [&lt;c045d66c&gt;] do_sync_read+0x0/0xfd
 [&lt;c045e688&gt;] sys_pread64+0x5e/0x62
 [&lt;c0403a27&gt;] syscall_call+0x7/0xb
 =======================
BUG: soft lockup detected on CPU#2!
 [&lt;c043dc1c&gt;] softlockup_tick+0x8f/0xb1
 [&lt;c0428cb5&gt;] update_process_times+0x26/0x5c
 [&lt;c0411256&gt;] smp_apic_timer_interrupt+0x5d/0x67
 [&lt;c04044e7&gt;] apic_timer_interrupt+0x1f/0x24
 [&lt;c06fe0bb&gt;] _spin_lock+0x7/0xf
 [&lt;c04aaf17&gt;] journal_try_to_free_buffers+0xf4/0x17b
 [&lt;c0442c52&gt;] find_get_pages+0x28/0x5d
 [&lt;c049c4b1&gt;] ext3_releasepage+0x0/0x7d
 [&lt;c045f0bf&gt;] try_to_release_page+0x2c/0x46
 [&lt;c0447894&gt;] invalidate_mapping_pages+0xc9/0x167
 [&lt;c04813b0&gt;] drop_pagecache+0x86/0xd2
 [&lt;c048144e&gt;] drop_caches_sysctl_handler+0x52/0x64
 [&lt;c04813fc&gt;] drop_caches_sysctl_handler+0x0/0x64
 [&lt;c042623d&gt;] do_rw_proc+0xe8/0xf4
 [&lt;c0426268&gt;] proc_writesys+0x1f/0x24
 [&lt;c045df81&gt;] vfs_write+0xa6/0x169
 [&lt;c0426249&gt;] proc_writesys+0x0/0x24
 [&lt;c045e601&gt;] sys_write+0x41/0x6a
 [&lt;c0403a27&gt;] syscall_call+0x7/0xb
 =======================
BUG: soft lockup detected on CPU#1!
 [&lt;c043dc1c&gt;] softlockup_tick+0x8f/0xb1
 [&lt;c0428cb5&gt;] update_process_times+0x26/0x5c
 [&lt;c0411256&gt;] smp_apic_timer_interrupt+0x5d/0x67
 [&lt;c04044e7&gt;] apic_timer_interrupt+0x1f/0x24
 [&lt;c06f007b&gt;] inet_diag_dump+0x804/0x821
 [&lt;c06fe0bb&gt;] _spin_lock+0x7/0xf
 [&lt;c047db2a&gt;] __mark_inode_dirty+0x50/0x176
 [&lt;c043168d&gt;] wake_bit_function+0x0/0x3c
 [&lt;c04ae0f6&gt;] __journal_remove_journal_head+0xee/0x1a5
 [&lt;c0445ae8&gt;] __set_page_dirty_nobuffers+0x87/0xc6
 [&lt;c04a908e&gt;] __journal_unfile_buffer+0x8/0x11
 [&lt;c04ab94d&gt;] journal_commit_transaction+0x8e0/0x1103
 [&lt;c0431656&gt;] autoremove_wake_function+0x0/0x37
 [&lt;c04af690&gt;] kjournald+0xa9/0x1e5
 [&lt;c0431656&gt;] autoremove_wake_function+0x0/0x37
 [&lt;c04af5e7&gt;] kjournald+0x0/0x1e5
 [&lt;c04314da&gt;] kthread+0xde/0xe2
 [&lt;c04313fc&gt;] kthread+0x0/0xe2
 [&lt;c0404763&gt;] kernel_thread_helper+0x7/0x14
 =======================
BUG: soft lockup detected on CPU#3!
 [&lt;c043dc1c&gt;] softlockup_tick+0x8f/0xb1
 [&lt;c0428cb5&gt;] update_process_times+0x26/0x5c
 [&lt;c0411256&gt;] smp_apic_timer_interrupt+0x5d/0x67
 [&lt;c04044e7&gt;] apic_timer_interrupt+0x1f/0x24
 [&lt;c06fe0bb&gt;] _spin_lock+0x7/0xf
 [&lt;c047db2a&gt;] __mark_inode_dirty+0x50/0x176
 [&lt;c0424eef&gt;] current_fs_time+0x4d/0x5e
 [&lt;c0475ccd&gt;] touch_atime+0x51/0x94
 [&lt;c0440926&gt;] do_generic_mapping_read+0x425/0x563
 [&lt;c044134b&gt;] __generic_file_aio_read+0xf3/0x267
 [&lt;c043fcd0&gt;] file_read_actor+0x0/0xd4
 [&lt;c04414fb&gt;] generic_file_aio_read+0x3c/0x4d
 [&lt;c045d72d&gt;] do_sync_read+0xc1/0xfd
 [&lt;c0431656&gt;] autoremove_wake_function+0x0/0x37
 [&lt;c045e0e8&gt;] vfs_read+0xa4/0x167
 [&lt;c045d66c&gt;] do_sync_read+0x0/0xfd
 [&lt;c045e688&gt;] sys_pread64+0x5e/0x62
 [&lt;c0403a27&gt;] syscall_call+0x7/0xb
</code></pre>

<p>=======================</p>
"
